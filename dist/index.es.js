import * as _ from "react";
import Ye, { forwardRef as rn, useContext as Kr, useState as Ke, useRef as Ne, useEffect as De, isValidElement as bn, Children as LE, createContext as gr, useCallback as xt, PureComponent as FE, useMemo as Un, cloneElement as cr, createElement as BE, useImperativeHandle as zE, Component as NM, useLayoutEffect as WE } from "react";
import * as DM from "react-dom";
import cc, { createPortal as VE } from "react-dom";
function xi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var uc = { exports: {} }, as = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xb;
function RM() {
  if (xb) return as;
  xb = 1;
  var e = Ye, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, c) {
    var u, d = {}, p = null, h = null;
    c !== void 0 && (p = "" + c), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (u in l) r.call(l, u) && !o.hasOwnProperty(u) && (d[u] = l[u]);
    if (s && s.defaultProps) for (u in l = s.defaultProps, l) d[u] === void 0 && (d[u] = l[u]);
    return { $$typeof: t, type: s, key: p, ref: h, props: d, _owner: i.current };
  }
  return as.Fragment = n, as.jsx = a, as.jsxs = a, as;
}
var ss = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wb;
function IM() {
  return wb || (wb = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = Ye, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), g = Symbol.iterator, m = "@@iterator";
    function v(I) {
      if (I === null || typeof I != "object")
        return null;
      var Q = g && I[g] || I[m];
      return typeof Q == "function" ? Q : null;
    }
    var y = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(I) {
      {
        for (var Q = arguments.length, ae = new Array(Q > 1 ? Q - 1 : 0), be = 1; be < Q; be++)
          ae[be - 1] = arguments[be];
        w("error", I, ae);
      }
    }
    function w(I, Q, ae) {
      {
        var be = y.ReactDebugCurrentFrame, $e = be.getStackAddendum();
        $e !== "" && (Q += "%s", ae = ae.concat([$e]));
        var rt = ae.map(function(_e) {
          return String(_e);
        });
        rt.unshift("Warning: " + Q), Function.prototype.apply.call(console[I], console, rt);
      }
    }
    var b = !1, O = !1, E = !1, C = !1, T = !1, j;
    j = Symbol.for("react.module.reference");
    function A(I) {
      return !!(typeof I == "string" || typeof I == "function" || I === r || I === o || T || I === i || I === c || I === u || C || I === h || b || O || E || typeof I == "object" && I !== null && (I.$$typeof === p || I.$$typeof === d || I.$$typeof === a || I.$$typeof === s || I.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      I.$$typeof === j || I.getModuleId !== void 0));
    }
    function M(I, Q, ae) {
      var be = I.displayName;
      if (be)
        return be;
      var $e = Q.displayName || Q.name || "";
      return $e !== "" ? ae + "(" + $e + ")" : ae;
    }
    function P(I) {
      return I.displayName || "Context";
    }
    function R(I) {
      if (I == null)
        return null;
      if (typeof I.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof I == "function")
        return I.displayName || I.name || null;
      if (typeof I == "string")
        return I;
      switch (I) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof I == "object")
        switch (I.$$typeof) {
          case s:
            var Q = I;
            return P(Q) + ".Consumer";
          case a:
            var ae = I;
            return P(ae._context) + ".Provider";
          case l:
            return M(I, I.render, "ForwardRef");
          case d:
            var be = I.displayName || null;
            return be !== null ? be : R(I.type) || "Memo";
          case p: {
            var $e = I, rt = $e._payload, _e = $e._init;
            try {
              return R(_e(rt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, D = 0, $, F, q, B, L, Y, K;
    function te() {
    }
    te.__reactDisabledLog = !0;
    function J() {
      {
        if (D === 0) {
          $ = console.log, F = console.info, q = console.warn, B = console.error, L = console.group, Y = console.groupCollapsed, K = console.groupEnd;
          var I = {
            configurable: !0,
            enumerable: !0,
            value: te,
            writable: !0
          };
          Object.defineProperties(console, {
            info: I,
            log: I,
            warn: I,
            error: I,
            group: I,
            groupCollapsed: I,
            groupEnd: I
          });
        }
        D++;
      }
    }
    function G() {
      {
        if (D--, D === 0) {
          var I = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, I, {
              value: $
            }),
            info: N({}, I, {
              value: F
            }),
            warn: N({}, I, {
              value: q
            }),
            error: N({}, I, {
              value: B
            }),
            group: N({}, I, {
              value: L
            }),
            groupCollapsed: N({}, I, {
              value: Y
            }),
            groupEnd: N({}, I, {
              value: K
            })
          });
        }
        D < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ee = y.ReactCurrentDispatcher, re;
    function oe(I, Q, ae) {
      {
        if (re === void 0)
          try {
            throw Error();
          } catch ($e) {
            var be = $e.stack.trim().match(/\n( *(at )?)/);
            re = be && be[1] || "";
          }
        return `
` + re + I;
      }
    }
    var W = !1, U;
    {
      var Z = typeof WeakMap == "function" ? WeakMap : Map;
      U = new Z();
    }
    function k(I, Q) {
      if (!I || W)
        return "";
      {
        var ae = U.get(I);
        if (ae !== void 0)
          return ae;
      }
      var be;
      W = !0;
      var $e = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var rt;
      rt = ee.current, ee.current = null, J();
      try {
        if (Q) {
          var _e = function() {
            throw Error();
          };
          if (Object.defineProperty(_e.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(_e, []);
            } catch (Sn) {
              be = Sn;
            }
            Reflect.construct(I, [], _e);
          } else {
            try {
              _e.call();
            } catch (Sn) {
              be = Sn;
            }
            I.call(_e.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Sn) {
            be = Sn;
          }
          I();
        }
      } catch (Sn) {
        if (Sn && be && typeof Sn.stack == "string") {
          for (var Se = Sn.stack.split(`
`), gn = be.stack.split(`
`), At = Se.length - 1, Rt = gn.length - 1; At >= 1 && Rt >= 0 && Se[At] !== gn[Rt]; )
            Rt--;
          for (; At >= 1 && Rt >= 0; At--, Rt--)
            if (Se[At] !== gn[Rt]) {
              if (At !== 1 || Rt !== 1)
                do
                  if (At--, Rt--, Rt < 0 || Se[At] !== gn[Rt]) {
                    var er = `
` + Se[At].replace(" at new ", " at ");
                    return I.displayName && er.includes("<anonymous>") && (er = er.replace("<anonymous>", I.displayName)), typeof I == "function" && U.set(I, er), er;
                  }
                while (At >= 1 && Rt >= 0);
              break;
            }
        }
      } finally {
        W = !1, ee.current = rt, G(), Error.prepareStackTrace = $e;
      }
      var ta = I ? I.displayName || I.name : "", ao = ta ? oe(ta) : "";
      return typeof I == "function" && U.set(I, ao), ao;
    }
    function de(I, Q, ae) {
      return k(I, !1);
    }
    function ne(I) {
      var Q = I.prototype;
      return !!(Q && Q.isReactComponent);
    }
    function he(I, Q, ae) {
      if (I == null)
        return "";
      if (typeof I == "function")
        return k(I, ne(I));
      if (typeof I == "string")
        return oe(I);
      switch (I) {
        case c:
          return oe("Suspense");
        case u:
          return oe("SuspenseList");
      }
      if (typeof I == "object")
        switch (I.$$typeof) {
          case l:
            return de(I.render);
          case d:
            return he(I.type, Q, ae);
          case p: {
            var be = I, $e = be._payload, rt = be._init;
            try {
              return he(rt($e), Q, ae);
            } catch {
            }
          }
        }
      return "";
    }
    var xe = Object.prototype.hasOwnProperty, Oe = {}, Ee = y.ReactDebugCurrentFrame;
    function et(I) {
      if (I) {
        var Q = I._owner, ae = he(I.type, I._source, Q ? Q.type : null);
        Ee.setExtraStackFrame(ae);
      } else
        Ee.setExtraStackFrame(null);
    }
    function Ie(I, Q, ae, be, $e) {
      {
        var rt = Function.call.bind(xe);
        for (var _e in I)
          if (rt(I, _e)) {
            var Se = void 0;
            try {
              if (typeof I[_e] != "function") {
                var gn = Error((be || "React class") + ": " + ae + " type `" + _e + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof I[_e] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw gn.name = "Invariant Violation", gn;
              }
              Se = I[_e](Q, _e, be, ae, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (At) {
              Se = At;
            }
            Se && !(Se instanceof Error) && (et($e), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", be || "React class", ae, _e, typeof Se), et(null)), Se instanceof Error && !(Se.message in Oe) && (Oe[Se.message] = !0, et($e), S("Failed %s type: %s", ae, Se.message), et(null));
          }
      }
    }
    var Ce = Array.isArray;
    function ue(I) {
      return Ce(I);
    }
    function Tt(I) {
      {
        var Q = typeof Symbol == "function" && Symbol.toStringTag, ae = Q && I[Symbol.toStringTag] || I.constructor.name || "Object";
        return ae;
      }
    }
    function tt(I) {
      try {
        return an(I), !1;
      } catch {
        return !0;
      }
    }
    function an(I) {
      return "" + I;
    }
    function Jt(I) {
      if (tt(I))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Tt(I)), an(I);
    }
    var sn = y.ReactCurrentOwner, wn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ut, On;
    function ve(I) {
      if (xe.call(I, "ref")) {
        var Q = Object.getOwnPropertyDescriptor(I, "ref").get;
        if (Q && Q.isReactWarning)
          return !1;
      }
      return I.ref !== void 0;
    }
    function ln(I) {
      if (xe.call(I, "key")) {
        var Q = Object.getOwnPropertyDescriptor(I, "key").get;
        if (Q && Q.isReactWarning)
          return !1;
      }
      return I.key !== void 0;
    }
    function Ht(I, Q) {
      typeof I.ref == "string" && sn.current;
    }
    function V(I, Q) {
      {
        var ae = function() {
          Ut || (Ut = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        ae.isReactWarning = !0, Object.defineProperty(I, "key", {
          get: ae,
          configurable: !0
        });
      }
    }
    function se(I, Q) {
      {
        var ae = function() {
          On || (On = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        ae.isReactWarning = !0, Object.defineProperty(I, "ref", {
          get: ae,
          configurable: !0
        });
      }
    }
    var X = function(I, Q, ae, be, $e, rt, _e) {
      var Se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: I,
        key: Q,
        ref: ae,
        props: _e,
        // Record the component responsible for creating this element.
        _owner: rt
      };
      return Se._store = {}, Object.defineProperty(Se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: be
      }), Object.defineProperty(Se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $e
      }), Object.freeze && (Object.freeze(Se.props), Object.freeze(Se)), Se;
    };
    function le(I, Q, ae, be, $e) {
      {
        var rt, _e = {}, Se = null, gn = null;
        ae !== void 0 && (Jt(ae), Se = "" + ae), ln(Q) && (Jt(Q.key), Se = "" + Q.key), ve(Q) && (gn = Q.ref, Ht(Q, $e));
        for (rt in Q)
          xe.call(Q, rt) && !wn.hasOwnProperty(rt) && (_e[rt] = Q[rt]);
        if (I && I.defaultProps) {
          var At = I.defaultProps;
          for (rt in At)
            _e[rt] === void 0 && (_e[rt] = At[rt]);
        }
        if (Se || gn) {
          var Rt = typeof I == "function" ? I.displayName || I.name || "Unknown" : I;
          Se && V(_e, Rt), gn && se(_e, Rt);
        }
        return X(I, Se, gn, $e, be, sn.current, _e);
      }
    }
    var fe = y.ReactCurrentOwner, nt = y.ReactDebugCurrentFrame;
    function ht(I) {
      if (I) {
        var Q = I._owner, ae = he(I.type, I._source, Q ? Q.type : null);
        nt.setExtraStackFrame(ae);
      } else
        nt.setExtraStackFrame(null);
    }
    var Jn;
    Jn = !1;
    function Ci(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function Qn() {
      {
        if (fe.current) {
          var I = R(fe.current.type);
          if (I)
            return `

Check the render method of \`` + I + "`.";
        }
        return "";
      }
    }
    function oo(I) {
      return "";
    }
    var Xr = {};
    function Pr(I) {
      {
        var Q = Qn();
        if (!Q) {
          var ae = typeof I == "string" ? I : I.displayName || I.name;
          ae && (Q = `

Check the top-level render call using <` + ae + ">.");
        }
        return Q;
      }
    }
    function ye(I, Q) {
      {
        if (!I._store || I._store.validated || I.key != null)
          return;
        I._store.validated = !0;
        var ae = Pr(Q);
        if (Xr[ae])
          return;
        Xr[ae] = !0;
        var be = "";
        I && I._owner && I._owner !== fe.current && (be = " It was passed a child from " + R(I._owner.type) + "."), ht(I), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ae, be), ht(null);
      }
    }
    function mn(I, Q) {
      {
        if (typeof I != "object")
          return;
        if (ue(I))
          for (var ae = 0; ae < I.length; ae++) {
            var be = I[ae];
            Ci(be) && ye(be, Q);
          }
        else if (Ci(I))
          I._store && (I._store.validated = !0);
        else if (I) {
          var $e = v(I);
          if (typeof $e == "function" && $e !== I.entries)
            for (var rt = $e.call(I), _e; !(_e = rt.next()).done; )
              Ci(_e.value) && ye(_e.value, Q);
        }
      }
    }
    function ea(I) {
      {
        var Q = I.type;
        if (Q == null || typeof Q == "string")
          return;
        var ae;
        if (typeof Q == "function")
          ae = Q.propTypes;
        else if (typeof Q == "object" && (Q.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Q.$$typeof === d))
          ae = Q.propTypes;
        else
          return;
        if (ae) {
          var be = R(Q);
          Ie(ae, I.props, "prop", be, I);
        } else if (Q.PropTypes !== void 0 && !Jn) {
          Jn = !0;
          var $e = R(Q);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", $e || "Unknown");
        }
        typeof Q.getDefaultProps == "function" && !Q.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function PM(I) {
      {
        for (var Q = Object.keys(I.props), ae = 0; ae < Q.length; ae++) {
          var be = Q[ae];
          if (be !== "children" && be !== "key") {
            ht(I), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", be), ht(null);
            break;
          }
        }
        I.ref !== null && (ht(I), S("Invalid attribute `ref` supplied to `React.Fragment`."), ht(null));
      }
    }
    var yb = {};
    function bb(I, Q, ae, be, $e, rt) {
      {
        var _e = A(I);
        if (!_e) {
          var Se = "";
          (I === void 0 || typeof I == "object" && I !== null && Object.keys(I).length === 0) && (Se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var gn = oo();
          gn ? Se += gn : Se += Qn();
          var At;
          I === null ? At = "null" : ue(I) ? At = "array" : I !== void 0 && I.$$typeof === t ? (At = "<" + (R(I.type) || "Unknown") + " />", Se = " Did you accidentally export a JSX literal instead of a component?") : At = typeof I, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", At, Se);
        }
        var Rt = le(I, Q, ae, $e, rt);
        if (Rt == null)
          return Rt;
        if (_e) {
          var er = Q.children;
          if (er !== void 0)
            if (be)
              if (ue(er)) {
                for (var ta = 0; ta < er.length; ta++)
                  mn(er[ta], I);
                Object.freeze && Object.freeze(er);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              mn(er, I);
        }
        if (xe.call(Q, "key")) {
          var ao = R(I), Sn = Object.keys(Q).filter(function(jM) {
            return jM !== "key";
          }), zf = Sn.length > 0 ? "{key: someKey, " + Sn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yb[ao + zf]) {
            var MM = Sn.length > 0 ? "{" + Sn.join(": ..., ") + ": ...}" : "{}";
            S(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, zf, ao, MM, ao), yb[ao + zf] = !0;
          }
        }
        return I === r ? PM(Rt) : ea(Rt), Rt;
      }
    }
    function CM(I, Q, ae) {
      return bb(I, Q, ae, !0);
    }
    function TM(I, Q, ae) {
      return bb(I, Q, ae, !1);
    }
    var AM = TM, kM = CM;
    ss.Fragment = r, ss.jsx = AM, ss.jsxs = kM;
  })()), ss;
}
var Ob;
function $M() {
  return Ob || (Ob = 1, process.env.NODE_ENV === "production" ? uc.exports = RM() : uc.exports = IM()), uc.exports;
}
var x = $M();
const ft = ({
  title: e,
  icon: t,
  period: n,
  children: r,
  footer: i,
  className: o = "",
  childrenClassName: a,
  titleWeight: s
}) => {
  const l = s === "semi-bold" ? 600 : 500;
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: `relative bg-white !border-[0.5px] !border-[#EBEBEB] !rounded-[12px] !shadow-[0_0_12px_0_#EAF2FF] p-[16px] flex flex-col gap-[24px] ${o}`,
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[12px]", children: [
            t,
            /* @__PURE__ */ x.jsx(
              "div",
              {
                style: {
                  fontWeight: l,
                  fontSize: "16px",
                  lineHeight: "20px"
                },
                className: "!my-0 !text-[16px] !leading-[20px] !text-[#121212]",
                children: e
              }
            )
          ] }),
          n && /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] !leading-[16px] !text-[#64748B]", children: n })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: `flex-1 min-h-0 space-y-[24px] ${a}`, children: r }),
        i && /* @__PURE__ */ x.jsx("div", { className: "mt-3 pt-3 border-t border-gray-100 !text-[12px] text-[#64748B]", children: i })
      ]
    }
  );
}, Sb = (e) => e, LM = () => {
  let e = Sb;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = Sb;
    }
  };
}, FM = LM();
function zr(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function Re(e) {
  if (typeof e != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : zr(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Eb(...e) {
  return e.reduce((t, n) => n == null ? t : function(...i) {
    t.apply(this, i), n.apply(this, i);
  }, () => {
  });
}
var dc = { exports: {} }, fc = { exports: {} }, Le = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _b;
function BM() {
  if (_b) return Le;
  _b = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
  function w(O) {
    if (typeof O == "object" && O !== null) {
      var E = O.$$typeof;
      switch (E) {
        case t:
          switch (O = O.type, O) {
            case l:
            case c:
            case r:
            case o:
            case i:
            case d:
              return O;
            default:
              switch (O = O && O.$$typeof, O) {
                case s:
                case u:
                case g:
                case h:
                case a:
                  return O;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function b(O) {
    return w(O) === c;
  }
  return Le.AsyncMode = l, Le.ConcurrentMode = c, Le.ContextConsumer = s, Le.ContextProvider = a, Le.Element = t, Le.ForwardRef = u, Le.Fragment = r, Le.Lazy = g, Le.Memo = h, Le.Portal = n, Le.Profiler = o, Le.StrictMode = i, Le.Suspense = d, Le.isAsyncMode = function(O) {
    return b(O) || w(O) === l;
  }, Le.isConcurrentMode = b, Le.isContextConsumer = function(O) {
    return w(O) === s;
  }, Le.isContextProvider = function(O) {
    return w(O) === a;
  }, Le.isElement = function(O) {
    return typeof O == "object" && O !== null && O.$$typeof === t;
  }, Le.isForwardRef = function(O) {
    return w(O) === u;
  }, Le.isFragment = function(O) {
    return w(O) === r;
  }, Le.isLazy = function(O) {
    return w(O) === g;
  }, Le.isMemo = function(O) {
    return w(O) === h;
  }, Le.isPortal = function(O) {
    return w(O) === n;
  }, Le.isProfiler = function(O) {
    return w(O) === o;
  }, Le.isStrictMode = function(O) {
    return w(O) === i;
  }, Le.isSuspense = function(O) {
    return w(O) === d;
  }, Le.isValidElementType = function(O) {
    return typeof O == "string" || typeof O == "function" || O === r || O === c || O === o || O === i || O === d || O === p || typeof O == "object" && O !== null && (O.$$typeof === g || O.$$typeof === h || O.$$typeof === a || O.$$typeof === s || O.$$typeof === u || O.$$typeof === v || O.$$typeof === y || O.$$typeof === S || O.$$typeof === m);
  }, Le.typeOf = w, Le;
}
var Fe = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Pb;
function zM() {
  return Pb || (Pb = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
    function w(k) {
      return typeof k == "string" || typeof k == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      k === r || k === c || k === o || k === i || k === d || k === p || typeof k == "object" && k !== null && (k.$$typeof === g || k.$$typeof === h || k.$$typeof === a || k.$$typeof === s || k.$$typeof === u || k.$$typeof === v || k.$$typeof === y || k.$$typeof === S || k.$$typeof === m);
    }
    function b(k) {
      if (typeof k == "object" && k !== null) {
        var de = k.$$typeof;
        switch (de) {
          case t:
            var ne = k.type;
            switch (ne) {
              case l:
              case c:
              case r:
              case o:
              case i:
              case d:
                return ne;
              default:
                var he = ne && ne.$$typeof;
                switch (he) {
                  case s:
                  case u:
                  case g:
                  case h:
                  case a:
                    return he;
                  default:
                    return de;
                }
            }
          case n:
            return de;
        }
      }
    }
    var O = l, E = c, C = s, T = a, j = t, A = u, M = r, P = g, R = h, N = n, D = o, $ = i, F = d, q = !1;
    function B(k) {
      return q || (q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(k) || b(k) === l;
    }
    function L(k) {
      return b(k) === c;
    }
    function Y(k) {
      return b(k) === s;
    }
    function K(k) {
      return b(k) === a;
    }
    function te(k) {
      return typeof k == "object" && k !== null && k.$$typeof === t;
    }
    function J(k) {
      return b(k) === u;
    }
    function G(k) {
      return b(k) === r;
    }
    function ee(k) {
      return b(k) === g;
    }
    function re(k) {
      return b(k) === h;
    }
    function oe(k) {
      return b(k) === n;
    }
    function W(k) {
      return b(k) === o;
    }
    function U(k) {
      return b(k) === i;
    }
    function Z(k) {
      return b(k) === d;
    }
    Fe.AsyncMode = O, Fe.ConcurrentMode = E, Fe.ContextConsumer = C, Fe.ContextProvider = T, Fe.Element = j, Fe.ForwardRef = A, Fe.Fragment = M, Fe.Lazy = P, Fe.Memo = R, Fe.Portal = N, Fe.Profiler = D, Fe.StrictMode = $, Fe.Suspense = F, Fe.isAsyncMode = B, Fe.isConcurrentMode = L, Fe.isContextConsumer = Y, Fe.isContextProvider = K, Fe.isElement = te, Fe.isForwardRef = J, Fe.isFragment = G, Fe.isLazy = ee, Fe.isMemo = re, Fe.isPortal = oe, Fe.isProfiler = W, Fe.isStrictMode = U, Fe.isSuspense = Z, Fe.isValidElementType = w, Fe.typeOf = b;
  })()), Fe;
}
var Cb;
function UE() {
  return Cb || (Cb = 1, process.env.NODE_ENV === "production" ? fc.exports = BM() : fc.exports = zM()), fc.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Wf, Tb;
function WM() {
  if (Tb) return Wf;
  Tb = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(u) {
        return a[u];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        c[u] = u;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Wf = i() ? Object.assign : function(o, a) {
    for (var s, l = r(o), c, u = 1; u < arguments.length; u++) {
      s = Object(arguments[u]);
      for (var d in s)
        t.call(s, d) && (l[d] = s[d]);
      if (e) {
        c = e(s);
        for (var p = 0; p < c.length; p++)
          n.call(s, c[p]) && (l[c[p]] = s[c[p]]);
      }
    }
    return l;
  }, Wf;
}
var Vf, Ab;
function xg() {
  if (Ab) return Vf;
  Ab = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Vf = e, Vf;
}
var Uf, kb;
function HE() {
  return kb || (kb = 1, Uf = Function.call.bind(Object.prototype.hasOwnProperty)), Uf;
}
var Hf, Mb;
function VM() {
  if (Mb) return Hf;
  Mb = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = /* @__PURE__ */ xg(), n = {}, r = /* @__PURE__ */ HE();
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in o)
        if (r(o, u)) {
          var d;
          try {
            if (typeof o[u] != "function") {
              var p = Error(
                (l || "React class") + ": " + s + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = o[u](a, u, l, s, null, t);
          } catch (g) {
            d = g;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var h = c ? c() : "";
            e(
              "Failed " + s + " type: " + d.message + (h ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Hf = i, Hf;
}
var qf, jb;
function UM() {
  if (jb) return qf;
  jb = 1;
  var e = UE(), t = WM(), n = /* @__PURE__ */ xg(), r = /* @__PURE__ */ HE(), i = /* @__PURE__ */ VM(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return qf = function(s, l) {
    var c = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function d(L) {
      var Y = L && (c && L[c] || L[u]);
      if (typeof Y == "function")
        return Y;
    }
    var p = "<<anonymous>>", h = {
      array: y("array"),
      bigint: y("bigint"),
      bool: y("boolean"),
      func: y("function"),
      number: y("number"),
      object: y("object"),
      string: y("string"),
      symbol: y("symbol"),
      any: S(),
      arrayOf: w,
      element: b(),
      elementType: O(),
      instanceOf: E,
      node: A(),
      objectOf: T,
      oneOf: C,
      oneOfType: j,
      shape: P,
      exact: R
    };
    function g(L, Y) {
      return L === Y ? L !== 0 || 1 / L === 1 / Y : L !== L && Y !== Y;
    }
    function m(L, Y) {
      this.message = L, this.data = Y && typeof Y == "object" ? Y : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(L) {
      if (process.env.NODE_ENV !== "production")
        var Y = {}, K = 0;
      function te(G, ee, re, oe, W, U, Z) {
        if (oe = oe || p, U = U || re, Z !== n) {
          if (l) {
            var k = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw k.name = "Invariant Violation", k;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var de = oe + ":" + re;
            !Y[de] && // Avoid spamming the console because they are often not actionable except for lib authors
            K < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + U + "` prop on `" + oe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), Y[de] = !0, K++);
          }
        }
        return ee[re] == null ? G ? ee[re] === null ? new m("The " + W + " `" + U + "` is marked as required " + ("in `" + oe + "`, but its value is `null`.")) : new m("The " + W + " `" + U + "` is marked as required in " + ("`" + oe + "`, but its value is `undefined`.")) : null : L(ee, re, oe, W, U);
      }
      var J = te.bind(null, !1);
      return J.isRequired = te.bind(null, !0), J;
    }
    function y(L) {
      function Y(K, te, J, G, ee, re) {
        var oe = K[te], W = $(oe);
        if (W !== L) {
          var U = F(oe);
          return new m(
            "Invalid " + G + " `" + ee + "` of type " + ("`" + U + "` supplied to `" + J + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return v(Y);
    }
    function S() {
      return v(a);
    }
    function w(L) {
      function Y(K, te, J, G, ee) {
        if (typeof L != "function")
          return new m("Property `" + ee + "` of component `" + J + "` has invalid PropType notation inside arrayOf.");
        var re = K[te];
        if (!Array.isArray(re)) {
          var oe = $(re);
          return new m("Invalid " + G + " `" + ee + "` of type " + ("`" + oe + "` supplied to `" + J + "`, expected an array."));
        }
        for (var W = 0; W < re.length; W++) {
          var U = L(re, W, J, G, ee + "[" + W + "]", n);
          if (U instanceof Error)
            return U;
        }
        return null;
      }
      return v(Y);
    }
    function b() {
      function L(Y, K, te, J, G) {
        var ee = Y[K];
        if (!s(ee)) {
          var re = $(ee);
          return new m("Invalid " + J + " `" + G + "` of type " + ("`" + re + "` supplied to `" + te + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(L);
    }
    function O() {
      function L(Y, K, te, J, G) {
        var ee = Y[K];
        if (!e.isValidElementType(ee)) {
          var re = $(ee);
          return new m("Invalid " + J + " `" + G + "` of type " + ("`" + re + "` supplied to `" + te + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(L);
    }
    function E(L) {
      function Y(K, te, J, G, ee) {
        if (!(K[te] instanceof L)) {
          var re = L.name || p, oe = B(K[te]);
          return new m("Invalid " + G + " `" + ee + "` of type " + ("`" + oe + "` supplied to `" + J + "`, expected ") + ("instance of `" + re + "`."));
        }
        return null;
      }
      return v(Y);
    }
    function C(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function Y(K, te, J, G, ee) {
        for (var re = K[te], oe = 0; oe < L.length; oe++)
          if (g(re, L[oe]))
            return null;
        var W = JSON.stringify(L, function(Z, k) {
          var de = F(k);
          return de === "symbol" ? String(k) : k;
        });
        return new m("Invalid " + G + " `" + ee + "` of value `" + String(re) + "` " + ("supplied to `" + J + "`, expected one of " + W + "."));
      }
      return v(Y);
    }
    function T(L) {
      function Y(K, te, J, G, ee) {
        if (typeof L != "function")
          return new m("Property `" + ee + "` of component `" + J + "` has invalid PropType notation inside objectOf.");
        var re = K[te], oe = $(re);
        if (oe !== "object")
          return new m("Invalid " + G + " `" + ee + "` of type " + ("`" + oe + "` supplied to `" + J + "`, expected an object."));
        for (var W in re)
          if (r(re, W)) {
            var U = L(re, W, J, G, ee + "." + W, n);
            if (U instanceof Error)
              return U;
          }
        return null;
      }
      return v(Y);
    }
    function j(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var Y = 0; Y < L.length; Y++) {
        var K = L[Y];
        if (typeof K != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + q(K) + " at index " + Y + "."
          ), a;
      }
      function te(J, G, ee, re, oe) {
        for (var W = [], U = 0; U < L.length; U++) {
          var Z = L[U], k = Z(J, G, ee, re, oe, n);
          if (k == null)
            return null;
          k.data && r(k.data, "expectedType") && W.push(k.data.expectedType);
        }
        var de = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new m("Invalid " + re + " `" + oe + "` supplied to " + ("`" + ee + "`" + de + "."));
      }
      return v(te);
    }
    function A() {
      function L(Y, K, te, J, G) {
        return N(Y[K]) ? null : new m("Invalid " + J + " `" + G + "` supplied to " + ("`" + te + "`, expected a ReactNode."));
      }
      return v(L);
    }
    function M(L, Y, K, te, J) {
      return new m(
        (L || "React class") + ": " + Y + " type `" + K + "." + te + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + J + "`."
      );
    }
    function P(L) {
      function Y(K, te, J, G, ee) {
        var re = K[te], oe = $(re);
        if (oe !== "object")
          return new m("Invalid " + G + " `" + ee + "` of type `" + oe + "` " + ("supplied to `" + J + "`, expected `object`."));
        for (var W in L) {
          var U = L[W];
          if (typeof U != "function")
            return M(J, G, ee, W, F(U));
          var Z = U(re, W, J, G, ee + "." + W, n);
          if (Z)
            return Z;
        }
        return null;
      }
      return v(Y);
    }
    function R(L) {
      function Y(K, te, J, G, ee) {
        var re = K[te], oe = $(re);
        if (oe !== "object")
          return new m("Invalid " + G + " `" + ee + "` of type `" + oe + "` " + ("supplied to `" + J + "`, expected `object`."));
        var W = t({}, K[te], L);
        for (var U in W) {
          var Z = L[U];
          if (r(L, U) && typeof Z != "function")
            return M(J, G, ee, U, F(Z));
          if (!Z)
            return new m(
              "Invalid " + G + " `" + ee + "` key `" + U + "` supplied to `" + J + "`.\nBad object: " + JSON.stringify(K[te], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var k = Z(re, U, J, G, ee + "." + U, n);
          if (k)
            return k;
        }
        return null;
      }
      return v(Y);
    }
    function N(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(N);
          if (L === null || s(L))
            return !0;
          var Y = d(L);
          if (Y) {
            var K = Y.call(L), te;
            if (Y !== L.entries) {
              for (; !(te = K.next()).done; )
                if (!N(te.value))
                  return !1;
            } else
              for (; !(te = K.next()).done; ) {
                var J = te.value;
                if (J && !N(J[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function D(L, Y) {
      return L === "symbol" ? !0 : Y ? Y["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && Y instanceof Symbol : !1;
    }
    function $(L) {
      var Y = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : D(Y, L) ? "symbol" : Y;
    }
    function F(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var Y = $(L);
      if (Y === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return Y;
    }
    function q(L) {
      var Y = F(L);
      switch (Y) {
        case "array":
        case "object":
          return "an " + Y;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + Y;
        default:
          return Y;
      }
    }
    function B(L) {
      return !L.constructor || !L.constructor.name ? p : L.constructor.name;
    }
    return h.checkPropTypes = i, h.resetWarningCache = i.resetWarningCache, h.PropTypes = h, h;
  }, qf;
}
var Kf, Nb;
function HM() {
  if (Nb) return Kf;
  Nb = 1;
  var e = /* @__PURE__ */ xg();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Kf = function() {
    function r(a, s, l, c, u, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, Kf;
}
var Db;
function qM() {
  if (Db) return dc.exports;
  if (Db = 1, process.env.NODE_ENV !== "production") {
    var e = UE(), t = !0;
    dc.exports = /* @__PURE__ */ UM()(e.isElement, t);
  } else
    dc.exports = /* @__PURE__ */ HM()();
  return dc.exports;
}
var KM = /* @__PURE__ */ qM();
const f = /* @__PURE__ */ xi(KM);
function qE(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = qE(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function ie() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = qE(e)) && (r && (r += " "), r += t);
  return r;
}
function at(e, t, n = void 0) {
  const r = {};
  for (const i in e) {
    const o = e[i];
    let a = "", s = !0;
    for (let l = 0; l < o.length; l += 1) {
      const c = o[l];
      c && (a += (s === !0 ? "" : " ") + t(c), s = !1, n && n[c] && (a += " " + n[c]));
    }
    r[i] = a;
  }
  return r;
}
var pc = { exports: {} }, Xe = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rb;
function YM() {
  if (Rb) return Xe;
  Rb = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), a = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), p = Symbol.for("react.view_transition"), h = Symbol.for("react.client.reference");
  function g(m) {
    if (typeof m == "object" && m !== null) {
      var v = m.$$typeof;
      switch (v) {
        case e:
          switch (m = m.type, m) {
            case n:
            case i:
            case r:
            case l:
            case c:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case a:
                case s:
                case d:
                case u:
                  return m;
                case o:
                  return m;
                default:
                  return v;
              }
          }
        case t:
          return v;
      }
    }
  }
  return Xe.ContextConsumer = o, Xe.ContextProvider = a, Xe.Element = e, Xe.ForwardRef = s, Xe.Fragment = n, Xe.Lazy = d, Xe.Memo = u, Xe.Portal = t, Xe.Profiler = i, Xe.StrictMode = r, Xe.Suspense = l, Xe.SuspenseList = c, Xe.isContextConsumer = function(m) {
    return g(m) === o;
  }, Xe.isContextProvider = function(m) {
    return g(m) === a;
  }, Xe.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === e;
  }, Xe.isForwardRef = function(m) {
    return g(m) === s;
  }, Xe.isFragment = function(m) {
    return g(m) === n;
  }, Xe.isLazy = function(m) {
    return g(m) === d;
  }, Xe.isMemo = function(m) {
    return g(m) === u;
  }, Xe.isPortal = function(m) {
    return g(m) === t;
  }, Xe.isProfiler = function(m) {
    return g(m) === i;
  }, Xe.isStrictMode = function(m) {
    return g(m) === r;
  }, Xe.isSuspense = function(m) {
    return g(m) === l;
  }, Xe.isSuspenseList = function(m) {
    return g(m) === c;
  }, Xe.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === n || m === i || m === r || m === l || m === c || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === u || m.$$typeof === a || m.$$typeof === o || m.$$typeof === s || m.$$typeof === h || m.getModuleId !== void 0);
  }, Xe.typeOf = g, Xe;
}
var Ze = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ib;
function GM() {
  return Ib || (Ib = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(m) {
      if (typeof m == "object" && m !== null) {
        var v = m.$$typeof;
        switch (v) {
          case t:
            switch (m = m.type, m) {
              case r:
              case o:
              case i:
              case c:
              case u:
              case h:
                return m;
              default:
                switch (m = m && m.$$typeof, m) {
                  case s:
                  case l:
                  case p:
                  case d:
                    return m;
                  case a:
                    return m;
                  default:
                    return v;
                }
            }
          case n:
            return v;
        }
      }
    }
    var t = Symbol.for("react.transitional.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.view_transition"), g = Symbol.for("react.client.reference");
    Ze.ContextConsumer = a, Ze.ContextProvider = s, Ze.Element = t, Ze.ForwardRef = l, Ze.Fragment = r, Ze.Lazy = p, Ze.Memo = d, Ze.Portal = n, Ze.Profiler = o, Ze.StrictMode = i, Ze.Suspense = c, Ze.SuspenseList = u, Ze.isContextConsumer = function(m) {
      return e(m) === a;
    }, Ze.isContextProvider = function(m) {
      return e(m) === s;
    }, Ze.isElement = function(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }, Ze.isForwardRef = function(m) {
      return e(m) === l;
    }, Ze.isFragment = function(m) {
      return e(m) === r;
    }, Ze.isLazy = function(m) {
      return e(m) === p;
    }, Ze.isMemo = function(m) {
      return e(m) === d;
    }, Ze.isPortal = function(m) {
      return e(m) === n;
    }, Ze.isProfiler = function(m) {
      return e(m) === o;
    }, Ze.isStrictMode = function(m) {
      return e(m) === i;
    }, Ze.isSuspense = function(m) {
      return e(m) === c;
    }, Ze.isSuspenseList = function(m) {
      return e(m) === u;
    }, Ze.isValidElementType = function(m) {
      return typeof m == "string" || typeof m == "function" || m === r || m === o || m === i || m === c || m === u || typeof m == "object" && m !== null && (m.$$typeof === p || m.$$typeof === d || m.$$typeof === s || m.$$typeof === a || m.$$typeof === l || m.$$typeof === g || m.getModuleId !== void 0);
    }, Ze.typeOf = e;
  })()), Ze;
}
var $b;
function XM() {
  return $b || ($b = 1, process.env.NODE_ENV === "production" ? pc.exports = /* @__PURE__ */ YM() : pc.exports = /* @__PURE__ */ GM()), pc.exports;
}
var Bi = /* @__PURE__ */ XM();
function Rr(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function KE(e) {
  if (/* @__PURE__ */ _.isValidElement(e) || Bi.isValidElementType(e) || !Rr(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = KE(e[n]);
  }), t;
}
function pn(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return Rr(e) && Rr(t) && Object.keys(t).forEach((i) => {
    /* @__PURE__ */ _.isValidElement(t[i]) || Bi.isValidElementType(t[i]) ? r[i] = t[i] : Rr(t[i]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, i) && Rr(e[i]) ? r[i] = pn(e[i], t[i], n) : n.clone ? r[i] = Rr(t[i]) ? KE(t[i]) : t[i] : r[i] = t[i];
  }), r;
}
function zs(e, t) {
  return t ? pn(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const Yi = process.env.NODE_ENV !== "production" ? f.oneOfType([f.number, f.string, f.object, f.array]) : {};
function Lb(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, i) => {
    const o = /min-width:\s*([0-9.]+)/;
    return +(r.match(o)?.[1] || 0) - +(i.match(o)?.[1] || 0);
  });
  return n.length ? n.reduce((r, i) => {
    const o = t[i];
    return delete r[i], r[i] = o, r;
  }, {
    ...t
  }) : t;
}
function ZM(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function JM(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n) {
    if (process.env.NODE_ENV !== "production")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The provided shorthand ${`(${t})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : zr(18, `(${t})`));
    return null;
  }
  const [, r, i] = n, o = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(i).up(o);
}
function QM(e) {
  const t = (o, a) => o.replace("@media", a ? `@container ${a}` : "@container");
  function n(o, a) {
    o.up = (...s) => t(e.breakpoints.up(...s), a), o.down = (...s) => t(e.breakpoints.down(...s), a), o.between = (...s) => t(e.breakpoints.between(...s), a), o.only = (...s) => t(e.breakpoints.only(...s), a), o.not = (...s) => {
      const l = t(e.breakpoints.not(...s), a);
      return l.includes("not all and") ? l.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : l;
    };
  }
  const r = {}, i = (o) => (n(r, o), r);
  return n(i), {
    ...e,
    containerQueries: i
  };
}
const _d = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, Fb = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${_d[e]}px)`
}, ej = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : _d[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function fi(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const o = r.breakpoints || Fb;
    return t.reduce((a, s, l) => (a[o.up(o.keys[l])] = n(t[l]), a), {});
  }
  if (typeof t == "object") {
    const o = r.breakpoints || Fb;
    return Object.keys(t).reduce((a, s) => {
      if (ZM(o.keys, s)) {
        const l = JM(r.containerQueries ? r : ej, s);
        l && (a[l] = n(t[s], s));
      } else if (Object.keys(o.values || _d).includes(s)) {
        const l = o.up(s);
        a[l] = n(t[s], s);
      } else {
        const l = s;
        a[l] = t[l];
      }
      return a;
    }, {});
  }
  return n(t);
}
function tj(e = {}) {
  return e.keys?.reduce((n, r) => {
    const i = e.up(r);
    return n[i] = {}, n;
  }, {}) || {};
}
function Bb(e, t) {
  return e.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n;
  }, t);
}
function Pd(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((i, o) => i && i[o] ? i[o] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, e);
}
function mu(e, t, n, r = n) {
  let i;
  return typeof e == "function" ? i = e(n) : Array.isArray(e) ? i = e[n] || r : i = Pd(e, n) || r, t && (i = t(i, r, e)), i;
}
function jt(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: i
  } = e, o = (a) => {
    if (a[t] == null)
      return null;
    const s = a[t], l = a.theme, c = Pd(l, r) || {};
    return fi(a, s, (d) => {
      let p = mu(c, i, d);
      return d === p && typeof d == "string" && (p = mu(c, i, `${t}${d === "default" ? "" : Re(d)}`, d)), n === !1 ? p : {
        [n]: p
      };
    });
  };
  return o.propTypes = process.env.NODE_ENV !== "production" ? {
    [t]: Yi
  } : {}, o.filterProps = [t], o;
}
function nj(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const rj = {
  m: "margin",
  p: "padding"
}, ij = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, zb = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, oj = nj((e) => {
  if (e.length > 2)
    if (zb[e])
      e = zb[e];
    else
      return [e];
  const [t, n] = e.split(""), r = rj[t], i = ij[n] || "";
  return Array.isArray(i) ? i.map((o) => r + o) : [r + i];
}), Cd = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], Td = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], aj = [...Cd, ...Td];
function Al(e, t, n, r) {
  const i = Pd(e, t, !0) ?? n;
  return typeof i == "number" || typeof i == "string" ? (o) => typeof o == "string" ? o : (process.env.NODE_ENV !== "production" && typeof o != "number" && console.error(`MUI: Expected ${r} argument to be a number or a string, got ${o}.`), typeof i == "string" ? i.startsWith("var(") && o === 0 ? 0 : i.startsWith("var(") && o === 1 ? i : `calc(${o} * ${i})` : i * o) : Array.isArray(i) ? (o) => {
    if (typeof o == "string")
      return o;
    const a = Math.abs(o);
    process.env.NODE_ENV !== "production" && (Number.isInteger(a) ? a > i.length - 1 && console.error([`MUI: The value provided (${a}) overflows.`, `The supported values are: ${JSON.stringify(i)}.`, `${a} > ${i.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${t}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${t}\` as a number.`].join(`
`)));
    const s = i[a];
    return o >= 0 ? s : typeof s == "number" ? -s : typeof s == "string" && s.startsWith("var(") ? `calc(-1 * ${s})` : `-${s}`;
  } : typeof i == "function" ? i : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${t}\` value (${i}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function wg(e) {
  return Al(e, "spacing", 8, "spacing");
}
function kl(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function sj(e, t) {
  return (n) => e.reduce((r, i) => (r[i] = kl(t, n), r), {});
}
function lj(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const i = oj(n), o = sj(i, r), a = e[n];
  return fi(e, a, o);
}
function YE(e, t) {
  const n = wg(e.theme);
  return Object.keys(e).map((r) => lj(e, t, r, n)).reduce(zs, {});
}
function Ot(e) {
  return YE(e, Cd);
}
Ot.propTypes = process.env.NODE_ENV !== "production" ? Cd.reduce((e, t) => (e[t] = Yi, e), {}) : {};
Ot.filterProps = Cd;
function St(e) {
  return YE(e, Td);
}
St.propTypes = process.env.NODE_ENV !== "production" ? Td.reduce((e, t) => (e[t] = Yi, e), {}) : {};
St.filterProps = Td;
process.env.NODE_ENV !== "production" && aj.reduce((e, t) => (e[t] = Yi, e), {});
function Ad(...e) {
  const t = e.reduce((r, i) => (i.filterProps.forEach((o) => {
    r[o] = i;
  }), r), {}), n = (r) => Object.keys(r).reduce((i, o) => t[o] ? zs(i, t[o](r)) : i, {});
  return n.propTypes = process.env.NODE_ENV !== "production" ? e.reduce((r, i) => Object.assign(r, i.propTypes), {}) : {}, n.filterProps = e.reduce((r, i) => r.concat(i.filterProps), []), n;
}
function ar(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function vr(e, t) {
  return jt({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const cj = vr("border", ar), uj = vr("borderTop", ar), dj = vr("borderRight", ar), fj = vr("borderBottom", ar), pj = vr("borderLeft", ar), hj = vr("borderColor"), mj = vr("borderTopColor"), gj = vr("borderRightColor"), vj = vr("borderBottomColor"), yj = vr("borderLeftColor"), bj = vr("outline", ar), xj = vr("outlineColor"), kd = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Al(e.theme, "shape.borderRadius", 4, "borderRadius"), n = (r) => ({
      borderRadius: kl(t, r)
    });
    return fi(e, e.borderRadius, n);
  }
  return null;
};
kd.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: Yi
} : {};
kd.filterProps = ["borderRadius"];
Ad(cj, uj, dj, fj, pj, hj, mj, gj, vj, yj, kd, bj, xj);
const Md = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Al(e.theme, "spacing", 8, "gap"), n = (r) => ({
      gap: kl(t, r)
    });
    return fi(e, e.gap, n);
  }
  return null;
};
Md.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: Yi
} : {};
Md.filterProps = ["gap"];
const jd = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Al(e.theme, "spacing", 8, "columnGap"), n = (r) => ({
      columnGap: kl(t, r)
    });
    return fi(e, e.columnGap, n);
  }
  return null;
};
jd.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: Yi
} : {};
jd.filterProps = ["columnGap"];
const Nd = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Al(e.theme, "spacing", 8, "rowGap"), n = (r) => ({
      rowGap: kl(t, r)
    });
    return fi(e, e.rowGap, n);
  }
  return null;
};
Nd.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: Yi
} : {};
Nd.filterProps = ["rowGap"];
const wj = jt({
  prop: "gridColumn"
}), Oj = jt({
  prop: "gridRow"
}), Sj = jt({
  prop: "gridAutoFlow"
}), Ej = jt({
  prop: "gridAutoColumns"
}), _j = jt({
  prop: "gridAutoRows"
}), Pj = jt({
  prop: "gridTemplateColumns"
}), Cj = jt({
  prop: "gridTemplateRows"
}), Tj = jt({
  prop: "gridTemplateAreas"
}), Aj = jt({
  prop: "gridArea"
});
Ad(Md, jd, Nd, wj, Oj, Sj, Ej, _j, Pj, Cj, Tj, Aj);
function ba(e, t) {
  return t === "grey" ? t : e;
}
const kj = jt({
  prop: "color",
  themeKey: "palette",
  transform: ba
}), Mj = jt({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: ba
}), jj = jt({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: ba
});
Ad(kj, Mj, jj);
function Bn(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const Nj = jt({
  prop: "width",
  transform: Bn
}), Og = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      const r = e.theme?.breakpoints?.values?.[n] || _d[n];
      return r ? e.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: Bn(n)
      };
    };
    return fi(e, e.maxWidth, t);
  }
  return null;
};
Og.filterProps = ["maxWidth"];
const Dj = jt({
  prop: "minWidth",
  transform: Bn
}), Rj = jt({
  prop: "height",
  transform: Bn
}), Ij = jt({
  prop: "maxHeight",
  transform: Bn
}), $j = jt({
  prop: "minHeight",
  transform: Bn
});
jt({
  prop: "size",
  cssProperty: "width",
  transform: Bn
});
jt({
  prop: "size",
  cssProperty: "height",
  transform: Bn
});
const Lj = jt({
  prop: "boxSizing"
});
Ad(Nj, Og, Dj, Rj, Ij, $j, Lj);
const Ml = {
  // borders
  border: {
    themeKey: "borders",
    transform: ar
  },
  borderTop: {
    themeKey: "borders",
    transform: ar
  },
  borderRight: {
    themeKey: "borders",
    transform: ar
  },
  borderBottom: {
    themeKey: "borders",
    transform: ar
  },
  borderLeft: {
    themeKey: "borders",
    transform: ar
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: ar
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: kd
  },
  // palette
  color: {
    themeKey: "palette",
    transform: ba
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: ba
  },
  backgroundColor: {
    themeKey: "palette",
    transform: ba
  },
  // spacing
  p: {
    style: St
  },
  pt: {
    style: St
  },
  pr: {
    style: St
  },
  pb: {
    style: St
  },
  pl: {
    style: St
  },
  px: {
    style: St
  },
  py: {
    style: St
  },
  padding: {
    style: St
  },
  paddingTop: {
    style: St
  },
  paddingRight: {
    style: St
  },
  paddingBottom: {
    style: St
  },
  paddingLeft: {
    style: St
  },
  paddingX: {
    style: St
  },
  paddingY: {
    style: St
  },
  paddingInline: {
    style: St
  },
  paddingInlineStart: {
    style: St
  },
  paddingInlineEnd: {
    style: St
  },
  paddingBlock: {
    style: St
  },
  paddingBlockStart: {
    style: St
  },
  paddingBlockEnd: {
    style: St
  },
  m: {
    style: Ot
  },
  mt: {
    style: Ot
  },
  mr: {
    style: Ot
  },
  mb: {
    style: Ot
  },
  ml: {
    style: Ot
  },
  mx: {
    style: Ot
  },
  my: {
    style: Ot
  },
  margin: {
    style: Ot
  },
  marginTop: {
    style: Ot
  },
  marginRight: {
    style: Ot
  },
  marginBottom: {
    style: Ot
  },
  marginLeft: {
    style: Ot
  },
  marginX: {
    style: Ot
  },
  marginY: {
    style: Ot
  },
  marginInline: {
    style: Ot
  },
  marginInlineStart: {
    style: Ot
  },
  marginInlineEnd: {
    style: Ot
  },
  marginBlock: {
    style: Ot
  },
  marginBlockStart: {
    style: Ot
  },
  marginBlockEnd: {
    style: Ot
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Md
  },
  rowGap: {
    style: Nd
  },
  columnGap: {
    style: jd
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Bn
  },
  maxWidth: {
    style: Og
  },
  minWidth: {
    transform: Bn
  },
  height: {
    transform: Bn
  },
  maxHeight: {
    transform: Bn
  },
  minHeight: {
    transform: Bn
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Fj(...e) {
  const t = e.reduce((r, i) => r.concat(Object.keys(i)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function Bj(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function zj() {
  function e(n, r, i, o) {
    const a = {
      [n]: r,
      theme: i
    }, s = o[n];
    if (!s)
      return {
        [n]: r
      };
    const {
      cssProperty: l = n,
      themeKey: c,
      transform: u,
      style: d
    } = s;
    if (r == null)
      return null;
    if (c === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const p = Pd(i, c) || {};
    return d ? d(a) : fi(a, r, (g) => {
      let m = mu(p, u, g);
      return g === m && typeof g == "string" && (m = mu(p, u, `${n}${g === "default" ? "" : Re(g)}`, g)), l === !1 ? m : {
        [l]: m
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: i = {},
      nested: o
    } = n || {};
    if (!r)
      return null;
    const a = i.unstable_sxConfig ?? Ml;
    function s(l) {
      let c = l;
      if (typeof l == "function")
        c = l(i);
      else if (typeof l != "object")
        return l;
      if (!c)
        return null;
      const u = tj(i.breakpoints), d = Object.keys(u);
      let p = u;
      return Object.keys(c).forEach((h) => {
        const g = Bj(c[h], i);
        if (g != null)
          if (typeof g == "object")
            if (a[h])
              p = zs(p, e(h, g, i, a));
            else {
              const m = fi({
                theme: i
              }, g, (v) => ({
                [h]: v
              }));
              Fj(m, g) ? p[h] = t({
                sx: g,
                theme: i,
                nested: !0
              }) : p = zs(p, m);
            }
          else
            p = zs(p, e(h, g, i, a));
      }), !o && i.modularCssLayers ? {
        "@layer sx": Lb(i, Bb(d, p))
      } : Lb(i, Bb(d, p));
    }
    return Array.isArray(r) ? r.map(s) : s(r);
  }
  return t;
}
const Pa = zj();
Pa.filterProps = ["sx"];
const Wj = (e) => {
  const t = {
    systemProps: {},
    otherProps: {}
  }, n = e?.theme?.unstable_sxConfig ?? Ml;
  return Object.keys(e).forEach((r) => {
    n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r];
  }), t;
};
function Vj(e) {
  const {
    sx: t,
    ...n
  } = e, {
    systemProps: r,
    otherProps: i
  } = Wj(n);
  let o;
  return Array.isArray(t) ? o = [r, ...t] : typeof t == "function" ? o = (...a) => {
    const s = t(...a);
    return Rr(s) ? {
      ...r,
      ...s
    } : r;
  } : o = {
    ...r,
    ...t
  }, {
    ...i,
    sx: o
  };
}
function gu() {
  return gu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, gu.apply(null, arguments);
}
function Uj(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function Hj(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var qj = /* @__PURE__ */ (function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Hj(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = Uj(i);
      try {
        o.insertRule(r, o.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), cn = "-ms-", vu = "-moz-", ke = "-webkit-", GE = "comm", Sg = "rule", Eg = "decl", Kj = "@import", XE = "@keyframes", Yj = "@layer", Gj = Math.abs, Dd = String.fromCharCode, Xj = Object.assign;
function Zj(e, t) {
  return tn(e, 0) ^ 45 ? (((t << 2 ^ tn(e, 0)) << 2 ^ tn(e, 1)) << 2 ^ tn(e, 2)) << 2 ^ tn(e, 3) : 0;
}
function ZE(e) {
  return e.trim();
}
function Jj(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function Me(e, t, n) {
  return e.replace(t, n);
}
function Jh(e, t) {
  return e.indexOf(t);
}
function tn(e, t) {
  return e.charCodeAt(t) | 0;
}
function Qs(e, t, n) {
  return e.slice(t, n);
}
function jr(e) {
  return e.length;
}
function _g(e) {
  return e.length;
}
function hc(e, t) {
  return t.push(e), e;
}
function Qj(e, t) {
  return e.map(t).join("");
}
var Rd = 1, Ca = 1, JE = 0, jn = 0, It = 0, Va = "";
function Id(e, t, n, r, i, o, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: o, line: Rd, column: Ca, length: a, return: "" };
}
function ls(e, t) {
  return Xj(Id("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function eN() {
  return It;
}
function tN() {
  return It = jn > 0 ? tn(Va, --jn) : 0, Ca--, It === 10 && (Ca = 1, Rd--), It;
}
function Vn() {
  return It = jn < JE ? tn(Va, jn++) : 0, Ca++, It === 10 && (Ca = 1, Rd++), It;
}
function $r() {
  return tn(Va, jn);
}
function ou() {
  return jn;
}
function jl(e, t) {
  return Qs(Va, e, t);
}
function el(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function QE(e) {
  return Rd = Ca = 1, JE = jr(Va = e), jn = 0, [];
}
function e_(e) {
  return Va = "", e;
}
function au(e) {
  return ZE(jl(jn - 1, Qh(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function nN(e) {
  for (; (It = $r()) && It < 33; )
    Vn();
  return el(e) > 2 || el(It) > 3 ? "" : " ";
}
function rN(e, t) {
  for (; --t && Vn() && !(It < 48 || It > 102 || It > 57 && It < 65 || It > 70 && It < 97); )
    ;
  return jl(e, ou() + (t < 6 && $r() == 32 && Vn() == 32));
}
function Qh(e) {
  for (; Vn(); )
    switch (It) {
      // ] ) " '
      case e:
        return jn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Qh(It);
        break;
      // (
      case 40:
        e === 41 && Qh(e);
        break;
      // \
      case 92:
        Vn();
        break;
    }
  return jn;
}
function iN(e, t) {
  for (; Vn() && e + It !== 57; )
    if (e + It === 84 && $r() === 47)
      break;
  return "/*" + jl(t, jn - 1) + "*" + Dd(e === 47 ? e : Vn());
}
function oN(e) {
  for (; !el($r()); )
    Vn();
  return jl(e, jn);
}
function aN(e) {
  return e_(su("", null, null, null, [""], e = QE(e), 0, [0], e));
}
function su(e, t, n, r, i, o, a, s, l) {
  for (var c = 0, u = 0, d = a, p = 0, h = 0, g = 0, m = 1, v = 1, y = 1, S = 0, w = "", b = i, O = o, E = r, C = w; v; )
    switch (g = S, S = Vn()) {
      // (
      case 40:
        if (g != 108 && tn(C, d - 1) == 58) {
          Jh(C += Me(au(S), "&", "&\f"), "&\f") != -1 && (y = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        C += au(S);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        C += nN(g);
        break;
      // \
      case 92:
        C += rN(ou() - 1, 7);
        continue;
      // /
      case 47:
        switch ($r()) {
          case 42:
          case 47:
            hc(sN(iN(Vn(), ou()), t, n), l);
            break;
          default:
            C += "/";
        }
        break;
      // {
      case 123 * m:
        s[c++] = jr(C) * y;
      // } ; \0
      case 125 * m:
      case 59:
      case 0:
        switch (S) {
          // \0 }
          case 0:
          case 125:
            v = 0;
          // ;
          case 59 + u:
            y == -1 && (C = Me(C, /\f/g, "")), h > 0 && jr(C) - d && hc(h > 32 ? Vb(C + ";", r, n, d - 1) : Vb(Me(C, " ", "") + ";", r, n, d - 2), l);
            break;
          // @ ;
          case 59:
            C += ";";
          // { rule/at-rule
          default:
            if (hc(E = Wb(C, t, n, c, u, i, s, w, b = [], O = [], d), o), S === 123)
              if (u === 0)
                su(C, t, E, E, b, o, d, s, O);
              else
                switch (p === 99 && tn(C, 3) === 110 ? 100 : p) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    su(e, E, E, r && hc(Wb(e, E, E, 0, 0, i, s, w, i, b = [], d), O), i, O, d, s, r ? b : O);
                    break;
                  default:
                    su(C, E, E, E, [""], O, 0, s, O);
                }
        }
        c = u = h = 0, m = y = 1, w = C = "", d = a;
        break;
      // :
      case 58:
        d = 1 + jr(C), h = g;
      default:
        if (m < 1) {
          if (S == 123)
            --m;
          else if (S == 125 && m++ == 0 && tN() == 125)
            continue;
        }
        switch (C += Dd(S), S * m) {
          // &
          case 38:
            y = u > 0 ? 1 : (C += "\f", -1);
            break;
          // ,
          case 44:
            s[c++] = (jr(C) - 1) * y, y = 1;
            break;
          // @
          case 64:
            $r() === 45 && (C += au(Vn())), p = $r(), u = d = jr(w = C += oN(ou())), S++;
            break;
          // -
          case 45:
            g === 45 && jr(C) == 2 && (m = 0);
        }
    }
  return o;
}
function Wb(e, t, n, r, i, o, a, s, l, c, u) {
  for (var d = i - 1, p = i === 0 ? o : [""], h = _g(p), g = 0, m = 0, v = 0; g < r; ++g)
    for (var y = 0, S = Qs(e, d + 1, d = Gj(m = a[g])), w = e; y < h; ++y)
      (w = ZE(m > 0 ? p[y] + " " + S : Me(S, /&\f/g, p[y]))) && (l[v++] = w);
  return Id(e, t, n, i === 0 ? Sg : s, l, c, u);
}
function sN(e, t, n) {
  return Id(e, t, n, GE, Dd(eN()), Qs(e, 2, -2), 0);
}
function Vb(e, t, n, r) {
  return Id(e, t, n, Eg, Qs(e, 0, r), Qs(e, r + 1, -1), r);
}
function xa(e, t) {
  for (var n = "", r = _g(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function lN(e, t, n, r) {
  switch (e.type) {
    case Yj:
      if (e.children.length) break;
    case Kj:
    case Eg:
      return e.return = e.return || e.value;
    case GE:
      return "";
    case XE:
      return e.return = e.value + "{" + xa(e.children, r) + "}";
    case Sg:
      e.value = e.props.join(",");
  }
  return jr(n = xa(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function cN(e) {
  var t = _g(e);
  return function(n, r, i, o) {
    for (var a = "", s = 0; s < t; s++)
      a += e[s](n, r, i, o) || "";
    return a;
  };
}
function uN(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function t_(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var dN = function(t, n, r) {
  for (var i = 0, o = 0; i = o, o = $r(), i === 38 && o === 12 && (n[r] = 1), !el(o); )
    Vn();
  return jl(t, jn);
}, fN = function(t, n) {
  var r = -1, i = 44;
  do
    switch (el(i)) {
      case 0:
        i === 38 && $r() === 12 && (n[r] = 1), t[r] += dN(jn - 1, n, r);
        break;
      case 2:
        t[r] += au(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = $r() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Dd(i);
    }
  while (i = Vn());
  return t;
}, pN = function(t, n) {
  return e_(fN(QE(t), n));
}, Ub = /* @__PURE__ */ new WeakMap(), hN = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Ub.get(r)) && !i) {
      Ub.set(t, !0);
      for (var o = [], a = pN(n, o), s = r.props, l = 0, c = 0; l < a.length; l++)
        for (var u = 0; u < s.length; u++, c++)
          t.props[c] = o[l] ? a[l].replace(/&\f/g, s[u]) : s[u] + " " + a[l];
    }
  }
}, mN = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function n_(e, t) {
  switch (Zj(e, t)) {
    // color-adjust
    case 5103:
      return ke + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return ke + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return ke + e + vu + e + cn + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return ke + e + cn + e + e;
    // order
    case 6165:
      return ke + e + cn + "flex-" + e + e;
    // align-items
    case 5187:
      return ke + e + Me(e, /(\w+).+(:[^]+)/, ke + "box-$1$2" + cn + "flex-$1$2") + e;
    // align-self
    case 5443:
      return ke + e + cn + "flex-item-" + Me(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return ke + e + cn + "flex-line-pack" + Me(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return ke + e + cn + Me(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return ke + e + cn + Me(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return ke + "box-" + Me(e, "-grow", "") + ke + e + cn + Me(e, "grow", "positive") + e;
    // transition
    case 4554:
      return ke + Me(e, /([^-])(transform)/g, "$1" + ke + "$2") + e;
    // cursor
    case 6187:
      return Me(Me(Me(e, /(zoom-|grab)/, ke + "$1"), /(image-set)/, ke + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return Me(e, /(image-set\([^]*)/, ke + "$1$`$1");
    // justify-content
    case 4968:
      return Me(Me(e, /(.+:)(flex-)?(.*)/, ke + "box-pack:$3" + cn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + ke + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Me(e, /(.+)-inline(.+)/, ke + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (jr(e) - 1 - t > 6) switch (tn(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (tn(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return Me(e, /(.+:)(.+)-([^]+)/, "$1" + ke + "$2-$3$1" + vu + (tn(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Jh(e, "stretch") ? n_(Me(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (tn(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (tn(e, jr(e) - 3 - (~Jh(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return Me(e, ":", ":" + ke) + e;
        // (inline-)?fl(e)x
        case 101:
          return Me(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + ke + (tn(e, 14) === 45 ? "inline-" : "") + "box$3$1" + ke + "$2$3$1" + cn + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (tn(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return ke + e + cn + Me(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return ke + e + cn + Me(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return ke + e + cn + Me(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return ke + e + cn + e + e;
  }
  return e;
}
var gN = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Eg:
      t.return = n_(t.value, t.length);
      break;
    case XE:
      return xa([ls(t, {
        value: Me(t.value, "@", "@" + ke)
      })], i);
    case Sg:
      if (t.length) return Qj(t.props, function(o) {
        switch (Jj(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return xa([ls(t, {
              props: [Me(o, /:(read-\w+)/, ":" + vu + "$1")]
            })], i);
          // :placeholder
          case "::placeholder":
            return xa([ls(t, {
              props: [Me(o, /:(plac\w+)/, ":" + ke + "input-$1")]
            }), ls(t, {
              props: [Me(o, /:(plac\w+)/, ":" + vu + "$1")]
            }), ls(t, {
              props: [Me(o, /:(plac\w+)/, cn + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, vN = [gN], yN = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(m) {
      var v = m.getAttribute("data-emotion");
      v.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || vN, o = {}, a, s = [];
  a = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(m) {
      for (var v = m.getAttribute("data-emotion").split(" "), y = 1; y < v.length; y++)
        o[v[y]] = !0;
      s.push(m);
    }
  );
  var l, c = [hN, mN];
  {
    var u, d = [lN, uN(function(m) {
      u.insert(m);
    })], p = cN(c.concat(i, d)), h = function(v) {
      return xa(aN(v), p);
    };
    l = function(v, y, S, w) {
      u = S, h(v ? v + "{" + y.styles + "}" : y.styles), w && (g.inserted[y.name] = !0);
    };
  }
  var g = {
    key: n,
    sheet: new qj({
      key: n,
      container: a,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: l
  };
  return g.sheet.hydrate(s), g;
}, mc = { exports: {} }, Be = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hb;
function bN() {
  if (Hb) return Be;
  Hb = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
  function w(O) {
    if (typeof O == "object" && O !== null) {
      var E = O.$$typeof;
      switch (E) {
        case t:
          switch (O = O.type, O) {
            case l:
            case c:
            case r:
            case o:
            case i:
            case d:
              return O;
            default:
              switch (O = O && O.$$typeof, O) {
                case s:
                case u:
                case g:
                case h:
                case a:
                  return O;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function b(O) {
    return w(O) === c;
  }
  return Be.AsyncMode = l, Be.ConcurrentMode = c, Be.ContextConsumer = s, Be.ContextProvider = a, Be.Element = t, Be.ForwardRef = u, Be.Fragment = r, Be.Lazy = g, Be.Memo = h, Be.Portal = n, Be.Profiler = o, Be.StrictMode = i, Be.Suspense = d, Be.isAsyncMode = function(O) {
    return b(O) || w(O) === l;
  }, Be.isConcurrentMode = b, Be.isContextConsumer = function(O) {
    return w(O) === s;
  }, Be.isContextProvider = function(O) {
    return w(O) === a;
  }, Be.isElement = function(O) {
    return typeof O == "object" && O !== null && O.$$typeof === t;
  }, Be.isForwardRef = function(O) {
    return w(O) === u;
  }, Be.isFragment = function(O) {
    return w(O) === r;
  }, Be.isLazy = function(O) {
    return w(O) === g;
  }, Be.isMemo = function(O) {
    return w(O) === h;
  }, Be.isPortal = function(O) {
    return w(O) === n;
  }, Be.isProfiler = function(O) {
    return w(O) === o;
  }, Be.isStrictMode = function(O) {
    return w(O) === i;
  }, Be.isSuspense = function(O) {
    return w(O) === d;
  }, Be.isValidElementType = function(O) {
    return typeof O == "string" || typeof O == "function" || O === r || O === c || O === o || O === i || O === d || O === p || typeof O == "object" && O !== null && (O.$$typeof === g || O.$$typeof === h || O.$$typeof === a || O.$$typeof === s || O.$$typeof === u || O.$$typeof === v || O.$$typeof === y || O.$$typeof === S || O.$$typeof === m);
  }, Be.typeOf = w, Be;
}
var ze = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qb;
function xN() {
  return qb || (qb = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
    function w(k) {
      return typeof k == "string" || typeof k == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      k === r || k === c || k === o || k === i || k === d || k === p || typeof k == "object" && k !== null && (k.$$typeof === g || k.$$typeof === h || k.$$typeof === a || k.$$typeof === s || k.$$typeof === u || k.$$typeof === v || k.$$typeof === y || k.$$typeof === S || k.$$typeof === m);
    }
    function b(k) {
      if (typeof k == "object" && k !== null) {
        var de = k.$$typeof;
        switch (de) {
          case t:
            var ne = k.type;
            switch (ne) {
              case l:
              case c:
              case r:
              case o:
              case i:
              case d:
                return ne;
              default:
                var he = ne && ne.$$typeof;
                switch (he) {
                  case s:
                  case u:
                  case g:
                  case h:
                  case a:
                    return he;
                  default:
                    return de;
                }
            }
          case n:
            return de;
        }
      }
    }
    var O = l, E = c, C = s, T = a, j = t, A = u, M = r, P = g, R = h, N = n, D = o, $ = i, F = d, q = !1;
    function B(k) {
      return q || (q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(k) || b(k) === l;
    }
    function L(k) {
      return b(k) === c;
    }
    function Y(k) {
      return b(k) === s;
    }
    function K(k) {
      return b(k) === a;
    }
    function te(k) {
      return typeof k == "object" && k !== null && k.$$typeof === t;
    }
    function J(k) {
      return b(k) === u;
    }
    function G(k) {
      return b(k) === r;
    }
    function ee(k) {
      return b(k) === g;
    }
    function re(k) {
      return b(k) === h;
    }
    function oe(k) {
      return b(k) === n;
    }
    function W(k) {
      return b(k) === o;
    }
    function U(k) {
      return b(k) === i;
    }
    function Z(k) {
      return b(k) === d;
    }
    ze.AsyncMode = O, ze.ConcurrentMode = E, ze.ContextConsumer = C, ze.ContextProvider = T, ze.Element = j, ze.ForwardRef = A, ze.Fragment = M, ze.Lazy = P, ze.Memo = R, ze.Portal = N, ze.Profiler = D, ze.StrictMode = $, ze.Suspense = F, ze.isAsyncMode = B, ze.isConcurrentMode = L, ze.isContextConsumer = Y, ze.isContextProvider = K, ze.isElement = te, ze.isForwardRef = J, ze.isFragment = G, ze.isLazy = ee, ze.isMemo = re, ze.isPortal = oe, ze.isProfiler = W, ze.isStrictMode = U, ze.isSuspense = Z, ze.isValidElementType = w, ze.typeOf = b;
  })()), ze;
}
var Kb;
function wN() {
  return Kb || (Kb = 1, process.env.NODE_ENV === "production" ? mc.exports = bN() : mc.exports = xN()), mc.exports;
}
var Yf, Yb;
function ON() {
  if (Yb) return Yf;
  Yb = 1;
  var e = wN(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, i = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, o = {};
  o[e.ForwardRef] = r, o[e.Memo] = i;
  function a(g) {
    return e.isMemo(g) ? i : o[g.$$typeof] || t;
  }
  var s = Object.defineProperty, l = Object.getOwnPropertyNames, c = Object.getOwnPropertySymbols, u = Object.getOwnPropertyDescriptor, d = Object.getPrototypeOf, p = Object.prototype;
  function h(g, m, v) {
    if (typeof m != "string") {
      if (p) {
        var y = d(m);
        y && y !== p && h(g, y, v);
      }
      var S = l(m);
      c && (S = S.concat(c(m)));
      for (var w = a(g), b = a(m), O = 0; O < S.length; ++O) {
        var E = S[O];
        if (!n[E] && !(v && v[E]) && !(b && b[E]) && !(w && w[E])) {
          var C = u(m, E);
          try {
            s(g, E, C);
          } catch {
          }
        }
      }
    }
    return g;
  }
  return Yf = h, Yf;
}
ON();
var SN = !0;
function r_(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var Pg = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  SN === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, Cg = function(t, n, r) {
  Pg(t, n, r);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + i : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function EN(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var _N = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, PN = /[A-Z]|^ms/g, CN = /_EMO_([^_]+?)_([^]*?)_EMO_/g, i_ = function(t) {
  return t.charCodeAt(1) === 45;
}, Gb = function(t) {
  return t != null && typeof t != "boolean";
}, Gf = /* @__PURE__ */ t_(function(e) {
  return i_(e) ? e : e.replace(PN, "-$&").toLowerCase();
}), Xb = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(CN, function(r, i, o) {
          return Nr = {
            name: i,
            styles: o,
            next: Nr
          }, i;
        });
  }
  return _N[t] !== 1 && !i_(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function tl(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return Nr = {
          name: i.name,
          styles: i.styles,
          next: Nr
        }, i.name;
      var o = n;
      if (o.styles !== void 0) {
        var a = o.next;
        if (a !== void 0)
          for (; a !== void 0; )
            Nr = {
              name: a.name,
              styles: a.styles,
              next: Nr
            }, a = a.next;
        var s = o.styles + ";";
        return s;
      }
      return TN(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var l = Nr, c = n(e);
        return Nr = l, tl(e, t, c);
      }
      break;
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function TN(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += tl(e, t, n[i]) + ";";
  else
    for (var o in n) {
      var a = n[o];
      if (typeof a != "object") {
        var s = a;
        t != null && t[s] !== void 0 ? r += o + "{" + t[s] + "}" : Gb(s) && (r += Gf(o) + ":" + Xb(o, s) + ";");
      } else if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
        for (var l = 0; l < a.length; l++)
          Gb(a[l]) && (r += Gf(o) + ":" + Xb(o, a[l]) + ";");
      else {
        var c = tl(e, t, a);
        switch (o) {
          case "animation":
          case "animationName": {
            r += Gf(o) + ":" + c + ";";
            break;
          }
          default:
            r += o + "{" + c + "}";
        }
      }
    }
  return r;
}
var Zb = /label:\s*([^\s;{]+)\s*(;|$)/g, Nr;
function Nl(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  Nr = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    r = !1, i += tl(n, t, o);
  else {
    var a = o;
    i += a[0];
  }
  for (var s = 1; s < e.length; s++)
    if (i += tl(n, t, e[s]), r) {
      var l = o;
      i += l[s];
    }
  Zb.lastIndex = 0;
  for (var c = "", u; (u = Zb.exec(i)) !== null; )
    c += "-" + u[1];
  var d = EN(i) + c;
  return {
    name: d,
    styles: i,
    next: Nr
  };
}
var AN = function(t) {
  return t();
}, o_ = _.useInsertionEffect ? _.useInsertionEffect : !1, a_ = o_ || AN, Jb = o_ || _.useLayoutEffect, s_ = /* @__PURE__ */ _.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ yN({
    key: "css"
  }) : null
);
s_.Provider;
var Tg = function(t) {
  return /* @__PURE__ */ rn(function(n, r) {
    var i = Kr(s_);
    return t(n, i, r);
  });
}, $d = /* @__PURE__ */ _.createContext({}), Ag = {}.hasOwnProperty, em = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", kN = function(t, n) {
  var r = {};
  for (var i in n)
    Ag.call(n, i) && (r[i] = n[i]);
  return r[em] = t, r;
}, MN = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return Pg(n, r, i), a_(function() {
    return Cg(n, r, i);
  }), null;
}, jN = /* @__PURE__ */ Tg(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var i = e[em], o = [r], a = "";
  typeof e.className == "string" ? a = r_(t.registered, o, e.className) : e.className != null && (a = e.className + " ");
  var s = Nl(o, void 0, _.useContext($d));
  a += t.key + "-" + s.name;
  var l = {};
  for (var c in e)
    Ag.call(e, c) && c !== "css" && c !== em && (l[c] = e[c]);
  return l.className = a, n && (l.ref = n), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(MN, {
    cache: t,
    serialized: s,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ _.createElement(i, l));
}), NN = jN, Qb = function(t, n) {
  var r = arguments;
  if (n == null || !Ag.call(n, "css"))
    return _.createElement.apply(void 0, r);
  var i = r.length, o = new Array(i);
  o[0] = NN, o[1] = kN(t, n);
  for (var a = 2; a < i; a++)
    o[a] = r[a];
  return _.createElement.apply(null, o);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(Qb || (Qb = {}));
var DN = /* @__PURE__ */ Tg(function(e, t) {
  var n = e.styles, r = Nl([n], void 0, _.useContext($d)), i = _.useRef();
  return Jb(function() {
    var o = t.key + "-global", a = new t.sheet.constructor({
      key: o,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), s = !1, l = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
    return t.sheet.tags.length && (a.before = t.sheet.tags[0]), l !== null && (s = !0, l.setAttribute("data-emotion", o), a.hydrate([l])), i.current = [a, s], function() {
      a.flush();
    };
  }, [t]), Jb(function() {
    var o = i.current, a = o[0], s = o[1];
    if (s) {
      o[1] = !1;
      return;
    }
    if (r.next !== void 0 && Cg(t, r.next, !0), a.tags.length) {
      var l = a.tags[a.tags.length - 1].nextElementSibling;
      a.before = l, a.flush();
    }
    t.insert("", r, a, !1);
  }, [t, r.name]), null;
});
function RN() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Nl(t);
}
function kg() {
  var e = RN.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var IN = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, $N = /* @__PURE__ */ t_(
  function(e) {
    return IN.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), LN = $N, FN = function(t) {
  return t !== "theme";
}, e0 = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? LN : FN;
}, t0 = function(t, n, r) {
  var i;
  if (n) {
    var o = n.shouldForwardProp;
    i = t.__emotion_forwardProp && o ? function(a) {
      return t.__emotion_forwardProp(a) && o(a);
    } : o;
  }
  return typeof i != "function" && r && (i = t.__emotion_forwardProp), i;
}, BN = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return Pg(n, r, i), a_(function() {
    return Cg(n, r, i);
  }), null;
}, zN = function e(t, n) {
  var r = t.__emotion_real === t, i = r && t.__emotion_base || t, o, a;
  n !== void 0 && (o = n.label, a = n.target);
  var s = t0(t, n, r), l = s || e0(i), c = !l("as");
  return function() {
    var u = arguments, d = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (o !== void 0 && d.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0)
      d.push.apply(d, u);
    else {
      var p = u[0];
      d.push(p[0]);
      for (var h = u.length, g = 1; g < h; g++)
        d.push(u[g], p[g]);
    }
    var m = Tg(function(v, y, S) {
      var w = c && v.as || i, b = "", O = [], E = v;
      if (v.theme == null) {
        E = {};
        for (var C in v)
          E[C] = v[C];
        E.theme = _.useContext($d);
      }
      typeof v.className == "string" ? b = r_(y.registered, O, v.className) : v.className != null && (b = v.className + " ");
      var T = Nl(d.concat(O), y.registered, E);
      b += y.key + "-" + T.name, a !== void 0 && (b += " " + a);
      var j = c && s === void 0 ? e0(w) : l, A = {};
      for (var M in v)
        c && M === "as" || j(M) && (A[M] = v[M]);
      return A.className = b, S && (A.ref = S), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(BN, {
        cache: y,
        serialized: T,
        isStringTag: typeof w == "string"
      }), /* @__PURE__ */ _.createElement(w, A));
    });
    return m.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", m.defaultProps = t.defaultProps, m.__emotion_real = m, m.__emotion_base = i, m.__emotion_styles = d, m.__emotion_forwardProp = s, Object.defineProperty(m, "toString", {
      value: function() {
        return "." + a;
      }
    }), m.withComponent = function(v, y) {
      var S = e(v, gu({}, n, y, {
        shouldForwardProp: t0(m, y, !0)
      }));
      return S.apply(void 0, d);
    }, m;
  };
}, WN = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], yu = zN.bind(null);
WN.forEach(function(e) {
  yu[e] = yu(e);
});
function VN(e) {
  return e == null || Object.keys(e).length === 0;
}
function l_(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? (i) => t(VN(i) ? n : i) : t;
  return /* @__PURE__ */ x.jsx(DN, {
    styles: r
  });
}
process.env.NODE_ENV !== "production" && (l_.propTypes = {
  defaultTheme: f.object,
  styles: f.oneOfType([f.array, f.string, f.object, f.func])
});
/**
 * @mui/styled-engine v7.3.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function UN(e, t) {
  const n = yu(e, t);
  return process.env.NODE_ENV !== "production" ? (...r) => {
    const i = typeof e == "string" ? `"${e}"` : "component";
    return r.length === 0 ? console.error([`MUI: Seems like you called \`styled(${i})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : r.some((o) => o === void 0) && console.error(`MUI: the styled(${i})(...args) API requires all its args to be defined.`), n(...r);
  } : n;
}
function HN(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const n0 = [];
function $i(e) {
  return n0[0] = e, Nl(n0);
}
const qN = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function KN(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...i
  } = e, o = qN(t), a = Object.keys(o);
  function s(p) {
    return `@media (min-width:${typeof t[p] == "number" ? t[p] : p}${n})`;
  }
  function l(p) {
    return `@media (max-width:${(typeof t[p] == "number" ? t[p] : p) - r / 100}${n})`;
  }
  function c(p, h) {
    const g = a.indexOf(h);
    return `@media (min-width:${typeof t[p] == "number" ? t[p] : p}${n}) and (max-width:${(g !== -1 && typeof t[a[g]] == "number" ? t[a[g]] : h) - r / 100}${n})`;
  }
  function u(p) {
    return a.indexOf(p) + 1 < a.length ? c(p, a[a.indexOf(p) + 1]) : s(p);
  }
  function d(p) {
    const h = a.indexOf(p);
    return h === 0 ? s(a[1]) : h === a.length - 1 ? l(a[h]) : c(p, a[a.indexOf(p) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: a,
    values: o,
    up: s,
    down: l,
    between: c,
    only: u,
    not: d,
    unit: n,
    ...i
  };
}
const YN = {
  borderRadius: 4
};
function c_(e = 8, t = wg({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (process.env.NODE_ENV !== "production" && (r.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${r.length}`)), (r.length === 0 ? [1] : r).map((o) => {
    const a = t(o);
    return typeof a == "number" ? `${a}px` : a;
  }).join(" "));
  return n.mui = !0, n;
}
function GN(e, t) {
  const n = this;
  if (n.vars) {
    if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
      return {};
    let r = n.getColorSchemeSelector(e);
    return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
      [r]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function Mg(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: i,
    shape: o = {},
    ...a
  } = e, s = KN(n), l = c_(i);
  let c = pn({
    breakpoints: s,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: l,
    shape: {
      ...YN,
      ...o
    }
  }, a);
  return c = QM(c), c.applyStyles = GN, c = t.reduce((u, d) => pn(u, d), c), c.unstable_sxConfig = {
    ...Ml,
    ...a?.unstable_sxConfig
  }, c.unstable_sx = function(d) {
    return Pa({
      sx: d,
      theme: this
    });
  }, c;
}
function XN(e) {
  return Object.keys(e).length === 0;
}
function ZN(e = null) {
  const t = _.useContext($d);
  return !t || XN(t) ? e : t;
}
const JN = Mg();
function u_(e = JN) {
  return ZN(e);
}
function Xf(e) {
  const t = $i(e);
  return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : e;
}
function d_({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = u_(n), i = t && r[t] || r;
  let o = typeof e == "function" ? e(i) : e;
  return i.modularCssLayers && (Array.isArray(o) ? o = o.map((a) => Xf(typeof a == "function" ? a(i) : a)) : o = Xf(o)), /* @__PURE__ */ x.jsx(l_, {
    styles: o
  });
}
process.env.NODE_ENV !== "production" && (d_.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  defaultTheme: f.object,
  /**
   * @ignore
   */
  styles: f.oneOfType([f.array, f.func, f.number, f.object, f.string, f.bool]),
  /**
   * @ignore
   */
  themeId: f.string
});
const QN = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function Je(e, t, n = "Mui") {
  const r = QN[t];
  return r ? `${n}-${r}` : `${FM.generate(e)}-${t}`;
}
function Ge(e, t, n = "Mui") {
  const r = {};
  return t.forEach((i) => {
    r[i] = Je(e, i, n);
  }), r;
}
function f_(e, t = "") {
  return e.displayName || e.name || t;
}
function r0(e, t, n) {
  const r = f_(t);
  return e.displayName || (r !== "" ? `${n}(${r})` : n);
}
function eD(e) {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return f_(e, "Component");
    if (typeof e == "object")
      switch (e.$$typeof) {
        case Bi.ForwardRef:
          return r0(e, e.render, "ForwardRef");
        case Bi.Memo:
          return r0(e, e.type, "memo");
        default:
          return;
      }
  }
}
function p_(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: $i(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((i) => {
    typeof i.style != "function" && (i.style = $i(i.style));
  }), r;
}
const tD = Mg();
function Zf(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function Oo(e, t) {
  return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
}
function nD(e) {
  return e ? (t, n) => n[e] : null;
}
function rD(e, t, n) {
  e.theme = sD(e.theme) ? n : e.theme[t] || e.theme;
}
function lu(e, t, n) {
  const r = typeof t == "function" ? t(e) : t;
  if (Array.isArray(r))
    return r.flatMap((i) => lu(e, i, n));
  if (Array.isArray(r?.variants)) {
    let i;
    if (r.isProcessed)
      i = n ? Oo(r.style, n) : r.style;
    else {
      const {
        variants: o,
        ...a
      } = r;
      i = n ? Oo($i(a), n) : a;
    }
    return h_(e, r.variants, [i], n);
  }
  return r?.isProcessed ? n ? Oo($i(r.style), n) : r.style : n ? Oo($i(r), n) : r;
}
function h_(e, t, n = [], r = void 0) {
  let i;
  e: for (let o = 0; o < t.length; o += 1) {
    const a = t[o];
    if (typeof a.props == "function") {
      if (i ??= {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }, !a.props(i))
        continue;
    } else
      for (const s in a.props)
        if (e[s] !== a.props[s] && e.ownerState?.[s] !== a.props[s])
          continue e;
    typeof a.style == "function" ? (i ??= {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }, n.push(r ? Oo($i(a.style(i)), r) : a.style(i))) : n.push(r ? Oo($i(a.style), r) : a.style);
  }
  return n;
}
function iD(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = tD,
    rootShouldForwardProp: r = Zf,
    slotShouldForwardProp: i = Zf
  } = e;
  function o(s) {
    rD(s, t, n);
  }
  return (s, l = {}) => {
    HN(s, (E) => E.filter((C) => C !== Pa));
    const {
      name: c,
      slot: u,
      skipVariantsResolver: d,
      skipSx: p,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: h = nD(m_(u)),
      ...g
    } = l, m = c && c.startsWith("Mui") || u ? "components" : "custom", v = d !== void 0 ? d : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      u && u !== "Root" && u !== "root" || !1
    ), y = p || !1;
    let S = Zf;
    u === "Root" || u === "root" ? S = r : u ? S = i : lD(s) && (S = void 0);
    const w = UN(s, {
      shouldForwardProp: S,
      label: aD(c, u),
      ...g
    }), b = (E) => {
      if (E.__emotion_real === E)
        return E;
      if (typeof E == "function")
        return function(T) {
          return lu(T, E, T.theme.modularCssLayers ? m : void 0);
        };
      if (Rr(E)) {
        const C = p_(E);
        return function(j) {
          return C.variants ? lu(j, C, j.theme.modularCssLayers ? m : void 0) : j.theme.modularCssLayers ? Oo(C.style, m) : C.style;
        };
      }
      return E;
    }, O = (...E) => {
      const C = [], T = E.map(b), j = [];
      if (C.push(o), c && h && j.push(function(R) {
        const D = R.theme.components?.[c]?.styleOverrides;
        if (!D)
          return null;
        const $ = {};
        for (const F in D)
          $[F] = lu(R, D[F], R.theme.modularCssLayers ? "theme" : void 0);
        return h(R, $);
      }), c && !v && j.push(function(R) {
        const D = R.theme?.components?.[c]?.variants;
        return D ? h_(R, D, [], R.theme.modularCssLayers ? "theme" : void 0) : null;
      }), y || j.push(Pa), Array.isArray(T[0])) {
        const P = T.shift(), R = new Array(C.length).fill(""), N = new Array(j.length).fill("");
        let D;
        D = [...R, ...P, ...N], D.raw = [...R, ...P.raw, ...N], C.unshift(D);
      }
      const A = [...C, ...T, ...j], M = w(...A);
      return s.muiName && (M.muiName = s.muiName), process.env.NODE_ENV !== "production" && (M.displayName = oD(c, u, s)), M;
    };
    return w.withConfig && (O.withConfig = w.withConfig), O;
  };
}
function oD(e, t, n) {
  return e ? `${e}${Re(t || "")}` : `Styled(${eD(n)})`;
}
function aD(e, t) {
  let n;
  return process.env.NODE_ENV !== "production" && e && (n = `${e}-${m_(t || "Root")}`), n;
}
function sD(e) {
  for (const t in e)
    return !1;
  return !0;
}
function lD(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function m_(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function tm(e, t, n = !1) {
  const r = {
    ...t
  };
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const o = i;
      if (o === "components" || o === "slots")
        r[o] = {
          ...e[o],
          ...r[o]
        };
      else if (o === "componentsProps" || o === "slotProps") {
        const a = e[o], s = t[o];
        if (!s)
          r[o] = a || {};
        else if (!a)
          r[o] = s;
        else {
          r[o] = {
            ...s
          };
          for (const l in a)
            if (Object.prototype.hasOwnProperty.call(a, l)) {
              const c = l;
              r[o][c] = tm(a[c], s[c], n);
            }
        }
      } else o === "className" && n && t.className ? r.className = ie(e?.className, t?.className) : o === "style" && n && t.style ? r.style = {
        ...e?.style,
        ...t?.style
      } : r[o] === void 0 && (r[o] = e[o]);
    }
  return r;
}
const Wr = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function cD(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function jg(e, t = 0, n = 1) {
  return process.env.NODE_ENV !== "production" && (e < t || e > n) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${n}].`), cD(e, t, n);
}
function uD(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), process.env.NODE_ENV !== "production" && e.length !== e.trim().length && console.error(`MUI: The color: "${e}" is invalid. Make sure the color input doesn't contain leading/trailing space.`), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, i) => i < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function zi(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return zi(uD(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${e}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : zr(9, e));
  let r = e.substring(t + 1, e.length - 1), i;
  if (n === "color") {
    if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(i))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${i}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : zr(10, i));
  } else
    r = r.split(",");
  return r = r.map((o) => parseFloat(o)), {
    type: n,
    values: r,
    colorSpace: i
  };
}
const dD = (e) => {
  const t = zi(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, ks = (e, t) => {
  try {
    return dD(e);
  } catch {
    return t && process.env.NODE_ENV !== "production" && console.warn(t), e;
  }
};
function Ld(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((i, o) => o < 3 ? parseInt(i, 10) : i) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function g_(e) {
  e = zi(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, o = r * Math.min(i, 1 - i), a = (c, u = (c + n / 30) % 12) => i - o * Math.max(Math.min(u - 3, 9 - u, 1), -1);
  let s = "rgb";
  const l = [Math.round(a(0) * 255), Math.round(a(8) * 255), Math.round(a(4) * 255)];
  return e.type === "hsla" && (s += "a", l.push(t[3])), Ld({
    type: s,
    values: l
  });
}
function nm(e) {
  e = zi(e);
  let t = e.type === "hsl" || e.type === "hsla" ? zi(g_(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function i0(e, t) {
  const n = nm(e), r = nm(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function bu(e, t) {
  return e = zi(e), t = jg(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, Ld(e);
}
function so(e, t, n) {
  try {
    return bu(e, t);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), e;
  }
}
function Fd(e, t) {
  if (e = zi(e), t = jg(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return Ld(e);
}
function Ve(e, t, n) {
  try {
    return Fd(e, t);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), e;
  }
}
function Bd(e, t) {
  if (e = zi(e), t = jg(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return Ld(e);
}
function Ue(e, t, n) {
  try {
    return Bd(e, t);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), e;
  }
}
function fD(e, t = 0.15) {
  return nm(e) > 0.5 ? Fd(e, t) : Bd(e, t);
}
function gc(e, t, n) {
  try {
    return fD(e, t);
  } catch {
    return e;
  }
}
const pD = "exact-prop: ";
function v_(e) {
  return process.env.NODE_ENV === "production" ? e : {
    ...e,
    [pD]: (t) => {
      const n = Object.keys(t).filter((r) => !e.hasOwnProperty(r));
      return n.length > 0 ? new Error(`The following props are not supported: ${n.map((r) => `\`${r}\``).join(", ")}. Please remove them.`) : null;
    }
  };
}
const hD = /* @__PURE__ */ _.createContext();
process.env.NODE_ENV !== "production" && (f.node, f.bool);
const Ng = () => _.useContext(hD) ?? !1, mD = /* @__PURE__ */ _.createContext(void 0);
process.env.NODE_ENV !== "production" && (f.node, f.object);
function gD(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const i = t.components[n];
  return i.defaultProps ? tm(i.defaultProps, r, t.components.mergeClassNameAndStyle) : !i.styleOverrides && !i.variants ? tm(i, r, t.components.mergeClassNameAndStyle) : r;
}
function vD({
  props: e,
  name: t
}) {
  const n = _.useContext(mD);
  return gD({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
let o0 = 0;
function yD(e) {
  const [t, n] = _.useState(e), r = e || t;
  return _.useEffect(() => {
    t == null && (o0 += 1, n(`mui-${o0}`));
  }, [t]), r;
}
const bD = {
  ..._
}, a0 = bD.useId;
function Dg(e) {
  if (a0 !== void 0) {
    const t = a0();
    return e ?? t;
  }
  return yD(e);
}
const s0 = {
  theme: void 0
};
function xD(e) {
  let t, n;
  return function(i) {
    let o = t;
    return (o === void 0 || i.theme !== n) && (s0.theme = i.theme, o = p_(e(s0)), t = o, n = i.theme), o;
  };
}
function wD(e = "") {
  function t(...r) {
    if (!r.length)
      return "";
    const i = r[0];
    return typeof i == "string" && !i.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${i}${t(...r.slice(1))})` : `, ${i}`;
  }
  return (r, ...i) => `var(--${e ? `${e}-` : ""}${r}${t(...i)})`;
}
const l0 = (e, t, n, r = []) => {
  let i = e;
  t.forEach((o, a) => {
    a === t.length - 1 ? Array.isArray(i) ? i[Number(o)] = n : i && typeof i == "object" && (i[o] = n) : i && typeof i == "object" && (i[o] || (i[o] = r.includes(o) ? [] : {}), i = i[o]);
  });
}, OD = (e, t, n) => {
  function r(i, o = [], a = []) {
    Object.entries(i).forEach(([s, l]) => {
      (!n || n && !n([...o, s])) && l != null && (typeof l == "object" && Object.keys(l).length > 0 ? r(l, [...o, s], Array.isArray(l) ? [...a, s] : a) : t([...o, s], l, a));
    });
  }
  r(e);
}, SD = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function Jf(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, i = {}, o = {}, a = {};
  return OD(
    e,
    (s, l, c) => {
      if ((typeof l == "string" || typeof l == "number") && (!r || !r(s, l))) {
        const u = `--${n ? `${n}-` : ""}${s.join("-")}`, d = SD(s, l);
        Object.assign(i, {
          [u]: d
        }), l0(o, s, `var(${u})`, c), l0(a, s, `var(${u}, ${d})`, c);
      }
    },
    (s) => s[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: i,
    vars: o,
    varsWithDefaults: a
  };
}
function ED(e, t = {}) {
  const {
    getSelector: n = y,
    disableCssColorScheme: r,
    colorSchemeSelector: i,
    enableContrastVars: o
  } = t, {
    colorSchemes: a = {},
    components: s,
    defaultColorScheme: l = "light",
    ...c
  } = e, {
    vars: u,
    css: d,
    varsWithDefaults: p
  } = Jf(c, t);
  let h = p;
  const g = {}, {
    [l]: m,
    ...v
  } = a;
  if (Object.entries(v || {}).forEach(([b, O]) => {
    const {
      vars: E,
      css: C,
      varsWithDefaults: T
    } = Jf(O, t);
    h = pn(h, T), g[b] = {
      css: C,
      vars: E
    };
  }), m) {
    const {
      css: b,
      vars: O,
      varsWithDefaults: E
    } = Jf(m, t);
    h = pn(h, E), g[l] = {
      css: b,
      vars: O
    };
  }
  function y(b, O) {
    let E = i;
    if (i === "class" && (E = ".%s"), i === "data" && (E = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (E = `[${i}="%s"]`), b) {
      if (E === "media")
        return e.defaultColorScheme === b ? ":root" : {
          [`@media (prefers-color-scheme: ${a[b]?.palette?.mode || b})`]: {
            ":root": O
          }
        };
      if (E)
        return e.defaultColorScheme === b ? `:root, ${E.replace("%s", String(b))}` : E.replace("%s", String(b));
    }
    return ":root";
  }
  return {
    vars: h,
    generateThemeVars: () => {
      let b = {
        ...u
      };
      return Object.entries(g).forEach(([, {
        vars: O
      }]) => {
        b = pn(b, O);
      }), b;
    },
    generateStyleSheets: () => {
      const b = [], O = e.defaultColorScheme || "light";
      function E(j, A) {
        Object.keys(A).length && b.push(typeof j == "string" ? {
          [j]: {
            ...A
          }
        } : j);
      }
      E(n(void 0, {
        ...d
      }), d);
      const {
        [O]: C,
        ...T
      } = g;
      if (C) {
        const {
          css: j
        } = C, A = a[O]?.palette?.mode, M = !r && A ? {
          colorScheme: A,
          ...j
        } : {
          ...j
        };
        E(n(O, {
          ...M
        }), M);
      }
      return Object.entries(T).forEach(([j, {
        css: A
      }]) => {
        const M = a[j]?.palette?.mode, P = !r && M ? {
          colorScheme: M,
          ...A
        } : {
          ...A
        };
        E(n(j, {
          ...P
        }), P);
      }), o && b.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      }), b;
    }
  };
}
function _D(e) {
  return function(n) {
    return e === "media" ? (process.env.NODE_ENV !== "production" && n !== "light" && n !== "dark" && console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${n}'.`), `@media (prefers-color-scheme: ${n})`) : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
  };
}
function Qf(e, t) {
  return /* @__PURE__ */ _.isValidElement(e) && t.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    e.type.muiName ?? e.type?._payload?.value?.muiName
  ) !== -1;
}
const nl = {
  black: "#000",
  white: "#fff"
}, PD = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, na = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, ra = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, cs = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, ia = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, oa = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, aa = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function y_() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: nl.white,
      default: nl.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const b_ = y_();
function x_() {
  return {
    text: {
      primary: nl.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: nl.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const rm = x_();
function c0(e, t, n, r) {
  const i = r.light || r, o = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = Bd(e.main, i) : t === "dark" && (e.dark = Fd(e.main, o)));
}
function u0(e, t, n, r, i) {
  const o = i.light || i, a = i.dark || i * 1.5;
  t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(o * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(a * 100).toFixed(0)}%)`));
}
function CD(e = "light") {
  return e === "dark" ? {
    main: ia[200],
    light: ia[50],
    dark: ia[400]
  } : {
    main: ia[700],
    light: ia[400],
    dark: ia[800]
  };
}
function TD(e = "light") {
  return e === "dark" ? {
    main: na[200],
    light: na[50],
    dark: na[400]
  } : {
    main: na[500],
    light: na[300],
    dark: na[700]
  };
}
function AD(e = "light") {
  return e === "dark" ? {
    main: ra[500],
    light: ra[300],
    dark: ra[700]
  } : {
    main: ra[700],
    light: ra[400],
    dark: ra[800]
  };
}
function kD(e = "light") {
  return e === "dark" ? {
    main: oa[400],
    light: oa[300],
    dark: oa[700]
  } : {
    main: oa[700],
    light: oa[500],
    dark: oa[900]
  };
}
function MD(e = "light") {
  return e === "dark" ? {
    main: aa[400],
    light: aa[300],
    dark: aa[700]
  } : {
    main: aa[800],
    light: aa[500],
    dark: aa[900]
  };
}
function jD(e = "light") {
  return e === "dark" ? {
    main: cs[400],
    light: cs[300],
    dark: cs[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: cs[500],
    dark: cs[900]
  };
}
function ND(e) {
  return `oklch(from ${e} var(--__l) 0 h / var(--__a))`;
}
function Rg(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    colorSpace: i,
    ...o
  } = e, a = e.primary || CD(t), s = e.secondary || TD(t), l = e.error || AD(t), c = e.info || kD(t), u = e.success || MD(t), d = e.warning || jD(t);
  function p(v) {
    if (i)
      return ND(v);
    const y = i0(v, rm.text.primary) >= n ? rm.text.primary : b_.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const S = i0(v, y);
      S < 3 && console.error([`MUI: The contrast ratio of ${S}:1 for ${y} on ${v}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return y;
  }
  const h = ({
    color: v,
    name: y,
    mainShade: S = 500,
    lightShade: w = 300,
    darkShade: b = 700
  }) => {
    if (v = {
      ...v
    }, !v.main && v[S] && (v.main = v[S]), !v.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${S}\` property.` : zr(11, y ? ` (${y})` : "", S));
    if (typeof v.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(v.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : zr(12, y ? ` (${y})` : "", JSON.stringify(v.main)));
    return i ? (u0(i, v, "light", w, r), u0(i, v, "dark", b, r)) : (c0(v, "light", w, r), c0(v, "dark", b, r)), v.contrastText || (v.contrastText = p(v.main)), v;
  };
  let g;
  return t === "light" ? g = y_() : t === "dark" && (g = x_()), process.env.NODE_ENV !== "production" && (g || console.error(`MUI: The palette mode \`${t}\` is not supported.`)), pn({
    // A collection of common colors.
    common: {
      ...nl
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: h({
      color: a,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: h({
      color: s,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: h({
      color: l,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: h({
      color: d,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: h({
      color: c,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: h({
      color: u,
      name: "success"
    }),
    // The grey colors.
    grey: PD,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: p,
    // Generate a rich color object.
    augmentColor: h,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...g
  }, o);
}
function DD(e) {
  const t = {};
  return Object.entries(e).forEach((r) => {
    const [i, o] = r;
    typeof o == "object" && (t[i] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`);
  }), t;
}
function RD(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function ID(e) {
  return Math.round(e * 1e5) / 1e5;
}
const d0 = {
  textTransform: "uppercase"
}, f0 = '"Roboto", "Helvetica", "Arial", sans-serif';
function $D(e, t) {
  const {
    fontFamily: n = f0,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: i = 300,
    fontWeightRegular: o = 400,
    fontWeightMedium: a = 500,
    fontWeightBold: s = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: l = 16,
    // Apply the CSS properties to all the variants.
    allVariants: c,
    pxToRem: u,
    ...d
  } = typeof t == "function" ? t(e) : t;
  process.env.NODE_ENV !== "production" && (typeof r != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof l != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const p = r / 14, h = u || ((v) => `${v / l * p}rem`), g = (v, y, S, w, b) => ({
    fontFamily: n,
    fontWeight: v,
    fontSize: h(y),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: S,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === f0 ? {
      letterSpacing: `${ID(w / y)}em`
    } : {},
    ...b,
    ...c
  }), m = {
    h1: g(i, 96, 1.167, -1.5),
    h2: g(i, 60, 1.2, -0.5),
    h3: g(o, 48, 1.167, 0),
    h4: g(o, 34, 1.235, 0.25),
    h5: g(o, 24, 1.334, 0),
    h6: g(a, 20, 1.6, 0.15),
    subtitle1: g(o, 16, 1.75, 0.15),
    subtitle2: g(a, 14, 1.57, 0.1),
    body1: g(o, 16, 1.5, 0.15),
    body2: g(o, 14, 1.43, 0.15),
    button: g(a, 14, 1.75, 0.4, d0),
    caption: g(o, 12, 1.66, 0.4),
    overline: g(o, 12, 2.66, 1, d0),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return pn({
    htmlFontSize: l,
    pxToRem: h,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: i,
    fontWeightRegular: o,
    fontWeightMedium: a,
    fontWeightBold: s,
    ...m
  }, d, {
    clone: !1
    // No need to clone deep
  });
}
const LD = 0.2, FD = 0.14, BD = 0.12;
function mt(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${LD})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${FD})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${BD})`].join(",");
}
const zD = ["none", mt(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), mt(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), mt(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), mt(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), mt(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), mt(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), mt(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), mt(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), mt(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), mt(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), mt(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), mt(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), mt(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), mt(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), mt(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), mt(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), mt(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), mt(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), mt(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), mt(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), mt(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), mt(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), mt(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), mt(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], WD = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, VD = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function p0(e) {
  return `${Math.round(e)}ms`;
}
function UD(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function HD(e) {
  const t = {
    ...WD,
    ...e.easing
  }, n = {
    ...VD,
    ...e.duration
  };
  return {
    getAutoHeightDuration: UD,
    create: (i = ["all"], o = {}) => {
      const {
        duration: a = n.standard,
        easing: s = t.easeInOut,
        delay: l = 0,
        ...c
      } = o;
      if (process.env.NODE_ENV !== "production") {
        const u = (p) => typeof p == "string", d = (p) => !Number.isNaN(parseFloat(p));
        !u(i) && !Array.isArray(i) && console.error('MUI: Argument "props" must be a string or Array.'), !d(a) && !u(a) && console.error(`MUI: Argument "duration" must be a number or a string but found ${a}.`), u(s) || console.error('MUI: Argument "easing" must be a string.'), !d(l) && !u(l) && console.error('MUI: Argument "delay" must be a number or a string.'), typeof o != "object" && console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join(`
`)), Object.keys(c).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(c).join(",")}].`);
      }
      return (Array.isArray(i) ? i : [i]).map((u) => `${u} ${typeof a == "string" ? a : p0(a)} ${s} ${typeof l == "string" ? l : p0(l)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const qD = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function KD(e) {
  return Rr(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function w_(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const i = Object.entries(r);
    for (let o = 0; o < i.length; o++) {
      const [a, s] = i[o];
      !KD(s) || a.startsWith("unstable_") ? delete r[a] : Rr(s) && (r[a] = {
        ...s
      }, n(r[a]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function h0(e) {
  return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`;
}
const YD = (e) => {
  if (!Number.isNaN(+e))
    return +e;
  const t = e.match(/\d*\.?\d+/g);
  if (!t)
    return 0;
  let n = 0;
  for (let r = 0; r < t.length; r += 1)
    n += +t[r];
  return n;
};
function GD(e) {
  Object.assign(e, {
    alpha(t, n) {
      const r = this || e;
      return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : bu(t, YD(n));
    },
    lighten(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${h0(n)})` : Bd(t, n);
    },
    darken(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${h0(n)})` : Fd(t, n);
    }
  });
}
function im(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: i,
    palette: o = {},
    transitions: a = {},
    typography: s = {},
    shape: l,
    colorSpace: c,
    ...u
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature." : zr(20));
  const d = Rg({
    ...o,
    colorSpace: c
  }), p = Mg(e);
  let h = pn(p, {
    mixins: RD(p.breakpoints, r),
    palette: d,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: zD.slice(),
    typography: $D(d, s),
    transitions: HD(a),
    zIndex: {
      ...qD
    }
  });
  if (h = pn(h, u), h = t.reduce((g, m) => pn(g, m), h), process.env.NODE_ENV !== "production") {
    const g = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], m = (v, y) => {
      let S;
      for (S in v) {
        const w = v[S];
        if (g.includes(S) && Object.keys(w).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const b = Je("", S);
            console.error([`MUI: The \`${y}\` component increases the CSS specificity of the \`${S}\` internal state.`, "You can not override it like this: ", JSON.stringify(v, null, 2), "", `Instead, you need to use the '&.${b}' syntax:`, JSON.stringify({
              root: {
                [`&.${b}`]: w
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          v[S] = {};
        }
      }
    };
    Object.keys(h.components).forEach((v) => {
      const y = h.components[v].styleOverrides;
      y && v.startsWith("Mui") && m(y, v);
    });
  }
  return h.unstable_sxConfig = {
    ...Ml,
    ...u?.unstable_sxConfig
  }, h.unstable_sx = function(m) {
    return Pa({
      sx: m,
      theme: this
    });
  }, h.toRuntimeSource = w_, GD(h), h;
}
function om(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const XD = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = om(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function O_(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function S_(e) {
  return e === "dark" ? XD : [];
}
function ZD(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    colorSpace: i,
    ...o
  } = e, a = Rg({
    ...t,
    colorSpace: i
  });
  return {
    palette: a,
    opacity: {
      ...O_(a.mode),
      ...n
    },
    overlays: r || S_(a.mode),
    ...o
  };
}
function JD(e) {
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const QD = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], eR = (e) => (t, n) => {
  const r = e.rootSelector || ":root", i = e.colorSchemeSelector;
  let o = i;
  if (i === "class" && (o = ".%s"), i === "data" && (o = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (o = `[${i}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const a = {};
      return QD(e.cssVarPrefix).forEach((s) => {
        a[s] = n[s], delete n[s];
      }), o === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: a
        }
      } : o ? {
        [o.replace("%s", t)]: a,
        [`${r}, ${o.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...a
        }
      };
    }
    if (o && o !== "media")
      return `${r}, ${o.replace("%s", String(t))}`;
  } else if (t) {
    if (o === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (o)
      return o.replace("%s", String(t));
  }
  return r;
};
function tR(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function H(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function Ms(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : g_(e);
}
function Zr(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = ks(Ms(e[t]), `MUI: Can't create \`palette.${t}Channel\` because \`palette.${t}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${t}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`));
}
function nR(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Cr = (e) => {
  try {
    return e();
  } catch {
  }
}, rR = (e = "mui") => wD(e);
function ep(e, t, n, r, i) {
  if (!n)
    return;
  n = n === !0 ? {} : n;
  const o = i === "dark" ? "dark" : "light";
  if (!r) {
    t[i] = ZD({
      ...n,
      palette: {
        mode: o,
        ...n?.palette
      },
      colorSpace: e
    });
    return;
  }
  const {
    palette: a,
    ...s
  } = im({
    ...r,
    palette: {
      mode: o,
      ...n?.palette
    },
    colorSpace: e
  });
  return t[i] = {
    ...n,
    palette: a,
    opacity: {
      ...O_(o),
      ...n?.opacity
    },
    overlays: n?.overlays || S_(o)
  }, s;
}
function iR(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: i = !1,
    cssVarPrefix: o = "mui",
    nativeColor: a = !1,
    shouldSkipGeneratingVar: s = JD,
    colorSchemeSelector: l = n.light && n.dark ? "media" : void 0,
    rootSelector: c = ":root",
    ...u
  } = e, d = Object.keys(n)[0], p = r || (n.light && d !== "light" ? "light" : d), h = rR(o), {
    [p]: g,
    light: m,
    dark: v,
    ...y
  } = n, S = {
    ...y
  };
  let w = g;
  if ((p === "dark" && !("dark" in n) || p === "light" && !("light" in n)) && (w = !0), !w)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The \`colorSchemes.${p}\` option is either missing or invalid.` : zr(21, p));
  let b;
  a && (b = "oklch");
  const O = ep(b, S, w, u, p);
  m && !S.light && ep(b, S, m, void 0, "light"), v && !S.dark && ep(b, S, v, void 0, "dark");
  let E = {
    defaultColorScheme: p,
    ...O,
    cssVarPrefix: o,
    colorSchemeSelector: l,
    rootSelector: c,
    getCssVar: h,
    colorSchemes: S,
    font: {
      ...DD(O.typography),
      ...O.font
    },
    spacing: nR(u.spacing)
  };
  Object.keys(E.colorSchemes).forEach((M) => {
    const P = E.colorSchemes[M].palette, R = (D) => {
      const $ = D.split("-"), F = $[1], q = $[2];
      return h(D, P[F][q]);
    };
    P.mode === "light" && (H(P.common, "background", "#fff"), H(P.common, "onBackground", "#000")), P.mode === "dark" && (H(P.common, "background", "#000"), H(P.common, "onBackground", "#fff"));
    function N(D, $, F) {
      if (b) {
        let q;
        return D === so && (q = `transparent ${((1 - F) * 100).toFixed(0)}%`), D === Ve && (q = `#000 ${(F * 100).toFixed(0)}%`), D === Ue && (q = `#fff ${(F * 100).toFixed(0)}%`), `color-mix(in ${b}, ${$}, ${q})`;
      }
      return D($, F);
    }
    if (tR(P, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), P.mode === "light") {
      H(P.Alert, "errorColor", N(Ve, P.error.light, 0.6)), H(P.Alert, "infoColor", N(Ve, P.info.light, 0.6)), H(P.Alert, "successColor", N(Ve, P.success.light, 0.6)), H(P.Alert, "warningColor", N(Ve, P.warning.light, 0.6)), H(P.Alert, "errorFilledBg", R("palette-error-main")), H(P.Alert, "infoFilledBg", R("palette-info-main")), H(P.Alert, "successFilledBg", R("palette-success-main")), H(P.Alert, "warningFilledBg", R("palette-warning-main")), H(P.Alert, "errorFilledColor", Cr(() => P.getContrastText(P.error.main))), H(P.Alert, "infoFilledColor", Cr(() => P.getContrastText(P.info.main))), H(P.Alert, "successFilledColor", Cr(() => P.getContrastText(P.success.main))), H(P.Alert, "warningFilledColor", Cr(() => P.getContrastText(P.warning.main))), H(P.Alert, "errorStandardBg", N(Ue, P.error.light, 0.9)), H(P.Alert, "infoStandardBg", N(Ue, P.info.light, 0.9)), H(P.Alert, "successStandardBg", N(Ue, P.success.light, 0.9)), H(P.Alert, "warningStandardBg", N(Ue, P.warning.light, 0.9)), H(P.Alert, "errorIconColor", R("palette-error-main")), H(P.Alert, "infoIconColor", R("palette-info-main")), H(P.Alert, "successIconColor", R("palette-success-main")), H(P.Alert, "warningIconColor", R("palette-warning-main")), H(P.AppBar, "defaultBg", R("palette-grey-100")), H(P.Avatar, "defaultBg", R("palette-grey-400")), H(P.Button, "inheritContainedBg", R("palette-grey-300")), H(P.Button, "inheritContainedHoverBg", R("palette-grey-A100")), H(P.Chip, "defaultBorder", R("palette-grey-400")), H(P.Chip, "defaultAvatarColor", R("palette-grey-700")), H(P.Chip, "defaultIconColor", R("palette-grey-700")), H(P.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), H(P.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), H(P.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), H(P.LinearProgress, "primaryBg", N(Ue, P.primary.main, 0.62)), H(P.LinearProgress, "secondaryBg", N(Ue, P.secondary.main, 0.62)), H(P.LinearProgress, "errorBg", N(Ue, P.error.main, 0.62)), H(P.LinearProgress, "infoBg", N(Ue, P.info.main, 0.62)), H(P.LinearProgress, "successBg", N(Ue, P.success.main, 0.62)), H(P.LinearProgress, "warningBg", N(Ue, P.warning.main, 0.62)), H(P.Skeleton, "bg", b ? N(so, P.text.primary, 0.11) : `rgba(${R("palette-text-primaryChannel")} / 0.11)`), H(P.Slider, "primaryTrack", N(Ue, P.primary.main, 0.62)), H(P.Slider, "secondaryTrack", N(Ue, P.secondary.main, 0.62)), H(P.Slider, "errorTrack", N(Ue, P.error.main, 0.62)), H(P.Slider, "infoTrack", N(Ue, P.info.main, 0.62)), H(P.Slider, "successTrack", N(Ue, P.success.main, 0.62)), H(P.Slider, "warningTrack", N(Ue, P.warning.main, 0.62));
      const D = b ? N(Ve, P.background.default, 0.6825) : gc(P.background.default, 0.8);
      H(P.SnackbarContent, "bg", D), H(P.SnackbarContent, "color", Cr(() => b ? rm.text.primary : P.getContrastText(D))), H(P.SpeedDialAction, "fabHoverBg", gc(P.background.paper, 0.15)), H(P.StepConnector, "border", R("palette-grey-400")), H(P.StepContent, "border", R("palette-grey-400")), H(P.Switch, "defaultColor", R("palette-common-white")), H(P.Switch, "defaultDisabledColor", R("palette-grey-100")), H(P.Switch, "primaryDisabledColor", N(Ue, P.primary.main, 0.62)), H(P.Switch, "secondaryDisabledColor", N(Ue, P.secondary.main, 0.62)), H(P.Switch, "errorDisabledColor", N(Ue, P.error.main, 0.62)), H(P.Switch, "infoDisabledColor", N(Ue, P.info.main, 0.62)), H(P.Switch, "successDisabledColor", N(Ue, P.success.main, 0.62)), H(P.Switch, "warningDisabledColor", N(Ue, P.warning.main, 0.62)), H(P.TableCell, "border", N(Ue, N(so, P.divider, 1), 0.88)), H(P.Tooltip, "bg", N(so, P.grey[700], 0.92));
    }
    if (P.mode === "dark") {
      H(P.Alert, "errorColor", N(Ue, P.error.light, 0.6)), H(P.Alert, "infoColor", N(Ue, P.info.light, 0.6)), H(P.Alert, "successColor", N(Ue, P.success.light, 0.6)), H(P.Alert, "warningColor", N(Ue, P.warning.light, 0.6)), H(P.Alert, "errorFilledBg", R("palette-error-dark")), H(P.Alert, "infoFilledBg", R("palette-info-dark")), H(P.Alert, "successFilledBg", R("palette-success-dark")), H(P.Alert, "warningFilledBg", R("palette-warning-dark")), H(P.Alert, "errorFilledColor", Cr(() => P.getContrastText(P.error.dark))), H(P.Alert, "infoFilledColor", Cr(() => P.getContrastText(P.info.dark))), H(P.Alert, "successFilledColor", Cr(() => P.getContrastText(P.success.dark))), H(P.Alert, "warningFilledColor", Cr(() => P.getContrastText(P.warning.dark))), H(P.Alert, "errorStandardBg", N(Ve, P.error.light, 0.9)), H(P.Alert, "infoStandardBg", N(Ve, P.info.light, 0.9)), H(P.Alert, "successStandardBg", N(Ve, P.success.light, 0.9)), H(P.Alert, "warningStandardBg", N(Ve, P.warning.light, 0.9)), H(P.Alert, "errorIconColor", R("palette-error-main")), H(P.Alert, "infoIconColor", R("palette-info-main")), H(P.Alert, "successIconColor", R("palette-success-main")), H(P.Alert, "warningIconColor", R("palette-warning-main")), H(P.AppBar, "defaultBg", R("palette-grey-900")), H(P.AppBar, "darkBg", R("palette-background-paper")), H(P.AppBar, "darkColor", R("palette-text-primary")), H(P.Avatar, "defaultBg", R("palette-grey-600")), H(P.Button, "inheritContainedBg", R("palette-grey-800")), H(P.Button, "inheritContainedHoverBg", R("palette-grey-700")), H(P.Chip, "defaultBorder", R("palette-grey-700")), H(P.Chip, "defaultAvatarColor", R("palette-grey-300")), H(P.Chip, "defaultIconColor", R("palette-grey-300")), H(P.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), H(P.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), H(P.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), H(P.LinearProgress, "primaryBg", N(Ve, P.primary.main, 0.5)), H(P.LinearProgress, "secondaryBg", N(Ve, P.secondary.main, 0.5)), H(P.LinearProgress, "errorBg", N(Ve, P.error.main, 0.5)), H(P.LinearProgress, "infoBg", N(Ve, P.info.main, 0.5)), H(P.LinearProgress, "successBg", N(Ve, P.success.main, 0.5)), H(P.LinearProgress, "warningBg", N(Ve, P.warning.main, 0.5)), H(P.Skeleton, "bg", b ? N(so, P.text.primary, 0.13) : `rgba(${R("palette-text-primaryChannel")} / 0.13)`), H(P.Slider, "primaryTrack", N(Ve, P.primary.main, 0.5)), H(P.Slider, "secondaryTrack", N(Ve, P.secondary.main, 0.5)), H(P.Slider, "errorTrack", N(Ve, P.error.main, 0.5)), H(P.Slider, "infoTrack", N(Ve, P.info.main, 0.5)), H(P.Slider, "successTrack", N(Ve, P.success.main, 0.5)), H(P.Slider, "warningTrack", N(Ve, P.warning.main, 0.5));
      const D = b ? N(Ue, P.background.default, 0.985) : gc(P.background.default, 0.98);
      H(P.SnackbarContent, "bg", D), H(P.SnackbarContent, "color", Cr(() => b ? b_.text.primary : P.getContrastText(D))), H(P.SpeedDialAction, "fabHoverBg", gc(P.background.paper, 0.15)), H(P.StepConnector, "border", R("palette-grey-600")), H(P.StepContent, "border", R("palette-grey-600")), H(P.Switch, "defaultColor", R("palette-grey-300")), H(P.Switch, "defaultDisabledColor", R("palette-grey-600")), H(P.Switch, "primaryDisabledColor", N(Ve, P.primary.main, 0.55)), H(P.Switch, "secondaryDisabledColor", N(Ve, P.secondary.main, 0.55)), H(P.Switch, "errorDisabledColor", N(Ve, P.error.main, 0.55)), H(P.Switch, "infoDisabledColor", N(Ve, P.info.main, 0.55)), H(P.Switch, "successDisabledColor", N(Ve, P.success.main, 0.55)), H(P.Switch, "warningDisabledColor", N(Ve, P.warning.main, 0.55)), H(P.TableCell, "border", N(Ve, N(so, P.divider, 1), 0.68)), H(P.Tooltip, "bg", N(so, P.grey[700], 0.92));
    }
    Zr(P.background, "default"), Zr(P.background, "paper"), Zr(P.common, "background"), Zr(P.common, "onBackground"), Zr(P, "divider"), Object.keys(P).forEach((D) => {
      const $ = P[D];
      D !== "tonalOffset" && $ && typeof $ == "object" && ($.main && H(P[D], "mainChannel", ks(Ms($.main))), $.light && H(P[D], "lightChannel", ks(Ms($.light))), $.dark && H(P[D], "darkChannel", ks(Ms($.dark))), $.contrastText && H(P[D], "contrastTextChannel", ks(Ms($.contrastText))), D === "text" && (Zr(P[D], "primary"), Zr(P[D], "secondary")), D === "action" && ($.active && Zr(P[D], "active"), $.selected && Zr(P[D], "selected")));
    });
  }), E = t.reduce((M, P) => pn(M, P), E);
  const C = {
    prefix: o,
    disableCssColorScheme: i,
    shouldSkipGeneratingVar: s,
    getSelector: eR(E),
    enableContrastVars: a
  }, {
    vars: T,
    generateThemeVars: j,
    generateStyleSheets: A
  } = ED(E, C);
  return E.vars = T, Object.entries(E.colorSchemes[E.defaultColorScheme]).forEach(([M, P]) => {
    E[M] = P;
  }), E.generateThemeVars = j, E.generateStyleSheets = A, E.generateSpacing = function() {
    return c_(u.spacing, wg(this));
  }, E.getColorSchemeSelector = _D(l), E.spacing = E.generateSpacing(), E.shouldSkipGeneratingVar = s, E.unstable_sxConfig = {
    ...Ml,
    ...u?.unstable_sxConfig
  }, E.unstable_sx = function(P) {
    return Pa({
      sx: P,
      theme: this
    });
  }, E.toRuntimeSource = w_, E;
}
function m0(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: Rg({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function oR(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: i = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: o = n?.mode,
    ...a
  } = e, s = o || "light", l = i?.[s], c = {
    ...i,
    ...n ? {
      [s]: {
        ...typeof l != "boolean" && l,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return im(e, ...t);
    let u = n;
    "palette" in e || c[s] && (c[s] !== !0 ? u = c[s].palette : s === "dark" && (u = {
      mode: "dark"
    }));
    const d = im({
      ...e,
      palette: u
    }, ...t);
    return d.defaultColorScheme = s, d.colorSchemes = c, d.palette.mode === "light" && (d.colorSchemes.light = {
      ...c.light !== !0 && c.light,
      palette: d.palette
    }, m0(d, "dark", c.dark)), d.palette.mode === "dark" && (d.colorSchemes.dark = {
      ...c.dark !== !0 && c.dark,
      palette: d.palette
    }, m0(d, "light", c.light)), d;
  }
  return !n && !("light" in c) && s === "light" && (c.light = !0), iR({
    ...a,
    colorSchemes: c,
    defaultColorScheme: s,
    ...typeof r != "boolean" && r
  }, ...t);
}
const Ig = oR(), $g = "$$material";
function zd() {
  const e = u_(Ig);
  return process.env.NODE_ENV !== "production" && _.useDebugValue(e), e[$g] || e;
}
function E_(e) {
  return /* @__PURE__ */ x.jsx(d_, {
    ...e,
    defaultTheme: Ig,
    themeId: $g
  });
}
process.env.NODE_ENV !== "production" && (E_.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The styles you want to apply globally.
   */
  styles: f.oneOfType([f.array, f.func, f.number, f.object, f.string, f.bool])
});
function __(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Xn = (e) => __(e) && e !== "classes", ge = iD({
  themeId: $g,
  defaultTheme: Ig,
  rootShouldForwardProp: Xn
});
function aR(e) {
  return function(n) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ x.jsx(E_, {
        styles: typeof e == "function" ? (r) => e({
          theme: r,
          ...n
        }) : e
      })
    );
  };
}
function sR() {
  return Vj;
}
const Ct = xD;
process.env.NODE_ENV !== "production" && (f.node, f.object.isRequired);
function pt(e) {
  return vD(e);
}
function lR(e) {
  return Je("MuiSvgIcon", e);
}
Ge("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const cR = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, i = {
    root: ["root", t !== "inherit" && `color${Re(t)}`, `fontSize${Re(n)}`]
  };
  return at(i, lR, r);
}, uR = ge("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${Re(n.color)}`], t[`fontSize${Re(n.fontSize)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: e.transitions?.create?.("fill", {
    duration: (e.vars ?? e).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars ?? e).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), xu = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: i,
    className: o,
    color: a = "inherit",
    component: s = "svg",
    fontSize: l = "medium",
    htmlColor: c,
    inheritViewBox: u = !1,
    titleAccess: d,
    viewBox: p = "0 0 24 24",
    ...h
  } = r, g = /* @__PURE__ */ _.isValidElement(i) && i.type === "svg", m = {
    ...r,
    color: a,
    component: s,
    fontSize: l,
    instanceFontSize: t.fontSize,
    inheritViewBox: u,
    viewBox: p,
    hasSvgAsChild: g
  }, v = {};
  u || (v.viewBox = p);
  const y = cR(m);
  return /* @__PURE__ */ x.jsxs(uR, {
    as: s,
    className: ie(y.root, o),
    focusable: "false",
    color: c,
    "aria-hidden": d ? void 0 : !0,
    role: d ? "img" : void 0,
    ref: n,
    ...v,
    ...h,
    ...g && i.props,
    ownerState: m,
    children: [g ? i.props.children : i, d ? /* @__PURE__ */ x.jsx("title", {
      children: d
    }) : null]
  });
});
process.env.NODE_ENV !== "production" && (xu.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Node passed into the SVG element.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: f.oneOfType([f.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), f.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: f.oneOfType([f.oneOf(["inherit", "large", "medium", "small"]), f.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: f.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: f.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: f.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: f.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: f.string
});
xu.muiName = "SvgIcon";
function Gi(e, t) {
  function n(r, i) {
    return /* @__PURE__ */ x.jsx(xu, {
      "data-testid": process.env.NODE_ENV !== "production" ? `${t}Icon` : void 0,
      ref: i,
      ...r,
      children: e
    });
  }
  return process.env.NODE_ENV !== "production" && (n.displayName = `${t}Icon`), n.muiName = xu.muiName, /* @__PURE__ */ _.memo(/* @__PURE__ */ _.forwardRef(n));
}
function P_(e, t = 166) {
  let n;
  function r(...i) {
    const o = () => {
      e.apply(this, i);
    };
    clearTimeout(n), n = setTimeout(o, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function Hn(e) {
  return e && e.ownerDocument || document;
}
function pi(e) {
  return Hn(e).defaultView || window;
}
function g0(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
function wu(e) {
  const {
    controlled: t,
    default: n,
    name: r,
    state: i = "value"
  } = e, {
    current: o
  } = _.useRef(t !== void 0), [a, s] = _.useState(n), l = o ? t : a;
  if (process.env.NODE_ENV !== "production") {
    _.useEffect(() => {
      o !== (t !== void 0) && console.error([`MUI: A component is changing the ${o ? "" : "un"}controlled ${i} state of ${r} to be ${o ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [i, r, t]);
    const {
      current: u
    } = _.useRef(n);
    _.useEffect(() => {
      !o && JSON.stringify(n) !== JSON.stringify(u) && console.error([`MUI: A component is changing the default ${i} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`
`));
    }, [JSON.stringify(n)]);
  }
  const c = _.useCallback((u) => {
    o || s(u);
  }, []);
  return [l, c];
}
function ci(e) {
  const t = _.useRef(e);
  return Wr(() => {
    t.current = e;
  }), _.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
function Gt(...e) {
  const t = _.useRef(void 0), n = _.useCallback((r) => {
    const i = e.map((o) => {
      if (o == null)
        return null;
      if (typeof o == "function") {
        const a = o, s = a(r);
        return typeof s == "function" ? s : () => {
          a(null);
        };
      }
      return o.current = r, () => {
        o.current = null;
      };
    });
    return () => {
      i.forEach((o) => o?.());
    };
  }, e);
  return _.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
function dR(e, t) {
  const n = e.charCodeAt(2);
  return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function";
}
function C_(e, t) {
  if (!e)
    return t;
  function n(a, s) {
    const l = {};
    return Object.keys(s).forEach((c) => {
      dR(c, s[c]) && typeof a[c] == "function" && (l[c] = (...u) => {
        a[c](...u), s[c](...u);
      });
    }), l;
  }
  if (typeof e == "function" || typeof t == "function")
    return (a) => {
      const s = typeof t == "function" ? t(a) : t, l = typeof e == "function" ? e({
        ...a,
        ...s
      }) : e, c = ie(a?.className, s?.className, l?.className), u = n(l, s);
      return {
        ...s,
        ...l,
        ...u,
        ...!!c && {
          className: c
        },
        ...s?.style && l?.style && {
          style: {
            ...s.style,
            ...l.style
          }
        },
        ...s?.sx && l?.sx && {
          sx: [...Array.isArray(s.sx) ? s.sx : [s.sx], ...Array.isArray(l.sx) ? l.sx : [l.sx]]
        }
      };
    };
  const r = t, i = n(e, r), o = ie(r?.className, e?.className);
  return {
    ...t,
    ...e,
    ...i,
    ...!!o && {
      className: o
    },
    ...r?.style && e?.style && {
      style: {
        ...r.style,
        ...e.style
      }
    },
    ...r?.sx && e?.sx && {
      sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
    }
  };
}
const fR = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M20 3h-1V1h-2v2H7V1H5v2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 18H4V10h16zm0-13H4V5h16z"
}), "CalendarTodayOutlined"), Dl = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M8 16h8v2H8zm0-4h8v2H8zm6-10H6c-1.1 0-2 .9-2 2v16c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm4 18H6V4h7v5h5z"
}), "DescriptionOutlined"), pR = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zm-1-4-1.41-1.41L13 12.17V4h-2v8.17L8.41 9.59 7 11l5 5z"
}), "FileDownloadOutlined"), xn = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"
}), "OpenInNewOutlined");
var T_ = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, v0 = Ye.createContext && /* @__PURE__ */ Ye.createContext(T_), hR = ["attr", "size", "title"];
function mR(e, t) {
  if (e == null) return {};
  var n = gR(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function gR(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function Ou() {
  return Ou = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ou.apply(this, arguments);
}
function y0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Su(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y0(Object(n), !0).forEach(function(r) {
      vR(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function vR(e, t, n) {
  return t = yR(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function yR(e) {
  var t = bR(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function bR(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function A_(e) {
  return e && e.map((t, n) => /* @__PURE__ */ Ye.createElement(t.tag, Su({
    key: n
  }, t.attr), A_(t.child)));
}
function Qe(e) {
  return (t) => /* @__PURE__ */ Ye.createElement(xR, Ou({
    attr: Su({}, e.attr)
  }, t), A_(e.child));
}
function xR(e) {
  var t = (n) => {
    var {
      attr: r,
      size: i,
      title: o
    } = e, a = mR(e, hR), s = i || n.size || "1em", l;
    return n.className && (l = n.className), e.className && (l = (l ? l + " " : "") + e.className), /* @__PURE__ */ Ye.createElement("svg", Ou({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, r, a, {
      className: l,
      style: Su(Su({
        color: e.color || n.color
      }, n.style), e.style),
      height: s,
      width: s,
      xmlns: "http://www.w3.org/2000/svg"
    }), o && /* @__PURE__ */ Ye.createElement("title", null, o), e.children);
  };
  return v0 !== void 0 ? /* @__PURE__ */ Ye.createElement(v0.Consumer, null, (n) => t(n)) : t(T_);
}
function wR(e) {
  return Qe({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M384 160c-17.7 0-32-14.3-32-32s14.3-32 32-32l160 0c17.7 0 32 14.3 32 32l0 160c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-82.7L342.6 374.6c-12.5 12.5-32.8 12.5-45.3 0L192 269.3 54.6 406.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160c12.5-12.5 32.8-12.5 45.3 0L320 306.7 466.7 160 384 160z" }, child: [] }] })(e);
}
function OR(e) {
  return Qe({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z" }, child: [] }] })(e);
}
function SR(e) {
  return Qe({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z" }, child: [] }] })(e);
}
function b0(e) {
  return Qe({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z" }, child: [] }] })(e);
}
function ER(e) {
  return Qe({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z" }, child: [] }] })(e);
}
const am = (e) => new Date(e.getFullYear(), e.getMonth(), 1), sm = (e) => new Date(e.getFullYear(), e.getMonth() + 1, 0), x0 = (e, t) => new Date(e.getFullYear(), e.getMonth() + t, 1), w0 = (e, t) => e && t && e.toDateString() === t.toDateString(), _R = (e, t, n) => t && n && e > t && e < n, sa = (e) => e.toISOString().split("T")[0];
function O0({ monthDate: e, startDate: t, endDate: n, hoverDate: r, onSelect: i, onHover: o }) {
  const a = am(e), s = sm(e), l = [];
  for (let c = 0; c < a.getDay(); c++) l.push(null);
  for (let c = 1; c <= s.getDate(); c++)
    l.push(new Date(e.getFullYear(), e.getMonth(), c));
  return /* @__PURE__ */ x.jsxs("div", { className: "w-[260px]", children: [
    /* @__PURE__ */ x.jsx("div", { className: "text-center font-medium mb-2", children: e.toLocaleString("default", { month: "long", year: "numeric" }) }),
    /* @__PURE__ */ x.jsx("div", { className: "grid grid-cols-7 text-xs text-center text-gray-500 mb-1", children: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map((c) => /* @__PURE__ */ x.jsx("div", { children: c }, c)) }),
    /* @__PURE__ */ x.jsx("div", { className: "grid grid-cols-7 gap-1 text-sm", children: l.map(
      (c, u) => c ? /* @__PURE__ */ x.jsx(
        "button",
        {
          onClick: () => i(c),
          onMouseEnter: () => o(c),
          className: `h-8 rounded transition
                ${w0(c, t) || w0(c, n) ? "bg-purple-600 text-white" : _R(c, t, r || n) ? "bg-purple-100" : "hover:bg-gray-100"}`,
          children: c.getDate()
        },
        u
      ) : /* @__PURE__ */ x.jsx("div", {}, u)
    ) })
  ] });
}
function zte({ title: e, description: t, onExport: n }) {
  const [r, i] = Ke(!1), [o, a] = Ke(!1), [s, l] = Ke("Last 7 Days"), [c, u] = Ke(!1), [d, p] = Ke(null), [h, g] = Ke(null), [m, v] = Ke(null), [y] = Ke(/* @__PURE__ */ new Date()), [S, w] = Ke(!1), b = Ne(null), O = Ne(null), E = [
    {
      label: "Today",
      range: () => {
        const A = /* @__PURE__ */ new Date();
        return [A, A];
      }
    },
    {
      label: "Yesterday",
      range: () => {
        const A = /* @__PURE__ */ new Date();
        return A.setDate(A.getDate() - 1), [A, A];
      }
    },
    {
      label: "Last 7 Days",
      range: () => {
        const A = /* @__PURE__ */ new Date(), M = /* @__PURE__ */ new Date();
        return M.setDate(A.getDate() - 7), [M, A];
      }
    },
    {
      label: "Last 30 Days",
      range: () => {
        const A = /* @__PURE__ */ new Date(), M = /* @__PURE__ */ new Date();
        return M.setDate(A.getDate() - 30), [M, A];
      }
    },
    {
      label: "This Month",
      range: () => {
        const A = /* @__PURE__ */ new Date();
        return [am(A), sm(A)];
      }
    },
    {
      label: "Previous Month",
      range: () => {
        const A = x0(/* @__PURE__ */ new Date(), -1);
        return [am(A), sm(A)];
      }
    }
  ];
  De(() => {
    const A = (M) => {
      b.current && !b.current.contains(M.target) && (i(!1), u(!1)), O.current && !O.current.contains(M.target) && a(!1);
    };
    return document.addEventListener("mousedown", A), () => document.removeEventListener("mousedown", A);
  }, []);
  const C = (A) => {
    !d || h ? (p(A), g(null)) : A < d ? p(A) : g(A);
  }, T = (A, M) => {
    const P = new URLSearchParams(window.location.search);
    P.set(`${e.toLowerCase()}startdate`, sa(A)), P.set(`${e.toLowerCase()}enddate`, sa(M)), window.history.pushState({}, "", `${window.location.pathname}?${P}`), window.dispatchEvent(new Event("dateRangeChange"));
  }, j = s === "Custom Range" && d && h ? `${sa(d)} - ${sa(h)}` : s;
  return /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between px-6 my-6", children: [
    /* @__PURE__ */ x.jsxs("div", { children: [
      /* @__PURE__ */ x.jsx("div", { className: "text-[24px] font-semibold", children: e }),
      /* @__PURE__ */ x.jsx("div", { className: "text-gray-500 text-sm", children: t })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "flex gap-3", children: [
      /* @__PURE__ */ x.jsxs("div", { className: "relative", ref: b, children: [
        /* @__PURE__ */ x.jsxs(
          "button",
          {
            onClick: () => i((A) => !A),
            className: "flex items-center gap-2 px-4 py-2 bg-white shadow rounded text-sm",
            children: [
              /* @__PURE__ */ x.jsx(fR, { fontSize: "small" }),
              j,
              /* @__PURE__ */ x.jsx(b0, {})
            ]
          }
        ),
        r && /* @__PURE__ */ x.jsxs("div", { className: "absolute right-0 mt-2 bg-white border shadow-xl rounded-md z-50 flex", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "w-[160px] border-r", children: [
            E.map((A) => /* @__PURE__ */ x.jsx(
              "button",
              {
                onClick: () => {
                  const [M, P] = A.range();
                  p(M), g(P), l(A.label), i(!1), T(M, P);
                },
                className: "w-full text-left px-4 py-2 text-sm hover:bg-gray-100",
                children: A.label
              },
              A.label
            )),
            /* @__PURE__ */ x.jsx(
              "button",
              {
                onClick: () => {
                  l("Custom Range"), u(!0);
                },
                className: "w-full text-left px-4 py-2 text-sm hover:bg-gray-100 font-medium",
                children: "Custom Range"
              }
            )
          ] }),
          c && /* @__PURE__ */ x.jsxs("div", { className: "p-4 flex gap-6 relative", children: [
            /* @__PURE__ */ x.jsx(
              O0,
              {
                monthDate: y,
                startDate: d,
                endDate: h,
                hoverDate: m,
                onSelect: C,
                onHover: v
              }
            ),
            /* @__PURE__ */ x.jsx(
              O0,
              {
                monthDate: x0(y, 1),
                startDate: d,
                endDate: h,
                hoverDate: m,
                onSelect: C,
                onHover: v
              }
            ),
            /* @__PURE__ */ x.jsxs("div", { className: "absolute bottom-0 left-0 right-0 border-t p-3 flex justify-between text-sm", children: [
              /* @__PURE__ */ x.jsx("span", { children: d && h && `${sa(d)} - ${sa(h)}` }),
              /* @__PURE__ */ x.jsxs("div", { className: "flex gap-3", children: [
                /* @__PURE__ */ x.jsx("button", { onClick: () => u(!1), children: "Cancel" }),
                /* @__PURE__ */ x.jsx(
                  "button",
                  {
                    disabled: !d || !h,
                    onClick: () => {
                      i(!1), u(!1), T(d, h);
                    },
                    className: "bg-purple-600 text-white px-4 py-1 rounded disabled:opacity-40",
                    children: "Apply"
                  }
                )
              ] })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ x.jsxs("div", { className: "relative", ref: O, children: [
        /* @__PURE__ */ x.jsxs(
          "button",
          {
            disabled: S,
            onClick: () => a((A) => !A),
            className: "flex items-center gap-2 px-4 py-2 bg-white shadow rounded text-sm text-purple-600",
            children: [
              "Export",
              /* @__PURE__ */ x.jsx(pR, { fontSize: "small" }),
              /* @__PURE__ */ x.jsx(b0, {})
            ]
          }
        ),
        o && /* @__PURE__ */ x.jsx("div", { className: "absolute right-0 mt-2 bg-white border shadow rounded z-50", children: ["xlsx", "pdf"].map((A) => /* @__PURE__ */ x.jsxs(
          "button",
          {
            onClick: () => n?.({ format: A }),
            className: "block px-4 py-2 text-sm hover:bg-purple-50",
            children: [
              "Export ",
              A.toUpperCase()
            ]
          },
          A
        )) })
      ] })
    ] })
  ] });
}
function S0(e) {
  return Qe({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z" }, child: [] }] })(e);
}
function PR(e) {
  return Qe({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M192 208c0-17.67-14.33-32-32-32h-16c-35.35 0-64 28.65-64 64v48c0 35.35 28.65 64 64 64h16c17.67 0 32-14.33 32-32V208zm176 144c35.35 0 64-28.65 64-64v-48c0-35.35-28.65-64-64-64h-16c-17.67 0-32 14.33-32 32v112c0 17.67 14.33 32 32 32h16zM256 0C113.18 0 4.58 118.83 0 256v16c0 8.84 7.16 16 16 16h16c8.84 0 16-7.16 16-16v-16c0-114.69 93.31-208 208-208s208 93.31 208 208h-.12c.08 2.43.12 165.72.12 165.72 0 23.35-18.93 42.28-42.28 42.28H320c0-26.51-21.49-48-48-48h-32c-26.51 0-48 21.49-48 48s21.49 48 48 48h181.72c49.86 0 90.28-40.42 90.28-90.28V256C507.42 118.83 398.82 0 256 0z" }, child: [] }] })(e);
}
function Lg(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "rect", attr: { width: "16", height: "20", x: "4", y: "2", rx: "2", ry: "2" }, child: [] }, { tag: "path", attr: { d: "M9 22v-4h6v4" }, child: [] }, { tag: "path", attr: { d: "M8 6h.01" }, child: [] }, { tag: "path", attr: { d: "M16 6h.01" }, child: [] }, { tag: "path", attr: { d: "M12 6h.01" }, child: [] }, { tag: "path", attr: { d: "M12 10h.01" }, child: [] }, { tag: "path", attr: { d: "M12 14h.01" }, child: [] }, { tag: "path", attr: { d: "M16 10h.01" }, child: [] }, { tag: "path", attr: { d: "M16 14h.01" }, child: [] }, { tag: "path", attr: { d: "M8 10h.01" }, child: [] }, { tag: "path", attr: { d: "M8 14h.01" }, child: [] }] })(e);
}
function CR(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2" }, child: [] }, { tag: "circle", attr: { cx: "7", cy: "17", r: "2" }, child: [] }, { tag: "path", attr: { d: "M9 17h6" }, child: [] }, { tag: "circle", attr: { cx: "17", cy: "17", r: "2" }, child: [] }] })(e);
}
function k_(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M13 4h3a2 2 0 0 1 2 2v14" }, child: [] }, { tag: "path", attr: { d: "M2 20h3" }, child: [] }, { tag: "path", attr: { d: "M13 20h9" }, child: [] }, { tag: "path", attr: { d: "M10 12v.01" }, child: [] }, { tag: "path", attr: { d: "M13 4.562v16.157a1 1 0 0 1-1.242.97L5 20V5.562a2 2 0 0 1 1.515-1.94l4-1A2 2 0 0 1 13 4.561Z" }, child: [] }] })(e);
}
function TR(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M16 5h6" }, child: [] }, { tag: "path", attr: { d: "M19 2v6" }, child: [] }, { tag: "path", attr: { d: "M21 11.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7.5" }, child: [] }, { tag: "path", attr: { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }, child: [] }, { tag: "circle", attr: { cx: "9", cy: "9", r: "2" }, child: [] }] })(e);
}
function M_(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }, child: [] }] })(e);
}
function E0(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }, child: [] }, { tag: "path", attr: { d: "M14 8H8" }, child: [] }, { tag: "path", attr: { d: "M16 12H8" }, child: [] }, { tag: "path", attr: { d: "M13 16H8" }, child: [] }] })(e);
}
function j_(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z" }, child: [] }, { tag: "path", attr: { d: "m9 12 2 2 4-4" }, child: [] }] })(e);
}
function Fg(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M2 6c.6.5 1.2 1 2.5 1C7 7 7 5 9.5 5c2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }, child: [] }, { tag: "path", attr: { d: "M2 12c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }, child: [] }, { tag: "path", attr: { d: "M2 18c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }, child: [] }] })(e);
}
function AR(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" }, child: [] }] })(e);
}
function N_(e) {
  return Qe({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z" }, child: [] }] })(e);
}
function D_(e) {
  return Qe({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M3.5 8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 8Z" }, child: [] }] })(e);
}
function R_(e) {
  return Qe({ attr: { viewBox: "0 0 32 32" }, child: [{ tag: "path", attr: { d: "M 2 7 L 2 24 L 30 24 L 30 7 L 2 7 z M 6 9 L 26 9 C 26 10.105 26.895 11 28 11 L 28 20 C 26.895 20 26 20.895 26 22 L 6 22 C 6 20.895 5.105 20 4 20 L 4 11 C 5.105 11 6 10.105 6 9 z M 16 11 C 13.789 11 12 13.016 12 15.5 C 12 17.984 13.789 20 16 20 C 18.211 20 20 17.984 20 15.5 C 20 13.016 18.211 11 16 11 z M 16 13 C 17.102 13 18 14.121 18 15.5 C 18 16.879 17.102 18 16 18 C 14.898 18 14 16.879 14 15.5 C 14 14.121 14.898 13 16 13 z M 8.5 14 C 7.672 14 7 14.672 7 15.5 C 7 16.328 7.672 17 8.5 17 C 9.328 17 10 16.328 10 15.5 C 10 14.672 9.328 14 8.5 14 z M 23.5 14 C 22.672 14 22 14.672 22 15.5 C 22 16.328 22.672 17 23.5 17 C 24.328 17 25 16.328 25 15.5 C 25 14.672 24.328 14 23.5 14 z" }, child: [] }] })(e);
}
const kR = [
  { name: "Overview", icon: N_ },
  { name: "Community", icon: Lg },
  { name: "Financials", icon: R_ },
  { name: "Facilities", icon: k_ },
  { name: "Gate & Security", icon: Fg },
  { name: "Helpdesk", icon: PR },
  { name: "Engagement", icon: M_ }
];
function Wte() {
  const [e, t] = Ke("Overview");
  return /* @__PURE__ */ x.jsx("div", { className: "flex gap-[8px] p-3", children: kR.map((n) => {
    const r = n.icon, i = e === n.name;
    return /* @__PURE__ */ x.jsxs(
      "button",
      {
        onClick: () => t(n.name),
        className: `flex items-center gap-[8px] rounded px-4 py-3 text-[14px] leading-[16px] font-medium transition 
              ${i ? "bg-[#FBF5FF] text-[#884EA7]" : "bg-white text-[#64748B] hover:bg-gray-50"}`,
        children: [
          /* @__PURE__ */ x.jsx(r, { className: "h-[15px] w-[15px] font-bold" }),
          n.name
        ]
      },
      n.name
    );
  }) });
}
const _0 = ({ color: e }) => /* @__PURE__ */ x.jsx(
  "span",
  {
    style: {
      display: "inline-block",
      width: "8px",
      height: "8px",
      borderRadius: "50%",
      backgroundColor: e,
      marginRight: "6px"
    }
  }
), Rl = ({ active: e, payload: t }) => !e || !t || !t.length ? null : /* @__PURE__ */ x.jsx("div", { className: "bg-[#121212] text-white !text-[12px] p-3 rounded-lg shadow-lg", children: t.map((n, r) => /* @__PURE__ */ x.jsxs(
  "div",
  {
    className: "capitalize flex gap-[4px] items-center leading-relaxed",
    children: [
      n.color && /* @__PURE__ */ x.jsx(_0, { color: n.color }),
      n.payload.color && /* @__PURE__ */ x.jsx(_0, { color: n.payload.color }),
      /* @__PURE__ */ x.jsx("div", { className: "min-w-[84px] text-[#D1D3D4]", children: n.name }),
      /* @__PURE__ */ x.jsx("div", { className: "font-semibold", children: n.value })
    ]
  },
  r
)) }), I_ = ({ value: e }) => {
  const t = typeof e == "string" ? parseFloat(e.replace("%", "")) : e ?? 0, n = t >= 0;
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: `w-fit p-1 rounded text-[10px] leading-[14px] font-medium flex items-center gap-1 ${n ? "bg-[#F7FEFA] text-[#1FA05B]" : "bg-[#FFF2F2] text-[#AB0000]"}`,
      children: [
        n ? /* @__PURE__ */ x.jsx(SR, {}) : /* @__PURE__ */ x.jsx(OR, {}),
        Math.abs(t).toFixed(1),
        "%"
      ]
    }
  );
}, qo = ({
  title: e,
  icon: t,
  period: n,
  actionButtons: r,
  children: i,
  footer: o,
  className: a = "",
  childrenClassName: s,
  titleWeight: l
}) => {
  const c = l === "semi-bold" ? 600 : 500;
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: `relative bg-white !border-[0.5px] !border-[#EBEBEB] !rounded-[12px] !shadow-[0_0_12px_0_#EAF2FF] p-[16px] flex flex-col gap-[24px] ${a}`,
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[12px]", children: [
            t,
            /* @__PURE__ */ x.jsx(
              "div",
              {
                style: {
                  fontWeight: c,
                  fontSize: "16px",
                  lineHeight: "20px"
                },
                className: "!my-0 !text-[16px] !leading-[20px] !text-[#121212]",
                children: e
              }
            )
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-2", children: [
            r && r,
            n && /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] !leading-[16px] !text-[#64748B]", children: n })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: `flex-1 min-h-0 space-y-[24px] ${s}`, children: i }),
        o && /* @__PURE__ */ x.jsx("div", { className: "mt-3 pt-3 border-t border-gray-100 !text-[12px] text-[#64748B]", children: o })
      ]
    }
  );
};
function Ti(e, t) {
  sessionStorage.setItem(e, t), (e === "community_id" || e === "export" || e === "widget_id") && window.dispatchEvent(new StorageEvent("dashboard-update", { key: e }));
}
var tp = {}, np = {}, P0;
function MR() {
  return P0 || (P0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n === "__proto__";
    }
    e.isUnsafeProperty = t;
  })(np)), np;
}
var rp = {}, C0;
function $_() {
  return C0 || (C0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      switch (typeof n) {
        case "number":
        case "symbol":
          return !1;
        case "string":
          return n.includes(".") || n.includes("[") || n.includes("]");
      }
    }
    e.isDeepKey = t;
  })(rp)), rp;
}
var ip = {}, T0;
function L_() {
  return T0 || (T0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return typeof n == "string" || typeof n == "symbol" ? n : Object.is(n?.valueOf?.(), -0) ? "-0" : String(n);
    }
    e.toKey = t;
  })(ip)), ip;
}
var op = {}, A0;
function Bg() {
  return A0 || (A0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      const r = [], i = n.length;
      if (i === 0)
        return r;
      let o = 0, a = "", s = "", l = !1;
      for (n.charCodeAt(0) === 46 && (r.push(""), o++); o < i; ) {
        const c = n[o];
        s ? c === "\\" && o + 1 < i ? (o++, a += n[o]) : c === s ? s = "" : a += c : l ? c === '"' || c === "'" ? s = c : c === "]" ? (l = !1, r.push(a), a = "") : a += c : c === "[" ? (l = !0, a && (r.push(a), a = "")) : c === "." ? a && (r.push(a), a = "") : a += c, o++;
      }
      return a && r.push(a), r;
    }
    e.toPath = t;
  })(op)), op;
}
var k0;
function zg() {
  return k0 || (k0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ MR(), n = /* @__PURE__ */ $_(), r = /* @__PURE__ */ L_(), i = /* @__PURE__ */ Bg();
    function o(s, l, c) {
      if (s == null)
        return c;
      switch (typeof l) {
        case "string": {
          if (t.isUnsafeProperty(l))
            return c;
          const u = s[l];
          return u === void 0 ? n.isDeepKey(l) ? o(s, i.toPath(l), c) : c : u;
        }
        case "number":
        case "symbol": {
          typeof l == "number" && (l = r.toKey(l));
          const u = s[l];
          return u === void 0 ? c : u;
        }
        default: {
          if (Array.isArray(l))
            return a(s, l, c);
          if (Object.is(l?.valueOf(), -0) ? l = "-0" : l = String(l), t.isUnsafeProperty(l))
            return c;
          const u = s[l];
          return u === void 0 ? c : u;
        }
      }
    }
    function a(s, l, c) {
      if (l.length === 0)
        return c;
      let u = s;
      for (let d = 0; d < l.length; d++) {
        if (u == null || t.isUnsafeProperty(l[d]))
          return c;
        u = u[l[d]];
      }
      return u === void 0 ? c : u;
    }
    e.get = o;
  })(tp)), tp;
}
var ap, M0;
function jR() {
  return M0 || (M0 = 1, ap = zg().get), ap;
}
var NR = /* @__PURE__ */ jR();
const Io = /* @__PURE__ */ xi(NR);
var Yt = (e) => e === 0 ? 0 : e > 0 ? 1 : -1, qn = (e) => typeof e == "number" && e != +e, So = (e) => typeof e == "string" && e.indexOf("%") === e.length - 1, me = (e) => (typeof e == "number" || e instanceof Number) && !qn(e), Vr = (e) => me(e) || typeof e == "string", DR = 0, rl = (e) => {
  var t = ++DR;
  return "".concat(e || "").concat(t);
}, hn = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (!me(t) && typeof t != "string")
    return r;
  var o;
  if (So(t)) {
    if (n == null)
      return r;
    var a = t.indexOf("%");
    o = n * parseFloat(t.slice(0, a)) / 100;
  } else
    o = +t;
  return qn(o) && (o = r), i && n != null && o > n && (o = n), o;
}, F_ = (e) => {
  if (!Array.isArray(e))
    return !1;
  for (var t = e.length, n = {}, r = 0; r < t; r++)
    if (!n[e[r]])
      n[e[r]] = !0;
    else
      return !0;
  return !1;
};
function _t(e, t, n) {
  return me(e) && me(t) ? e + n * (t - e) : t;
}
function B_(e, t, n) {
  if (!(!e || !e.length))
    return e.find((r) => r && (typeof t == "function" ? t(r) : Io(r, t)) === n);
}
var yt = (e) => e === null || typeof e > "u", Il = (e) => yt(e) ? e : "".concat(e.charAt(0).toUpperCase()).concat(e.slice(1)), RR = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
function Wg(e) {
  if (typeof e != "string")
    return !1;
  var t = RR;
  return t.includes(e);
}
var IR = ["viewBox", "children"], j0 = ["points", "pathLength"], sp = {
  svg: IR,
  polygon: j0,
  polyline: j0
}, Vg = (e, t) => {
  if (!e || typeof e == "function" || typeof e == "boolean")
    return null;
  var n = e;
  if (/* @__PURE__ */ bn(e) && (n = e.props), typeof n != "object" && typeof n != "function")
    return null;
  var r = {};
  return Object.keys(n).forEach((i) => {
    Wg(i) && (r[i] = ((o) => n[i](n, o)));
  }), r;
}, $R = (e, t, n) => (r) => (e(t, n, r), null), Wd = (e, t, n) => {
  if (e === null || typeof e != "object" && typeof e != "function")
    return null;
  var r = null;
  return Object.keys(e).forEach((i) => {
    var o = e[i];
    Wg(i) && typeof o == "function" && (r || (r = {}), r[i] = $R(o, t, n));
  }), r;
}, LR = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it, and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
];
function z_(e) {
  if (typeof e != "string")
    return !1;
  var t = LR;
  return t.includes(e);
}
function Yr(e) {
  var t = Object.entries(e).filter((n) => {
    var [r] = n;
    return z_(r);
  });
  return Object.fromEntries(t);
}
var N0 = (e) => typeof e == "string" ? e : e ? e.displayName || e.name || "Component" : "", D0 = null, lp = null, W_ = (e) => {
  if (e === D0 && Array.isArray(lp))
    return lp;
  var t = [];
  return LE.forEach(e, (n) => {
    yt(n) || (Bi.isFragment(n) ? t = t.concat(W_(n.props.children)) : t.push(n));
  }), lp = t, D0 = e, t;
};
function Ug(e, t) {
  var n = [], r = [];
  return Array.isArray(t) ? r = t.map((i) => N0(i)) : r = [N0(t)], W_(e).forEach((i) => {
    var o = Io(i, "type.displayName") || Io(i, "type.name");
    r.indexOf(o) !== -1 && n.push(i);
  }), n;
}
var V_ = (e) => e && typeof e == "object" && "clipDot" in e ? !!e.clipDot : !0, FR = (e, t, n, r) => {
  var i;
  if (typeof t == "symbol" || typeof t == "number")
    return !0;
  var o = (i = r && sp?.[r]) !== null && i !== void 0 ? i : [], a = t.startsWith("data-"), s = typeof e != "function" && (!!r && o.includes(t) || z_(t)), l = !!n && Wg(t);
  return a || s || l;
}, wt = (e, t, n) => {
  if (!e || typeof e == "function" || typeof e == "boolean")
    return null;
  var r = e;
  if (/* @__PURE__ */ bn(e) && (r = e.props), typeof r != "object" && typeof r != "function")
    return null;
  var i = {};
  return Object.keys(r).forEach((o) => {
    var a;
    FR((a = r) === null || a === void 0 ? void 0 : a[o], o, t, n) && (i[o] = r[o]);
  }), i;
}, BR = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function lm() {
  return lm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, lm.apply(null, arguments);
}
function zR(e, t) {
  if (e == null) return {};
  var n, r, i = WR(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function WR(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var U_ = /* @__PURE__ */ rn((e, t) => {
  var {
    children: n,
    width: r,
    height: i,
    viewBox: o,
    className: a,
    style: s,
    title: l,
    desc: c
  } = e, u = zR(e, BR), d = o || {
    width: r,
    height: i,
    x: 0,
    y: 0
  }, p = ie("recharts-surface", a);
  return /* @__PURE__ */ _.createElement("svg", lm({}, wt(u, !0, "svg"), {
    className: p,
    width: r,
    height: i,
    style: s,
    viewBox: "".concat(d.x, " ").concat(d.y, " ").concat(d.width, " ").concat(d.height),
    ref: t
  }), /* @__PURE__ */ _.createElement("title", null, l), /* @__PURE__ */ _.createElement("desc", null, c), n);
}), VR = ["children", "className"];
function cm() {
  return cm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, cm.apply(null, arguments);
}
function UR(e, t) {
  if (e == null) return {};
  var n, r, i = HR(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function HR(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var nn = /* @__PURE__ */ _.forwardRef((e, t) => {
  var {
    children: n,
    className: r
  } = e, i = UR(e, VR), o = ie("recharts-layer", r);
  return /* @__PURE__ */ _.createElement("g", cm({
    className: o
  }, wt(i, !0), {
    ref: t
  }), n);
}), qR = /* @__PURE__ */ gr(null);
function st(e) {
  return function() {
    return e;
  };
}
const H_ = Math.cos, Eu = Math.sin, Sr = Math.sqrt, _u = Math.PI, Vd = 2 * _u, um = Math.PI, dm = 2 * um, ho = 1e-6, KR = dm - ho;
function q_(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function YR(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return q_;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, o = r.length; i < o; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
class GR {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? q_ : YR(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, o, a) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +o},${this._y1 = +a}`;
  }
  arcTo(t, n, r, i, o) {
    if (t = +t, n = +n, r = +r, i = +i, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let a = this._x1, s = this._y1, l = r - t, c = i - n, u = a - t, d = s - n, p = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > ho) if (!(Math.abs(d * l - c * u) > ho) || !o)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let h = r - a, g = i - s, m = l * l + c * c, v = h * h + g * g, y = Math.sqrt(m), S = Math.sqrt(p), w = o * Math.tan((um - Math.acos((m + p - v) / (2 * y * S))) / 2), b = w / S, O = w / y;
      Math.abs(b - 1) > ho && this._append`L${t + b * u},${n + b * d}`, this._append`A${o},${o},0,0,${+(d * h > u * g)},${this._x1 = t + O * l},${this._y1 = n + O * c}`;
    }
  }
  arc(t, n, r, i, o, a) {
    if (t = +t, n = +n, r = +r, a = !!a, r < 0) throw new Error(`negative radius: ${r}`);
    let s = r * Math.cos(i), l = r * Math.sin(i), c = t + s, u = n + l, d = 1 ^ a, p = a ? i - o : o - i;
    this._x1 === null ? this._append`M${c},${u}` : (Math.abs(this._x1 - c) > ho || Math.abs(this._y1 - u) > ho) && this._append`L${c},${u}`, r && (p < 0 && (p = p % dm + dm), p > KR ? this._append`A${r},${r},0,1,${d},${t - s},${n - l}A${r},${r},0,1,${d},${this._x1 = c},${this._y1 = u}` : p > ho && this._append`A${r},${r},0,${+(p >= um)},${d},${this._x1 = t + r * Math.cos(o)},${this._y1 = n + r * Math.sin(o)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
}
function Hg(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new GR(t);
}
function qg(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function K_(e) {
  this._context = e;
}
K_.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Ud(e) {
  return new K_(e);
}
function Y_(e) {
  return e[0];
}
function G_(e) {
  return e[1];
}
function X_(e, t) {
  var n = st(!0), r = null, i = Ud, o = null, a = Hg(s);
  e = typeof e == "function" ? e : e === void 0 ? Y_ : st(e), t = typeof t == "function" ? t : t === void 0 ? G_ : st(t);
  function s(l) {
    var c, u = (l = qg(l)).length, d, p = !1, h;
    for (r == null && (o = i(h = a())), c = 0; c <= u; ++c)
      !(c < u && n(d = l[c], c, l)) === p && ((p = !p) ? o.lineStart() : o.lineEnd()), p && o.point(+e(d, c, l), +t(d, c, l));
    if (h) return o = null, h + "" || null;
  }
  return s.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : st(+l), s) : e;
  }, s.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : st(+l), s) : t;
  }, s.defined = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : st(!!l), s) : n;
  }, s.curve = function(l) {
    return arguments.length ? (i = l, r != null && (o = i(r)), s) : i;
  }, s.context = function(l) {
    return arguments.length ? (l == null ? r = o = null : o = i(r = l), s) : r;
  }, s;
}
function vc(e, t, n) {
  var r = null, i = st(!0), o = null, a = Ud, s = null, l = Hg(c);
  e = typeof e == "function" ? e : e === void 0 ? Y_ : st(+e), t = typeof t == "function" ? t : st(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? G_ : st(+n);
  function c(d) {
    var p, h, g, m = (d = qg(d)).length, v, y = !1, S, w = new Array(m), b = new Array(m);
    for (o == null && (s = a(S = l())), p = 0; p <= m; ++p) {
      if (!(p < m && i(v = d[p], p, d)) === y)
        if (y = !y)
          h = p, s.areaStart(), s.lineStart();
        else {
          for (s.lineEnd(), s.lineStart(), g = p - 1; g >= h; --g)
            s.point(w[g], b[g]);
          s.lineEnd(), s.areaEnd();
        }
      y && (w[p] = +e(v, p, d), b[p] = +t(v, p, d), s.point(r ? +r(v, p, d) : w[p], n ? +n(v, p, d) : b[p]));
    }
    if (S) return s = null, S + "" || null;
  }
  function u() {
    return X_().defined(i).curve(a).context(o);
  }
  return c.x = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : st(+d), r = null, c) : e;
  }, c.x0 = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : st(+d), c) : e;
  }, c.x1 = function(d) {
    return arguments.length ? (r = d == null ? null : typeof d == "function" ? d : st(+d), c) : r;
  }, c.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : st(+d), n = null, c) : t;
  }, c.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : st(+d), c) : t;
  }, c.y1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : st(+d), c) : n;
  }, c.lineX0 = c.lineY0 = function() {
    return u().x(e).y(t);
  }, c.lineY1 = function() {
    return u().x(e).y(n);
  }, c.lineX1 = function() {
    return u().x(r).y(t);
  }, c.defined = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : st(!!d), c) : i;
  }, c.curve = function(d) {
    return arguments.length ? (a = d, o != null && (s = a(o)), c) : a;
  }, c.context = function(d) {
    return arguments.length ? (d == null ? o = s = null : s = a(o = d), c) : o;
  }, c;
}
class Z_ {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function XR(e) {
  return new Z_(e, !0);
}
function ZR(e) {
  return new Z_(e, !1);
}
const Kg = {
  draw(e, t) {
    const n = Sr(t / _u);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, Vd);
  }
}, JR = {
  draw(e, t) {
    const n = Sr(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, J_ = Sr(1 / 3), QR = J_ * 2, eI = {
  draw(e, t) {
    const n = Sr(t / QR), r = n * J_;
    e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath();
  }
}, tI = {
  draw(e, t) {
    const n = Sr(t), r = -n / 2;
    e.rect(r, r, n, n);
  }
}, nI = 0.8908130915292852, Q_ = Eu(_u / 10) / Eu(7 * _u / 10), rI = Eu(Vd / 10) * Q_, iI = -H_(Vd / 10) * Q_, oI = {
  draw(e, t) {
    const n = Sr(t * nI), r = rI * n, i = iI * n;
    e.moveTo(0, -n), e.lineTo(r, i);
    for (let o = 1; o < 5; ++o) {
      const a = Vd * o / 5, s = H_(a), l = Eu(a);
      e.lineTo(l * n, -s * n), e.lineTo(s * r - l * i, l * r + s * i);
    }
    e.closePath();
  }
}, cp = Sr(3), aI = {
  draw(e, t) {
    const n = -Sr(t / (cp * 3));
    e.moveTo(0, n * 2), e.lineTo(-cp * n, -n), e.lineTo(cp * n, -n), e.closePath();
  }
}, tr = -0.5, nr = Sr(3) / 2, fm = 1 / Sr(12), sI = (fm / 2 + 1) * 3, lI = {
  draw(e, t) {
    const n = Sr(t / sI), r = n / 2, i = n * fm, o = r, a = n * fm + n, s = -o, l = a;
    e.moveTo(r, i), e.lineTo(o, a), e.lineTo(s, l), e.lineTo(tr * r - nr * i, nr * r + tr * i), e.lineTo(tr * o - nr * a, nr * o + tr * a), e.lineTo(tr * s - nr * l, nr * s + tr * l), e.lineTo(tr * r + nr * i, tr * i - nr * r), e.lineTo(tr * o + nr * a, tr * a - nr * o), e.lineTo(tr * s + nr * l, tr * l - nr * s), e.closePath();
  }
};
function cI(e, t) {
  let n = null, r = Hg(i);
  e = typeof e == "function" ? e : st(e || Kg), t = typeof t == "function" ? t : st(t === void 0 ? 64 : +t);
  function i() {
    let o;
    if (n || (n = o = r()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null;
  }
  return i.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : st(o), i) : e;
  }, i.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : st(+o), i) : t;
  }, i.context = function(o) {
    return arguments.length ? (n = o ?? null, i) : n;
  }, i;
}
function Pu() {
}
function Cu(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function eP(e) {
  this._context = e;
}
eP.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Cu(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        Cu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function uI(e) {
  return new eP(e);
}
function tP(e) {
  this._context = e;
}
tP.prototype = {
  areaStart: Pu,
  areaEnd: Pu,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        Cu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function dI(e) {
  return new tP(e);
}
function nP(e) {
  this._context = e;
}
nP.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Cu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function fI(e) {
  return new nP(e);
}
function rP(e) {
  this._context = e;
}
rP.prototype = {
  areaStart: Pu,
  areaEnd: Pu,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function pI(e) {
  return new rP(e);
}
function R0(e) {
  return e < 0 ? -1 : 1;
}
function I0(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), s = (o * i + a * r) / (r + i);
  return (R0(o) + R0(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(s)) || 0;
}
function $0(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function up(e, t, n) {
  var r = e._x0, i = e._y0, o = e._x1, a = e._y1, s = (o - r) / 3;
  e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a);
}
function Tu(e) {
  this._context = e;
}
Tu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        up(this, this._t0, $0(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, up(this, $0(this, n = I0(this, e, t)), n);
          break;
        default:
          up(this, this._t0, n = I0(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function iP(e) {
  this._context = new oP(e);
}
(iP.prototype = Object.create(Tu.prototype)).point = function(e, t) {
  Tu.prototype.point.call(this, t, e);
};
function oP(e) {
  this._context = e;
}
oP.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i);
  }
};
function hI(e) {
  return new Tu(e);
}
function mI(e) {
  return new iP(e);
}
function aP(e) {
  this._context = e;
}
aP.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = L0(e), i = L0(t), o = 0, a = 1; a < n; ++o, ++a)
          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function L0(e) {
  var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), a = new Array(n);
  for (i[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) i[t] = 1, o[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) r = i[t] / o[t - 1], o[t] -= r, a[t] -= r * a[t - 1];
  for (i[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t) i[t] = (a[t] - i[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t) o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function gI(e) {
  return new aP(e);
}
function Hd(e, t) {
  this._context = e, this._t = t;
}
Hd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function vI(e) {
  return new Hd(e, 0.5);
}
function yI(e) {
  return new Hd(e, 0);
}
function bI(e) {
  return new Hd(e, 1);
}
function Ta(e, t) {
  if ((a = e.length) > 1)
    for (var n = 1, r, i, o = e[t[0]], a, s = o.length; n < a; ++n)
      for (i = o, o = e[t[n]], r = 0; r < s; ++r)
        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function pm(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; ) n[t] = t;
  return n;
}
function xI(e, t) {
  return e[t];
}
function wI(e) {
  const t = [];
  return t.key = e, t;
}
function OI() {
  var e = st([]), t = pm, n = Ta, r = xI;
  function i(o) {
    var a = Array.from(e.apply(this, arguments), wI), s, l = a.length, c = -1, u;
    for (const d of o)
      for (s = 0, ++c; s < l; ++s)
        (a[s][c] = [0, +r(d, a[s].key, c, o)]).data = d;
    for (s = 0, u = qg(t(a)); s < l; ++s)
      a[u[s]].index = s;
    return n(a, u), a;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : st(Array.from(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : st(+o), i) : r;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? pm : typeof o == "function" ? o : st(Array.from(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (n = o ?? Ta, i) : n;
  }, i;
}
function SI(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, i = 0, o = e[0].length, a; i < o; ++i) {
      for (a = n = 0; n < r; ++n) a += e[n][i][1] || 0;
      if (a) for (n = 0; n < r; ++n) e[n][i][1] /= a;
    }
    Ta(e, t);
  }
}
function EI(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
      for (var a = 0, s = 0; a < i; ++a) s += e[a][n][1] || 0;
      r[n][1] += r[n][0] = -s / 2;
    }
    Ta(e, t);
  }
}
function _I(e, t) {
  if (!(!((a = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, i, o, a; r < o; ++r) {
      for (var s = 0, l = 0, c = 0; s < a; ++s) {
        for (var u = e[t[s]], d = u[r][1] || 0, p = u[r - 1][1] || 0, h = (d - p) / 2, g = 0; g < s; ++g) {
          var m = e[t[g]], v = m[r][1] || 0, y = m[r - 1][1] || 0;
          h += v - y;
        }
        l += d, c += h * d;
      }
      i[r - 1][1] += i[r - 1][0] = n, l && (n -= c / l);
    }
    i[r - 1][1] += i[r - 1][0] = n, Ta(e, t);
  }
}
var PI = ["type", "size", "sizeType"];
function hm() {
  return hm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, hm.apply(null, arguments);
}
function F0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function B0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F0(Object(n), !0).forEach(function(r) {
      CI(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function CI(e, t, n) {
  return (t = TI(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function TI(e) {
  var t = AI(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function AI(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function kI(e, t) {
  if (e == null) return {};
  var n, r, i = MI(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function MI(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var sP = {
  symbolCircle: Kg,
  symbolCross: JR,
  symbolDiamond: eI,
  symbolSquare: tI,
  symbolStar: oI,
  symbolTriangle: aI,
  symbolWye: lI
}, jI = Math.PI / 180, NI = (e) => {
  var t = "symbol".concat(Il(e));
  return sP[t] || Kg;
}, DI = (e, t, n) => {
  if (t === "area")
    return e;
  switch (n) {
    case "cross":
      return 5 * e * e / 9;
    case "diamond":
      return 0.5 * e * e / Math.sqrt(3);
    case "square":
      return e * e;
    case "star": {
      var r = 18 * jI;
      return 1.25 * e * e * (Math.tan(r) - Math.tan(r * 2) * Math.tan(r) ** 2);
    }
    case "triangle":
      return Math.sqrt(3) * e * e / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * e * e / 8;
    default:
      return Math.PI * e * e / 4;
  }
}, RI = (e, t) => {
  sP["symbol".concat(Il(e))] = t;
}, lP = (e) => {
  var {
    type: t = "circle",
    size: n = 64,
    sizeType: r = "area"
  } = e, i = kI(e, PI), o = B0(B0({}, i), {}, {
    type: t,
    size: n,
    sizeType: r
  }), a = "circle";
  typeof t == "string" && (a = t);
  var s = () => {
    var p = NI(a), h = cI().type(p).size(DI(n, r, a));
    return h();
  }, {
    className: l,
    cx: c,
    cy: u
  } = o, d = wt(o, !0);
  return c === +c && u === +u && n === +n ? /* @__PURE__ */ _.createElement("path", hm({}, d, {
    className: ie("recharts-symbols", l),
    transform: "translate(".concat(c, ", ").concat(u, ")"),
    d: s()
  })) : null;
};
lP.registerSymbol = RI;
var dp = {}, fp = {}, z0;
function II() {
  return z0 || (z0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r) {
      const i = /* @__PURE__ */ new Map();
      for (let o = 0; o < n.length; o++) {
        const a = n[o], s = r(a);
        i.has(s) || i.set(s, a);
      }
      return Array.from(i.values());
    }
    e.uniqBy = t;
  })(fp)), fp;
}
var pp = {}, W0;
function cP() {
  return W0 || (W0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n;
    }
    e.identity = t;
  })(pp)), pp;
}
var hp = {}, mp = {}, gp = {}, V0;
function $I() {
  return V0 || (V0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return Number.isSafeInteger(n) && n >= 0;
    }
    e.isLength = t;
  })(gp)), gp;
}
var U0;
function Yg() {
  return U0 || (U0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ $I();
    function n(r) {
      return r != null && typeof r != "function" && t.isLength(r.length);
    }
    e.isArrayLike = n;
  })(mp)), mp;
}
var vp = {}, H0;
function LI() {
  return H0 || (H0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return typeof n == "object" && n !== null;
    }
    e.isObjectLike = t;
  })(vp)), vp;
}
var q0;
function FI() {
  return q0 || (q0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ Yg(), n = /* @__PURE__ */ LI();
    function r(i) {
      return n.isObjectLike(i) && t.isArrayLike(i);
    }
    e.isArrayLikeObject = r;
  })(hp)), hp;
}
var yp = {}, bp = {}, K0;
function BI() {
  return K0 || (K0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ zg();
    function n(r) {
      return function(i) {
        return t.get(i, r);
      };
    }
    e.property = n;
  })(bp)), bp;
}
var xp = {}, wp = {}, Op = {}, Sp = {}, Y0;
function uP() {
  return Y0 || (Y0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n !== null && (typeof n == "object" || typeof n == "function");
    }
    e.isObject = t;
  })(Sp)), Sp;
}
var Ep = {}, G0;
function dP() {
  return G0 || (G0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n == null || typeof n != "object" && typeof n != "function";
    }
    e.isPrimitive = t;
  })(Ep)), Ep;
}
var _p = {}, X0;
function fP() {
  return X0 || (X0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r) {
      return n === r || Number.isNaN(n) && Number.isNaN(r);
    }
    e.eq = t;
  })(_p)), _p;
}
var Z0;
function zI() {
  return Z0 || (Z0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ Gg(), n = /* @__PURE__ */ uP(), r = /* @__PURE__ */ dP(), i = /* @__PURE__ */ fP();
    function o(d, p, h) {
      return typeof h != "function" ? t.isMatch(d, p) : a(d, p, function g(m, v, y, S, w, b) {
        const O = h(m, v, y, S, w, b);
        return O !== void 0 ? !!O : a(m, v, g, b);
      }, /* @__PURE__ */ new Map());
    }
    function a(d, p, h, g) {
      if (p === d)
        return !0;
      switch (typeof p) {
        case "object":
          return s(d, p, h, g);
        case "function":
          return Object.keys(p).length > 0 ? a(d, { ...p }, h, g) : i.eq(d, p);
        default:
          return n.isObject(d) ? typeof p == "string" ? p === "" : !0 : i.eq(d, p);
      }
    }
    function s(d, p, h, g) {
      if (p == null)
        return !0;
      if (Array.isArray(p))
        return c(d, p, h, g);
      if (p instanceof Map)
        return l(d, p, h, g);
      if (p instanceof Set)
        return u(d, p, h, g);
      const m = Object.keys(p);
      if (d == null)
        return m.length === 0;
      if (m.length === 0)
        return !0;
      if (g && g.has(p))
        return g.get(p) === d;
      g && g.set(p, d);
      try {
        for (let v = 0; v < m.length; v++) {
          const y = m[v];
          if (!r.isPrimitive(d) && !(y in d) || p[y] === void 0 && d[y] !== void 0 || p[y] === null && d[y] !== null || !h(d[y], p[y], y, d, p, g))
            return !1;
        }
        return !0;
      } finally {
        g && g.delete(p);
      }
    }
    function l(d, p, h, g) {
      if (p.size === 0)
        return !0;
      if (!(d instanceof Map))
        return !1;
      for (const [m, v] of p.entries()) {
        const y = d.get(m);
        if (h(y, v, m, d, p, g) === !1)
          return !1;
      }
      return !0;
    }
    function c(d, p, h, g) {
      if (p.length === 0)
        return !0;
      if (!Array.isArray(d))
        return !1;
      const m = /* @__PURE__ */ new Set();
      for (let v = 0; v < p.length; v++) {
        const y = p[v];
        let S = !1;
        for (let w = 0; w < d.length; w++) {
          if (m.has(w))
            continue;
          const b = d[w];
          let O = !1;
          if (h(b, y, v, d, p, g) && (O = !0), O) {
            m.add(w), S = !0;
            break;
          }
        }
        if (!S)
          return !1;
      }
      return !0;
    }
    function u(d, p, h, g) {
      return p.size === 0 ? !0 : d instanceof Set ? c([...d], [...p], h, g) : !1;
    }
    e.isMatchWith = o, e.isSetMatch = u;
  })(Op)), Op;
}
var J0;
function Gg() {
  return J0 || (J0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ zI();
    function n(r, i) {
      return t.isMatchWith(r, i, () => {
      });
    }
    e.isMatch = n;
  })(wp)), wp;
}
var Pp = {}, Cp = {}, Tp = {}, Q0;
function WI() {
  return Q0 || (Q0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return Object.getOwnPropertySymbols(n).filter((r) => Object.prototype.propertyIsEnumerable.call(n, r));
    }
    e.getSymbols = t;
  })(Tp)), Tp;
}
var Ap = {}, ex;
function pP() {
  return ex || (ex = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n == null ? n === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(n);
    }
    e.getTag = t;
  })(Ap)), Ap;
}
var kp = {}, tx;
function hP() {
  return tx || (tx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = "[object RegExp]", n = "[object String]", r = "[object Number]", i = "[object Boolean]", o = "[object Arguments]", a = "[object Symbol]", s = "[object Date]", l = "[object Map]", c = "[object Set]", u = "[object Array]", d = "[object Function]", p = "[object ArrayBuffer]", h = "[object Object]", g = "[object Error]", m = "[object DataView]", v = "[object Uint8Array]", y = "[object Uint8ClampedArray]", S = "[object Uint16Array]", w = "[object Uint32Array]", b = "[object BigUint64Array]", O = "[object Int8Array]", E = "[object Int16Array]", C = "[object Int32Array]", T = "[object BigInt64Array]", j = "[object Float32Array]", A = "[object Float64Array]";
    e.argumentsTag = o, e.arrayBufferTag = p, e.arrayTag = u, e.bigInt64ArrayTag = T, e.bigUint64ArrayTag = b, e.booleanTag = i, e.dataViewTag = m, e.dateTag = s, e.errorTag = g, e.float32ArrayTag = j, e.float64ArrayTag = A, e.functionTag = d, e.int16ArrayTag = E, e.int32ArrayTag = C, e.int8ArrayTag = O, e.mapTag = l, e.numberTag = r, e.objectTag = h, e.regexpTag = t, e.setTag = c, e.stringTag = n, e.symbolTag = a, e.uint16ArrayTag = S, e.uint32ArrayTag = w, e.uint8ArrayTag = v, e.uint8ClampedArrayTag = y;
  })(kp)), kp;
}
var Mp = {}, nx;
function VI() {
  return nx || (nx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return ArrayBuffer.isView(n) && !(n instanceof DataView);
    }
    e.isTypedArray = t;
  })(Mp)), Mp;
}
var rx;
function mP() {
  return rx || (rx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ WI(), n = /* @__PURE__ */ pP(), r = /* @__PURE__ */ hP(), i = /* @__PURE__ */ dP(), o = /* @__PURE__ */ VI();
    function a(u, d) {
      return s(u, void 0, u, /* @__PURE__ */ new Map(), d);
    }
    function s(u, d, p, h = /* @__PURE__ */ new Map(), g = void 0) {
      const m = g?.(u, d, p, h);
      if (m !== void 0)
        return m;
      if (i.isPrimitive(u))
        return u;
      if (h.has(u))
        return h.get(u);
      if (Array.isArray(u)) {
        const v = new Array(u.length);
        h.set(u, v);
        for (let y = 0; y < u.length; y++)
          v[y] = s(u[y], y, p, h, g);
        return Object.hasOwn(u, "index") && (v.index = u.index), Object.hasOwn(u, "input") && (v.input = u.input), v;
      }
      if (u instanceof Date)
        return new Date(u.getTime());
      if (u instanceof RegExp) {
        const v = new RegExp(u.source, u.flags);
        return v.lastIndex = u.lastIndex, v;
      }
      if (u instanceof Map) {
        const v = /* @__PURE__ */ new Map();
        h.set(u, v);
        for (const [y, S] of u)
          v.set(y, s(S, y, p, h, g));
        return v;
      }
      if (u instanceof Set) {
        const v = /* @__PURE__ */ new Set();
        h.set(u, v);
        for (const y of u)
          v.add(s(y, void 0, p, h, g));
        return v;
      }
      if (typeof Buffer < "u" && Buffer.isBuffer(u))
        return u.subarray();
      if (o.isTypedArray(u)) {
        const v = new (Object.getPrototypeOf(u)).constructor(u.length);
        h.set(u, v);
        for (let y = 0; y < u.length; y++)
          v[y] = s(u[y], y, p, h, g);
        return v;
      }
      if (u instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && u instanceof SharedArrayBuffer)
        return u.slice(0);
      if (u instanceof DataView) {
        const v = new DataView(u.buffer.slice(0), u.byteOffset, u.byteLength);
        return h.set(u, v), l(v, u, p, h, g), v;
      }
      if (typeof File < "u" && u instanceof File) {
        const v = new File([u], u.name, {
          type: u.type
        });
        return h.set(u, v), l(v, u, p, h, g), v;
      }
      if (u instanceof Blob) {
        const v = new Blob([u], { type: u.type });
        return h.set(u, v), l(v, u, p, h, g), v;
      }
      if (u instanceof Error) {
        const v = new u.constructor();
        return h.set(u, v), v.message = u.message, v.name = u.name, v.stack = u.stack, v.cause = u.cause, l(v, u, p, h, g), v;
      }
      if (typeof u == "object" && c(u)) {
        const v = Object.create(Object.getPrototypeOf(u));
        return h.set(u, v), l(v, u, p, h, g), v;
      }
      return u;
    }
    function l(u, d, p = u, h, g) {
      const m = [...Object.keys(d), ...t.getSymbols(d)];
      for (let v = 0; v < m.length; v++) {
        const y = m[v], S = Object.getOwnPropertyDescriptor(u, y);
        (S == null || S.writable) && (u[y] = s(d[y], y, p, h, g));
      }
    }
    function c(u) {
      switch (n.getTag(u)) {
        case r.argumentsTag:
        case r.arrayTag:
        case r.arrayBufferTag:
        case r.dataViewTag:
        case r.booleanTag:
        case r.dateTag:
        case r.float32ArrayTag:
        case r.float64ArrayTag:
        case r.int8ArrayTag:
        case r.int16ArrayTag:
        case r.int32ArrayTag:
        case r.mapTag:
        case r.numberTag:
        case r.objectTag:
        case r.regexpTag:
        case r.setTag:
        case r.stringTag:
        case r.symbolTag:
        case r.uint8ArrayTag:
        case r.uint8ClampedArrayTag:
        case r.uint16ArrayTag:
        case r.uint32ArrayTag:
          return !0;
        default:
          return !1;
      }
    }
    e.cloneDeepWith = a, e.cloneDeepWithImpl = s, e.copyProperties = l;
  })(Cp)), Cp;
}
var ix;
function UI() {
  return ix || (ix = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ mP();
    function n(r) {
      return t.cloneDeepWithImpl(r, void 0, r, /* @__PURE__ */ new Map(), void 0);
    }
    e.cloneDeep = n;
  })(Pp)), Pp;
}
var ox;
function HI() {
  return ox || (ox = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ Gg(), n = /* @__PURE__ */ UI();
    function r(i) {
      return i = n.cloneDeep(i), (o) => t.isMatch(o, i);
    }
    e.matches = r;
  })(xp)), xp;
}
var jp = {}, Np = {}, Dp = {}, ax;
function qI() {
  return ax || (ax = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ mP(), n = /* @__PURE__ */ hP();
    function r(i, o) {
      return t.cloneDeepWith(i, (a, s, l, c) => {
        const u = o?.(a, s, l, c);
        if (u !== void 0)
          return u;
        if (typeof i == "object")
          switch (Object.prototype.toString.call(i)) {
            case n.numberTag:
            case n.stringTag:
            case n.booleanTag: {
              const d = new i.constructor(i?.valueOf());
              return t.copyProperties(d, i), d;
            }
            case n.argumentsTag: {
              const d = {};
              return t.copyProperties(d, i), d.length = i.length, d[Symbol.iterator] = i[Symbol.iterator], d;
            }
            default:
              return;
          }
      });
    }
    e.cloneDeepWith = r;
  })(Dp)), Dp;
}
var sx;
function KI() {
  return sx || (sx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ qI();
    function n(r) {
      return t.cloneDeepWith(r);
    }
    e.cloneDeep = n;
  })(Np)), Np;
}
var Rp = {}, Ip = {}, lx;
function gP() {
  return lx || (lx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /^(?:0|[1-9]\d*)$/;
    function n(r, i = Number.MAX_SAFE_INTEGER) {
      switch (typeof r) {
        case "number":
          return Number.isInteger(r) && r >= 0 && r < i;
        case "symbol":
          return !1;
        case "string":
          return t.test(r);
      }
    }
    e.isIndex = n;
  })(Ip)), Ip;
}
var $p = {}, cx;
function YI() {
  return cx || (cx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ pP();
    function n(r) {
      return r !== null && typeof r == "object" && t.getTag(r) === "[object Arguments]";
    }
    e.isArguments = n;
  })($p)), $p;
}
var ux;
function GI() {
  return ux || (ux = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ $_(), n = /* @__PURE__ */ gP(), r = /* @__PURE__ */ YI(), i = /* @__PURE__ */ Bg();
    function o(a, s) {
      let l;
      if (Array.isArray(s) ? l = s : typeof s == "string" && t.isDeepKey(s) && a?.[s] == null ? l = i.toPath(s) : l = [s], l.length === 0)
        return !1;
      let c = a;
      for (let u = 0; u < l.length; u++) {
        const d = l[u];
        if ((c == null || !Object.hasOwn(c, d)) && !((Array.isArray(c) || r.isArguments(c)) && n.isIndex(d) && d < c.length))
          return !1;
        c = c[d];
      }
      return !0;
    }
    e.has = o;
  })(Rp)), Rp;
}
var dx;
function XI() {
  return dx || (dx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ Gg(), n = /* @__PURE__ */ L_(), r = /* @__PURE__ */ KI(), i = /* @__PURE__ */ zg(), o = /* @__PURE__ */ GI();
    function a(s, l) {
      switch (typeof s) {
        case "object": {
          Object.is(s?.valueOf(), -0) && (s = "-0");
          break;
        }
        case "number": {
          s = n.toKey(s);
          break;
        }
      }
      return l = r.cloneDeep(l), function(c) {
        const u = i.get(c, s);
        return u === void 0 ? o.has(c, s) : l === void 0 ? u === void 0 : t.isMatch(u, l);
      };
    }
    e.matchesProperty = a;
  })(jp)), jp;
}
var fx;
function ZI() {
  return fx || (fx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ cP(), n = /* @__PURE__ */ BI(), r = /* @__PURE__ */ HI(), i = /* @__PURE__ */ XI();
    function o(a) {
      if (a == null)
        return t.identity;
      switch (typeof a) {
        case "function":
          return a;
        case "object":
          return Array.isArray(a) && a.length === 2 ? i.matchesProperty(a[0], a[1]) : r.matches(a);
        case "string":
        case "symbol":
        case "number":
          return n.property(a);
      }
    }
    e.iteratee = o;
  })(yp)), yp;
}
var px;
function JI() {
  return px || (px = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ II(), n = /* @__PURE__ */ cP(), r = /* @__PURE__ */ FI(), i = /* @__PURE__ */ ZI();
    function o(a, s = n.identity) {
      return r.isArrayLikeObject(a) ? t.uniqBy(Array.from(a), i.iteratee(s)) : [];
    }
    e.uniqBy = o;
  })(dp)), dp;
}
var Lp, hx;
function QI() {
  return hx || (hx = 1, Lp = JI().uniqBy), Lp;
}
var e$ = /* @__PURE__ */ QI();
const mx = /* @__PURE__ */ xi(e$);
function t$(e, t, n) {
  return t === !0 ? mx(e, n) : typeof t == "function" ? mx(e, t) : e;
}
var yc = { exports: {} }, Fp = {}, bc = { exports: {} }, Bp = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gx;
function n$() {
  if (gx) return Bp;
  gx = 1;
  var e = Ye;
  function t(d, p) {
    return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, a = e.useDebugValue;
  function s(d, p) {
    var h = p(), g = r({ inst: { value: h, getSnapshot: p } }), m = g[0].inst, v = g[1];
    return o(
      function() {
        m.value = h, m.getSnapshot = p, l(m) && v({ inst: m });
      },
      [d, h, p]
    ), i(
      function() {
        return l(m) && v({ inst: m }), d(function() {
          l(m) && v({ inst: m });
        });
      },
      [d]
    ), a(h), h;
  }
  function l(d) {
    var p = d.getSnapshot;
    d = d.value;
    try {
      var h = p();
      return !n(d, h);
    } catch {
      return !0;
    }
  }
  function c(d, p) {
    return p();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : s;
  return Bp.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, Bp;
}
var zp = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vx;
function r$() {
  return vx || (vx = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(h, g) {
      return h === g && (h !== 0 || 1 / h === 1 / g) || h !== h && g !== g;
    }
    function t(h, g) {
      u || i.startTransition === void 0 || (u = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var m = g();
      if (!d) {
        var v = g();
        o(m, v) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      v = a({
        inst: { value: m, getSnapshot: g }
      });
      var y = v[0].inst, S = v[1];
      return l(
        function() {
          y.value = m, y.getSnapshot = g, n(y) && S({ inst: y });
        },
        [h, m, g]
      ), s(
        function() {
          return n(y) && S({ inst: y }), h(function() {
            n(y) && S({ inst: y });
          });
        },
        [h]
      ), c(m), m;
    }
    function n(h) {
      var g = h.getSnapshot;
      h = h.value;
      try {
        var m = g();
        return !o(h, m);
      } catch {
        return !0;
      }
    }
    function r(h, g) {
      return g();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var i = Ye, o = typeof Object.is == "function" ? Object.is : e, a = i.useState, s = i.useEffect, l = i.useLayoutEffect, c = i.useDebugValue, u = !1, d = !1, p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : t;
    zp.useSyncExternalStore = i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : p, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), zp;
}
var yx;
function vP() {
  return yx || (yx = 1, process.env.NODE_ENV === "production" ? bc.exports = n$() : bc.exports = r$()), bc.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bx;
function i$() {
  if (bx) return Fp;
  bx = 1;
  var e = Ye, t = vP();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, l = e.useDebugValue;
  return Fp.useSyncExternalStoreWithSelector = function(c, u, d, p, h) {
    var g = o(null);
    if (g.current === null) {
      var m = { hasValue: !1, value: null };
      g.current = m;
    } else m = g.current;
    g = s(
      function() {
        function y(E) {
          if (!S) {
            if (S = !0, w = E, E = p(E), h !== void 0 && m.hasValue) {
              var C = m.value;
              if (h(C, E))
                return b = C;
            }
            return b = E;
          }
          if (C = b, r(w, E)) return C;
          var T = p(E);
          return h !== void 0 && h(C, T) ? (w = E, C) : (w = E, b = T);
        }
        var S = !1, w, b, O = d === void 0 ? null : d;
        return [
          function() {
            return y(u());
          },
          O === null ? void 0 : function() {
            return y(O());
          }
        ];
      },
      [u, d, p, h]
    );
    var v = i(c, g[0], g[1]);
    return a(
      function() {
        m.hasValue = !0, m.value = v;
      },
      [v]
    ), l(v), v;
  }, Fp;
}
var Wp = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xx;
function o$() {
  return xx || (xx = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(c, u) {
      return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = Ye, n = vP(), r = typeof Object.is == "function" ? Object.is : e, i = n.useSyncExternalStore, o = t.useRef, a = t.useEffect, s = t.useMemo, l = t.useDebugValue;
    Wp.useSyncExternalStoreWithSelector = function(c, u, d, p, h) {
      var g = o(null);
      if (g.current === null) {
        var m = { hasValue: !1, value: null };
        g.current = m;
      } else m = g.current;
      g = s(
        function() {
          function y(E) {
            if (!S) {
              if (S = !0, w = E, E = p(E), h !== void 0 && m.hasValue) {
                var C = m.value;
                if (h(C, E))
                  return b = C;
              }
              return b = E;
            }
            if (C = b, r(w, E))
              return C;
            var T = p(E);
            return h !== void 0 && h(C, T) ? (w = E, C) : (w = E, b = T);
          }
          var S = !1, w, b, O = d === void 0 ? null : d;
          return [
            function() {
              return y(u());
            },
            O === null ? void 0 : function() {
              return y(O());
            }
          ];
        },
        [u, d, p, h]
      );
      var v = i(c, g[0], g[1]);
      return a(
        function() {
          m.hasValue = !0, m.value = v;
        },
        [v]
      ), l(v), v;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), Wp;
}
var wx;
function a$() {
  return wx || (wx = 1, process.env.NODE_ENV === "production" ? yc.exports = i$() : yc.exports = o$()), yc.exports;
}
var s$ = a$(), Xg = /* @__PURE__ */ gr(null), l$ = (e) => e, Nt = () => {
  var e = Kr(Xg);
  return e ? e.store.dispatch : l$;
}, cu = () => {
}, c$ = () => cu, u$ = (e, t) => e === t;
function pe(e) {
  var t = Kr(Xg);
  return s$.useSyncExternalStoreWithSelector(t ? t.subscription.addNestedSub : c$, t ? t.store.getState : cu, t ? t.store.getState : cu, t ? e : cu, u$);
}
var d$ = (e, t, n) => {
  if (t.length === 1 && t[0] === n) {
    let r = !1;
    try {
      const i = {};
      e(i) === i && (r = !0);
    } catch {
    }
    if (r) {
      let i;
      try {
        throw new Error();
      } catch (o) {
        ({ stack: i } = o);
      }
      console.warn(
        `The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,
        { stack: i }
      );
    }
  }
}, f$ = (e, t, n) => {
  const { memoize: r, memoizeOptions: i } = t, { inputSelectorResults: o, inputSelectorResultsCopy: a } = e, s = r(() => ({}), ...i);
  if (!(s.apply(null, o) === s.apply(null, a))) {
    let c;
    try {
      throw new Error();
    } catch (u) {
      ({ stack: c } = u);
    }
    console.warn(
      `An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,
      {
        arguments: n,
        firstInputs: o,
        secondInputs: a,
        stack: c
      }
    );
  }
}, p$ = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
function h$(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function")
    throw new TypeError(t);
}
function m$(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object")
    throw new TypeError(t);
}
function g$(e, t = "expected all items to be functions, instead received the following types: ") {
  if (!e.every((n) => typeof n == "function")) {
    const n = e.map(
      (r) => typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
    ).join(", ");
    throw new TypeError(`${t}[${n}]`);
  }
}
var Ox = (e) => Array.isArray(e) ? e : [e];
function v$(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return g$(
    t,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), t;
}
function Sx(e, t) {
  const n = [], { length: r } = e;
  for (let i = 0; i < r; i++)
    n.push(e[i].apply(null, t));
  return n;
}
var y$ = (e, t) => {
  const { identityFunctionCheck: n, inputStabilityCheck: r } = {
    ...p$,
    ...t
  };
  return {
    identityFunctionCheck: {
      shouldRun: n === "always" || n === "once" && e,
      run: d$
    },
    inputStabilityCheck: {
      shouldRun: r === "always" || r === "once" && e,
      run: f$
    }
  };
}, b$ = class {
  constructor(e) {
    this.value = e;
  }
  deref() {
    return this.value;
  }
}, x$ = typeof WeakRef < "u" ? WeakRef : b$, w$ = 0, Ex = 1;
function xc() {
  return {
    s: w$,
    v: void 0,
    o: null,
    p: null
  };
}
function yP(e, t = {}) {
  let n = xc();
  const { resultEqualityCheck: r } = t;
  let i, o = 0;
  function a() {
    let s = n;
    const { length: l } = arguments;
    for (let d = 0, p = l; d < p; d++) {
      const h = arguments[d];
      if (typeof h == "function" || typeof h == "object" && h !== null) {
        let g = s.o;
        g === null && (s.o = g = /* @__PURE__ */ new WeakMap());
        const m = g.get(h);
        m === void 0 ? (s = xc(), g.set(h, s)) : s = m;
      } else {
        let g = s.p;
        g === null && (s.p = g = /* @__PURE__ */ new Map());
        const m = g.get(h);
        m === void 0 ? (s = xc(), g.set(h, s)) : s = m;
      }
    }
    const c = s;
    let u;
    if (s.s === Ex)
      u = s.v;
    else if (u = e.apply(null, arguments), o++, r) {
      const d = i?.deref?.() ?? i;
      d != null && r(d, u) && (u = d, o !== 0 && o--), i = typeof u == "object" && u !== null || typeof u == "function" ? new x$(u) : u;
    }
    return c.s = Ex, c.v = u, u;
  }
  return a.clearCache = () => {
    n = xc(), a.resetResultsCount();
  }, a.resultsCount = () => o, a.resetResultsCount = () => {
    o = 0;
  }, a;
}
function O$(e, ...t) {
  const n = typeof e == "function" ? {
    memoize: e,
    memoizeOptions: t
  } : e, r = (...i) => {
    let o = 0, a = 0, s, l = {}, c = i.pop();
    typeof c == "object" && (l = c, c = i.pop()), h$(
      c,
      `createSelector expects an output function after the inputs, but received: [${typeof c}]`
    );
    const u = {
      ...n,
      ...l
    }, {
      memoize: d,
      memoizeOptions: p = [],
      argsMemoize: h = yP,
      argsMemoizeOptions: g = [],
      devModeChecks: m = {}
    } = u, v = Ox(p), y = Ox(g), S = v$(i), w = d(function() {
      return o++, c.apply(
        null,
        arguments
      );
    }, ...v);
    let b = !0;
    const O = h(function() {
      a++;
      const C = Sx(
        S,
        arguments
      );
      if (s = w.apply(null, C), process.env.NODE_ENV !== "production") {
        const { identityFunctionCheck: T, inputStabilityCheck: j } = y$(b, m);
        if (T.shouldRun && T.run(
          c,
          C,
          s
        ), j.shouldRun) {
          const A = Sx(
            S,
            arguments
          );
          j.run(
            { inputSelectorResults: C, inputSelectorResultsCopy: A },
            { memoize: d, memoizeOptions: v },
            arguments
          );
        }
        b && (b = !1);
      }
      return s;
    }, ...y);
    return Object.assign(O, {
      resultFunc: c,
      memoizedResultFunc: w,
      dependencies: S,
      dependencyRecomputations: () => a,
      resetDependencyRecomputations: () => {
        a = 0;
      },
      lastResult: () => s,
      recomputations: () => o,
      resetRecomputations: () => {
        o = 0;
      },
      memoize: d,
      argsMemoize: h
    });
  };
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var z = /* @__PURE__ */ O$(yP), S$ = Object.assign(
  (e, t = z) => {
    m$(
      e,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
    );
    const n = Object.keys(e), r = n.map(
      (o) => e[o]
    );
    return t(
      r,
      (...o) => o.reduce((a, s, l) => (a[n[l]] = s, a), {})
    );
  },
  { withTypes: () => S$ }
), Vp = {}, Up = {}, Hp = {}, _x;
function E$() {
  return _x || (_x = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(r) {
      return typeof r == "symbol" ? 1 : r === null ? 2 : r === void 0 ? 3 : r !== r ? 4 : 0;
    }
    const n = (r, i, o) => {
      if (r !== i) {
        const a = t(r), s = t(i);
        if (a === s && a === 0) {
          if (r < i)
            return o === "desc" ? 1 : -1;
          if (r > i)
            return o === "desc" ? -1 : 1;
        }
        return o === "desc" ? s - a : a - s;
      }
      return 0;
    };
    e.compareValues = n;
  })(Hp)), Hp;
}
var qp = {}, Kp = {}, Px;
function bP() {
  return Px || (Px = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return typeof n == "symbol" || n instanceof Symbol;
    }
    e.isSymbol = t;
  })(Kp)), Kp;
}
var Cx;
function _$() {
  return Cx || (Cx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ bP(), n = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, r = /^\w*$/;
    function i(o, a) {
      return Array.isArray(o) ? !1 : typeof o == "number" || typeof o == "boolean" || o == null || t.isSymbol(o) ? !0 : typeof o == "string" && (r.test(o) || !n.test(o)) || a != null && Object.hasOwn(a, o);
    }
    e.isKey = i;
  })(qp)), qp;
}
var Tx;
function P$() {
  return Tx || (Tx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ E$(), n = /* @__PURE__ */ _$(), r = /* @__PURE__ */ Bg();
    function i(o, a, s, l) {
      if (o == null)
        return [];
      s = l ? void 0 : s, Array.isArray(o) || (o = Object.values(o)), Array.isArray(a) || (a = a == null ? [null] : [a]), a.length === 0 && (a = [null]), Array.isArray(s) || (s = s == null ? [] : [s]), s = s.map((h) => String(h));
      const c = (h, g) => {
        let m = h;
        for (let v = 0; v < g.length && m != null; ++v)
          m = m[g[v]];
        return m;
      }, u = (h, g) => g == null || h == null ? g : typeof h == "object" && "key" in h ? Object.hasOwn(g, h.key) ? g[h.key] : c(g, h.path) : typeof h == "function" ? h(g) : Array.isArray(h) ? c(g, h) : typeof g == "object" ? g[h] : g, d = a.map((h) => (Array.isArray(h) && h.length === 1 && (h = h[0]), h == null || typeof h == "function" || Array.isArray(h) || n.isKey(h) ? h : { key: h, path: r.toPath(h) }));
      return o.map((h) => ({
        original: h,
        criteria: d.map((g) => u(g, h))
      })).slice().sort((h, g) => {
        for (let m = 0; m < d.length; m++) {
          const v = t.compareValues(h.criteria[m], g.criteria[m], s[m]);
          if (v !== 0)
            return v;
        }
        return 0;
      }).map((h) => h.original);
    }
    e.orderBy = i;
  })(Up)), Up;
}
var Yp = {}, Ax;
function C$() {
  return Ax || (Ax = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r = 1) {
      const i = [], o = Math.floor(r), a = (s, l) => {
        for (let c = 0; c < s.length; c++) {
          const u = s[c];
          Array.isArray(u) && l < o ? a(u, l + 1) : i.push(u);
        }
      };
      return a(n, 0), i;
    }
    e.flatten = t;
  })(Yp)), Yp;
}
var Gp = {}, kx;
function xP() {
  return kx || (kx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ gP(), n = /* @__PURE__ */ Yg(), r = /* @__PURE__ */ uP(), i = /* @__PURE__ */ fP();
    function o(a, s, l) {
      return r.isObject(l) && (typeof s == "number" && n.isArrayLike(l) && t.isIndex(s) && s < l.length || typeof s == "string" && s in l) ? i.eq(l[s], a) : !1;
    }
    e.isIterateeCall = o;
  })(Gp)), Gp;
}
var Mx;
function T$() {
  return Mx || (Mx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ P$(), n = /* @__PURE__ */ C$(), r = /* @__PURE__ */ xP();
    function i(o, ...a) {
      const s = a.length;
      return s > 1 && r.isIterateeCall(o, a[0], a[1]) ? a = [] : s > 2 && r.isIterateeCall(a[0], a[1], a[2]) && (a = [a[0]]), t.orderBy(o, n.flatten(a), ["asc"]);
    }
    e.sortBy = i;
  })(Vp)), Vp;
}
var Xp, jx;
function A$() {
  return jx || (jx = 1, Xp = T$().sortBy), Xp;
}
var k$ = /* @__PURE__ */ A$();
const qd = /* @__PURE__ */ xi(k$);
var wP = (e) => e.legend.settings, M$ = (e) => e.legend.size, j$ = (e) => e.legend.payload;
z([j$, wP], (e, t) => {
  var {
    itemSorter: n
  } = t, r = e.flat(1);
  return n ? qd(r, n) : r;
});
var wc = 1;
function N$() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], [t, n] = Ke({
    height: 0,
    left: 0,
    top: 0,
    width: 0
  }), r = xt(
    (i) => {
      if (i != null) {
        var o = i.getBoundingClientRect(), a = {
          height: o.height,
          left: o.left,
          top: o.top,
          width: o.width
        };
        (Math.abs(a.height - t.height) > wc || Math.abs(a.left - t.left) > wc || Math.abs(a.top - t.top) > wc || Math.abs(a.width - t.width) > wc) && n({
          height: a.height,
          left: a.left,
          top: a.top,
          width: a.width
        });
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t.width, t.height, t.top, t.left, ...e]
  );
  return [t, r];
}
function Qt(e) {
  return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
var D$ = typeof Symbol == "function" && Symbol.observable || "@@observable", Nx = D$, Zp = () => Math.random().toString(36).substring(7).split("").join("."), R$ = {
  INIT: `@@redux/INIT${/* @__PURE__ */ Zp()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ Zp()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${Zp()}`
}, Ao = R$;
function $l(e) {
  if (typeof e != "object" || e === null)
    return !1;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null;
}
function I$(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  const t = typeof e;
  switch (t) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return t;
  }
  if (Array.isArray(e))
    return "array";
  if (F$(e))
    return "date";
  if (L$(e))
    return "error";
  const n = $$(e);
  switch (n) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return n;
  }
  return Object.prototype.toString.call(e).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function $$(e) {
  return typeof e.constructor == "function" ? e.constructor.name : null;
}
function L$(e) {
  return e instanceof Error || typeof e.message == "string" && e.constructor && typeof e.constructor.stackTraceLimit == "number";
}
function F$(e) {
  return e instanceof Date ? !0 : typeof e.toDateString == "function" && typeof e.getDate == "function" && typeof e.setDate == "function";
}
function Ai(e) {
  let t = typeof e;
  return process.env.NODE_ENV !== "production" && (t = I$(e)), t;
}
function OP(e, t, n) {
  if (typeof e != "function")
    throw new Error(process.env.NODE_ENV === "production" ? Qt(2) : `Expected the root reducer to be a function. Instead, received: '${Ai(e)}'`);
  if (typeof t == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? Qt(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof t == "function" && typeof n > "u" && (n = t, t = void 0), typeof n < "u") {
    if (typeof n != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Qt(1) : `Expected the enhancer to be a function. Instead, received: '${Ai(n)}'`);
    return n(OP)(e, t);
  }
  let r = e, i = t, o = /* @__PURE__ */ new Map(), a = o, s = 0, l = !1;
  function c() {
    a === o && (a = /* @__PURE__ */ new Map(), o.forEach((v, y) => {
      a.set(y, v);
    }));
  }
  function u() {
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Qt(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return i;
  }
  function d(v) {
    if (typeof v != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Qt(4) : `Expected the listener to be a function. Instead, received: '${Ai(v)}'`);
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Qt(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    let y = !0;
    c();
    const S = s++;
    return a.set(S, v), function() {
      if (y) {
        if (l)
          throw new Error(process.env.NODE_ENV === "production" ? Qt(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        y = !1, c(), a.delete(S), o = null;
      }
    };
  }
  function p(v) {
    if (!$l(v))
      throw new Error(process.env.NODE_ENV === "production" ? Qt(7) : `Actions must be plain objects. Instead, the actual type was: '${Ai(v)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    if (typeof v.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Qt(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (typeof v.type != "string")
      throw new Error(process.env.NODE_ENV === "production" ? Qt(17) : `Action "type" property must be a string. Instead, the actual type was: '${Ai(v.type)}'. Value was: '${v.type}' (stringified)`);
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Qt(9) : "Reducers may not dispatch actions.");
    try {
      l = !0, i = r(i, v);
    } finally {
      l = !1;
    }
    return (o = a).forEach((S) => {
      S();
    }), v;
  }
  function h(v) {
    if (typeof v != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Qt(10) : `Expected the nextReducer to be a function. Instead, received: '${Ai(v)}`);
    r = v, p({
      type: Ao.REPLACE
    });
  }
  function g() {
    const v = d;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(y) {
        if (typeof y != "object" || y === null)
          throw new Error(process.env.NODE_ENV === "production" ? Qt(11) : `Expected the observer to be an object. Instead, received: '${Ai(y)}'`);
        function S() {
          const b = y;
          b.next && b.next(u());
        }
        return S(), {
          unsubscribe: v(S)
        };
      },
      [Nx]() {
        return this;
      }
    };
  }
  return p({
    type: Ao.INIT
  }), {
    dispatch: p,
    subscribe: d,
    getState: u,
    replaceReducer: h,
    [Nx]: g
  };
}
function Dx(e) {
  typeof console < "u" && typeof console.error == "function" && console.error(e);
  try {
    throw new Error(e);
  } catch {
  }
}
function B$(e, t, n, r) {
  const i = Object.keys(t), o = n && n.type === Ao.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (i.length === 0)
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  if (!$l(e))
    return `The ${o} has unexpected type of "${Ai(e)}". Expected argument to be an object with the following keys: "${i.join('", "')}"`;
  const a = Object.keys(e).filter((s) => !t.hasOwnProperty(s) && !r[s]);
  if (a.forEach((s) => {
    r[s] = !0;
  }), !(n && n.type === Ao.REPLACE) && a.length > 0)
    return `Unexpected ${a.length > 1 ? "keys" : "key"} "${a.join('", "')}" found in ${o}. Expected to find one of the known reducer keys instead: "${i.join('", "')}". Unexpected keys will be ignored.`;
}
function z$(e) {
  Object.keys(e).forEach((t) => {
    const n = e[t];
    if (typeof n(void 0, {
      type: Ao.INIT
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Qt(12) : `The slice reducer for key "${t}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    if (typeof n(void 0, {
      type: Ao.PROBE_UNKNOWN_ACTION()
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Qt(13) : `The slice reducer for key "${t}" returned undefined when probed with a random type. Don't try to handle '${Ao.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
  });
}
function SP(e) {
  const t = Object.keys(e), n = {};
  for (let a = 0; a < t.length; a++) {
    const s = t[a];
    process.env.NODE_ENV !== "production" && typeof e[s] > "u" && Dx(`No reducer provided for key "${s}"`), typeof e[s] == "function" && (n[s] = e[s]);
  }
  const r = Object.keys(n);
  let i;
  process.env.NODE_ENV !== "production" && (i = {});
  let o;
  try {
    z$(n);
  } catch (a) {
    o = a;
  }
  return function(s = {}, l) {
    if (o)
      throw o;
    if (process.env.NODE_ENV !== "production") {
      const d = B$(s, n, l, i);
      d && Dx(d);
    }
    let c = !1;
    const u = {};
    for (let d = 0; d < r.length; d++) {
      const p = r[d], h = n[p], g = s[p], m = h(g, l);
      if (typeof m > "u") {
        const v = l && l.type;
        throw new Error(process.env.NODE_ENV === "production" ? Qt(14) : `When called with an action of type ${v ? `"${String(v)}"` : "(unknown type)"}, the slice reducer for key "${p}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      u[p] = m, c = c || m !== g;
    }
    return c = c || r.length !== Object.keys(s).length, c ? u : s;
  };
}
function Au(...e) {
  return e.length === 0 ? (t) => t : e.length === 1 ? e[0] : e.reduce((t, n) => (...r) => t(n(...r)));
}
function W$(...e) {
  return (t) => (n, r) => {
    const i = t(n, r);
    let o = () => {
      throw new Error(process.env.NODE_ENV === "production" ? Qt(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const a = {
      getState: i.getState,
      dispatch: (l, ...c) => o(l, ...c)
    }, s = e.map((l) => l(a));
    return o = Au(...s)(i.dispatch), {
      ...i,
      dispatch: o
    };
  };
}
function Zg(e) {
  return $l(e) && "type" in e && typeof e.type == "string";
}
var EP = Symbol.for("immer-nothing"), Rx = Symbol.for("immer-draftable"), Kn = Symbol.for("immer-state"), V$ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Pn(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = V$[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Aa = Object.getPrototypeOf;
function $o(e) {
  return !!e && !!e[Kn];
}
function hi(e) {
  return e ? _P(e) || Array.isArray(e) || !!e[Rx] || !!e.constructor?.[Rx] || Ll(e) || Yd(e) : !1;
}
var U$ = Object.prototype.constructor.toString();
function _P(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Aa(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === U$;
}
function ku(e, t) {
  Kd(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Kd(e) {
  const t = e[Kn];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ll(e) ? 2 : Yd(e) ? 3 : 0;
}
function mm(e, t) {
  return Kd(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function PP(e, t, n) {
  const r = Kd(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function H$(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ll(e) {
  return e instanceof Map;
}
function Yd(e) {
  return e instanceof Set;
}
function mo(e) {
  return e.copy_ || e.base_;
}
function gm(e, t) {
  if (Ll(e))
    return new Map(e);
  if (Yd(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = _P(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Kn];
    let i = Reflect.ownKeys(r);
    for (let o = 0; o < i.length; o++) {
      const a = i[o], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Aa(e), r);
  } else {
    const r = Aa(e);
    if (r !== null && n)
      return { ...e };
    const i = Object.create(r);
    return Object.assign(i, e);
  }
}
function Jg(e, t = !1) {
  return Gd(e) || $o(e) || !hi(e) || (Kd(e) > 1 && Object.defineProperties(e, {
    set: { value: Oc },
    add: { value: Oc },
    clear: { value: Oc },
    delete: { value: Oc }
  }), Object.freeze(e), t && Object.values(e).forEach((n) => Jg(n, !0))), e;
}
function Oc() {
  Pn(2);
}
function Gd(e) {
  return Object.isFrozen(e);
}
var q$ = {};
function Lo(e) {
  const t = q$[e];
  return t || Pn(0, e), t;
}
var il;
function CP() {
  return il;
}
function K$(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Ix(e, t) {
  t && (Lo("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function vm(e) {
  ym(e), e.drafts_.forEach(Y$), e.drafts_ = null;
}
function ym(e) {
  e === il && (il = e.parent_);
}
function $x(e) {
  return il = K$(il, e);
}
function Y$(e) {
  const t = e[Kn];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Lx(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Kn].modified_ && (vm(t), Pn(4)), hi(e) && (e = Mu(t, e), t.parent_ || ju(t, e)), t.patches_ && Lo("Patches").generateReplacementPatches_(
    n[Kn].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Mu(t, n, []), vm(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== EP ? e : void 0;
}
function Mu(e, t, n) {
  if (Gd(t))
    return t;
  const r = t[Kn];
  if (!r)
    return ku(
      t,
      (i, o) => Fx(e, r, t, i, o, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return ju(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let o = i, a = !1;
    r.type_ === 3 && (o = new Set(i), i.clear(), a = !0), ku(
      o,
      (s, l) => Fx(e, r, i, s, l, n, a)
    ), ju(e, i, !1), n && e.patches_ && Lo("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Fx(e, t, n, r, i, o, a) {
  if (process.env.NODE_ENV !== "production" && i === n && Pn(5), $o(i)) {
    const s = o && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !mm(t.assigned_, r) ? o.concat(r) : void 0, l = Mu(e, i, s);
    if (PP(n, r, l), $o(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(i);
  if (hi(i) && !Gd(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Mu(e, i), (!t || !t.scope_.parent_) && typeof r != "symbol" && (Ll(n) ? n.has(r) : Object.prototype.propertyIsEnumerable.call(n, r)) && ju(e, i);
  }
}
function ju(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Jg(t, n);
}
function G$(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : CP(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = r, o = Qg;
  n && (i = [r], o = ol);
  const { revoke: a, proxy: s } = Proxy.revocable(i, o);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Qg = {
  get(e, t) {
    if (t === Kn)
      return e;
    const n = mo(e);
    if (!mm(n, t))
      return X$(e, n, t);
    const r = n[t];
    return e.finalized_ || !hi(r) ? r : r === Jp(e.base_, t) ? (Qp(e), e.copy_[t] = xm(r, e)) : r;
  },
  has(e, t) {
    return t in mo(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(mo(e));
  },
  set(e, t, n) {
    const r = TP(mo(e), t);
    if (r?.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const i = Jp(mo(e), t), o = i?.[Kn];
      if (o && o.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (H$(n, i) && (n !== void 0 || mm(e.base_, t)))
        return !0;
      Qp(e), bm(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Jp(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Qp(e), bm(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = mo(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Pn(11);
  },
  getPrototypeOf(e) {
    return Aa(e.base_);
  },
  setPrototypeOf() {
    Pn(12);
  }
}, ol = {};
ku(Qg, (e, t) => {
  ol[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ol.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Pn(13), ol.set.call(this, e, t, void 0);
};
ol.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Pn(14), Qg.set.call(this, e[0], t, n, e[0]);
};
function Jp(e, t) {
  const n = e[Kn];
  return (n ? mo(n) : e)[t];
}
function X$(e, t, n) {
  const r = TP(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    r.get?.call(e.draft_)
  ) : void 0;
}
function TP(e, t) {
  if (!(t in e))
    return;
  let n = Aa(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Aa(n);
  }
}
function bm(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && bm(e.parent_));
}
function Qp(e) {
  e.copy_ || (e.copy_ = gm(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Z$ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const o = n;
        n = t;
        const a = this;
        return function(l = o, ...c) {
          return a.produce(l, (u) => n.call(this, u, ...c));
        };
      }
      typeof n != "function" && Pn(6), r !== void 0 && typeof r != "function" && Pn(7);
      let i;
      if (hi(t)) {
        const o = $x(this), a = xm(t, void 0);
        let s = !0;
        try {
          i = n(a), s = !1;
        } finally {
          s ? vm(o) : ym(o);
        }
        return Ix(o, r), Lx(i, o);
      } else if (!t || typeof t != "object") {
        if (i = n(t), i === void 0 && (i = t), i === EP && (i = void 0), this.autoFreeze_ && Jg(i, !0), r) {
          const o = [], a = [];
          Lo("Patches").generateReplacementPatches_(t, i, o, a), r(o, a);
        }
        return i;
      } else
        Pn(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, i;
      return [this.produce(t, n, (a, s) => {
        r = a, i = s;
      }), r, i];
    }, typeof e?.autoFreeze == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof e?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    hi(e) || Pn(8), $o(e) && (e = ui(e));
    const t = $x(this), n = xm(e, void 0);
    return n[Kn].isManual_ = !0, ym(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Kn];
    (!n || !n.isManual_) && Pn(9);
    const { scope_: r } = n;
    return Ix(r, t), Lx(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const i = t[n];
      if (i.path.length === 0 && i.op === "replace") {
        e = i.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Lo("Patches").applyPatches_;
    return $o(e) ? r(e, t) : this.produce(
      e,
      (i) => r(i, t)
    );
  }
};
function xm(e, t) {
  const n = Ll(e) ? Lo("MapSet").proxyMap_(e, t) : Yd(e) ? Lo("MapSet").proxySet_(e, t) : G$(e, t);
  return (t ? t.scope_ : CP()).drafts_.push(n), n;
}
function ui(e) {
  return $o(e) || Pn(10, e), AP(e);
}
function AP(e) {
  if (!hi(e) || Gd(e))
    return e;
  const t = e[Kn];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = gm(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = gm(e, !0);
  return ku(n, (r, i) => {
    PP(n, r, AP(i));
  }), t && (t.finalized_ = !1), n;
}
var J$ = new Z$(), kP = J$.produce;
function MP(e) {
  return ({ dispatch: n, getState: r }) => (i) => (o) => typeof o == "function" ? o(n, r, e) : i(o);
}
var Q$ = MP(), e5 = MP, t5 = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length !== 0)
    return typeof arguments[0] == "object" ? Au : Au.apply(null, arguments);
}, n5 = (e) => e && typeof e.match == "function";
function dr(e, t) {
  function n(...r) {
    if (t) {
      let i = t(...r);
      if (!i)
        throw new Error(process.env.NODE_ENV === "production" ? je(0) : "prepareAction did not return an object");
      return {
        type: e,
        payload: i.payload,
        ..."meta" in i && {
          meta: i.meta
        },
        ..."error" in i && {
          error: i.error
        }
      };
    }
    return {
      type: e,
      payload: r[0]
    };
  }
  return n.toString = () => `${e}`, n.type = e, n.match = (r) => Zg(r) && r.type === e, n;
}
function r5(e) {
  return typeof e == "function" && "type" in e && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  n5(e);
}
function i5(e) {
  const t = e ? `${e}`.split("/") : [], n = t[t.length - 1] || "actionCreator";
  return `Detected an action creator with type "${e || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${n}())\` instead of \`dispatch(${n})\`. This is necessary even if the action has no payload.`;
}
function o5(e = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (n) => (r) => n(r);
  const {
    isActionCreator: t = r5
  } = e;
  return () => (n) => (r) => (t(r) && console.warn(i5(r.type)), n(r));
}
function jP(e, t) {
  let n = 0;
  return {
    measureTime(r) {
      const i = Date.now();
      try {
        return r();
      } finally {
        const o = Date.now();
        n += o - i;
      }
    },
    warnIfExceeded() {
      n > e && console.warn(`${t} took ${n}ms, which is more than the warning threshold of ${e}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
    }
  };
}
var NP = class js extends Array {
  constructor(...t) {
    super(...t), Object.setPrototypeOf(this, js.prototype);
  }
  static get [Symbol.species]() {
    return js;
  }
  concat(...t) {
    return super.concat.apply(this, t);
  }
  prepend(...t) {
    return t.length === 1 && Array.isArray(t[0]) ? new js(...t[0].concat(this)) : new js(...t.concat(this));
  }
};
function Bx(e) {
  return hi(e) ? kP(e, () => {
  }) : e;
}
function Sc(e, t, n) {
  return e.has(t) ? e.get(t) : e.set(t, n(t)).get(t);
}
function a5(e) {
  return typeof e != "object" || e == null || Object.isFrozen(e);
}
function s5(e, t, n) {
  const r = DP(e, t, n);
  return {
    detectMutations() {
      return RP(e, t, r, n);
    }
  };
}
function DP(e, t = [], n, r = "", i = /* @__PURE__ */ new Set()) {
  const o = {
    value: n
  };
  if (!e(n) && !i.has(n)) {
    i.add(n), o.children = {};
    for (const a in n) {
      const s = r ? r + "." + a : a;
      t.length && t.indexOf(s) !== -1 || (o.children[a] = DP(e, t, n[a], s));
    }
  }
  return o;
}
function RP(e, t = [], n, r, i = !1, o = "") {
  const a = n ? n.value : void 0, s = a === r;
  if (i && !s && !Number.isNaN(r))
    return {
      wasMutated: !0,
      path: o
    };
  if (e(a) || e(r))
    return {
      wasMutated: !1
    };
  const l = {};
  for (let u in n.children)
    l[u] = !0;
  for (let u in r)
    l[u] = !0;
  const c = t.length > 0;
  for (let u in l) {
    const d = o ? o + "." + u : u;
    if (c && t.some((g) => g instanceof RegExp ? g.test(d) : d === g))
      continue;
    const p = RP(e, t, n.children[u], r[u], s, d);
    if (p.wasMutated)
      return p;
  }
  return {
    wasMutated: !1
  };
}
function l5(e = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (t) => (n) => t(n);
  {
    let t = function(s, l, c, u) {
      return JSON.stringify(s, n(l, u), c);
    }, n = function(s, l) {
      let c = [], u = [];
      return l || (l = function(d, p) {
        return c[0] === p ? "[Circular ~]" : "[Circular ~." + u.slice(0, c.indexOf(p)).join(".") + "]";
      }), function(d, p) {
        if (c.length > 0) {
          var h = c.indexOf(this);
          ~h ? c.splice(h + 1) : c.push(this), ~h ? u.splice(h, 1 / 0, d) : u.push(d), ~c.indexOf(p) && (p = l.call(this, d, p));
        } else c.push(p);
        return s == null ? p : s.call(this, d, p);
      };
    }, {
      isImmutable: r = a5,
      ignoredPaths: i,
      warnAfter: o = 32
    } = e;
    const a = s5.bind(null, r, i);
    return ({
      getState: s
    }) => {
      let l = s(), c = a(l), u;
      return (d) => (p) => {
        const h = jP(o, "ImmutableStateInvariantMiddleware");
        h.measureTime(() => {
          if (l = s(), u = c.detectMutations(), c = a(l), u.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? je(19) : `A state mutation was detected between dispatches, in the path '${u.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        });
        const g = d(p);
        return h.measureTime(() => {
          if (l = s(), u = c.detectMutations(), c = a(l), u.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? je(20) : `A state mutation was detected inside a dispatch, in the path: ${u.path || ""}. Take a look at the reducer(s) handling the action ${t(p)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        }), h.warnIfExceeded(), g;
      };
    };
  }
}
function IP(e) {
  const t = typeof e;
  return e == null || t === "string" || t === "boolean" || t === "number" || Array.isArray(e) || $l(e);
}
function wm(e, t = "", n = IP, r, i = [], o) {
  let a;
  if (!n(e))
    return {
      keyPath: t || "<root>",
      value: e
    };
  if (typeof e != "object" || e === null || o?.has(e)) return !1;
  const s = r != null ? r(e) : Object.entries(e), l = i.length > 0;
  for (const [c, u] of s) {
    const d = t ? t + "." + c : c;
    if (!(l && i.some((h) => h instanceof RegExp ? h.test(d) : d === h))) {
      if (!n(u))
        return {
          keyPath: d,
          value: u
        };
      if (typeof u == "object" && (a = wm(u, d, n, r, i, o), a))
        return a;
    }
  }
  return o && $P(e) && o.add(e), !1;
}
function $P(e) {
  if (!Object.isFrozen(e)) return !1;
  for (const t of Object.values(e))
    if (!(typeof t != "object" || t === null) && !$P(t))
      return !1;
  return !0;
}
function c5(e = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (t) => (n) => t(n);
  {
    const {
      isSerializable: t = IP,
      getEntries: n,
      ignoredActions: r = [],
      ignoredActionPaths: i = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths: o = [],
      warnAfter: a = 32,
      ignoreState: s = !1,
      ignoreActions: l = !1,
      disableCache: c = !1
    } = e, u = !c && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (d) => (p) => (h) => {
      if (!Zg(h))
        return p(h);
      const g = p(h), m = jP(a, "SerializableStateInvariantMiddleware");
      return !l && !(r.length && r.indexOf(h.type) !== -1) && m.measureTime(() => {
        const v = wm(h, "", t, n, i, u);
        if (v) {
          const {
            keyPath: y,
            value: S
          } = v;
          console.error(`A non-serializable value was detected in an action, in the path: \`${y}\`. Value:`, S, `
Take a look at the logic that dispatched this action: `, h, `
(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)`, `
(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)`);
        }
      }), s || (m.measureTime(() => {
        const v = d.getState(), y = wm(v, "", t, n, o, u);
        if (y) {
          const {
            keyPath: S,
            value: w
          } = y;
          console.error(`A non-serializable value was detected in the state, in the path: \`${S}\`. Value:`, w, `
Take a look at the reducer(s) handling this action type: ${h.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
        }
      }), m.warnIfExceeded()), g;
    };
  }
}
function Ec(e) {
  return typeof e == "boolean";
}
var u5 = () => function(t) {
  const {
    thunk: n = !0,
    immutableCheck: r = !0,
    serializableCheck: i = !0,
    actionCreatorCheck: o = !0
  } = t ?? {};
  let a = new NP();
  if (n && (Ec(n) ? a.push(Q$) : a.push(e5(n.extraArgument))), process.env.NODE_ENV !== "production") {
    if (r) {
      let s = {};
      Ec(r) || (s = r), a.unshift(l5(s));
    }
    if (i) {
      let s = {};
      Ec(i) || (s = i), a.push(c5(s));
    }
    if (o) {
      let s = {};
      Ec(o) || (s = o), a.unshift(o5(s));
    }
  }
  return a;
}, d5 = "RTK_autoBatch", zx = (e) => (t) => {
  setTimeout(t, e);
}, f5 = (e = {
  type: "raf"
}) => (t) => (...n) => {
  const r = t(...n);
  let i = !0, o = !1, a = !1;
  const s = /* @__PURE__ */ new Set(), l = e.type === "tick" ? queueMicrotask : e.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame : zx(10)
  ) : e.type === "callback" ? e.queueNotification : zx(e.timeout), c = () => {
    a = !1, o && (o = !1, s.forEach((u) => u()));
  };
  return Object.assign({}, r, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(u) {
      const d = () => i && u(), p = r.subscribe(d);
      return s.add(u), () => {
        p(), s.delete(u);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(u) {
      try {
        return i = !u?.meta?.[d5], o = !i, o && (a || (a = !0, l(c))), r.dispatch(u);
      } finally {
        i = !0;
      }
    }
  });
}, p5 = (e) => function(n) {
  const {
    autoBatch: r = !0
  } = n ?? {};
  let i = new NP(e);
  return r && i.push(f5(typeof r == "object" ? r : void 0)), i;
};
function h5(e) {
  const t = u5(), {
    reducer: n = void 0,
    middleware: r,
    devTools: i = !0,
    duplicateMiddlewareCheck: o = !0,
    preloadedState: a = void 0,
    enhancers: s = void 0
  } = e || {};
  let l;
  if (typeof n == "function")
    l = n;
  else if ($l(n))
    l = SP(n);
  else
    throw new Error(process.env.NODE_ENV === "production" ? je(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  if (process.env.NODE_ENV !== "production" && r && typeof r != "function")
    throw new Error(process.env.NODE_ENV === "production" ? je(2) : "`middleware` field must be a callback");
  let c;
  if (typeof r == "function") {
    if (c = r(t), process.env.NODE_ENV !== "production" && !Array.isArray(c))
      throw new Error(process.env.NODE_ENV === "production" ? je(3) : "when using a middleware builder function, an array of middleware must be returned");
  } else
    c = t();
  if (process.env.NODE_ENV !== "production" && c.some((m) => typeof m != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? je(4) : "each middleware provided to configureStore must be a function");
  if (process.env.NODE_ENV !== "production" && o) {
    let m = /* @__PURE__ */ new Set();
    c.forEach((v) => {
      if (m.has(v))
        throw new Error(process.env.NODE_ENV === "production" ? je(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
      m.add(v);
    });
  }
  let u = Au;
  i && (u = t5({
    // Enable capture of stack traces for dispatched Redux actions
    trace: process.env.NODE_ENV !== "production",
    ...typeof i == "object" && i
  }));
  const d = W$(...c), p = p5(d);
  if (process.env.NODE_ENV !== "production" && s && typeof s != "function")
    throw new Error(process.env.NODE_ENV === "production" ? je(5) : "`enhancers` field must be a callback");
  let h = typeof s == "function" ? s(p) : p();
  if (process.env.NODE_ENV !== "production" && !Array.isArray(h))
    throw new Error(process.env.NODE_ENV === "production" ? je(6) : "`enhancers` callback must return an array");
  if (process.env.NODE_ENV !== "production" && h.some((m) => typeof m != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? je(7) : "each enhancer provided to configureStore must be a function");
  process.env.NODE_ENV !== "production" && c.length && !h.includes(d) && console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  const g = u(...h);
  return OP(l, a, g);
}
function LP(e) {
  const t = {}, n = [];
  let r;
  const i = {
    addCase(o, a) {
      if (process.env.NODE_ENV !== "production") {
        if (n.length > 0)
          throw new Error(process.env.NODE_ENV === "production" ? je(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        if (r)
          throw new Error(process.env.NODE_ENV === "production" ? je(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
      }
      const s = typeof o == "string" ? o : o.type;
      if (!s)
        throw new Error(process.env.NODE_ENV === "production" ? je(28) : "`builder.addCase` cannot be called with an empty action type");
      if (s in t)
        throw new Error(process.env.NODE_ENV === "production" ? je(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${s}'`);
      return t[s] = a, i;
    },
    addAsyncThunk(o, a) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? je(43) : "`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`");
      return a.pending && (t[o.pending.type] = a.pending), a.rejected && (t[o.rejected.type] = a.rejected), a.fulfilled && (t[o.fulfilled.type] = a.fulfilled), a.settled && n.push({
        matcher: o.settled,
        reducer: a.settled
      }), i;
    },
    addMatcher(o, a) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? je(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
      return n.push({
        matcher: o,
        reducer: a
      }), i;
    },
    addDefaultCase(o) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? je(31) : "`builder.addDefaultCase` can only be called once");
      return r = o, i;
    }
  };
  return e(i), [t, n, r];
}
function m5(e) {
  return typeof e == "function";
}
function g5(e, t) {
  if (process.env.NODE_ENV !== "production" && typeof t == "object")
    throw new Error(process.env.NODE_ENV === "production" ? je(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
  let [n, r, i] = LP(t), o;
  if (m5(e))
    o = () => Bx(e());
  else {
    const s = Bx(e);
    o = () => s;
  }
  function a(s = o(), l) {
    let c = [n[l.type], ...r.filter(({
      matcher: u
    }) => u(l)).map(({
      reducer: u
    }) => u)];
    return c.filter((u) => !!u).length === 0 && (c = [i]), c.reduce((u, d) => {
      if (d)
        if ($o(u)) {
          const h = d(u, l);
          return h === void 0 ? u : h;
        } else {
          if (hi(u))
            return kP(u, (p) => d(p, l));
          {
            const p = d(u, l);
            if (p === void 0) {
              if (u === null)
                return u;
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return p;
          }
        }
      return u;
    }, s);
  }
  return a.getInitialState = o, a;
}
var v5 = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", y5 = (e = 21) => {
  let t = "", n = e;
  for (; n--; )
    t += v5[Math.random() * 64 | 0];
  return t;
}, b5 = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function x5(e, t) {
  return `${e}/${t}`;
}
function w5({
  creators: e
} = {}) {
  const t = e?.asyncThunk?.[b5];
  return function(r) {
    const {
      name: i,
      reducerPath: o = i
    } = r;
    if (!i)
      throw new Error(process.env.NODE_ENV === "production" ? je(11) : "`name` is a required option for createSlice");
    typeof process < "u" && process.env.NODE_ENV === "development" && r.initialState === void 0 && console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    const a = (typeof r.reducers == "function" ? r.reducers(S5()) : r.reducers) || {}, s = Object.keys(a), l = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    }, c = {
      addCase(w, b) {
        const O = typeof w == "string" ? w : w.type;
        if (!O)
          throw new Error(process.env.NODE_ENV === "production" ? je(12) : "`context.addCase` cannot be called with an empty action type");
        if (O in l.sliceCaseReducersByType)
          throw new Error(process.env.NODE_ENV === "production" ? je(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + O);
        return l.sliceCaseReducersByType[O] = b, c;
      },
      addMatcher(w, b) {
        return l.sliceMatchers.push({
          matcher: w,
          reducer: b
        }), c;
      },
      exposeAction(w, b) {
        return l.actionCreators[w] = b, c;
      },
      exposeCaseReducer(w, b) {
        return l.sliceCaseReducersByName[w] = b, c;
      }
    };
    s.forEach((w) => {
      const b = a[w], O = {
        reducerName: w,
        type: x5(i, w),
        createNotation: typeof r.reducers == "function"
      };
      _5(b) ? C5(O, b, c, t) : E5(O, b, c);
    });
    function u() {
      if (process.env.NODE_ENV !== "production" && typeof r.extraReducers == "object")
        throw new Error(process.env.NODE_ENV === "production" ? je(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
      const [w = {}, b = [], O = void 0] = typeof r.extraReducers == "function" ? LP(r.extraReducers) : [r.extraReducers], E = {
        ...w,
        ...l.sliceCaseReducersByType
      };
      return g5(r.initialState, (C) => {
        for (let T in E)
          C.addCase(T, E[T]);
        for (let T of l.sliceMatchers)
          C.addMatcher(T.matcher, T.reducer);
        for (let T of b)
          C.addMatcher(T.matcher, T.reducer);
        O && C.addDefaultCase(O);
      });
    }
    const d = (w) => w, p = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new WeakMap();
    let g;
    function m(w, b) {
      return g || (g = u()), g(w, b);
    }
    function v() {
      return g || (g = u()), g.getInitialState();
    }
    function y(w, b = !1) {
      function O(C) {
        let T = C[w];
        if (typeof T > "u") {
          if (b)
            T = Sc(h, O, v);
          else if (process.env.NODE_ENV !== "production")
            throw new Error(process.env.NODE_ENV === "production" ? je(15) : "selectSlice returned undefined for an uninjected slice reducer");
        }
        return T;
      }
      function E(C = d) {
        const T = Sc(p, b, () => /* @__PURE__ */ new WeakMap());
        return Sc(T, C, () => {
          const j = {};
          for (const [A, M] of Object.entries(r.selectors ?? {}))
            j[A] = O5(M, C, () => Sc(h, C, v), b);
          return j;
        });
      }
      return {
        reducerPath: w,
        getSelectors: E,
        get selectors() {
          return E(O);
        },
        selectSlice: O
      };
    }
    const S = {
      name: i,
      reducer: m,
      actions: l.actionCreators,
      caseReducers: l.sliceCaseReducersByName,
      getInitialState: v,
      ...y(o),
      injectInto(w, {
        reducerPath: b,
        ...O
      } = {}) {
        const E = b ?? o;
        return w.inject({
          reducerPath: E,
          reducer: m
        }, O), {
          ...S,
          ...y(E, !0)
        };
      }
    };
    return S;
  };
}
function O5(e, t, n, r) {
  function i(o, ...a) {
    let s = t(o);
    if (typeof s > "u") {
      if (r)
        s = n();
      else if (process.env.NODE_ENV !== "production")
        throw new Error(process.env.NODE_ENV === "production" ? je(16) : "selectState returned undefined for an uninjected slice reducer");
    }
    return e(s, ...a);
  }
  return i.unwrapped = e, i;
}
var Zn = /* @__PURE__ */ w5();
function S5() {
  function e(t, n) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator: t,
      ...n
    };
  }
  return e.withTypes = () => e, {
    reducer(t) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [t.name](...n) {
          return t(...n);
        }
      }[t.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(t, n) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare: t,
        reducer: n
      };
    },
    asyncThunk: e
  };
}
function E5({
  type: e,
  reducerName: t,
  createNotation: n
}, r, i) {
  let o, a;
  if ("reducer" in r) {
    if (n && !P5(r))
      throw new Error(process.env.NODE_ENV === "production" ? je(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    o = r.reducer, a = r.prepare;
  } else
    o = r;
  i.addCase(e, o).exposeCaseReducer(t, o).exposeAction(t, a ? dr(e, a) : dr(e));
}
function _5(e) {
  return e._reducerDefinitionType === "asyncThunk";
}
function P5(e) {
  return e._reducerDefinitionType === "reducerWithPrepare";
}
function C5({
  type: e,
  reducerName: t
}, n, r, i) {
  if (!i)
    throw new Error(process.env.NODE_ENV === "production" ? je(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  const {
    payloadCreator: o,
    fulfilled: a,
    pending: s,
    rejected: l,
    settled: c,
    options: u
  } = n, d = i(e, o, u);
  r.exposeAction(t, d), a && r.addCase(d.fulfilled, a), s && r.addCase(d.pending, s), l && r.addCase(d.rejected, l), c && r.addMatcher(d.settled, c), r.exposeCaseReducer(t, {
    fulfilled: a || _c,
    pending: s || _c,
    rejected: l || _c,
    settled: c || _c
  });
}
function _c() {
}
var T5 = "task", FP = "listener", BP = "completed", ev = "cancelled", A5 = `task-${ev}`, k5 = `task-${BP}`, Om = `${FP}-${ev}`, M5 = `${FP}-${BP}`, Xd = class {
  constructor(e) {
    this.code = e, this.message = `${T5} ${ev} (reason: ${e})`;
  }
  name = "TaskAbortError";
  message;
}, tv = (e, t) => {
  if (typeof e != "function")
    throw new TypeError(process.env.NODE_ENV === "production" ? je(32) : `${t} is not a function`);
}, Nu = () => {
}, zP = (e, t = Nu) => (e.catch(t), e), WP = (e, t) => (e.addEventListener("abort", t, {
  once: !0
}), () => e.removeEventListener("abort", t)), ko = (e, t) => {
  const n = e.signal;
  n.aborted || ("reason" in n || Object.defineProperty(n, "reason", {
    enumerable: !0,
    value: t,
    configurable: !0,
    writable: !0
  }), e.abort(t));
}, Mo = (e) => {
  if (e.aborted) {
    const {
      reason: t
    } = e;
    throw new Xd(t);
  }
};
function VP(e, t) {
  let n = Nu;
  return new Promise((r, i) => {
    const o = () => i(new Xd(e.reason));
    if (e.aborted) {
      o();
      return;
    }
    n = WP(e, o), t.finally(() => n()).then(r, i);
  }).finally(() => {
    n = Nu;
  });
}
var j5 = async (e, t) => {
  try {
    return await Promise.resolve(), {
      status: "ok",
      value: await e()
    };
  } catch (n) {
    return {
      status: n instanceof Xd ? "cancelled" : "rejected",
      error: n
    };
  } finally {
    t?.();
  }
}, Du = (e) => (t) => zP(VP(e, t).then((n) => (Mo(e), n))), UP = (e) => {
  const t = Du(e);
  return (n) => t(new Promise((r) => setTimeout(r, n)));
}, {
  assign: wa
} = Object, Wx = {}, Fl = "listenerMiddleware", N5 = (e, t) => {
  const n = (r) => WP(e, () => ko(r, e.reason));
  return (r, i) => {
    tv(r, "taskExecutor");
    const o = new AbortController();
    n(o);
    const a = j5(async () => {
      Mo(e), Mo(o.signal);
      const s = await r({
        pause: Du(o.signal),
        delay: UP(o.signal),
        signal: o.signal
      });
      return Mo(o.signal), s;
    }, () => ko(o, k5));
    return i?.autoJoin && t.push(a.catch(Nu)), {
      result: Du(e)(a),
      cancel() {
        ko(o, A5);
      }
    };
  };
}, D5 = (e, t) => {
  const n = async (r, i) => {
    Mo(t);
    let o = () => {
    };
    const s = [new Promise((l, c) => {
      let u = e({
        predicate: r,
        effect: (d, p) => {
          p.unsubscribe(), l([d, p.getState(), p.getOriginalState()]);
        }
      });
      o = () => {
        u(), c();
      };
    })];
    i != null && s.push(new Promise((l) => setTimeout(l, i, null)));
    try {
      const l = await VP(t, Promise.race(s));
      return Mo(t), l;
    } finally {
      o();
    }
  };
  return (r, i) => zP(n(r, i));
}, HP = (e) => {
  let {
    type: t,
    actionCreator: n,
    matcher: r,
    predicate: i,
    effect: o
  } = e;
  if (t)
    i = dr(t).match;
  else if (n)
    t = n.type, i = n.match;
  else if (r)
    i = r;
  else if (!i) throw new Error(process.env.NODE_ENV === "production" ? je(21) : "Creating or removing a listener requires one of the known fields for matching an action");
  return tv(o, "options.listener"), {
    predicate: i,
    type: t,
    effect: o
  };
}, qP = /* @__PURE__ */ wa((e) => {
  const {
    type: t,
    predicate: n,
    effect: r
  } = HP(e);
  return {
    id: y5(),
    effect: r,
    type: t,
    predicate: n,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(process.env.NODE_ENV === "production" ? je(22) : "Unsubscribe not initialized");
    }
  };
}, {
  withTypes: () => qP
}), Vx = (e, t) => {
  const {
    type: n,
    effect: r,
    predicate: i
  } = HP(t);
  return Array.from(e.values()).find((o) => (typeof n == "string" ? o.type === n : o.predicate === i) && o.effect === r);
}, Sm = (e) => {
  e.pending.forEach((t) => {
    ko(t, Om);
  });
}, R5 = (e) => () => {
  e.forEach(Sm), e.clear();
}, Ux = (e, t, n) => {
  try {
    e(t, n);
  } catch (r) {
    setTimeout(() => {
      throw r;
    }, 0);
  }
}, KP = /* @__PURE__ */ wa(/* @__PURE__ */ dr(`${Fl}/add`), {
  withTypes: () => KP
}), I5 = /* @__PURE__ */ dr(`${Fl}/removeAll`), YP = /* @__PURE__ */ wa(/* @__PURE__ */ dr(`${Fl}/remove`), {
  withTypes: () => YP
}), $5 = (...e) => {
  console.error(`${Fl}/error`, ...e);
}, Bl = (e = {}) => {
  const t = /* @__PURE__ */ new Map(), {
    extra: n,
    onError: r = $5
  } = e;
  tv(r, "onError");
  const i = (u) => (u.unsubscribe = () => t.delete(u.id), t.set(u.id, u), (d) => {
    u.unsubscribe(), d?.cancelActive && Sm(u);
  }), o = (u) => {
    const d = Vx(t, u) ?? qP(u);
    return i(d);
  };
  wa(o, {
    withTypes: () => o
  });
  const a = (u) => {
    const d = Vx(t, u);
    return d && (d.unsubscribe(), u.cancelActive && Sm(d)), !!d;
  };
  wa(a, {
    withTypes: () => a
  });
  const s = async (u, d, p, h) => {
    const g = new AbortController(), m = D5(o, g.signal), v = [];
    try {
      u.pending.add(g), await Promise.resolve(u.effect(
        d,
        // Use assign() rather than ... to avoid extra helper functions added to bundle
        wa({}, p, {
          getOriginalState: h,
          condition: (y, S) => m(y, S).then(Boolean),
          take: m,
          delay: UP(g.signal),
          pause: Du(g.signal),
          extra: n,
          signal: g.signal,
          fork: N5(g.signal, v),
          unsubscribe: u.unsubscribe,
          subscribe: () => {
            t.set(u.id, u);
          },
          cancelActiveListeners: () => {
            u.pending.forEach((y, S, w) => {
              y !== g && (ko(y, Om), w.delete(y));
            });
          },
          cancel: () => {
            ko(g, Om), u.pending.delete(g);
          },
          throwIfCancelled: () => {
            Mo(g.signal);
          }
        })
      ));
    } catch (y) {
      y instanceof Xd || Ux(r, y, {
        raisedBy: "effect"
      });
    } finally {
      await Promise.all(v), ko(g, M5), u.pending.delete(g);
    }
  }, l = R5(t);
  return {
    middleware: (u) => (d) => (p) => {
      if (!Zg(p))
        return d(p);
      if (KP.match(p))
        return o(p.payload);
      if (I5.match(p)) {
        l();
        return;
      }
      if (YP.match(p))
        return a(p.payload);
      let h = u.getState();
      const g = () => {
        if (h === Wx)
          throw new Error(process.env.NODE_ENV === "production" ? je(23) : `${Fl}: getOriginalState can only be called synchronously`);
        return h;
      };
      let m;
      try {
        if (m = d(p), t.size > 0) {
          const v = u.getState(), y = Array.from(t.values());
          for (const S of y) {
            let w = !1;
            try {
              w = S.predicate(p, v, h);
            } catch (b) {
              w = !1, Ux(r, b, {
                raisedBy: "predicate"
              });
            }
            w && s(S, p, u, g);
          }
        }
      } finally {
        h = Wx;
      }
      return m;
    },
    startListening: o,
    stopListening: a,
    clearListeners: l
  };
};
function je(e) {
  return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
var L5 = {
  layoutType: "horizontal",
  width: 0,
  height: 0,
  margin: {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  },
  scale: 1
}, GP = Zn({
  name: "chartLayout",
  initialState: L5,
  reducers: {
    setLayout(e, t) {
      e.layoutType = t.payload;
    },
    setChartSize(e, t) {
      e.width = t.payload.width, e.height = t.payload.height;
    },
    setMargin(e, t) {
      var n, r, i, o;
      e.margin.top = (n = t.payload.top) !== null && n !== void 0 ? n : 0, e.margin.right = (r = t.payload.right) !== null && r !== void 0 ? r : 0, e.margin.bottom = (i = t.payload.bottom) !== null && i !== void 0 ? i : 0, e.margin.left = (o = t.payload.left) !== null && o !== void 0 ? o : 0;
    },
    setScale(e, t) {
      e.scale = t.payload;
    }
  }
}), {
  setMargin: F5,
  setLayout: B5,
  setChartSize: z5,
  setScale: W5
} = GP.actions, V5 = GP.reducer;
function Hx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hx(Object(n), !0).forEach(function(r) {
      U5(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function U5(e, t, n) {
  return (t = H5(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function H5(e) {
  var t = q5(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function q5(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Ru = Math.PI / 180, K5 = (e) => e * 180 / Math.PI, $t = (e, t, n, r) => ({
  x: e + Math.cos(-Ru * r) * n,
  y: t + Math.sin(-Ru * r) * n
}), XP = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  return Math.min(Math.abs(t - (r.left || 0) - (r.right || 0)), Math.abs(n - (r.top || 0) - (r.bottom || 0))) / 2;
}, Y5 = (e, t) => {
  var {
    x: n,
    y: r
  } = e, {
    x: i,
    y: o
  } = t;
  return Math.sqrt((n - i) ** 2 + (r - o) ** 2);
}, G5 = (e, t) => {
  var {
    x: n,
    y: r
  } = e, {
    cx: i,
    cy: o
  } = t, a = Y5({
    x: n,
    y: r
  }, {
    x: i,
    y: o
  });
  if (a <= 0)
    return {
      radius: a,
      angle: 0
    };
  var s = (n - i) / a, l = Math.acos(s);
  return r > o && (l = 2 * Math.PI - l), {
    radius: a,
    angle: K5(l),
    angleInRadian: l
  };
}, X5 = (e) => {
  var {
    startAngle: t,
    endAngle: n
  } = e, r = Math.floor(t / 360), i = Math.floor(n / 360), o = Math.min(r, i);
  return {
    startAngle: t - o * 360,
    endAngle: n - o * 360
  };
}, Z5 = (e, t) => {
  var {
    startAngle: n,
    endAngle: r
  } = t, i = Math.floor(n / 360), o = Math.floor(r / 360), a = Math.min(i, o);
  return e + a * 360;
}, J5 = (e, t) => {
  var {
    x: n,
    y: r
  } = e, {
    radius: i,
    angle: o
  } = G5({
    x: n,
    y: r
  }, t), {
    innerRadius: a,
    outerRadius: s
  } = t;
  if (i < a || i > s || i === 0)
    return null;
  var {
    startAngle: l,
    endAngle: c
  } = X5(t), u = o, d;
  if (l <= c) {
    for (; u > c; )
      u -= 360;
    for (; u < l; )
      u += 360;
    d = u >= l && u <= c;
  } else {
    for (; u > l; )
      u -= 360;
    for (; u < c; )
      u += 360;
    d = u >= c && u <= l;
  }
  return d ? qx(qx({}, t), {}, {
    radius: i,
    angle: Z5(u, t)
  }) : null;
};
function ZP(e, t, n) {
  return Array.isArray(e) && e && t + n !== 0 ? e.slice(t, n + 1) : e;
}
function Kx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kx(Object(n), !0).forEach(function(r) {
      Q5(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Kx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Q5(e, t, n) {
  return (t = eL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function eL(e) {
  var t = tL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function tL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ct(e, t, n) {
  return yt(e) || yt(t) ? n : Vr(t) ? Io(e, t, n) : typeof t == "function" ? t(e) : n;
}
var nL = (e, t, n, r, i) => {
  var o, a = -1, s = (o = t?.length) !== null && o !== void 0 ? o : 0;
  if (s <= 1 || e == null)
    return 0;
  if (r === "angleAxis" && i != null && Math.abs(Math.abs(i[1] - i[0]) - 360) <= 1e-6)
    for (var l = 0; l < s; l++) {
      var c = l > 0 ? n[l - 1].coordinate : n[s - 1].coordinate, u = n[l].coordinate, d = l >= s - 1 ? n[0].coordinate : n[l + 1].coordinate, p = void 0;
      if (Yt(u - c) !== Yt(d - u)) {
        var h = [];
        if (Yt(d - u) === Yt(i[1] - i[0])) {
          p = d;
          var g = u + i[1] - i[0];
          h[0] = Math.min(g, (g + c) / 2), h[1] = Math.max(g, (g + c) / 2);
        } else {
          p = c;
          var m = d + i[1] - i[0];
          h[0] = Math.min(u, (m + u) / 2), h[1] = Math.max(u, (m + u) / 2);
        }
        var v = [Math.min(u, (p + u) / 2), Math.max(u, (p + u) / 2)];
        if (e > v[0] && e <= v[1] || e >= h[0] && e <= h[1]) {
          ({
            index: a
          } = n[l]);
          break;
        }
      } else {
        var y = Math.min(c, d), S = Math.max(c, d);
        if (e > (y + u) / 2 && e <= (S + u) / 2) {
          ({
            index: a
          } = n[l]);
          break;
        }
      }
    }
  else if (t) {
    for (var w = 0; w < s; w++)
      if (w === 0 && e <= (t[w].coordinate + t[w + 1].coordinate) / 2 || w > 0 && w < s - 1 && e > (t[w].coordinate + t[w - 1].coordinate) / 2 && e <= (t[w].coordinate + t[w + 1].coordinate) / 2 || w === s - 1 && e > (t[w].coordinate + t[w - 1].coordinate) / 2) {
        ({
          index: a
        } = t[w]);
        break;
      }
  }
  return a;
}, rL = (e, t, n) => {
  if (t && n) {
    var {
      width: r,
      height: i
    } = n, {
      align: o,
      verticalAlign: a,
      layout: s
    } = t;
    if ((s === "vertical" || s === "horizontal" && a === "middle") && o !== "center" && me(e[o]))
      return sr(sr({}, e), {}, {
        [o]: e[o] + (r || 0)
      });
    if ((s === "horizontal" || s === "vertical" && o === "center") && a !== "middle" && me(e[a]))
      return sr(sr({}, e), {}, {
        [a]: e[a] + (i || 0)
      });
  }
  return e;
}, Xi = (e, t) => e === "horizontal" && t === "xAxis" || e === "vertical" && t === "yAxis" || e === "centric" && t === "angleAxis" || e === "radial" && t === "radiusAxis", JP = (e, t, n, r) => {
  if (r)
    return e.map((s) => s.coordinate);
  var i, o, a = e.map((s) => (s.coordinate === t && (i = !0), s.coordinate === n && (o = !0), s.coordinate));
  return i || a.push(t), o || a.push(n), a;
}, QP = (e, t, n) => {
  if (!e)
    return null;
  var {
    duplicateDomain: r,
    type: i,
    range: o,
    scale: a,
    realScaleType: s,
    isCategorical: l,
    categoricalDomain: c,
    tickCount: u,
    ticks: d,
    niceTicks: p,
    axisType: h
  } = e;
  if (!a)
    return null;
  var g = s === "scaleBand" && a.bandwidth ? a.bandwidth() / 2 : 2, m = i === "category" && a.bandwidth ? a.bandwidth() / g : 0;
  if (m = h === "angleAxis" && o && o.length >= 2 ? Yt(o[0] - o[1]) * 2 * m : m, d || p) {
    var v = (d || p || []).map((y, S) => {
      var w = r ? r.indexOf(y) : y;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: a(w) + m,
        value: y,
        offset: m,
        index: S
      };
    });
    return v.filter((y) => !qn(y.coordinate));
  }
  return l && c ? c.map((y, S) => ({
    coordinate: a(y) + m,
    value: y,
    index: S,
    offset: m
  })) : a.ticks && u != null ? a.ticks(u).map((y, S) => ({
    coordinate: a(y) + m,
    value: y,
    offset: m,
    index: S
  })) : a.domain().map((y, S) => ({
    coordinate: a(y) + m,
    value: r ? r[y] : y,
    index: S,
    offset: m
  }));
}, Yx = 1e-4, iL = (e) => {
  var t = e.domain();
  if (!(!t || t.length <= 2)) {
    var n = t.length, r = e.range(), i = Math.min(r[0], r[1]) - Yx, o = Math.max(r[0], r[1]) + Yx, a = e(t[0]), s = e(t[n - 1]);
    (a < i || a > o || s < i || s > o) && e.domain([t[0], t[n - 1]]);
  }
}, oL = (e, t) => {
  if (!t || t.length !== 2 || !me(t[0]) || !me(t[1]))
    return e;
  var n = Math.min(t[0], t[1]), r = Math.max(t[0], t[1]), i = [e[0], e[1]];
  return (!me(e[0]) || e[0] < n) && (i[0] = n), (!me(e[1]) || e[1] > r) && (i[1] = r), i[0] > r && (i[0] = r), i[1] < n && (i[1] = n), i;
}, aL = (e) => {
  var t = e.length;
  if (!(t <= 0))
    for (var n = 0, r = e[0].length; n < r; ++n)
      for (var i = 0, o = 0, a = 0; a < t; ++a) {
        var s = qn(e[a][n][1]) ? e[a][n][0] : e[a][n][1];
        s >= 0 ? (e[a][n][0] = i, e[a][n][1] = i + s, i = e[a][n][1]) : (e[a][n][0] = o, e[a][n][1] = o + s, o = e[a][n][1]);
      }
}, sL = (e) => {
  var t = e.length;
  if (!(t <= 0))
    for (var n = 0, r = e[0].length; n < r; ++n)
      for (var i = 0, o = 0; o < t; ++o) {
        var a = qn(e[o][n][1]) ? e[o][n][0] : e[o][n][1];
        a >= 0 ? (e[o][n][0] = i, e[o][n][1] = i + a, i = e[o][n][1]) : (e[o][n][0] = 0, e[o][n][1] = 0);
      }
}, lL = {
  sign: aL,
  // @ts-expect-error definitelytyped types are incorrect
  expand: SI,
  // @ts-expect-error definitelytyped types are incorrect
  none: Ta,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: EI,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: _I,
  positive: sL
}, cL = (e, t, n) => {
  var r = lL[n], i = OI().keys(t).value((o, a) => +ct(o, a, 0)).order(pm).offset(r);
  return i(e);
};
function uL(e) {
  return e == null ? void 0 : String(e);
}
function Gx(e) {
  var {
    axis: t,
    ticks: n,
    bandSize: r,
    entry: i,
    index: o,
    dataKey: a
  } = e;
  if (t.type === "category") {
    if (!t.allowDuplicatedCategory && t.dataKey && !yt(i[t.dataKey])) {
      var s = B_(n, "value", i[t.dataKey]);
      if (s)
        return s.coordinate + r / 2;
    }
    return n[o] ? n[o].coordinate + r / 2 : null;
  }
  var l = ct(i, yt(a) ? t.dataKey : a);
  return yt(l) ? null : t.scale(l);
}
var Xx = (e) => {
  var {
    axis: t,
    ticks: n,
    offset: r,
    bandSize: i,
    entry: o,
    index: a
  } = e;
  if (t.type === "category")
    return n[a] ? n[a].coordinate + r : null;
  var s = ct(o, t.dataKey, t.scale.domain()[a]);
  return yt(s) ? null : t.scale(s) - i / 2 + r;
}, dL = (e) => {
  var {
    numericAxis: t
  } = e, n = t.scale.domain();
  if (t.type === "number") {
    var r = Math.min(n[0], n[1]), i = Math.max(n[0], n[1]);
    return r <= 0 && i >= 0 ? 0 : i < 0 ? i : r;
  }
  return n[0];
}, fL = (e) => {
  var t = e.flat(2).filter(me);
  return [Math.min(...t), Math.max(...t)];
}, pL = (e) => [e[0] === 1 / 0 ? 0 : e[0], e[1] === -1 / 0 ? 0 : e[1]], hL = (e, t, n) => {
  if (e != null)
    return pL(Object.keys(e).reduce((r, i) => {
      var o = e[i], {
        stackedData: a
      } = o, s = a.reduce((l, c) => {
        var u = ZP(c, t, n), d = fL(u);
        return [Math.min(l[0], d[0]), Math.max(l[1], d[1])];
      }, [1 / 0, -1 / 0]);
      return [Math.min(s[0], r[0]), Math.max(s[1], r[1])];
    }, [1 / 0, -1 / 0]));
}, Zx = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, Jx = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, al = (e, t, n) => {
  if (e && e.scale && e.scale.bandwidth) {
    var r = e.scale.bandwidth();
    if (!n || r > 0)
      return r;
  }
  if (e && t && t.length >= 2) {
    for (var i = qd(t, (u) => u.coordinate), o = 1 / 0, a = 1, s = i.length; a < s; a++) {
      var l = i[a], c = i[a - 1];
      o = Math.min((l.coordinate || 0) - (c.coordinate || 0), o);
    }
    return o === 1 / 0 ? 0 : o;
  }
  return n ? void 0 : 0;
};
function Qx(e) {
  var {
    tooltipEntrySettings: t,
    dataKey: n,
    payload: r,
    value: i,
    name: o
  } = e;
  return sr(sr({}, t), {}, {
    dataKey: n,
    payload: r,
    value: i,
    name: o
  });
}
function Ua(e, t) {
  if (e)
    return String(e);
  if (typeof t == "string")
    return t;
}
function mL(e, t, n, r, i) {
  if (n === "horizontal" || n === "vertical") {
    var o = e >= i.left && e <= i.left + i.width && t >= i.top && t <= i.top + i.height;
    return o ? {
      x: e,
      y: t
    } : null;
  }
  return r ? J5({
    x: e,
    y: t
  }, r) : null;
}
var gL = (e, t, n, r) => {
  var i = t.find((c) => c && c.index === n);
  if (i) {
    if (e === "horizontal")
      return {
        x: i.coordinate,
        y: r.y
      };
    if (e === "vertical")
      return {
        x: r.x,
        y: i.coordinate
      };
    if (e === "centric") {
      var o = i.coordinate, {
        radius: a
      } = r;
      return sr(sr(sr({}, r), $t(r.cx, r.cy, a, o)), {}, {
        angle: o,
        radius: a
      });
    }
    var s = i.coordinate, {
      angle: l
    } = r;
    return sr(sr(sr({}, r), $t(r.cx, r.cy, s, l)), {}, {
      angle: l,
      radius: s
    });
  }
  return {
    x: 0,
    y: 0
  };
}, vL = (e, t) => t === "horizontal" ? e.x : t === "vertical" ? e.y : t === "centric" ? e.angle : e.radius, wi = (e) => e.layout.width, Oi = (e) => e.layout.height, yL = (e) => e.layout.scale, e2 = (e) => e.layout.margin, Zd = z((e) => e.cartesianAxis.xAxis, (e) => Object.values(e)), Jd = z((e) => e.cartesianAxis.yAxis, (e) => Object.values(e)), t2 = "data-recharts-item-index", n2 = "data-recharts-item-data-key", zl = 60;
function e1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e1(Object(n), !0).forEach(function(r) {
      bL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bL(e, t, n) {
  return (t = xL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function xL(e) {
  var t = wL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function wL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var OL = (e) => e.brush.height;
function SL(e) {
  var t = Jd(e);
  return t.reduce((n, r) => {
    if (r.orientation === "left" && !r.mirror && !r.hide) {
      var i = typeof r.width == "number" ? r.width : zl;
      return n + i;
    }
    return n;
  }, 0);
}
function EL(e) {
  var t = Jd(e);
  return t.reduce((n, r) => {
    if (r.orientation === "right" && !r.mirror && !r.hide) {
      var i = typeof r.width == "number" ? r.width : zl;
      return n + i;
    }
    return n;
  }, 0);
}
function _L(e) {
  var t = Zd(e);
  return t.reduce((n, r) => r.orientation === "top" && !r.mirror && !r.hide ? n + r.height : n, 0);
}
function PL(e) {
  var t = Zd(e);
  return t.reduce((n, r) => r.orientation === "bottom" && !r.mirror && !r.hide ? n + r.height : n, 0);
}
var zt = z([wi, Oi, e2, OL, SL, EL, _L, PL, wP, M$], (e, t, n, r, i, o, a, s, l, c) => {
  var u = {
    left: (n.left || 0) + i,
    right: (n.right || 0) + o
  }, d = {
    top: (n.top || 0) + a,
    bottom: (n.bottom || 0) + s
  }, p = Pc(Pc({}, d), u), h = p.bottom;
  p.bottom += r, p = rL(p, l, c);
  var g = e - p.left - p.right, m = t - p.top - p.bottom;
  return Pc(Pc({
    brushBottom: h
  }, p), {}, {
    // never return negative values for height and width
    width: Math.max(g, 0),
    height: Math.max(m, 0)
  });
}), CL = z(zt, (e) => ({
  x: e.left,
  y: e.top,
  width: e.width,
  height: e.height
})), nv = z(wi, Oi, (e, t) => ({
  x: 0,
  y: 0,
  width: e,
  height: t
})), TL = /* @__PURE__ */ gr(null), Nn = () => Kr(TL) != null, Qd = (e) => e.brush, ef = z([Qd, zt, e2], (e, t, n) => ({
  height: e.height,
  x: me(e.x) ? e.x : t.left,
  y: me(e.y) ? e.y : t.top + t.height + t.brushBottom - (n?.bottom || 0),
  width: me(e.width) ? e.width : t.width
})), rv = () => {
  var e, t = Nn(), n = pe(CL), r = pe(ef), i = (e = pe(Qd)) === null || e === void 0 ? void 0 : e.padding;
  return !t || !r || !i ? n : {
    width: r.width - i.left - i.right,
    height: r.height - i.top - i.bottom,
    x: i.left,
    y: i.top
  };
}, AL = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  width: 0,
  height: 0,
  brushBottom: 0
}, r2 = () => {
  var e;
  return (e = pe(zt)) !== null && e !== void 0 ? e : AL;
}, i2 = () => pe(wi), o2 = () => pe(Oi), Pe = (e) => e.layout.layoutType, tf = () => pe(Pe), kL = {
  settings: {
    layout: "horizontal",
    align: "center",
    verticalAlign: "middle",
    itemSorter: "value"
  },
  size: {
    width: 0,
    height: 0
  },
  payload: []
}, a2 = Zn({
  name: "legend",
  initialState: kL,
  reducers: {
    setLegendSize(e, t) {
      e.size.width = t.payload.width, e.size.height = t.payload.height;
    },
    setLegendSettings(e, t) {
      e.settings.align = t.payload.align, e.settings.layout = t.payload.layout, e.settings.verticalAlign = t.payload.verticalAlign, e.settings.itemSorter = t.payload.itemSorter;
    },
    addLegendPayload(e, t) {
      e.payload.push(t.payload);
    },
    removeLegendPayload(e, t) {
      var n = ui(e).payload.indexOf(t.payload);
      n > -1 && e.payload.splice(n, 1);
    }
  }
}), {
  setLegendSize: Vte,
  setLegendSettings: Ute,
  addLegendPayload: s2,
  removeLegendPayload: l2
} = a2.actions, ML = a2.reducer;
function Em() {
  return Em = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Em.apply(null, arguments);
}
function t1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t1(Object(n), !0).forEach(function(r) {
      jL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jL(e, t, n) {
  return (t = NL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function NL(e) {
  var t = DL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function DL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function RL(e) {
  return Array.isArray(e) && Vr(e[0]) && Vr(e[1]) ? e.join(" ~ ") : e;
}
var IL = (e) => {
  var {
    separator: t = " : ",
    contentStyle: n = {},
    itemStyle: r = {},
    labelStyle: i = {},
    payload: o,
    formatter: a,
    itemSorter: s,
    wrapperClassName: l,
    labelClassName: c,
    label: u,
    labelFormatter: d,
    accessibilityLayer: p = !1
  } = e, h = () => {
    if (o && o.length) {
      var O = {
        padding: 0,
        margin: 0
      }, E = (s ? qd(o, s) : o).map((C, T) => {
        if (C.type === "none")
          return null;
        var j = C.formatter || a || RL, {
          value: A,
          name: M
        } = C, P = A, R = M;
        if (j) {
          var N = j(A, M, C, T, o);
          if (Array.isArray(N))
            [P, R] = N;
          else if (N != null)
            P = N;
          else
            return null;
        }
        var D = eh({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: C.color || "#000"
        }, r);
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ _.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(T),
            style: D
          }, Vr(R) ? /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, R) : null, Vr(R) ? /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, t) : null, /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, P), /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, C.unit || ""))
        );
      });
      return /* @__PURE__ */ _.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: O
      }, E);
    }
    return null;
  }, g = eh({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, n), m = eh({
    margin: 0
  }, i), v = !yt(u), y = v ? u : "", S = ie("recharts-default-tooltip", l), w = ie("recharts-tooltip-label", c);
  v && d && o !== void 0 && o !== null && (y = d(u, o));
  var b = p ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ _.createElement("div", Em({
    className: S,
    style: g
  }, b), /* @__PURE__ */ _.createElement("p", {
    className: w,
    style: m
  }, /* @__PURE__ */ _.isValidElement(y) ? y : "".concat(y)), h());
}, us = "recharts-tooltip-wrapper", $L = {
  visibility: "hidden"
};
function LL(e) {
  var {
    coordinate: t,
    translateX: n,
    translateY: r
  } = e;
  return ie(us, {
    ["".concat(us, "-right")]: me(n) && t && me(t.x) && n >= t.x,
    ["".concat(us, "-left")]: me(n) && t && me(t.x) && n < t.x,
    ["".concat(us, "-bottom")]: me(r) && t && me(t.y) && r >= t.y,
    ["".concat(us, "-top")]: me(r) && t && me(t.y) && r < t.y
  });
}
function n1(e) {
  var {
    allowEscapeViewBox: t,
    coordinate: n,
    key: r,
    offsetTopLeft: i,
    position: o,
    reverseDirection: a,
    tooltipDimension: s,
    viewBox: l,
    viewBoxDimension: c
  } = e;
  if (o && me(o[r]))
    return o[r];
  var u = n[r] - s - (i > 0 ? i : 0), d = n[r] + i;
  if (t[r])
    return a[r] ? u : d;
  var p = l[r];
  if (p == null)
    return 0;
  if (a[r]) {
    var h = u, g = p;
    return h < g ? Math.max(d, p) : Math.max(u, p);
  }
  if (c == null)
    return 0;
  var m = d + s, v = p + c;
  return m > v ? Math.max(u, p) : Math.max(d, p);
}
function FL(e) {
  var {
    translateX: t,
    translateY: n,
    useTranslate3d: r
  } = e;
  return {
    transform: r ? "translate3d(".concat(t, "px, ").concat(n, "px, 0)") : "translate(".concat(t, "px, ").concat(n, "px)")
  };
}
function BL(e) {
  var {
    allowEscapeViewBox: t,
    coordinate: n,
    offsetTopLeft: r,
    position: i,
    reverseDirection: o,
    tooltipBox: a,
    useTranslate3d: s,
    viewBox: l
  } = e, c, u, d;
  return a.height > 0 && a.width > 0 && n ? (u = n1({
    allowEscapeViewBox: t,
    coordinate: n,
    key: "x",
    offsetTopLeft: r,
    position: i,
    reverseDirection: o,
    tooltipDimension: a.width,
    viewBox: l,
    viewBoxDimension: l.width
  }), d = n1({
    allowEscapeViewBox: t,
    coordinate: n,
    key: "y",
    offsetTopLeft: r,
    position: i,
    reverseDirection: o,
    tooltipDimension: a.height,
    viewBox: l,
    viewBoxDimension: l.height
  }), c = FL({
    translateX: u,
    translateY: d,
    useTranslate3d: s
  })) : c = $L, {
    cssProperties: c,
    cssClasses: LL({
      translateX: u,
      translateY: d,
      coordinate: n
    })
  };
}
function r1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r1(Object(n), !0).forEach(function(r) {
      _m(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function _m(e, t, n) {
  return (t = zL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function zL(e) {
  var t = WL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function WL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
class VL extends FE {
  constructor() {
    super(...arguments), _m(this, "state", {
      dismissed: !1,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      }
    }), _m(this, "handleKeyDown", (t) => {
      if (t.key === "Escape") {
        var n, r, i, o;
        this.setState({
          dismissed: !0,
          dismissedAtCoordinate: {
            x: (n = (r = this.props.coordinate) === null || r === void 0 ? void 0 : r.x) !== null && n !== void 0 ? n : 0,
            y: (i = (o = this.props.coordinate) === null || o === void 0 ? void 0 : o.y) !== null && i !== void 0 ? i : 0
          }
        });
      }
    });
  }
  componentDidMount() {
    document.addEventListener("keydown", this.handleKeyDown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  componentDidUpdate() {
    var t, n;
    this.state.dismissed && (((t = this.props.coordinate) === null || t === void 0 ? void 0 : t.x) !== this.state.dismissedAtCoordinate.x || ((n = this.props.coordinate) === null || n === void 0 ? void 0 : n.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);
  }
  render() {
    var {
      active: t,
      allowEscapeViewBox: n,
      animationDuration: r,
      animationEasing: i,
      children: o,
      coordinate: a,
      hasPayload: s,
      isAnimationActive: l,
      offset: c,
      position: u,
      reverseDirection: d,
      useTranslate3d: p,
      viewBox: h,
      wrapperStyle: g,
      lastBoundingBox: m,
      innerRef: v,
      hasPortalFromProps: y
    } = this.props, {
      cssClasses: S,
      cssProperties: w
    } = BL({
      allowEscapeViewBox: n,
      coordinate: a,
      offsetTopLeft: c,
      position: u,
      reverseDirection: d,
      tooltipBox: {
        height: m.height,
        width: m.width
      },
      useTranslate3d: p,
      viewBox: h
    }), b = y ? {} : Cc(Cc({
      transition: l && t ? "transform ".concat(r, "ms ").concat(i) : void 0
    }, w), {}, {
      pointerEvents: "none",
      visibility: !this.state.dismissed && t && s ? "visible" : "hidden",
      position: "absolute",
      top: 0,
      left: 0
    }), O = Cc(Cc({}, b), {}, {
      visibility: !this.state.dismissed && t && s ? "visible" : "hidden"
    }, g);
    return (
      // This element allow listening to the `Escape` key. See https://github.com/recharts/recharts/pull/2925
      /* @__PURE__ */ _.createElement("div", {
        // @ts-expect-error typescript library does not recognize xmlns attribute, but it's required for an HTML chunk inside SVG.
        xmlns: "http://www.w3.org/1999/xhtml",
        tabIndex: -1,
        className: S,
        style: O,
        ref: v
      }, o)
    );
  }
}
var UL = () => !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout), Zi = {
  devToolsEnabled: !1,
  isSsr: UL()
}, c2 = () => pe((e) => e.rootProps.accessibilityLayer);
function Yn(e) {
  return Number.isFinite(e);
}
function ka(e) {
  return typeof e == "number" && e > 0 && Number.isFinite(e);
}
function Pm() {
  return Pm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Pm.apply(null, arguments);
}
function i1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i1(Object(n), !0).forEach(function(r) {
      HL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function HL(e, t, n) {
  return (t = qL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function qL(e) {
  var t = KL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function KL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var a1 = {
  curveBasisClosed: dI,
  curveBasisOpen: fI,
  curveBasis: uI,
  curveBumpX: XR,
  curveBumpY: ZR,
  curveLinearClosed: pI,
  curveLinear: Ud,
  curveMonotoneX: hI,
  curveMonotoneY: mI,
  curveNatural: gI,
  curveStep: vI,
  curveStepAfter: bI,
  curveStepBefore: yI
}, Tc = (e) => Yn(e.x) && Yn(e.y), ds = (e) => e.x, fs = (e) => e.y, YL = (e, t) => {
  if (typeof e == "function")
    return e;
  var n = "curve".concat(Il(e));
  return (n === "curveMonotone" || n === "curveBump") && t ? a1["".concat(n).concat(t === "vertical" ? "Y" : "X")] : a1[n] || Ud;
}, GL = (e) => {
  var {
    type: t = "linear",
    points: n = [],
    baseLine: r,
    layout: i,
    connectNulls: o = !1
  } = e, a = YL(t, i), s = o ? n.filter(Tc) : n, l;
  if (Array.isArray(r)) {
    var c = o ? r.filter((d) => Tc(d)) : r, u = s.map((d, p) => o1(o1({}, d), {}, {
      base: c[p]
    }));
    return i === "vertical" ? l = vc().y(fs).x1(ds).x0((d) => d.base.x) : l = vc().x(ds).y1(fs).y0((d) => d.base.y), l.defined(Tc).curve(a), l(u);
  }
  return i === "vertical" && me(r) ? l = vc().y(fs).x1(ds).x0(r) : me(r) ? l = vc().x(ds).y1(fs).y0(r) : l = X_().x(ds).y(fs), l.defined(Tc).curve(a), l(s);
}, iv = (e) => {
  var {
    className: t,
    points: n,
    path: r,
    pathRef: i
  } = e;
  if ((!n || !n.length) && !r)
    return null;
  var o = n && n.length ? GL(e) : r;
  return /* @__PURE__ */ _.createElement("path", Pm({}, Yr(e), Vg(e), {
    className: ie("recharts-curve", t),
    d: o === null ? void 0 : o,
    ref: i
  }));
}, XL = ["x", "y", "top", "left", "width", "height", "className"];
function Cm() {
  return Cm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Cm.apply(null, arguments);
}
function s1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s1(Object(n), !0).forEach(function(r) {
      JL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function JL(e, t, n) {
  return (t = QL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function QL(e) {
  var t = eF(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function eF(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function tF(e, t) {
  if (e == null) return {};
  var n, r, i = nF(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function nF(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var rF = (e, t, n, r, i, o) => "M".concat(e, ",").concat(i, "v").concat(r, "M").concat(o, ",").concat(t, "h").concat(n), iF = (e) => {
  var {
    x: t = 0,
    y: n = 0,
    top: r = 0,
    left: i = 0,
    width: o = 0,
    height: a = 0,
    className: s
  } = e, l = tF(e, XL), c = ZL({
    x: t,
    y: n,
    top: r,
    left: i,
    width: o,
    height: a
  }, l);
  return !me(t) || !me(n) || !me(o) || !me(a) || !me(r) || !me(i) ? null : /* @__PURE__ */ _.createElement("path", Cm({}, wt(c, !0), {
    className: ie("recharts-cross", s),
    d: rF(t, n, o, a, r, i)
  }));
};
function oF(e, t, n, r) {
  var i = r / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: e === "horizontal" ? t.x - i : n.left + 0.5,
    y: e === "horizontal" ? n.top + 0.5 : t.y - i,
    width: e === "horizontal" ? r : n.width - 1,
    height: e === "horizontal" ? n.height - 1 : r
  };
}
function l1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l1(Object(n), !0).forEach(function(r) {
      sF(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function sF(e, t, n) {
  return (t = lF(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function lF(e) {
  var t = cF(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function cF(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function on(e, t) {
  var n = aF({}, e), r = t, i = Object.keys(t), o = i.reduce((a, s) => (a[s] === void 0 && r[s] !== void 0 && (a[s] = r[s]), a), n);
  return o;
}
function uF() {
}
function c1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function u1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c1(Object(n), !0).forEach(function(r) {
      dF(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function dF(e, t, n) {
  return (t = fF(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function fF(e) {
  var t = pF(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function pF(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var hF = (e) => e.replace(/([A-Z])/g, (t) => "-".concat(t.toLowerCase())), u2 = (e, t, n) => e.map((r) => "".concat(hF(r), " ").concat(t, "ms ").concat(n)).join(","), mF = (e, t) => [Object.keys(e), Object.keys(t)].reduce((n, r) => n.filter((i) => r.includes(i))), sl = (e, t) => Object.keys(t).reduce((n, r) => u1(u1({}, n), {}, {
  [r]: e(r, t[r])
}), {});
function d1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function en(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d1(Object(n), !0).forEach(function(r) {
      gF(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function gF(e, t, n) {
  return (t = vF(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function vF(e) {
  var t = yF(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function yF(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Iu = (e, t, n) => e + (t - e) * n, Tm = (e) => {
  var {
    from: t,
    to: n
  } = e;
  return t !== n;
}, d2 = (e, t, n) => {
  var r = sl((i, o) => {
    if (Tm(o)) {
      var [a, s] = e(o.from, o.to, o.velocity);
      return en(en({}, o), {}, {
        from: a,
        velocity: s
      });
    }
    return o;
  }, t);
  return n < 1 ? sl((i, o) => Tm(o) ? en(en({}, o), {}, {
    velocity: Iu(o.velocity, r[i].velocity, n),
    from: Iu(o.from, r[i].from, n)
  }) : o, t) : d2(e, r, n - 1);
};
function bF(e, t, n, r, i, o) {
  var a, s = r.reduce((p, h) => en(en({}, p), {}, {
    [h]: {
      from: e[h],
      velocity: 0,
      to: t[h]
    }
  }), {}), l = () => sl((p, h) => h.from, s), c = () => !Object.values(s).filter(Tm).length, u = null, d = (p) => {
    a || (a = p);
    var h = p - a, g = h / n.dt;
    s = d2(n, s, g), i(en(en(en({}, e), t), l())), a = p, c() || (u = o.setTimeout(d));
  };
  return () => (u = o.setTimeout(d), () => {
    u();
  });
}
function xF(e, t, n, r, i, o, a) {
  var s = null, l = i.reduce((d, p) => en(en({}, d), {}, {
    [p]: [e[p], t[p]]
  }), {}), c, u = (d) => {
    c || (c = d);
    var p = (d - c) / r, h = sl((m, v) => Iu(...v, n(p)), l);
    if (o(en(en(en({}, e), t), h)), p < 1)
      s = a.setTimeout(u);
    else {
      var g = sl((m, v) => Iu(...v, n(1)), l);
      o(en(en(en({}, e), t), g));
    }
  };
  return () => (s = a.setTimeout(u), () => {
    s();
  });
}
const wF = (e, t, n, r, i, o) => {
  var a = mF(e, t);
  return n.isStepper === !0 ? bF(e, t, n, a, i, o) : xF(e, t, n, r, a, i, o);
};
var $u = 1e-4, f2 = (e, t) => [0, 3 * e, 3 * t - 6 * e, 3 * e - 3 * t + 1], p2 = (e, t) => e.map((n, r) => n * t ** r).reduce((n, r) => n + r), f1 = (e, t) => (n) => {
  var r = f2(e, t);
  return p2(r, n);
}, OF = (e, t) => (n) => {
  var r = f2(e, t), i = [...r.map((o, a) => o * a).slice(1), 0];
  return p2(i, n);
}, p1 = function() {
  for (var t, n, r, i, o = arguments.length, a = new Array(o), s = 0; s < o; s++)
    a[s] = arguments[s];
  if (a.length === 1)
    switch (a[0]) {
      case "linear":
        [t, r, n, i] = [0, 0, 1, 1];
        break;
      case "ease":
        [t, r, n, i] = [0.25, 0.1, 0.25, 1];
        break;
      case "ease-in":
        [t, r, n, i] = [0.42, 0, 1, 1];
        break;
      case "ease-out":
        [t, r, n, i] = [0.42, 0, 0.58, 1];
        break;
      case "ease-in-out":
        [t, r, n, i] = [0, 0, 0.58, 1];
        break;
      default: {
        var l = a[0].split("(");
        l[0] === "cubic-bezier" && l[1].split(")")[0].split(",").length === 4 && ([t, r, n, i] = l[1].split(")")[0].split(",").map((g) => parseFloat(g)));
      }
    }
  else a.length === 4 && ([t, r, n, i] = a);
  var c = f1(t, n), u = f1(r, i), d = OF(t, n), p = (g) => g > 1 ? 1 : g < 0 ? 0 : g, h = (g) => {
    for (var m = g > 1 ? 1 : g, v = m, y = 0; y < 8; ++y) {
      var S = c(v) - m, w = d(v);
      if (Math.abs(S - m) < $u || w < $u)
        return u(v);
      v = p(v - S / w);
    }
    return u(v);
  };
  return h.isStepper = !1, h;
}, SF = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
    stiff: n = 100,
    damping: r = 8,
    dt: i = 17
  } = t, o = (a, s, l) => {
    var c = -(a - s) * n, u = l * r, d = l + (c - u) * i / 1e3, p = l * i / 1e3 + a;
    return Math.abs(p - s) < $u && Math.abs(d) < $u ? [s, 0] : [p, d];
  };
  return o.isStepper = !0, o.dt = i, o;
}, EF = (e) => {
  if (typeof e == "string")
    switch (e) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return p1(e);
      case "spring":
        return SF();
      default:
        if (e.split("(")[0] === "cubic-bezier")
          return p1(e);
    }
  return typeof e == "function" ? e : null;
};
function _F(e) {
  var t, n = () => null, r = !1, i = null, o = (a) => {
    if (!r) {
      if (Array.isArray(a)) {
        if (!a.length)
          return;
        var s = a, [l, ...c] = s;
        if (typeof l == "number") {
          i = e.setTimeout(o.bind(null, c), l);
          return;
        }
        o(l), i = e.setTimeout(o.bind(null, c));
        return;
      }
      typeof a == "string" && (t = a, n(t)), typeof a == "object" && (t = a, n(t)), typeof a == "function" && a();
    }
  };
  return {
    stop: () => {
      r = !0;
    },
    start: (a) => {
      r = !1, i && (i(), i = null), o(a);
    },
    subscribe: (a) => (n = a, () => {
      n = () => null;
    }),
    getTimeoutController: () => e
  };
}
class PF {
  setTimeout(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = performance.now(), i = null, o = (a) => {
      a - r >= n ? t(a) : typeof requestAnimationFrame == "function" && (i = requestAnimationFrame(o));
    };
    return i = requestAnimationFrame(o), () => {
      cancelAnimationFrame(i);
    };
  }
}
function CF() {
  return _F(new PF());
}
var TF = /* @__PURE__ */ gr(CF);
function AF(e, t) {
  var n = Kr(TF);
  return Un(() => t ?? n(e), [e, t, n]);
}
var kF = {
  begin: 0,
  duration: 1e3,
  easing: "ease",
  isActive: !0,
  canBegin: !0,
  onAnimationEnd: () => {
  },
  onAnimationStart: () => {
  }
}, h1 = {
  t: 0
}, th = {
  t: 1
};
function Wl(e) {
  var t = on(e, kF), {
    isActive: n,
    canBegin: r,
    duration: i,
    easing: o,
    begin: a,
    onAnimationEnd: s,
    onAnimationStart: l,
    children: c
  } = t, u = AF(t.animationId, t.animationManager), [d, p] = Ke(n ? h1 : th), h = Ne(null);
  return De(() => {
    n || p(th);
  }, [n]), De(() => {
    if (!n || !r)
      return uF;
    var g = wF(h1, th, EF(o), i, p, u.getTimeoutController()), m = () => {
      h.current = g();
    };
    return u.start([l, a, m, i, s]), () => {
      u.stop(), h.current && h.current(), s();
    };
  }, [n, r, i, o, a, l, s, u]), c(d.t);
}
function Vl(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-", n = Ne(rl(t)), r = Ne(e);
  return r.current !== e && (n.current = rl(t), r.current = e), n.current;
}
function m1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function g1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m1(Object(n), !0).forEach(function(r) {
      MF(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function MF(e, t, n) {
  return (t = jF(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function jF(e) {
  var t = NF(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function NF(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Lu() {
  return Lu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Lu.apply(null, arguments);
}
var v1 = (e, t, n, r, i) => {
  var o = Math.min(Math.abs(n) / 2, Math.abs(r) / 2), a = r >= 0 ? 1 : -1, s = n >= 0 ? 1 : -1, l = r >= 0 && n >= 0 || r < 0 && n < 0 ? 1 : 0, c;
  if (o > 0 && i instanceof Array) {
    for (var u = [0, 0, 0, 0], d = 0, p = 4; d < p; d++)
      u[d] = i[d] > o ? o : i[d];
    c = "M".concat(e, ",").concat(t + a * u[0]), u[0] > 0 && (c += "A ".concat(u[0], ",").concat(u[0], ",0,0,").concat(l, ",").concat(e + s * u[0], ",").concat(t)), c += "L ".concat(e + n - s * u[1], ",").concat(t), u[1] > 0 && (c += "A ".concat(u[1], ",").concat(u[1], ",0,0,").concat(l, `,
        `).concat(e + n, ",").concat(t + a * u[1])), c += "L ".concat(e + n, ",").concat(t + r - a * u[2]), u[2] > 0 && (c += "A ".concat(u[2], ",").concat(u[2], ",0,0,").concat(l, `,
        `).concat(e + n - s * u[2], ",").concat(t + r)), c += "L ".concat(e + s * u[3], ",").concat(t + r), u[3] > 0 && (c += "A ".concat(u[3], ",").concat(u[3], ",0,0,").concat(l, `,
        `).concat(e, ",").concat(t + r - a * u[3])), c += "Z";
  } else if (o > 0 && i === +i && i > 0) {
    var h = Math.min(o, i);
    c = "M ".concat(e, ",").concat(t + a * h, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(l, ",").concat(e + s * h, ",").concat(t, `
            L `).concat(e + n - s * h, ",").concat(t, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(l, ",").concat(e + n, ",").concat(t + a * h, `
            L `).concat(e + n, ",").concat(t + r - a * h, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(l, ",").concat(e + n - s * h, ",").concat(t + r, `
            L `).concat(e + s * h, ",").concat(t + r, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(l, ",").concat(e, ",").concat(t + r - a * h, " Z");
  } else
    c = "M ".concat(e, ",").concat(t, " h ").concat(n, " v ").concat(r, " h ").concat(-n, " Z");
  return c;
}, DF = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: !1,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, h2 = (e) => {
  var t = on(e, DF), n = Ne(null), [r, i] = Ke(-1);
  De(() => {
    if (n.current && n.current.getTotalLength)
      try {
        var N = n.current.getTotalLength();
        N && i(N);
      } catch {
      }
  }, []);
  var {
    x: o,
    y: a,
    width: s,
    height: l,
    radius: c,
    className: u
  } = t, {
    animationEasing: d,
    animationDuration: p,
    animationBegin: h,
    isAnimationActive: g,
    isUpdateAnimationActive: m
  } = t, v = Ne(s), y = Ne(l), S = Ne(o), w = Ne(a), b = Un(() => ({
    x: o,
    y: a,
    width: s,
    height: l,
    radius: c
  }), [o, a, s, l, c]), O = Vl(b, "rectangle-");
  if (o !== +o || a !== +a || s !== +s || l !== +l || s === 0 || l === 0)
    return null;
  var E = ie("recharts-rectangle", u);
  if (!m)
    return /* @__PURE__ */ _.createElement("path", Lu({}, wt(t, !0), {
      className: E,
      d: v1(o, a, s, l, c)
    }));
  var C = v.current, T = y.current, j = S.current, A = w.current, M = "0px ".concat(r === -1 ? 1 : r, "px"), P = "".concat(r, "px 0px"), R = u2(["strokeDasharray"], p, typeof d == "string" ? d : void 0);
  return /* @__PURE__ */ _.createElement(Wl, {
    animationId: O,
    key: O,
    canBegin: r > 0,
    duration: p,
    easing: d,
    isActive: m,
    begin: h
  }, (N) => {
    var D = _t(C, s, N), $ = _t(T, l, N), F = _t(j, o, N), q = _t(A, a, N);
    n.current && (v.current = D, y.current = $, S.current = F, w.current = q);
    var B;
    return g ? N > 0 ? B = {
      transition: R,
      strokeDasharray: P
    } : B = {
      strokeDasharray: M
    } : B = {
      strokeDasharray: P
    }, /* @__PURE__ */ _.createElement("path", Lu({}, wt(t, !0), {
      className: E,
      d: v1(F, q, D, $, c),
      ref: n,
      style: g1(g1({}, B), t.style)
    }));
  });
};
function m2(e) {
  var {
    cx: t,
    cy: n,
    radius: r,
    startAngle: i,
    endAngle: o
  } = e, a = $t(t, n, r, i), s = $t(t, n, r, o);
  return {
    points: [a, s],
    cx: t,
    cy: n,
    radius: r,
    startAngle: i,
    endAngle: o
  };
}
function Am() {
  return Am = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Am.apply(null, arguments);
}
var RF = (e, t) => {
  var n = Yt(t - e), r = Math.min(Math.abs(t - e), 359.999);
  return n * r;
}, Ac = (e) => {
  var {
    cx: t,
    cy: n,
    radius: r,
    angle: i,
    sign: o,
    isExternal: a,
    cornerRadius: s,
    cornerIsExternal: l
  } = e, c = s * (a ? 1 : -1) + r, u = Math.asin(s / c) / Ru, d = l ? i : i + o * u, p = $t(t, n, c, d), h = $t(t, n, r, d), g = l ? i - o * u : i, m = $t(t, n, c * Math.cos(u * Ru), g);
  return {
    center: p,
    circleTangency: h,
    lineTangency: m,
    theta: u
  };
}, g2 = (e) => {
  var {
    cx: t,
    cy: n,
    innerRadius: r,
    outerRadius: i,
    startAngle: o,
    endAngle: a
  } = e, s = RF(o, a), l = o + s, c = $t(t, n, i, o), u = $t(t, n, i, l), d = "M ".concat(c.x, ",").concat(c.y, `
    A `).concat(i, ",").concat(i, `,0,
    `).concat(+(Math.abs(s) > 180), ",").concat(+(o > l), `,
    `).concat(u.x, ",").concat(u.y, `
  `);
  if (r > 0) {
    var p = $t(t, n, r, o), h = $t(t, n, r, l);
    d += "L ".concat(h.x, ",").concat(h.y, `
            A `).concat(r, ",").concat(r, `,0,
            `).concat(+(Math.abs(s) > 180), ",").concat(+(o <= l), `,
            `).concat(p.x, ",").concat(p.y, " Z");
  } else
    d += "L ".concat(t, ",").concat(n, " Z");
  return d;
}, IF = (e) => {
  var {
    cx: t,
    cy: n,
    innerRadius: r,
    outerRadius: i,
    cornerRadius: o,
    forceCornerRadius: a,
    cornerIsExternal: s,
    startAngle: l,
    endAngle: c
  } = e, u = Yt(c - l), {
    circleTangency: d,
    lineTangency: p,
    theta: h
  } = Ac({
    cx: t,
    cy: n,
    radius: i,
    angle: l,
    sign: u,
    cornerRadius: o,
    cornerIsExternal: s
  }), {
    circleTangency: g,
    lineTangency: m,
    theta: v
  } = Ac({
    cx: t,
    cy: n,
    radius: i,
    angle: c,
    sign: -u,
    cornerRadius: o,
    cornerIsExternal: s
  }), y = s ? Math.abs(l - c) : Math.abs(l - c) - h - v;
  if (y < 0)
    return a ? "M ".concat(p.x, ",").concat(p.y, `
        a`).concat(o, ",").concat(o, ",0,0,1,").concat(o * 2, `,0
        a`).concat(o, ",").concat(o, ",0,0,1,").concat(-o * 2, `,0
      `) : g2({
      cx: t,
      cy: n,
      innerRadius: r,
      outerRadius: i,
      startAngle: l,
      endAngle: c
    });
  var S = "M ".concat(p.x, ",").concat(p.y, `
    A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(d.x, ",").concat(d.y, `
    A`).concat(i, ",").concat(i, ",0,").concat(+(y > 180), ",").concat(+(u < 0), ",").concat(g.x, ",").concat(g.y, `
    A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(m.x, ",").concat(m.y, `
  `);
  if (r > 0) {
    var {
      circleTangency: w,
      lineTangency: b,
      theta: O
    } = Ac({
      cx: t,
      cy: n,
      radius: r,
      angle: l,
      sign: u,
      isExternal: !0,
      cornerRadius: o,
      cornerIsExternal: s
    }), {
      circleTangency: E,
      lineTangency: C,
      theta: T
    } = Ac({
      cx: t,
      cy: n,
      radius: r,
      angle: c,
      sign: -u,
      isExternal: !0,
      cornerRadius: o,
      cornerIsExternal: s
    }), j = s ? Math.abs(l - c) : Math.abs(l - c) - O - T;
    if (j < 0 && o === 0)
      return "".concat(S, "L").concat(t, ",").concat(n, "Z");
    S += "L".concat(C.x, ",").concat(C.y, `
      A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(E.x, ",").concat(E.y, `
      A`).concat(r, ",").concat(r, ",0,").concat(+(j > 180), ",").concat(+(u > 0), ",").concat(w.x, ",").concat(w.y, `
      A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(b.x, ",").concat(b.y, "Z");
  } else
    S += "L".concat(t, ",").concat(n, "Z");
  return S;
}, $F = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: !1,
  cornerIsExternal: !1
}, v2 = (e) => {
  var t = on(e, $F), {
    cx: n,
    cy: r,
    innerRadius: i,
    outerRadius: o,
    cornerRadius: a,
    forceCornerRadius: s,
    cornerIsExternal: l,
    startAngle: c,
    endAngle: u,
    className: d
  } = t;
  if (o < i || c === u)
    return null;
  var p = ie("recharts-sector", d), h = o - i, g = hn(a, h, 0, !0), m;
  return g > 0 && Math.abs(c - u) < 360 ? m = IF({
    cx: n,
    cy: r,
    innerRadius: i,
    outerRadius: o,
    cornerRadius: Math.min(g, h / 2),
    forceCornerRadius: s,
    cornerIsExternal: l,
    startAngle: c,
    endAngle: u
  }) : m = g2({
    cx: n,
    cy: r,
    innerRadius: i,
    outerRadius: o,
    startAngle: c,
    endAngle: u
  }), /* @__PURE__ */ _.createElement("path", Am({}, wt(t, !0), {
    className: p,
    d: m
  }));
};
function LF(e, t, n) {
  var r, i, o, a;
  if (e === "horizontal")
    r = t.x, o = r, i = n.top, a = n.top + n.height;
  else if (e === "vertical")
    i = t.y, a = i, r = n.left, o = n.left + n.width;
  else if (t.cx != null && t.cy != null)
    if (e === "centric") {
      var {
        cx: s,
        cy: l,
        innerRadius: c,
        outerRadius: u,
        angle: d
      } = t, p = $t(s, l, c, d), h = $t(s, l, u, d);
      r = p.x, i = p.y, o = h.x, a = h.y;
    } else
      return m2(t);
  return [{
    x: r,
    y: i
  }, {
    x: o,
    y: a
  }];
}
var nh = {}, rh = {}, ih = {}, y1;
function FF() {
  return y1 || (y1 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ bP();
    function n(r) {
      return t.isSymbol(r) ? NaN : Number(r);
    }
    e.toNumber = n;
  })(ih)), ih;
}
var b1;
function BF() {
  return b1 || (b1 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ FF();
    function n(r) {
      return r ? (r = t.toNumber(r), r === 1 / 0 || r === -1 / 0 ? (r < 0 ? -1 : 1) * Number.MAX_VALUE : r === r ? r : 0) : r === 0 ? r : 0;
    }
    e.toFinite = n;
  })(rh)), rh;
}
var x1;
function zF() {
  return x1 || (x1 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ xP(), n = /* @__PURE__ */ BF();
    function r(i, o, a) {
      a && typeof a != "number" && t.isIterateeCall(i, o, a) && (o = a = void 0), i = n.toFinite(i), o === void 0 ? (o = i, i = 0) : o = n.toFinite(o), a = a === void 0 ? i < o ? 1 : -1 : n.toFinite(a);
      const s = Math.max(Math.ceil((o - i) / (a || 1)), 0), l = new Array(s);
      for (let c = 0; c < s; c++)
        l[c] = i, i += a;
      return l;
    }
    e.range = r;
  })(nh)), nh;
}
var oh, w1;
function WF() {
  return w1 || (w1 = 1, oh = zF().range), oh;
}
var VF = /* @__PURE__ */ WF();
const y2 = /* @__PURE__ */ xi(VF);
function Li(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function UF(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function ov(e) {
  let t, n, r;
  e.length !== 2 ? (t = Li, n = (s, l) => Li(e(s), l), r = (s, l) => e(s) - l) : (t = e === Li || e === UF ? e : HF, n = e, r = e);
  function i(s, l, c = 0, u = s.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = c + u >>> 1;
        n(s[d], l) < 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function o(s, l, c = 0, u = s.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = c + u >>> 1;
        n(s[d], l) <= 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function a(s, l, c = 0, u = s.length) {
    const d = i(s, l, c, u - 1);
    return d > c && r(s[d - 1], l) > -r(s[d], l) ? d - 1 : d;
  }
  return { left: i, center: a, right: o };
}
function HF() {
  return 0;
}
function b2(e) {
  return e === null ? NaN : +e;
}
function* qF(e, t) {
  for (let n of e)
    n != null && (n = +n) >= n && (yield n);
}
const KF = ov(Li), Ul = KF.right;
ov(b2).center;
class O1 extends Map {
  constructor(t, n = XF) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [r, i] of t) this.set(r, i);
  }
  get(t) {
    return super.get(S1(this, t));
  }
  has(t) {
    return super.has(S1(this, t));
  }
  set(t, n) {
    return super.set(YF(this, t), n);
  }
  delete(t) {
    return super.delete(GF(this, t));
  }
}
function S1({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function YF({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function GF({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function XF(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function ZF(e = Li) {
  if (e === Li) return x2;
  if (typeof e != "function") throw new TypeError("compare is not a function");
  return (t, n) => {
    const r = e(t, n);
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function x2(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
const JF = Math.sqrt(50), QF = Math.sqrt(10), e4 = Math.sqrt(2);
function Fu(e, t, n) {
  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), o = r / Math.pow(10, i), a = o >= JF ? 10 : o >= QF ? 5 : o >= e4 ? 2 : 1;
  let s, l, c;
  return i < 0 ? (c = Math.pow(10, -i) / a, s = Math.round(e * c), l = Math.round(t * c), s / c < e && ++s, l / c > t && --l, c = -c) : (c = Math.pow(10, i) * a, s = Math.round(e / c), l = Math.round(t / c), s * c < e && ++s, l * c > t && --l), l < s && 0.5 <= n && n < 2 ? Fu(e, t, n * 2) : [s, l, c];
}
function km(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const r = t < e, [i, o, a] = r ? Fu(t, e, n) : Fu(e, t, n);
  if (!(o >= i)) return [];
  const s = o - i + 1, l = new Array(s);
  if (r)
    if (a < 0) for (let c = 0; c < s; ++c) l[c] = (o - c) / -a;
    else for (let c = 0; c < s; ++c) l[c] = (o - c) * a;
  else if (a < 0) for (let c = 0; c < s; ++c) l[c] = (i + c) / -a;
  else for (let c = 0; c < s; ++c) l[c] = (i + c) * a;
  return l;
}
function Mm(e, t, n) {
  return t = +t, e = +e, n = +n, Fu(e, t, n)[2];
}
function jm(e, t, n) {
  t = +t, e = +e, n = +n;
  const r = t < e, i = r ? Mm(t, e, n) : Mm(e, t, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function E1(e, t) {
  let n;
  for (const r of e)
    r != null && (n < r || n === void 0 && r >= r) && (n = r);
  return n;
}
function _1(e, t) {
  let n;
  for (const r of e)
    r != null && (n > r || n === void 0 && r >= r) && (n = r);
  return n;
}
function w2(e, t, n = 0, r = 1 / 0, i) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r)) return e;
  for (i = i === void 0 ? x2 : ZF(i); r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, c = t - n + 1, u = Math.log(l), d = 0.5 * Math.exp(2 * u / 3), p = 0.5 * Math.sqrt(u * d * (l - d) / l) * (c - l / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - c * d / l + p)), g = Math.min(r, Math.floor(t + (l - c) * d / l + p));
      w2(e, t, h, g, i);
    }
    const o = e[t];
    let a = n, s = r;
    for (ps(e, n, t), i(e[r], o) > 0 && ps(e, n, r); a < s; ) {
      for (ps(e, a, s), ++a, --s; i(e[a], o) < 0; ) ++a;
      for (; i(e[s], o) > 0; ) --s;
    }
    i(e[n], o) === 0 ? ps(e, n, s) : (++s, ps(e, s, r)), s <= t && (n = s + 1), t <= s && (r = s - 1);
  }
  return e;
}
function ps(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function t4(e, t, n) {
  if (e = Float64Array.from(qF(e)), !(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2) return _1(e);
    if (t >= 1) return E1(e);
    var r, i = (r - 1) * t, o = Math.floor(i), a = E1(w2(e, o).subarray(0, o + 1)), s = _1(e.subarray(o + 1));
    return a + (s - a) * (i - o);
  }
}
function n4(e, t, n = b2) {
  if (!(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2) return +n(e[0], 0, e);
    if (t >= 1) return +n(e[r - 1], r - 1, e);
    var r, i = (r - 1) * t, o = Math.floor(i), a = +n(e[o], o, e), s = +n(e[o + 1], o + 1, e);
    return a + (s - a) * (i - o);
  }
}
function r4(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e + r * n;
  return o;
}
function yr(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Si(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const Nm = Symbol("implicit");
function av() {
  var e = new O1(), t = [], n = [], r = Nm;
  function i(o) {
    let a = e.get(o);
    if (a === void 0) {
      if (r !== Nm) return r;
      e.set(o, a = t.push(o) - 1);
    }
    return n[a % n.length];
  }
  return i.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new O1();
    for (const a of o)
      e.has(a) || e.set(a, t.push(a) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (n = Array.from(o), i) : n.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return av(t, n).unknown(r);
  }, yr.apply(i, arguments), i;
}
function sv() {
  var e = av().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, o, a, s = !1, l = 0, c = 0, u = 0.5;
  delete e.unknown;
  function d() {
    var p = t().length, h = i < r, g = h ? i : r, m = h ? r : i;
    o = (m - g) / Math.max(1, p - l + c * 2), s && (o = Math.floor(o)), g += (m - g - o * (p - l)) * u, a = o * (1 - l), s && (g = Math.round(g), a = Math.round(a));
    var v = r4(p).map(function(y) {
      return g + o * y;
    });
    return n(h ? v.reverse() : v);
  }
  return e.domain = function(p) {
    return arguments.length ? (t(p), d()) : t();
  }, e.range = function(p) {
    return arguments.length ? ([r, i] = p, r = +r, i = +i, d()) : [r, i];
  }, e.rangeRound = function(p) {
    return [r, i] = p, r = +r, i = +i, s = !0, d();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return o;
  }, e.round = function(p) {
    return arguments.length ? (s = !!p, d()) : s;
  }, e.padding = function(p) {
    return arguments.length ? (l = Math.min(1, c = +p), d()) : l;
  }, e.paddingInner = function(p) {
    return arguments.length ? (l = Math.min(1, p), d()) : l;
  }, e.paddingOuter = function(p) {
    return arguments.length ? (c = +p, d()) : c;
  }, e.align = function(p) {
    return arguments.length ? (u = Math.max(0, Math.min(1, p)), d()) : u;
  }, e.copy = function() {
    return sv(t(), [r, i]).round(s).paddingInner(l).paddingOuter(c).align(u);
  }, yr.apply(d(), arguments);
}
function O2(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return O2(t());
  }, e;
}
function i4() {
  return O2(sv.apply(null, arguments).paddingInner(1));
}
function lv(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function S2(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function Hl() {
}
var ll = 0.7, Bu = 1 / ll, Oa = "\\s*([+-]?\\d+)\\s*", cl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Lr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", o4 = /^#([0-9a-f]{3,8})$/, a4 = new RegExp(`^rgb\\(${Oa},${Oa},${Oa}\\)$`), s4 = new RegExp(`^rgb\\(${Lr},${Lr},${Lr}\\)$`), l4 = new RegExp(`^rgba\\(${Oa},${Oa},${Oa},${cl}\\)$`), c4 = new RegExp(`^rgba\\(${Lr},${Lr},${Lr},${cl}\\)$`), u4 = new RegExp(`^hsl\\(${cl},${Lr},${Lr}\\)$`), d4 = new RegExp(`^hsla\\(${cl},${Lr},${Lr},${cl}\\)$`), P1 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
lv(Hl, ul, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: C1,
  // Deprecated! Use color.formatHex.
  formatHex: C1,
  formatHex8: f4,
  formatHsl: p4,
  formatRgb: T1,
  toString: T1
});
function C1() {
  return this.rgb().formatHex();
}
function f4() {
  return this.rgb().formatHex8();
}
function p4() {
  return E2(this).formatHsl();
}
function T1() {
  return this.rgb().formatRgb();
}
function ul(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = o4.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? A1(t) : n === 3 ? new Tn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? kc(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? kc(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = a4.exec(e)) ? new Tn(t[1], t[2], t[3], 1) : (t = s4.exec(e)) ? new Tn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = l4.exec(e)) ? kc(t[1], t[2], t[3], t[4]) : (t = c4.exec(e)) ? kc(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = u4.exec(e)) ? j1(t[1], t[2] / 100, t[3] / 100, 1) : (t = d4.exec(e)) ? j1(t[1], t[2] / 100, t[3] / 100, t[4]) : P1.hasOwnProperty(e) ? A1(P1[e]) : e === "transparent" ? new Tn(NaN, NaN, NaN, 0) : null;
}
function A1(e) {
  return new Tn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function kc(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Tn(e, t, n, r);
}
function h4(e) {
  return e instanceof Hl || (e = ul(e)), e ? (e = e.rgb(), new Tn(e.r, e.g, e.b, e.opacity)) : new Tn();
}
function Dm(e, t, n, r) {
  return arguments.length === 1 ? h4(e) : new Tn(e, t, n, r ?? 1);
}
function Tn(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
lv(Tn, Dm, S2(Hl, {
  brighter(e) {
    return e = e == null ? Bu : Math.pow(Bu, e), new Tn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ll : Math.pow(ll, e), new Tn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Tn(jo(this.r), jo(this.g), jo(this.b), zu(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: k1,
  // Deprecated! Use color.formatHex.
  formatHex: k1,
  formatHex8: m4,
  formatRgb: M1,
  toString: M1
}));
function k1() {
  return `#${Eo(this.r)}${Eo(this.g)}${Eo(this.b)}`;
}
function m4() {
  return `#${Eo(this.r)}${Eo(this.g)}${Eo(this.b)}${Eo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function M1() {
  const e = zu(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${jo(this.r)}, ${jo(this.g)}, ${jo(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function zu(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function jo(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Eo(e) {
  return e = jo(e), (e < 16 ? "0" : "") + e.toString(16);
}
function j1(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new wr(e, t, n, r);
}
function E2(e) {
  if (e instanceof wr) return new wr(e.h, e.s, e.l, e.opacity);
  if (e instanceof Hl || (e = ul(e)), !e) return new wr();
  if (e instanceof wr) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), a = NaN, s = o - i, l = (o + i) / 2;
  return s ? (t === o ? a = (n - r) / s + (n < r) * 6 : n === o ? a = (r - t) / s + 2 : a = (t - n) / s + 4, s /= l < 0.5 ? o + i : 2 - o - i, a *= 60) : s = l > 0 && l < 1 ? 0 : a, new wr(a, s, l, e.opacity);
}
function g4(e, t, n, r) {
  return arguments.length === 1 ? E2(e) : new wr(e, t, n, r ?? 1);
}
function wr(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
lv(wr, g4, S2(Hl, {
  brighter(e) {
    return e = e == null ? Bu : Math.pow(Bu, e), new wr(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ll : Math.pow(ll, e), new wr(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new Tn(
      ah(e >= 240 ? e - 240 : e + 120, i, r),
      ah(e, i, r),
      ah(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new wr(N1(this.h), Mc(this.s), Mc(this.l), zu(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = zu(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${N1(this.h)}, ${Mc(this.s) * 100}%, ${Mc(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function N1(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Mc(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function ah(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const cv = (e) => () => e;
function v4(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function y4(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function b4(e) {
  return (e = +e) == 1 ? _2 : function(t, n) {
    return n - t ? y4(t, n, e) : cv(isNaN(t) ? n : t);
  };
}
function _2(e, t) {
  var n = t - e;
  return n ? v4(e, n) : cv(isNaN(e) ? t : e);
}
const D1 = (function e(t) {
  var n = b4(t);
  function r(i, o) {
    var a = n((i = Dm(i)).r, (o = Dm(o)).r), s = n(i.g, o.g), l = n(i.b, o.b), c = _2(i.opacity, o.opacity);
    return function(u) {
      return i.r = a(u), i.g = s(u), i.b = l(u), i.opacity = c(u), i + "";
    };
  }
  return r.gamma = e, r;
})(1);
function x4(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(o) {
    for (i = 0; i < n; ++i) r[i] = e[i] * (1 - o) + t[i] * o;
    return r;
  };
}
function w4(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function O4(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), o = new Array(n), a;
  for (a = 0; a < r; ++a) i[a] = Ha(e[a], t[a]);
  for (; a < n; ++a) o[a] = t[a];
  return function(s) {
    for (a = 0; a < r; ++a) o[a] = i[a](s);
    return o;
  };
}
function S4(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function Wu(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function E4(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = Ha(e[i], t[i]) : r[i] = t[i];
  return function(o) {
    for (i in n) r[i] = n[i](o);
    return r;
  };
}
var Rm = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, sh = new RegExp(Rm.source, "g");
function _4(e) {
  return function() {
    return e;
  };
}
function P4(e) {
  return function(t) {
    return e(t) + "";
  };
}
function C4(e, t) {
  var n = Rm.lastIndex = sh.lastIndex = 0, r, i, o, a = -1, s = [], l = [];
  for (e = e + "", t = t + ""; (r = Rm.exec(e)) && (i = sh.exec(t)); )
    (o = i.index) > n && (o = t.slice(n, o), s[a] ? s[a] += o : s[++a] = o), (r = r[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null, l.push({ i: a, x: Wu(r, i) })), n = sh.lastIndex;
  return n < t.length && (o = t.slice(n), s[a] ? s[a] += o : s[++a] = o), s.length < 2 ? l[0] ? P4(l[0].x) : _4(t) : (t = l.length, function(c) {
    for (var u = 0, d; u < t; ++u) s[(d = l[u]).i] = d.x(c);
    return s.join("");
  });
}
function Ha(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? cv(t) : (n === "number" ? Wu : n === "string" ? (r = ul(t)) ? (t = r, D1) : C4 : t instanceof ul ? D1 : t instanceof Date ? S4 : w4(t) ? x4 : Array.isArray(t) ? O4 : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? E4 : Wu)(e, t);
}
function uv(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
function T4(e, t) {
  t === void 0 && (t = e, e = Ha);
  for (var n = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); n < r; ) o[n] = e(i, i = t[++n]);
  return function(a) {
    var s = Math.max(0, Math.min(r - 1, Math.floor(a *= r)));
    return o[s](a - s);
  };
}
function A4(e) {
  return function() {
    return e;
  };
}
function Vu(e) {
  return +e;
}
var R1 = [0, 1];
function yn(e) {
  return e;
}
function Im(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : A4(isNaN(t) ? NaN : 0.5);
}
function k4(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function M4(e, t, n) {
  var r = e[0], i = e[1], o = t[0], a = t[1];
  return i < r ? (r = Im(i, r), o = n(a, o)) : (r = Im(r, i), o = n(o, a)), function(s) {
    return o(r(s));
  };
}
function j4(e, t, n) {
  var r = Math.min(e.length, t.length) - 1, i = new Array(r), o = new Array(r), a = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )
    i[a] = Im(e[a], e[a + 1]), o[a] = n(t[a], t[a + 1]);
  return function(s) {
    var l = Ul(e, s, 1, r) - 1;
    return o[l](i[l](s));
  };
}
function ql(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function nf() {
  var e = R1, t = R1, n = Ha, r, i, o, a = yn, s, l, c;
  function u() {
    var p = Math.min(e.length, t.length);
    return a !== yn && (a = k4(e[0], e[p - 1])), s = p > 2 ? j4 : M4, l = c = null, d;
  }
  function d(p) {
    return p == null || isNaN(p = +p) ? o : (l || (l = s(e.map(r), t, n)))(r(a(p)));
  }
  return d.invert = function(p) {
    return a(i((c || (c = s(t, e.map(r), Wu)))(p)));
  }, d.domain = function(p) {
    return arguments.length ? (e = Array.from(p, Vu), u()) : e.slice();
  }, d.range = function(p) {
    return arguments.length ? (t = Array.from(p), u()) : t.slice();
  }, d.rangeRound = function(p) {
    return t = Array.from(p), n = uv, u();
  }, d.clamp = function(p) {
    return arguments.length ? (a = p ? !0 : yn, u()) : a !== yn;
  }, d.interpolate = function(p) {
    return arguments.length ? (n = p, u()) : n;
  }, d.unknown = function(p) {
    return arguments.length ? (o = p, d) : o;
  }, function(p, h) {
    return r = p, i = h, u();
  };
}
function dv() {
  return nf()(yn, yn);
}
function N4(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Uu(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
  var n, r = e.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(n + 1)
  ];
}
function Ma(e) {
  return e = Uu(Math.abs(e)), e ? e[1] : NaN;
}
function D4(e, t) {
  return function(n, r) {
    for (var i = n.length, o = [], a = 0, s = e[0], l = 0; i > 0 && s > 0 && (l + s + 1 > r && (s = Math.max(1, r - l)), o.push(n.substring(i -= s, i + s)), !((l += s + 1) > r)); )
      s = e[a = (a + 1) % e.length];
    return o.reverse().join(t);
  };
}
function R4(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var I4 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function dl(e) {
  if (!(t = I4.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new fv({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
dl.prototype = fv.prototype;
function fv(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
fv.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function $4(e) {
  e: for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
    switch (e[n]) {
      case ".":
        r = i = n;
        break;
      case "0":
        r === 0 && (r = n), i = n;
        break;
      default:
        if (!+e[n]) break e;
        r > 0 && (r = 0);
        break;
    }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
}
var P2;
function L4(e, t) {
  var n = Uu(e, t);
  if (!n) return e + "";
  var r = n[0], i = n[1], o = i - (P2 = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;
  return o === a ? r : o > a ? r + new Array(o - a + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + Uu(e, Math.max(0, t + o - 1))[0];
}
function I1(e, t) {
  var n = Uu(e, t);
  if (!n) return e + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const $1 = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: N4,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => I1(e * 100, t),
  r: I1,
  s: L4,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function L1(e) {
  return e;
}
var F1 = Array.prototype.map, B1 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function F4(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? L1 : D4(F1.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? L1 : R4(F1.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", s = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function c(d) {
    d = dl(d);
    var p = d.fill, h = d.align, g = d.sign, m = d.symbol, v = d.zero, y = d.width, S = d.comma, w = d.precision, b = d.trim, O = d.type;
    O === "n" ? (S = !0, O = "g") : $1[O] || (w === void 0 && (w = 12), b = !0, O = "g"), (v || p === "0" && h === "=") && (v = !0, p = "0", h = "=");
    var E = m === "$" ? n : m === "#" && /[boxX]/.test(O) ? "0" + O.toLowerCase() : "", C = m === "$" ? r : /[%p]/.test(O) ? a : "", T = $1[O], j = /[defgprs%]/.test(O);
    w = w === void 0 ? 6 : /[gprs]/.test(O) ? Math.max(1, Math.min(21, w)) : Math.max(0, Math.min(20, w));
    function A(M) {
      var P = E, R = C, N, D, $;
      if (O === "c")
        R = T(M) + R, M = "";
      else {
        M = +M;
        var F = M < 0 || 1 / M < 0;
        if (M = isNaN(M) ? l : T(Math.abs(M), w), b && (M = $4(M)), F && +M == 0 && g !== "+" && (F = !1), P = (F ? g === "(" ? g : s : g === "-" || g === "(" ? "" : g) + P, R = (O === "s" ? B1[8 + P2 / 3] : "") + R + (F && g === "(" ? ")" : ""), j) {
          for (N = -1, D = M.length; ++N < D; )
            if ($ = M.charCodeAt(N), 48 > $ || $ > 57) {
              R = ($ === 46 ? i + M.slice(N + 1) : M.slice(N)) + R, M = M.slice(0, N);
              break;
            }
        }
      }
      S && !v && (M = t(M, 1 / 0));
      var q = P.length + M.length + R.length, B = q < y ? new Array(y - q + 1).join(p) : "";
      switch (S && v && (M = t(B + M, B.length ? y - R.length : 1 / 0), B = ""), h) {
        case "<":
          M = P + M + R + B;
          break;
        case "=":
          M = P + B + M + R;
          break;
        case "^":
          M = B.slice(0, q = B.length >> 1) + P + M + R + B.slice(q);
          break;
        default:
          M = B + P + M + R;
          break;
      }
      return o(M);
    }
    return A.toString = function() {
      return d + "";
    }, A;
  }
  function u(d, p) {
    var h = c((d = dl(d), d.type = "f", d)), g = Math.max(-8, Math.min(8, Math.floor(Ma(p) / 3))) * 3, m = Math.pow(10, -g), v = B1[8 + g / 3];
    return function(y) {
      return h(m * y) + v;
    };
  }
  return {
    format: c,
    formatPrefix: u
  };
}
var jc, pv, C2;
B4({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function B4(e) {
  return jc = F4(e), pv = jc.format, C2 = jc.formatPrefix, jc;
}
function z4(e) {
  return Math.max(0, -Ma(Math.abs(e)));
}
function W4(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Ma(t) / 3))) * 3 - Ma(Math.abs(e)));
}
function V4(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Ma(t) - Ma(e)) + 1;
}
function T2(e, t, n, r) {
  var i = jm(e, t, n), o;
  switch (r = dl(r ?? ",f"), r.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(o = W4(i, a)) && (r.precision = o), C2(r, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(o = V4(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = o - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(o = z4(i)) && (r.precision = o - (r.type === "%") * 2);
      break;
    }
  }
  return pv(r);
}
function Ji(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var r = t();
    return km(r[0], r[r.length - 1], n ?? 10);
  }, e.tickFormat = function(n, r) {
    var i = t();
    return T2(i[0], i[i.length - 1], n ?? 10, r);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, o = r.length - 1, a = r[i], s = r[o], l, c, u = 10;
    for (s < a && (c = a, a = s, s = c, c = i, i = o, o = c); u-- > 0; ) {
      if (c = Mm(a, s, n), c === l)
        return r[i] = a, r[o] = s, t(r);
      if (c > 0)
        a = Math.floor(a / c) * c, s = Math.ceil(s / c) * c;
      else if (c < 0)
        a = Math.ceil(a * c) / c, s = Math.floor(s * c) / c;
      else
        break;
      l = c;
    }
    return e;
  }, e;
}
function A2() {
  var e = dv();
  return e.copy = function() {
    return ql(e, A2());
  }, yr.apply(e, arguments), Ji(e);
}
function k2(e) {
  var t;
  function n(r) {
    return r == null || isNaN(r = +r) ? t : r;
  }
  return n.invert = n, n.domain = n.range = function(r) {
    return arguments.length ? (e = Array.from(r, Vu), n) : e.slice();
  }, n.unknown = function(r) {
    return arguments.length ? (t = r, n) : t;
  }, n.copy = function() {
    return k2(e).unknown(t);
  }, e = arguments.length ? Array.from(e, Vu) : [0, 1], Ji(n);
}
function M2(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], o = e[r], a;
  return o < i && (a = n, n = r, r = a, a = i, i = o, o = a), e[n] = t.floor(i), e[r] = t.ceil(o), e;
}
function z1(e) {
  return Math.log(e);
}
function W1(e) {
  return Math.exp(e);
}
function U4(e) {
  return -Math.log(-e);
}
function H4(e) {
  return -Math.exp(-e);
}
function q4(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function K4(e) {
  return e === 10 ? q4 : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function Y4(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function V1(e) {
  return (t, n) => -e(-t, n);
}
function hv(e) {
  const t = e(z1, W1), n = t.domain;
  let r = 10, i, o;
  function a() {
    return i = Y4(r), o = K4(r), n()[0] < 0 ? (i = V1(i), o = V1(o), e(U4, H4)) : e(z1, W1), t;
  }
  return t.base = function(s) {
    return arguments.length ? (r = +s, a()) : r;
  }, t.domain = function(s) {
    return arguments.length ? (n(s), a()) : n();
  }, t.ticks = (s) => {
    const l = n();
    let c = l[0], u = l[l.length - 1];
    const d = u < c;
    d && ([c, u] = [u, c]);
    let p = i(c), h = i(u), g, m;
    const v = s == null ? 10 : +s;
    let y = [];
    if (!(r % 1) && h - p < v) {
      if (p = Math.floor(p), h = Math.ceil(h), c > 0) {
        for (; p <= h; ++p)
          for (g = 1; g < r; ++g)
            if (m = p < 0 ? g / o(-p) : g * o(p), !(m < c)) {
              if (m > u) break;
              y.push(m);
            }
      } else for (; p <= h; ++p)
        for (g = r - 1; g >= 1; --g)
          if (m = p > 0 ? g / o(-p) : g * o(p), !(m < c)) {
            if (m > u) break;
            y.push(m);
          }
      y.length * 2 < v && (y = km(c, u, v));
    } else
      y = km(p, h, Math.min(h - p, v)).map(o);
    return d ? y.reverse() : y;
  }, t.tickFormat = (s, l) => {
    if (s == null && (s = 10), l == null && (l = r === 10 ? "s" : ","), typeof l != "function" && (!(r % 1) && (l = dl(l)).precision == null && (l.trim = !0), l = pv(l)), s === 1 / 0) return l;
    const c = Math.max(1, r * s / t.ticks().length);
    return (u) => {
      let d = u / o(Math.round(i(u)));
      return d * r < r - 0.5 && (d *= r), d <= c ? l(u) : "";
    };
  }, t.nice = () => n(M2(n(), {
    floor: (s) => o(Math.floor(i(s))),
    ceil: (s) => o(Math.ceil(i(s)))
  })), t;
}
function j2() {
  const e = hv(nf()).domain([1, 10]);
  return e.copy = () => ql(e, j2()).base(e.base()), yr.apply(e, arguments), e;
}
function U1(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function H1(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function mv(e) {
  var t = 1, n = e(U1(t), H1(t));
  return n.constant = function(r) {
    return arguments.length ? e(U1(t = +r), H1(t)) : t;
  }, Ji(n);
}
function N2() {
  var e = mv(nf());
  return e.copy = function() {
    return ql(e, N2()).constant(e.constant());
  }, yr.apply(e, arguments);
}
function q1(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function G4(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function X4(e) {
  return e < 0 ? -e * e : e * e;
}
function gv(e) {
  var t = e(yn, yn), n = 1;
  function r() {
    return n === 1 ? e(yn, yn) : n === 0.5 ? e(G4, X4) : e(q1(n), q1(1 / n));
  }
  return t.exponent = function(i) {
    return arguments.length ? (n = +i, r()) : n;
  }, Ji(t);
}
function vv() {
  var e = gv(nf());
  return e.copy = function() {
    return ql(e, vv()).exponent(e.exponent());
  }, yr.apply(e, arguments), e;
}
function Z4() {
  return vv.apply(null, arguments).exponent(0.5);
}
function K1(e) {
  return Math.sign(e) * e * e;
}
function J4(e) {
  return Math.sign(e) * Math.sqrt(Math.abs(e));
}
function D2() {
  var e = dv(), t = [0, 1], n = !1, r;
  function i(o) {
    var a = J4(e(o));
    return isNaN(a) ? r : n ? Math.round(a) : a;
  }
  return i.invert = function(o) {
    return e.invert(K1(o));
  }, i.domain = function(o) {
    return arguments.length ? (e.domain(o), i) : e.domain();
  }, i.range = function(o) {
    return arguments.length ? (e.range((t = Array.from(o, Vu)).map(K1)), i) : t.slice();
  }, i.rangeRound = function(o) {
    return i.range(o).round(!0);
  }, i.round = function(o) {
    return arguments.length ? (n = !!o, i) : n;
  }, i.clamp = function(o) {
    return arguments.length ? (e.clamp(o), i) : e.clamp();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return D2(e.domain(), t).round(n).clamp(e.clamp()).unknown(r);
  }, yr.apply(i, arguments), Ji(i);
}
function R2() {
  var e = [], t = [], n = [], r;
  function i() {
    var a = 0, s = Math.max(1, t.length);
    for (n = new Array(s - 1); ++a < s; ) n[a - 1] = n4(e, a / s);
    return o;
  }
  function o(a) {
    return a == null || isNaN(a = +a) ? r : t[Ul(n, a)];
  }
  return o.invertExtent = function(a) {
    var s = t.indexOf(a);
    return s < 0 ? [NaN, NaN] : [
      s > 0 ? n[s - 1] : e[0],
      s < n.length ? n[s] : e[e.length - 1]
    ];
  }, o.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let s of a) s != null && !isNaN(s = +s) && e.push(s);
    return e.sort(Li), i();
  }, o.range = function(a) {
    return arguments.length ? (t = Array.from(a), i()) : t.slice();
  }, o.unknown = function(a) {
    return arguments.length ? (r = a, o) : r;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return R2().domain(e).range(t).unknown(r);
  }, yr.apply(o, arguments);
}
function I2() {
  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], o;
  function a(l) {
    return l != null && l <= l ? i[Ul(r, l, 0, n)] : o;
  }
  function s() {
    var l = -1;
    for (r = new Array(n); ++l < n; ) r[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
    return a;
  }
  return a.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, s()) : [e, t];
  }, a.range = function(l) {
    return arguments.length ? (n = (i = Array.from(l)).length - 1, s()) : i.slice();
  }, a.invertExtent = function(l) {
    var c = i.indexOf(l);
    return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]];
  }, a.unknown = function(l) {
    return arguments.length && (o = l), a;
  }, a.thresholds = function() {
    return r.slice();
  }, a.copy = function() {
    return I2().domain([e, t]).range(i).unknown(o);
  }, yr.apply(Ji(a), arguments);
}
function $2() {
  var e = [0.5], t = [0, 1], n, r = 1;
  function i(o) {
    return o != null && o <= o ? t[Ul(e, o, 0, r)] : n;
  }
  return i.domain = function(o) {
    return arguments.length ? (e = Array.from(o), r = Math.min(e.length, t.length - 1), i) : e.slice();
  }, i.range = function(o) {
    return arguments.length ? (t = Array.from(o), r = Math.min(e.length, t.length - 1), i) : t.slice();
  }, i.invertExtent = function(o) {
    var a = t.indexOf(o);
    return [e[a - 1], e[a]];
  }, i.unknown = function(o) {
    return arguments.length ? (n = o, i) : n;
  }, i.copy = function() {
    return $2().domain(e).range(t).unknown(n);
  }, yr.apply(i, arguments);
}
const lh = /* @__PURE__ */ new Date(), ch = /* @__PURE__ */ new Date();
function Wt(e, t, n, r) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), i.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), i.round = (o) => {
    const a = i(o), s = i.ceil(o);
    return o - a < s - o ? a : s;
  }, i.offset = (o, a) => (t(o = /* @__PURE__ */ new Date(+o), a == null ? 1 : Math.floor(a)), o), i.range = (o, a, s) => {
    const l = [];
    if (o = i.ceil(o), s = s == null ? 1 : Math.floor(s), !(o < a) || !(s > 0)) return l;
    let c;
    do
      l.push(c = /* @__PURE__ */ new Date(+o)), t(o, s), e(o);
    while (c < o && o < a);
    return l;
  }, i.filter = (o) => Wt((a) => {
    if (a >= a) for (; e(a), !o(a); ) a.setTime(a - 1);
  }, (a, s) => {
    if (a >= a)
      if (s < 0) for (; ++s <= 0; )
        for (; t(a, -1), !o(a); )
          ;
      else for (; --s >= 0; )
        for (; t(a, 1), !o(a); )
          ;
  }), n && (i.count = (o, a) => (lh.setTime(+o), ch.setTime(+a), e(lh), e(ch), Math.floor(n(lh, ch))), i.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(r ? (a) => r(a) % o === 0 : (a) => i.count(0, a) % o === 0) : i)), i;
}
const Hu = Wt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Hu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Wt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Hu);
Hu.range;
const ai = 1e3, lr = ai * 60, si = lr * 60, mi = si * 24, yv = mi * 7, Y1 = mi * 30, uh = mi * 365, _o = Wt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * ai);
}, (e, t) => (t - e) / ai, (e) => e.getUTCSeconds());
_o.range;
const bv = Wt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ai);
}, (e, t) => {
  e.setTime(+e + t * lr);
}, (e, t) => (t - e) / lr, (e) => e.getMinutes());
bv.range;
const xv = Wt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * lr);
}, (e, t) => (t - e) / lr, (e) => e.getUTCMinutes());
xv.range;
const wv = Wt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ai - e.getMinutes() * lr);
}, (e, t) => {
  e.setTime(+e + t * si);
}, (e, t) => (t - e) / si, (e) => e.getHours());
wv.range;
const Ov = Wt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * si);
}, (e, t) => (t - e) / si, (e) => e.getUTCHours());
Ov.range;
const Kl = Wt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * lr) / mi,
  (e) => e.getDate() - 1
);
Kl.range;
const rf = Wt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / mi, (e) => e.getUTCDate() - 1);
rf.range;
const L2 = Wt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / mi, (e) => Math.floor(e / mi));
L2.range;
function Ko(e) {
  return Wt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * lr) / yv);
}
const of = Ko(0), qu = Ko(1), Q4 = Ko(2), eB = Ko(3), ja = Ko(4), tB = Ko(5), nB = Ko(6);
of.range;
qu.range;
Q4.range;
eB.range;
ja.range;
tB.range;
nB.range;
function Yo(e) {
  return Wt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / yv);
}
const af = Yo(0), Ku = Yo(1), rB = Yo(2), iB = Yo(3), Na = Yo(4), oB = Yo(5), aB = Yo(6);
af.range;
Ku.range;
rB.range;
iB.range;
Na.range;
oB.range;
aB.range;
const Sv = Wt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
Sv.range;
const Ev = Wt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
Ev.range;
const gi = Wt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
gi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Wt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
gi.range;
const vi = Wt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
vi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Wt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
vi.range;
function F2(e, t, n, r, i, o) {
  const a = [
    [_o, 1, ai],
    [_o, 5, 5 * ai],
    [_o, 15, 15 * ai],
    [_o, 30, 30 * ai],
    [o, 1, lr],
    [o, 5, 5 * lr],
    [o, 15, 15 * lr],
    [o, 30, 30 * lr],
    [i, 1, si],
    [i, 3, 3 * si],
    [i, 6, 6 * si],
    [i, 12, 12 * si],
    [r, 1, mi],
    [r, 2, 2 * mi],
    [n, 1, yv],
    [t, 1, Y1],
    [t, 3, 3 * Y1],
    [e, 1, uh]
  ];
  function s(c, u, d) {
    const p = u < c;
    p && ([c, u] = [u, c]);
    const h = d && typeof d.range == "function" ? d : l(c, u, d), g = h ? h.range(c, +u + 1) : [];
    return p ? g.reverse() : g;
  }
  function l(c, u, d) {
    const p = Math.abs(u - c) / d, h = ov(([, , v]) => v).right(a, p);
    if (h === a.length) return e.every(jm(c / uh, u / uh, d));
    if (h === 0) return Hu.every(Math.max(jm(c, u, d), 1));
    const [g, m] = a[p / a[h - 1][2] < a[h][2] / p ? h - 1 : h];
    return g.every(m);
  }
  return [s, l];
}
const [sB, lB] = F2(vi, Ev, af, L2, Ov, xv), [cB, uB] = F2(gi, Sv, of, Kl, wv, bv);
function dh(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function fh(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function hs(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function dB(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, o = e.days, a = e.shortDays, s = e.months, l = e.shortMonths, c = ms(i), u = gs(i), d = ms(o), p = gs(o), h = ms(a), g = gs(a), m = ms(s), v = gs(s), y = ms(l), S = gs(l), w = {
    a: F,
    A: q,
    b: B,
    B: L,
    c: null,
    d: ew,
    e: ew,
    f: DB,
    g: UB,
    G: qB,
    H: MB,
    I: jB,
    j: NB,
    L: B2,
    m: RB,
    M: IB,
    p: Y,
    q: K,
    Q: rw,
    s: iw,
    S: $B,
    u: LB,
    U: FB,
    V: BB,
    w: zB,
    W: WB,
    x: null,
    X: null,
    y: VB,
    Y: HB,
    Z: KB,
    "%": nw
  }, b = {
    a: te,
    A: J,
    b: G,
    B: ee,
    c: null,
    d: tw,
    e: tw,
    f: ZB,
    g: s6,
    G: c6,
    H: YB,
    I: GB,
    j: XB,
    L: W2,
    m: JB,
    M: QB,
    p: re,
    q: oe,
    Q: rw,
    s: iw,
    S: e6,
    u: t6,
    U: n6,
    V: r6,
    w: i6,
    W: o6,
    x: null,
    X: null,
    y: a6,
    Y: l6,
    Z: u6,
    "%": nw
  }, O = {
    a: A,
    A: M,
    b: P,
    B: R,
    c: N,
    d: J1,
    e: J1,
    f: CB,
    g: Z1,
    G: X1,
    H: Q1,
    I: Q1,
    j: SB,
    L: PB,
    m: OB,
    M: EB,
    p: j,
    q: wB,
    Q: AB,
    s: kB,
    S: _B,
    u: gB,
    U: vB,
    V: yB,
    w: mB,
    W: bB,
    x: D,
    X: $,
    y: Z1,
    Y: X1,
    Z: xB,
    "%": TB
  };
  w.x = E(n, w), w.X = E(r, w), w.c = E(t, w), b.x = E(n, b), b.X = E(r, b), b.c = E(t, b);
  function E(W, U) {
    return function(Z) {
      var k = [], de = -1, ne = 0, he = W.length, xe, Oe, Ee;
      for (Z instanceof Date || (Z = /* @__PURE__ */ new Date(+Z)); ++de < he; )
        W.charCodeAt(de) === 37 && (k.push(W.slice(ne, de)), (Oe = G1[xe = W.charAt(++de)]) != null ? xe = W.charAt(++de) : Oe = xe === "e" ? " " : "0", (Ee = U[xe]) && (xe = Ee(Z, Oe)), k.push(xe), ne = de + 1);
      return k.push(W.slice(ne, de)), k.join("");
    };
  }
  function C(W, U) {
    return function(Z) {
      var k = hs(1900, void 0, 1), de = T(k, W, Z += "", 0), ne, he;
      if (de != Z.length) return null;
      if ("Q" in k) return new Date(k.Q);
      if ("s" in k) return new Date(k.s * 1e3 + ("L" in k ? k.L : 0));
      if (U && !("Z" in k) && (k.Z = 0), "p" in k && (k.H = k.H % 12 + k.p * 12), k.m === void 0 && (k.m = "q" in k ? k.q : 0), "V" in k) {
        if (k.V < 1 || k.V > 53) return null;
        "w" in k || (k.w = 1), "Z" in k ? (ne = fh(hs(k.y, 0, 1)), he = ne.getUTCDay(), ne = he > 4 || he === 0 ? Ku.ceil(ne) : Ku(ne), ne = rf.offset(ne, (k.V - 1) * 7), k.y = ne.getUTCFullYear(), k.m = ne.getUTCMonth(), k.d = ne.getUTCDate() + (k.w + 6) % 7) : (ne = dh(hs(k.y, 0, 1)), he = ne.getDay(), ne = he > 4 || he === 0 ? qu.ceil(ne) : qu(ne), ne = Kl.offset(ne, (k.V - 1) * 7), k.y = ne.getFullYear(), k.m = ne.getMonth(), k.d = ne.getDate() + (k.w + 6) % 7);
      } else ("W" in k || "U" in k) && ("w" in k || (k.w = "u" in k ? k.u % 7 : "W" in k ? 1 : 0), he = "Z" in k ? fh(hs(k.y, 0, 1)).getUTCDay() : dh(hs(k.y, 0, 1)).getDay(), k.m = 0, k.d = "W" in k ? (k.w + 6) % 7 + k.W * 7 - (he + 5) % 7 : k.w + k.U * 7 - (he + 6) % 7);
      return "Z" in k ? (k.H += k.Z / 100 | 0, k.M += k.Z % 100, fh(k)) : dh(k);
    };
  }
  function T(W, U, Z, k) {
    for (var de = 0, ne = U.length, he = Z.length, xe, Oe; de < ne; ) {
      if (k >= he) return -1;
      if (xe = U.charCodeAt(de++), xe === 37) {
        if (xe = U.charAt(de++), Oe = O[xe in G1 ? U.charAt(de++) : xe], !Oe || (k = Oe(W, Z, k)) < 0) return -1;
      } else if (xe != Z.charCodeAt(k++))
        return -1;
    }
    return k;
  }
  function j(W, U, Z) {
    var k = c.exec(U.slice(Z));
    return k ? (W.p = u.get(k[0].toLowerCase()), Z + k[0].length) : -1;
  }
  function A(W, U, Z) {
    var k = h.exec(U.slice(Z));
    return k ? (W.w = g.get(k[0].toLowerCase()), Z + k[0].length) : -1;
  }
  function M(W, U, Z) {
    var k = d.exec(U.slice(Z));
    return k ? (W.w = p.get(k[0].toLowerCase()), Z + k[0].length) : -1;
  }
  function P(W, U, Z) {
    var k = y.exec(U.slice(Z));
    return k ? (W.m = S.get(k[0].toLowerCase()), Z + k[0].length) : -1;
  }
  function R(W, U, Z) {
    var k = m.exec(U.slice(Z));
    return k ? (W.m = v.get(k[0].toLowerCase()), Z + k[0].length) : -1;
  }
  function N(W, U, Z) {
    return T(W, t, U, Z);
  }
  function D(W, U, Z) {
    return T(W, n, U, Z);
  }
  function $(W, U, Z) {
    return T(W, r, U, Z);
  }
  function F(W) {
    return a[W.getDay()];
  }
  function q(W) {
    return o[W.getDay()];
  }
  function B(W) {
    return l[W.getMonth()];
  }
  function L(W) {
    return s[W.getMonth()];
  }
  function Y(W) {
    return i[+(W.getHours() >= 12)];
  }
  function K(W) {
    return 1 + ~~(W.getMonth() / 3);
  }
  function te(W) {
    return a[W.getUTCDay()];
  }
  function J(W) {
    return o[W.getUTCDay()];
  }
  function G(W) {
    return l[W.getUTCMonth()];
  }
  function ee(W) {
    return s[W.getUTCMonth()];
  }
  function re(W) {
    return i[+(W.getUTCHours() >= 12)];
  }
  function oe(W) {
    return 1 + ~~(W.getUTCMonth() / 3);
  }
  return {
    format: function(W) {
      var U = E(W += "", w);
      return U.toString = function() {
        return W;
      }, U;
    },
    parse: function(W) {
      var U = C(W += "", !1);
      return U.toString = function() {
        return W;
      }, U;
    },
    utcFormat: function(W) {
      var U = E(W += "", b);
      return U.toString = function() {
        return W;
      }, U;
    },
    utcParse: function(W) {
      var U = C(W += "", !0);
      return U.toString = function() {
        return W;
      }, U;
    }
  };
}
var G1 = { "-": "", _: " ", 0: "0" }, Xt = /^\s*\d+/, fB = /^%/, pB = /[\\^$*+?|[\]().{}]/g;
function Ae(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", o = i.length;
  return r + (o < n ? new Array(n - o + 1).join(t) + i : i);
}
function hB(e) {
  return e.replace(pB, "\\$&");
}
function ms(e) {
  return new RegExp("^(?:" + e.map(hB).join("|") + ")", "i");
}
function gs(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function mB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function gB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function vB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function yB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function bB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function X1(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function Z1(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function xB(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function wB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function OB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function J1(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function SB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function Q1(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function EB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function _B(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function PB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function CB(e, t, n) {
  var r = Xt.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function TB(e, t, n) {
  var r = fB.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function AB(e, t, n) {
  var r = Xt.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function kB(e, t, n) {
  var r = Xt.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function ew(e, t) {
  return Ae(e.getDate(), t, 2);
}
function MB(e, t) {
  return Ae(e.getHours(), t, 2);
}
function jB(e, t) {
  return Ae(e.getHours() % 12 || 12, t, 2);
}
function NB(e, t) {
  return Ae(1 + Kl.count(gi(e), e), t, 3);
}
function B2(e, t) {
  return Ae(e.getMilliseconds(), t, 3);
}
function DB(e, t) {
  return B2(e, t) + "000";
}
function RB(e, t) {
  return Ae(e.getMonth() + 1, t, 2);
}
function IB(e, t) {
  return Ae(e.getMinutes(), t, 2);
}
function $B(e, t) {
  return Ae(e.getSeconds(), t, 2);
}
function LB(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function FB(e, t) {
  return Ae(of.count(gi(e) - 1, e), t, 2);
}
function z2(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ja(e) : ja.ceil(e);
}
function BB(e, t) {
  return e = z2(e), Ae(ja.count(gi(e), e) + (gi(e).getDay() === 4), t, 2);
}
function zB(e) {
  return e.getDay();
}
function WB(e, t) {
  return Ae(qu.count(gi(e) - 1, e), t, 2);
}
function VB(e, t) {
  return Ae(e.getFullYear() % 100, t, 2);
}
function UB(e, t) {
  return e = z2(e), Ae(e.getFullYear() % 100, t, 2);
}
function HB(e, t) {
  return Ae(e.getFullYear() % 1e4, t, 4);
}
function qB(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? ja(e) : ja.ceil(e), Ae(e.getFullYear() % 1e4, t, 4);
}
function KB(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ae(t / 60 | 0, "0", 2) + Ae(t % 60, "0", 2);
}
function tw(e, t) {
  return Ae(e.getUTCDate(), t, 2);
}
function YB(e, t) {
  return Ae(e.getUTCHours(), t, 2);
}
function GB(e, t) {
  return Ae(e.getUTCHours() % 12 || 12, t, 2);
}
function XB(e, t) {
  return Ae(1 + rf.count(vi(e), e), t, 3);
}
function W2(e, t) {
  return Ae(e.getUTCMilliseconds(), t, 3);
}
function ZB(e, t) {
  return W2(e, t) + "000";
}
function JB(e, t) {
  return Ae(e.getUTCMonth() + 1, t, 2);
}
function QB(e, t) {
  return Ae(e.getUTCMinutes(), t, 2);
}
function e6(e, t) {
  return Ae(e.getUTCSeconds(), t, 2);
}
function t6(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function n6(e, t) {
  return Ae(af.count(vi(e) - 1, e), t, 2);
}
function V2(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Na(e) : Na.ceil(e);
}
function r6(e, t) {
  return e = V2(e), Ae(Na.count(vi(e), e) + (vi(e).getUTCDay() === 4), t, 2);
}
function i6(e) {
  return e.getUTCDay();
}
function o6(e, t) {
  return Ae(Ku.count(vi(e) - 1, e), t, 2);
}
function a6(e, t) {
  return Ae(e.getUTCFullYear() % 100, t, 2);
}
function s6(e, t) {
  return e = V2(e), Ae(e.getUTCFullYear() % 100, t, 2);
}
function l6(e, t) {
  return Ae(e.getUTCFullYear() % 1e4, t, 4);
}
function c6(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Na(e) : Na.ceil(e), Ae(e.getUTCFullYear() % 1e4, t, 4);
}
function u6() {
  return "+0000";
}
function nw() {
  return "%";
}
function rw(e) {
  return +e;
}
function iw(e) {
  return Math.floor(+e / 1e3);
}
var la, U2, H2;
d6({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function d6(e) {
  return la = dB(e), U2 = la.format, la.parse, H2 = la.utcFormat, la.utcParse, la;
}
function f6(e) {
  return new Date(e);
}
function p6(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function _v(e, t, n, r, i, o, a, s, l, c) {
  var u = dv(), d = u.invert, p = u.domain, h = c(".%L"), g = c(":%S"), m = c("%I:%M"), v = c("%I %p"), y = c("%a %d"), S = c("%b %d"), w = c("%B"), b = c("%Y");
  function O(E) {
    return (l(E) < E ? h : s(E) < E ? g : a(E) < E ? m : o(E) < E ? v : r(E) < E ? i(E) < E ? y : S : n(E) < E ? w : b)(E);
  }
  return u.invert = function(E) {
    return new Date(d(E));
  }, u.domain = function(E) {
    return arguments.length ? p(Array.from(E, p6)) : p().map(f6);
  }, u.ticks = function(E) {
    var C = p();
    return e(C[0], C[C.length - 1], E ?? 10);
  }, u.tickFormat = function(E, C) {
    return C == null ? O : c(C);
  }, u.nice = function(E) {
    var C = p();
    return (!E || typeof E.range != "function") && (E = t(C[0], C[C.length - 1], E ?? 10)), E ? p(M2(C, E)) : u;
  }, u.copy = function() {
    return ql(u, _v(e, t, n, r, i, o, a, s, l, c));
  }, u;
}
function h6() {
  return yr.apply(_v(cB, uB, gi, Sv, of, Kl, wv, bv, _o, U2).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function m6() {
  return yr.apply(_v(sB, lB, vi, Ev, af, rf, Ov, xv, _o, H2).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function sf() {
  var e = 0, t = 1, n, r, i, o, a = yn, s = !1, l;
  function c(d) {
    return d == null || isNaN(d = +d) ? l : a(i === 0 ? 0.5 : (d = (o(d) - n) * i, s ? Math.max(0, Math.min(1, d)) : d));
  }
  c.domain = function(d) {
    return arguments.length ? ([e, t] = d, n = o(e = +e), r = o(t = +t), i = n === r ? 0 : 1 / (r - n), c) : [e, t];
  }, c.clamp = function(d) {
    return arguments.length ? (s = !!d, c) : s;
  }, c.interpolator = function(d) {
    return arguments.length ? (a = d, c) : a;
  };
  function u(d) {
    return function(p) {
      var h, g;
      return arguments.length ? ([h, g] = p, a = d(h, g), c) : [a(0), a(1)];
    };
  }
  return c.range = u(Ha), c.rangeRound = u(uv), c.unknown = function(d) {
    return arguments.length ? (l = d, c) : l;
  }, function(d) {
    return o = d, n = d(e), r = d(t), i = n === r ? 0 : 1 / (r - n), c;
  };
}
function Qi(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function q2() {
  var e = Ji(sf()(yn));
  return e.copy = function() {
    return Qi(e, q2());
  }, Si.apply(e, arguments);
}
function K2() {
  var e = hv(sf()).domain([1, 10]);
  return e.copy = function() {
    return Qi(e, K2()).base(e.base());
  }, Si.apply(e, arguments);
}
function Y2() {
  var e = mv(sf());
  return e.copy = function() {
    return Qi(e, Y2()).constant(e.constant());
  }, Si.apply(e, arguments);
}
function Pv() {
  var e = gv(sf());
  return e.copy = function() {
    return Qi(e, Pv()).exponent(e.exponent());
  }, Si.apply(e, arguments);
}
function g6() {
  return Pv.apply(null, arguments).exponent(0.5);
}
function G2() {
  var e = [], t = yn;
  function n(r) {
    if (r != null && !isNaN(r = +r)) return t((Ul(e, r, 1) - 1) / (e.length - 1));
  }
  return n.domain = function(r) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of r) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort(Li), n;
  }, n.interpolator = function(r) {
    return arguments.length ? (t = r, n) : t;
  }, n.range = function() {
    return e.map((r, i) => t(i / (e.length - 1)));
  }, n.quantiles = function(r) {
    return Array.from({ length: r + 1 }, (i, o) => t4(e, o / r));
  }, n.copy = function() {
    return G2(t).domain(e);
  }, Si.apply(n, arguments);
}
function lf() {
  var e = 0, t = 0.5, n = 1, r = 1, i, o, a, s, l, c = yn, u, d = !1, p;
  function h(m) {
    return isNaN(m = +m) ? p : (m = 0.5 + ((m = +u(m)) - o) * (r * m < r * o ? s : l), c(d ? Math.max(0, Math.min(1, m)) : m));
  }
  h.domain = function(m) {
    return arguments.length ? ([e, t, n] = m, i = u(e = +e), o = u(t = +t), a = u(n = +n), s = i === o ? 0 : 0.5 / (o - i), l = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, h) : [e, t, n];
  }, h.clamp = function(m) {
    return arguments.length ? (d = !!m, h) : d;
  }, h.interpolator = function(m) {
    return arguments.length ? (c = m, h) : c;
  };
  function g(m) {
    return function(v) {
      var y, S, w;
      return arguments.length ? ([y, S, w] = v, c = T4(m, [y, S, w]), h) : [c(0), c(0.5), c(1)];
    };
  }
  return h.range = g(Ha), h.rangeRound = g(uv), h.unknown = function(m) {
    return arguments.length ? (p = m, h) : p;
  }, function(m) {
    return u = m, i = m(e), o = m(t), a = m(n), s = i === o ? 0 : 0.5 / (o - i), l = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, h;
  };
}
function X2() {
  var e = Ji(lf()(yn));
  return e.copy = function() {
    return Qi(e, X2());
  }, Si.apply(e, arguments);
}
function Z2() {
  var e = hv(lf()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return Qi(e, Z2()).base(e.base());
  }, Si.apply(e, arguments);
}
function J2() {
  var e = mv(lf());
  return e.copy = function() {
    return Qi(e, J2()).constant(e.constant());
  }, Si.apply(e, arguments);
}
function Cv() {
  var e = gv(lf());
  return e.copy = function() {
    return Qi(e, Cv()).exponent(e.exponent());
  }, Si.apply(e, arguments);
}
function v6() {
  return Cv.apply(null, arguments).exponent(0.5);
}
const Ns = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: sv,
  scaleDiverging: X2,
  scaleDivergingLog: Z2,
  scaleDivergingPow: Cv,
  scaleDivergingSqrt: v6,
  scaleDivergingSymlog: J2,
  scaleIdentity: k2,
  scaleImplicit: Nm,
  scaleLinear: A2,
  scaleLog: j2,
  scaleOrdinal: av,
  scalePoint: i4,
  scalePow: vv,
  scaleQuantile: R2,
  scaleQuantize: I2,
  scaleRadial: D2,
  scaleSequential: q2,
  scaleSequentialLog: K2,
  scaleSequentialPow: Pv,
  scaleSequentialQuantile: G2,
  scaleSequentialSqrt: g6,
  scaleSequentialSymlog: Y2,
  scaleSqrt: Z4,
  scaleSymlog: N2,
  scaleThreshold: $2,
  scaleTime: h6,
  scaleUtc: m6,
  tickFormat: T2
}, Symbol.toStringTag, { value: "Module" }));
var eo = (e) => e.chartData, Tv = z([eo], (e) => {
  var t = e.chartData != null ? e.chartData.length - 1 : 0;
  return {
    chartData: e.chartData,
    computedData: e.computedData,
    dataEndIndex: t,
    dataStartIndex: 0
  };
}), cf = (e, t, n, r) => r ? Tv(e) : eo(e);
function Da(e) {
  if (Array.isArray(e) && e.length === 2) {
    var [t, n] = e;
    if (Yn(t) && Yn(n))
      return !0;
  }
  return !1;
}
function ow(e, t, n) {
  return n ? e : [Math.min(e[0], t[0]), Math.max(e[1], t[1])];
}
function y6(e, t) {
  if (t && typeof e != "function" && Array.isArray(e) && e.length === 2) {
    var [n, r] = e, i, o;
    if (Yn(n))
      i = n;
    else if (typeof n == "function")
      return;
    if (Yn(r))
      o = r;
    else if (typeof r == "function")
      return;
    var a = [i, o];
    if (Da(a))
      return a;
  }
}
function b6(e, t, n) {
  if (!(!n && t == null)) {
    if (typeof e == "function" && t != null)
      try {
        var r = e(t, n);
        if (Da(r))
          return ow(r, t, n);
      } catch {
      }
    if (Array.isArray(e) && e.length === 2) {
      var [i, o] = e, a, s;
      if (i === "auto")
        t != null && (a = Math.min(...t));
      else if (me(i))
        a = i;
      else if (typeof i == "function")
        try {
          t != null && (a = i(t?.[0]));
        } catch {
        }
      else if (typeof i == "string" && Zx.test(i)) {
        var l = Zx.exec(i);
        if (l == null || t == null)
          a = void 0;
        else {
          var c = +l[1];
          a = t[0] - c;
        }
      } else
        a = t?.[0];
      if (o === "auto")
        t != null && (s = Math.max(...t));
      else if (me(o))
        s = o;
      else if (typeof o == "function")
        try {
          t != null && (s = o(t?.[1]));
        } catch {
        }
      else if (typeof o == "string" && Jx.test(o)) {
        var u = Jx.exec(o);
        if (u == null || t == null)
          s = void 0;
        else {
          var d = +u[1];
          s = t[1] + d;
        }
      } else
        s = t?.[1];
      var p = [a, s];
      if (Da(p))
        return t == null ? p : ow(p, t, n);
    }
  }
}
var qa = 1e9, x6 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, kv, vt = !0, fr = "[DecimalError] ", No = fr + "Invalid argument: ", Av = fr + "Exponent out of range: ", Ka = Math.floor, go = Math.pow, w6 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, zn, qt = 1e7, dt = 7, Q2 = 9007199254740991, Yu = Ka(Q2 / dt), ce = {};
ce.absoluteValue = ce.abs = function() {
  var e = new this.constructor(this);
  return e.s && (e.s = 1), e;
};
ce.comparedTo = ce.cmp = function(e) {
  var t, n, r, i, o = this;
  if (e = new o.constructor(e), o.s !== e.s) return o.s || -e.s;
  if (o.e !== e.e) return o.e > e.e ^ o.s < 0 ? 1 : -1;
  for (r = o.d.length, i = e.d.length, t = 0, n = r < i ? r : i; t < n; ++t)
    if (o.d[t] !== e.d[t]) return o.d[t] > e.d[t] ^ o.s < 0 ? 1 : -1;
  return r === i ? 0 : r > i ^ o.s < 0 ? 1 : -1;
};
ce.decimalPlaces = ce.dp = function() {
  var e = this, t = e.d.length - 1, n = (t - e.e) * dt;
  if (t = e.d[t], t) for (; t % 10 == 0; t /= 10) n--;
  return n < 0 ? 0 : n;
};
ce.dividedBy = ce.div = function(e) {
  return di(this, new this.constructor(e));
};
ce.dividedToIntegerBy = ce.idiv = function(e) {
  var t = this, n = t.constructor;
  return ot(di(t, new n(e), 0, 1), n.precision);
};
ce.equals = ce.eq = function(e) {
  return !this.cmp(e);
};
ce.exponent = function() {
  return Lt(this);
};
ce.greaterThan = ce.gt = function(e) {
  return this.cmp(e) > 0;
};
ce.greaterThanOrEqualTo = ce.gte = function(e) {
  return this.cmp(e) >= 0;
};
ce.isInteger = ce.isint = function() {
  return this.e > this.d.length - 2;
};
ce.isNegative = ce.isneg = function() {
  return this.s < 0;
};
ce.isPositive = ce.ispos = function() {
  return this.s > 0;
};
ce.isZero = function() {
  return this.s === 0;
};
ce.lessThan = ce.lt = function(e) {
  return this.cmp(e) < 0;
};
ce.lessThanOrEqualTo = ce.lte = function(e) {
  return this.cmp(e) < 1;
};
ce.logarithm = ce.log = function(e) {
  var t, n = this, r = n.constructor, i = r.precision, o = i + 5;
  if (e === void 0)
    e = new r(10);
  else if (e = new r(e), e.s < 1 || e.eq(zn)) throw Error(fr + "NaN");
  if (n.s < 1) throw Error(fr + (n.s ? "NaN" : "-Infinity"));
  return n.eq(zn) ? new r(0) : (vt = !1, t = di(fl(n, o), fl(e, o), o), vt = !0, ot(t, i));
};
ce.minus = ce.sub = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? nC(t, e) : eC(t, (e.s = -e.s, e));
};
ce.modulo = ce.mod = function(e) {
  var t, n = this, r = n.constructor, i = r.precision;
  if (e = new r(e), !e.s) throw Error(fr + "NaN");
  return n.s ? (vt = !1, t = di(n, e, 0, 1).times(e), vt = !0, n.minus(t)) : ot(new r(n), i);
};
ce.naturalExponential = ce.exp = function() {
  return tC(this);
};
ce.naturalLogarithm = ce.ln = function() {
  return fl(this);
};
ce.negated = ce.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s || 0, e;
};
ce.plus = ce.add = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? eC(t, e) : nC(t, (e.s = -e.s, e));
};
ce.precision = ce.sd = function(e) {
  var t, n, r, i = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(No + e);
  if (t = Lt(i) + 1, r = i.d.length - 1, n = r * dt + 1, r = i.d[r], r) {
    for (; r % 10 == 0; r /= 10) n--;
    for (r = i.d[0]; r >= 10; r /= 10) n++;
  }
  return e && t > n ? t : n;
};
ce.squareRoot = ce.sqrt = function() {
  var e, t, n, r, i, o, a, s = this, l = s.constructor;
  if (s.s < 1) {
    if (!s.s) return new l(0);
    throw Error(fr + "NaN");
  }
  for (e = Lt(s), vt = !1, i = Math.sqrt(+s), i == 0 || i == 1 / 0 ? (t = Ir(s.d), (t.length + e) % 2 == 0 && (t += "0"), i = Math.sqrt(t), e = Ka((e + 1) / 2) - (e < 0 || e % 2), i == 1 / 0 ? t = "5e" + e : (t = i.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), r = new l(t)) : r = new l(i.toString()), n = l.precision, i = a = n + 3; ; )
    if (o = r, r = o.plus(di(s, o, a + 2)).times(0.5), Ir(o.d).slice(0, a) === (t = Ir(r.d)).slice(0, a)) {
      if (t = t.slice(a - 3, a + 1), i == a && t == "4999") {
        if (ot(o, n + 1, 0), o.times(o).eq(s)) {
          r = o;
          break;
        }
      } else if (t != "9999")
        break;
      a += 4;
    }
  return vt = !0, ot(r, n);
};
ce.times = ce.mul = function(e) {
  var t, n, r, i, o, a, s, l, c, u = this, d = u.constructor, p = u.d, h = (e = new d(e)).d;
  if (!u.s || !e.s) return new d(0);
  for (e.s *= u.s, n = u.e + e.e, l = p.length, c = h.length, l < c && (o = p, p = h, h = o, a = l, l = c, c = a), o = [], a = l + c, r = a; r--; ) o.push(0);
  for (r = c; --r >= 0; ) {
    for (t = 0, i = l + r; i > r; )
      s = o[i] + h[r] * p[i - r - 1] + t, o[i--] = s % qt | 0, t = s / qt | 0;
    o[i] = (o[i] + t) % qt | 0;
  }
  for (; !o[--a]; ) o.pop();
  return t ? ++n : o.shift(), e.d = o, e.e = n, vt ? ot(e, d.precision) : e;
};
ce.toDecimalPlaces = ce.todp = function(e, t) {
  var n = this, r = n.constructor;
  return n = new r(n), e === void 0 ? n : (Ur(e, 0, qa), t === void 0 ? t = r.rounding : Ur(t, 0, 8), ot(n, e + Lt(n) + 1, t));
};
ce.toExponential = function(e, t) {
  var n, r = this, i = r.constructor;
  return e === void 0 ? n = Fo(r, !0) : (Ur(e, 0, qa), t === void 0 ? t = i.rounding : Ur(t, 0, 8), r = ot(new i(r), e + 1, t), n = Fo(r, !0, e + 1)), n;
};
ce.toFixed = function(e, t) {
  var n, r, i = this, o = i.constructor;
  return e === void 0 ? Fo(i) : (Ur(e, 0, qa), t === void 0 ? t = o.rounding : Ur(t, 0, 8), r = ot(new o(i), e + Lt(i) + 1, t), n = Fo(r.abs(), !1, e + Lt(r) + 1), i.isneg() && !i.isZero() ? "-" + n : n);
};
ce.toInteger = ce.toint = function() {
  var e = this, t = e.constructor;
  return ot(new t(e), Lt(e) + 1, t.rounding);
};
ce.toNumber = function() {
  return +this;
};
ce.toPower = ce.pow = function(e) {
  var t, n, r, i, o, a, s = this, l = s.constructor, c = 12, u = +(e = new l(e));
  if (!e.s) return new l(zn);
  if (s = new l(s), !s.s) {
    if (e.s < 1) throw Error(fr + "Infinity");
    return s;
  }
  if (s.eq(zn)) return s;
  if (r = l.precision, e.eq(zn)) return ot(s, r);
  if (t = e.e, n = e.d.length - 1, a = t >= n, o = s.s, a) {
    if ((n = u < 0 ? -u : u) <= Q2) {
      for (i = new l(zn), t = Math.ceil(r / dt + 4), vt = !1; n % 2 && (i = i.times(s), sw(i.d, t)), n = Ka(n / 2), n !== 0; )
        s = s.times(s), sw(s.d, t);
      return vt = !0, e.s < 0 ? new l(zn).div(i) : ot(i, r);
    }
  } else if (o < 0) throw Error(fr + "NaN");
  return o = o < 0 && e.d[Math.max(t, n)] & 1 ? -1 : 1, s.s = 1, vt = !1, i = e.times(fl(s, r + c)), vt = !0, i = tC(i), i.s = o, i;
};
ce.toPrecision = function(e, t) {
  var n, r, i = this, o = i.constructor;
  return e === void 0 ? (n = Lt(i), r = Fo(i, n <= o.toExpNeg || n >= o.toExpPos)) : (Ur(e, 1, qa), t === void 0 ? t = o.rounding : Ur(t, 0, 8), i = ot(new o(i), e, t), n = Lt(i), r = Fo(i, e <= n || n <= o.toExpNeg, e)), r;
};
ce.toSignificantDigits = ce.tosd = function(e, t) {
  var n = this, r = n.constructor;
  return e === void 0 ? (e = r.precision, t = r.rounding) : (Ur(e, 1, qa), t === void 0 ? t = r.rounding : Ur(t, 0, 8)), ot(new r(n), e, t);
};
ce.toString = ce.valueOf = ce.val = ce.toJSON = ce[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var e = this, t = Lt(e), n = e.constructor;
  return Fo(e, t <= n.toExpNeg || t >= n.toExpPos);
};
function eC(e, t) {
  var n, r, i, o, a, s, l, c, u = e.constructor, d = u.precision;
  if (!e.s || !t.s)
    return t.s || (t = new u(e)), vt ? ot(t, d) : t;
  if (l = e.d, c = t.d, a = e.e, i = t.e, l = l.slice(), o = a - i, o) {
    for (o < 0 ? (r = l, o = -o, s = c.length) : (r = c, i = a, s = l.length), a = Math.ceil(d / dt), s = a > s ? a + 1 : s + 1, o > s && (o = s, r.length = 1), r.reverse(); o--; ) r.push(0);
    r.reverse();
  }
  for (s = l.length, o = c.length, s - o < 0 && (o = s, r = c, c = l, l = r), n = 0; o; )
    n = (l[--o] = l[o] + c[o] + n) / qt | 0, l[o] %= qt;
  for (n && (l.unshift(n), ++i), s = l.length; l[--s] == 0; ) l.pop();
  return t.d = l, t.e = i, vt ? ot(t, d) : t;
}
function Ur(e, t, n) {
  if (e !== ~~e || e < t || e > n)
    throw Error(No + e);
}
function Ir(e) {
  var t, n, r, i = e.length - 1, o = "", a = e[0];
  if (i > 0) {
    for (o += a, t = 1; t < i; t++)
      r = e[t] + "", n = dt - r.length, n && (o += ki(n)), o += r;
    a = e[t], r = a + "", n = dt - r.length, n && (o += ki(n));
  } else if (a === 0)
    return "0";
  for (; a % 10 === 0; ) a /= 10;
  return o + a;
}
var di = /* @__PURE__ */ (function() {
  function e(r, i) {
    var o, a = 0, s = r.length;
    for (r = r.slice(); s--; )
      o = r[s] * i + a, r[s] = o % qt | 0, a = o / qt | 0;
    return a && r.unshift(a), r;
  }
  function t(r, i, o, a) {
    var s, l;
    if (o != a)
      l = o > a ? 1 : -1;
    else
      for (s = l = 0; s < o; s++)
        if (r[s] != i[s]) {
          l = r[s] > i[s] ? 1 : -1;
          break;
        }
    return l;
  }
  function n(r, i, o) {
    for (var a = 0; o--; )
      r[o] -= a, a = r[o] < i[o] ? 1 : 0, r[o] = a * qt + r[o] - i[o];
    for (; !r[0] && r.length > 1; ) r.shift();
  }
  return function(r, i, o, a) {
    var s, l, c, u, d, p, h, g, m, v, y, S, w, b, O, E, C, T, j = r.constructor, A = r.s == i.s ? 1 : -1, M = r.d, P = i.d;
    if (!r.s) return new j(r);
    if (!i.s) throw Error(fr + "Division by zero");
    for (l = r.e - i.e, C = P.length, O = M.length, h = new j(A), g = h.d = [], c = 0; P[c] == (M[c] || 0); ) ++c;
    if (P[c] > (M[c] || 0) && --l, o == null ? S = o = j.precision : a ? S = o + (Lt(r) - Lt(i)) + 1 : S = o, S < 0) return new j(0);
    if (S = S / dt + 2 | 0, c = 0, C == 1)
      for (u = 0, P = P[0], S++; (c < O || u) && S--; c++)
        w = u * qt + (M[c] || 0), g[c] = w / P | 0, u = w % P | 0;
    else {
      for (u = qt / (P[0] + 1) | 0, u > 1 && (P = e(P, u), M = e(M, u), C = P.length, O = M.length), b = C, m = M.slice(0, C), v = m.length; v < C; ) m[v++] = 0;
      T = P.slice(), T.unshift(0), E = P[0], P[1] >= qt / 2 && ++E;
      do
        u = 0, s = t(P, m, C, v), s < 0 ? (y = m[0], C != v && (y = y * qt + (m[1] || 0)), u = y / E | 0, u > 1 ? (u >= qt && (u = qt - 1), d = e(P, u), p = d.length, v = m.length, s = t(d, m, p, v), s == 1 && (u--, n(d, C < p ? T : P, p))) : (u == 0 && (s = u = 1), d = P.slice()), p = d.length, p < v && d.unshift(0), n(m, d, v), s == -1 && (v = m.length, s = t(P, m, C, v), s < 1 && (u++, n(m, C < v ? T : P, v))), v = m.length) : s === 0 && (u++, m = [0]), g[c++] = u, s && m[0] ? m[v++] = M[b] || 0 : (m = [M[b]], v = 1);
      while ((b++ < O || m[0] !== void 0) && S--);
    }
    return g[0] || g.shift(), h.e = l, ot(h, a ? o + Lt(h) + 1 : o);
  };
})();
function tC(e, t) {
  var n, r, i, o, a, s, l = 0, c = 0, u = e.constructor, d = u.precision;
  if (Lt(e) > 16) throw Error(Av + Lt(e));
  if (!e.s) return new u(zn);
  for (vt = !1, s = d, a = new u(0.03125); e.abs().gte(0.1); )
    e = e.times(a), c += 5;
  for (r = Math.log(go(2, c)) / Math.LN10 * 2 + 5 | 0, s += r, n = i = o = new u(zn), u.precision = s; ; ) {
    if (i = ot(i.times(e), s), n = n.times(++l), a = o.plus(di(i, n, s)), Ir(a.d).slice(0, s) === Ir(o.d).slice(0, s)) {
      for (; c--; ) o = ot(o.times(o), s);
      return u.precision = d, t == null ? (vt = !0, ot(o, d)) : o;
    }
    o = a;
  }
}
function Lt(e) {
  for (var t = e.e * dt, n = e.d[0]; n >= 10; n /= 10) t++;
  return t;
}
function ph(e, t, n) {
  if (t > e.LN10.sd())
    throw vt = !0, n && (e.precision = n), Error(fr + "LN10 precision limit exceeded");
  return ot(new e(e.LN10), t);
}
function ki(e) {
  for (var t = ""; e--; ) t += "0";
  return t;
}
function fl(e, t) {
  var n, r, i, o, a, s, l, c, u, d = 1, p = 10, h = e, g = h.d, m = h.constructor, v = m.precision;
  if (h.s < 1) throw Error(fr + (h.s ? "NaN" : "-Infinity"));
  if (h.eq(zn)) return new m(0);
  if (t == null ? (vt = !1, c = v) : c = t, h.eq(10))
    return t == null && (vt = !0), ph(m, c);
  if (c += p, m.precision = c, n = Ir(g), r = n.charAt(0), o = Lt(h), Math.abs(o) < 15e14) {
    for (; r < 7 && r != 1 || r == 1 && n.charAt(1) > 3; )
      h = h.times(e), n = Ir(h.d), r = n.charAt(0), d++;
    o = Lt(h), r > 1 ? (h = new m("0." + n), o++) : h = new m(r + "." + n.slice(1));
  } else
    return l = ph(m, c + 2, v).times(o + ""), h = fl(new m(r + "." + n.slice(1)), c - p).plus(l), m.precision = v, t == null ? (vt = !0, ot(h, v)) : h;
  for (s = a = h = di(h.minus(zn), h.plus(zn), c), u = ot(h.times(h), c), i = 3; ; ) {
    if (a = ot(a.times(u), c), l = s.plus(di(a, new m(i), c)), Ir(l.d).slice(0, c) === Ir(s.d).slice(0, c))
      return s = s.times(2), o !== 0 && (s = s.plus(ph(m, c + 2, v).times(o + ""))), s = di(s, new m(d), c), m.precision = v, t == null ? (vt = !0, ot(s, v)) : s;
    s = l, i += 2;
  }
}
function aw(e, t) {
  var n, r, i;
  for ((n = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (r = t.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +t.slice(r + 1), t = t.substring(0, r)) : n < 0 && (n = t.length), r = 0; t.charCodeAt(r) === 48; ) ++r;
  for (i = t.length; t.charCodeAt(i - 1) === 48; ) --i;
  if (t = t.slice(r, i), t) {
    if (i -= r, n = n - r - 1, e.e = Ka(n / dt), e.d = [], r = (n + 1) % dt, n < 0 && (r += dt), r < i) {
      for (r && e.d.push(+t.slice(0, r)), i -= dt; r < i; ) e.d.push(+t.slice(r, r += dt));
      t = t.slice(r), r = dt - t.length;
    } else
      r -= i;
    for (; r--; ) t += "0";
    if (e.d.push(+t), vt && (e.e > Yu || e.e < -Yu)) throw Error(Av + n);
  } else
    e.s = 0, e.e = 0, e.d = [0];
  return e;
}
function ot(e, t, n) {
  var r, i, o, a, s, l, c, u, d = e.d;
  for (a = 1, o = d[0]; o >= 10; o /= 10) a++;
  if (r = t - a, r < 0)
    r += dt, i = t, c = d[u = 0];
  else {
    if (u = Math.ceil((r + 1) / dt), o = d.length, u >= o) return e;
    for (c = o = d[u], a = 1; o >= 10; o /= 10) a++;
    r %= dt, i = r - dt + a;
  }
  if (n !== void 0 && (o = go(10, a - i - 1), s = c / o % 10 | 0, l = t < 0 || d[u + 1] !== void 0 || c % o, l = n < 4 ? (s || l) && (n == 0 || n == (e.s < 0 ? 3 : 2)) : s > 5 || s == 5 && (n == 4 || l || n == 6 && // Check whether the digit to the left of the rounding digit is odd.
  (r > 0 ? i > 0 ? c / go(10, a - i) : 0 : d[u - 1]) % 10 & 1 || n == (e.s < 0 ? 8 : 7))), t < 1 || !d[0])
    return l ? (o = Lt(e), d.length = 1, t = t - o - 1, d[0] = go(10, (dt - t % dt) % dt), e.e = Ka(-t / dt) || 0) : (d.length = 1, d[0] = e.e = e.s = 0), e;
  if (r == 0 ? (d.length = u, o = 1, u--) : (d.length = u + 1, o = go(10, dt - r), d[u] = i > 0 ? (c / go(10, a - i) % go(10, i) | 0) * o : 0), l)
    for (; ; )
      if (u == 0) {
        (d[0] += o) == qt && (d[0] = 1, ++e.e);
        break;
      } else {
        if (d[u] += o, d[u] != qt) break;
        d[u--] = 0, o = 1;
      }
  for (r = d.length; d[--r] === 0; ) d.pop();
  if (vt && (e.e > Yu || e.e < -Yu))
    throw Error(Av + Lt(e));
  return e;
}
function nC(e, t) {
  var n, r, i, o, a, s, l, c, u, d, p = e.constructor, h = p.precision;
  if (!e.s || !t.s)
    return t.s ? t.s = -t.s : t = new p(e), vt ? ot(t, h) : t;
  if (l = e.d, d = t.d, r = t.e, c = e.e, l = l.slice(), a = c - r, a) {
    for (u = a < 0, u ? (n = l, a = -a, s = d.length) : (n = d, r = c, s = l.length), i = Math.max(Math.ceil(h / dt), s) + 2, a > i && (a = i, n.length = 1), n.reverse(), i = a; i--; ) n.push(0);
    n.reverse();
  } else {
    for (i = l.length, s = d.length, u = i < s, u && (s = i), i = 0; i < s; i++)
      if (l[i] != d[i]) {
        u = l[i] < d[i];
        break;
      }
    a = 0;
  }
  for (u && (n = l, l = d, d = n, t.s = -t.s), s = l.length, i = d.length - s; i > 0; --i) l[s++] = 0;
  for (i = d.length; i > a; ) {
    if (l[--i] < d[i]) {
      for (o = i; o && l[--o] === 0; ) l[o] = qt - 1;
      --l[o], l[i] += qt;
    }
    l[i] -= d[i];
  }
  for (; l[--s] === 0; ) l.pop();
  for (; l[0] === 0; l.shift()) --r;
  return l[0] ? (t.d = l, t.e = r, vt ? ot(t, h) : t) : new p(0);
}
function Fo(e, t, n) {
  var r, i = Lt(e), o = Ir(e.d), a = o.length;
  return t ? (n && (r = n - a) > 0 ? o = o.charAt(0) + "." + o.slice(1) + ki(r) : a > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (i < 0 ? "e" : "e+") + i) : i < 0 ? (o = "0." + ki(-i - 1) + o, n && (r = n - a) > 0 && (o += ki(r))) : i >= a ? (o += ki(i + 1 - a), n && (r = n - i - 1) > 0 && (o = o + "." + ki(r))) : ((r = i + 1) < a && (o = o.slice(0, r) + "." + o.slice(r)), n && (r = n - a) > 0 && (i + 1 === a && (o += "."), o += ki(r))), e.s < 0 ? "-" + o : o;
}
function sw(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function rC(e) {
  var t, n, r;
  function i(o) {
    var a = this;
    if (!(a instanceof i)) return new i(o);
    if (a.constructor = i, o instanceof i) {
      a.s = o.s, a.e = o.e, a.d = (o = o.d) ? o.slice() : o;
      return;
    }
    if (typeof o == "number") {
      if (o * 0 !== 0)
        throw Error(No + o);
      if (o > 0)
        a.s = 1;
      else if (o < 0)
        o = -o, a.s = -1;
      else {
        a.s = 0, a.e = 0, a.d = [0];
        return;
      }
      if (o === ~~o && o < 1e7) {
        a.e = 0, a.d = [o];
        return;
      }
      return aw(a, o.toString());
    } else if (typeof o != "string")
      throw Error(No + o);
    if (o.charCodeAt(0) === 45 ? (o = o.slice(1), a.s = -1) : a.s = 1, w6.test(o)) aw(a, o);
    else throw Error(No + o);
  }
  if (i.prototype = ce, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = rC, i.config = i.set = O6, e === void 0 && (e = {}), e)
    for (r = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t = 0; t < r.length; ) e.hasOwnProperty(n = r[t++]) || (e[n] = this[n]);
  return i.config(e), i;
}
function O6(e) {
  if (!e || typeof e != "object")
    throw Error(fr + "Object expected");
  var t, n, r, i = [
    "precision",
    1,
    qa,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (t = 0; t < i.length; t += 3)
    if ((r = e[n = i[t]]) !== void 0)
      if (Ka(r) === r && r >= i[t + 1] && r <= i[t + 2]) this[n] = r;
      else throw Error(No + n + ": " + r);
  if ((r = e[n = "LN10"]) !== void 0)
    if (r == Math.LN10) this[n] = new this(r);
    else throw Error(No + n + ": " + r);
  return this;
}
var kv = rC(x6);
zn = new kv(1);
const qe = kv;
var S6 = (e) => e, iC = {}, oC = (e) => e === iC, lw = (e) => function t() {
  return arguments.length === 0 || arguments.length === 1 && oC(arguments.length <= 0 ? void 0 : arguments[0]) ? t : e(...arguments);
}, aC = (e, t) => e === 1 ? t : lw(function() {
  for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
    r[i] = arguments[i];
  var o = r.filter((a) => a !== iC).length;
  return o >= e ? t(...r) : aC(e - o, lw(function() {
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    var c = r.map((u) => oC(u) ? s.shift() : u);
    return t(...c, ...s);
  }));
}), uf = (e) => aC(e.length, e), $m = (e, t) => {
  for (var n = [], r = e; r < t; ++r)
    n[r - e] = r;
  return n;
}, E6 = uf((e, t) => Array.isArray(t) ? t.map(e) : Object.keys(t).map((n) => t[n]).map(e)), _6 = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  if (!n.length)
    return S6;
  var i = n.reverse(), o = i[0], a = i.slice(1);
  return function() {
    return a.reduce((s, l) => l(s), o(...arguments));
  };
}, Lm = (e) => Array.isArray(e) ? e.reverse() : e.split("").reverse().join(""), sC = (e) => {
  var t = null, n = null;
  return function() {
    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
      i[o] = arguments[o];
    return t && i.every((a, s) => {
      var l;
      return a === ((l = t) === null || l === void 0 ? void 0 : l[s]);
    }) || (t = i, n = e(...i)), n;
  };
};
function lC(e) {
  var t;
  return e === 0 ? t = 1 : t = Math.floor(new qe(e).abs().log(10).toNumber()) + 1, t;
}
function cC(e, t, n) {
  for (var r = new qe(e), i = 0, o = []; r.lt(t) && i < 1e5; )
    o.push(r.toNumber()), r = r.add(n), i++;
  return o;
}
uf((e, t, n) => {
  var r = +e, i = +t;
  return r + n * (i - r);
});
uf((e, t, n) => {
  var r = t - +e;
  return r = r || 1 / 0, (n - e) / r;
});
uf((e, t, n) => {
  var r = t - +e;
  return r = r || 1 / 0, Math.max(0, Math.min(1, (n - e) / r));
});
var uC = (e) => {
  var [t, n] = e, [r, i] = [t, n];
  return t > n && ([r, i] = [n, t]), [r, i];
}, dC = (e, t, n) => {
  if (e.lte(0))
    return new qe(0);
  var r = lC(e.toNumber()), i = new qe(10).pow(r), o = e.div(i), a = r !== 1 ? 0.05 : 0.1, s = new qe(Math.ceil(o.div(a).toNumber())).add(n).mul(a), l = s.mul(i);
  return t ? new qe(l.toNumber()) : new qe(Math.ceil(l.toNumber()));
}, P6 = (e, t, n) => {
  var r = new qe(1), i = new qe(e);
  if (!i.isint() && n) {
    var o = Math.abs(e);
    o < 1 ? (r = new qe(10).pow(lC(e) - 1), i = new qe(Math.floor(i.div(r).toNumber())).mul(r)) : o > 1 && (i = new qe(Math.floor(e)));
  } else e === 0 ? i = new qe(Math.floor((t - 1) / 2)) : n || (i = new qe(Math.floor(e)));
  var a = Math.floor((t - 1) / 2), s = _6(E6((l) => i.add(new qe(l - a).mul(r)).toNumber()), $m);
  return s(0, t);
}, fC = function(t, n, r, i) {
  var o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((n - t) / (r - 1)))
    return {
      step: new qe(0),
      tickMin: new qe(0),
      tickMax: new qe(0)
    };
  var a = dC(new qe(n).sub(t).div(r - 1), i, o), s;
  t <= 0 && n >= 0 ? s = new qe(0) : (s = new qe(t).add(n).div(2), s = s.sub(new qe(s).mod(a)));
  var l = Math.ceil(s.sub(t).div(a).toNumber()), c = Math.ceil(new qe(n).sub(s).div(a).toNumber()), u = l + c + 1;
  return u > r ? fC(t, n, r, i, o + 1) : (u < r && (c = n > 0 ? c + (r - u) : c, l = n > 0 ? l : l + (r - u)), {
    step: a,
    tickMin: s.sub(new qe(l).mul(a)),
    tickMax: s.add(new qe(c).mul(a))
  });
};
function C6(e) {
  var [t, n] = e, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = Math.max(r, 2), [a, s] = uC([t, n]);
  if (a === -1 / 0 || s === 1 / 0) {
    var l = s === 1 / 0 ? [a, ...$m(0, r - 1).map(() => 1 / 0)] : [...$m(0, r - 1).map(() => -1 / 0), s];
    return t > n ? Lm(l) : l;
  }
  if (a === s)
    return P6(a, r, i);
  var {
    step: c,
    tickMin: u,
    tickMax: d
  } = fC(a, s, o, i, 0), p = cC(u, d.add(new qe(0.1).mul(c)), c);
  return t > n ? Lm(p) : p;
}
function T6(e, t) {
  var [n, r] = e, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, [o, a] = uC([n, r]);
  if (o === -1 / 0 || a === 1 / 0)
    return [n, r];
  if (o === a)
    return [o];
  var s = Math.max(t, 2), l = dC(new qe(a).sub(o).div(s - 1), i, 0), c = [...cC(new qe(o), new qe(a), l), a];
  return i === !1 && (c = c.map((u) => Math.round(u))), n > r ? Lm(c) : c;
}
var A6 = sC(C6), k6 = sC(T6), pC = (e) => e.rootProps.maxBarSize, M6 = (e) => e.rootProps.barGap, hC = (e) => e.rootProps.barCategoryGap, j6 = (e) => e.rootProps.barSize, Yl = (e) => e.rootProps.stackOffset, Mv = (e) => e.options.chartName, jv = (e) => e.rootProps.syncId, mC = (e) => e.rootProps.syncMethod, Nv = (e) => e.options.eventEmitter, ii = {
  allowDuplicatedCategory: !0,
  // if I set this to false then Tooltip synchronisation stops working in Radar, wtf
  angleAxisId: 0,
  reversed: !1,
  scale: "auto",
  tick: !0,
  type: "category"
}, Ln = {
  allowDataOverflow: !1,
  allowDuplicatedCategory: !0,
  radiusAxisId: 0,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  type: "number"
}, df = (e, t) => {
  if (!(!e || !t))
    return e != null && e.reversed ? [t[1], t[0]] : t;
}, N6 = {
  allowDataOverflow: !1,
  allowDecimals: !1,
  allowDuplicatedCategory: !1,
  // defaultPolarAngleAxisProps.allowDuplicatedCategory has it set to true but the actual axis rendering ignores the prop because reasons,
  dataKey: void 0,
  domain: void 0,
  id: ii.angleAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: ii.reversed,
  scale: ii.scale,
  tick: ii.tick,
  tickCount: void 0,
  ticks: void 0,
  type: ii.type,
  unit: void 0
}, D6 = {
  allowDataOverflow: Ln.allowDataOverflow,
  allowDecimals: !1,
  allowDuplicatedCategory: Ln.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: Ln.radiusAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: Ln.scale,
  tick: Ln.tick,
  tickCount: Ln.tickCount,
  ticks: void 0,
  type: Ln.type,
  unit: void 0
}, R6 = {
  allowDataOverflow: !1,
  allowDecimals: !1,
  allowDuplicatedCategory: ii.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: ii.angleAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: ii.scale,
  tick: ii.tick,
  tickCount: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0
}, I6 = {
  allowDataOverflow: Ln.allowDataOverflow,
  allowDecimals: !1,
  allowDuplicatedCategory: Ln.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: Ln.radiusAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: Ln.scale,
  tick: Ln.tick,
  tickCount: Ln.tickCount,
  ticks: void 0,
  type: "category",
  unit: void 0
}, Dv = (e, t) => e.polarAxis.angleAxis[t] != null ? e.polarAxis.angleAxis[t] : e.layout.layoutType === "radial" ? R6 : N6, Rv = (e, t) => e.polarAxis.radiusAxis[t] != null ? e.polarAxis.radiusAxis[t] : e.layout.layoutType === "radial" ? I6 : D6, ff = (e) => e.polarOptions, Iv = z([wi, Oi, zt], XP), gC = z([ff, Iv], (e, t) => {
  if (e != null)
    return hn(e.innerRadius, t, 0);
}), vC = z([ff, Iv], (e, t) => {
  if (e != null)
    return hn(e.outerRadius, t, t * 0.8);
}), $6 = (e) => {
  if (e == null)
    return [0, 0];
  var {
    startAngle: t,
    endAngle: n
  } = e;
  return [t, n];
}, yC = z([ff], $6);
z([Dv, yC], df);
var bC = z([Iv, gC, vC], (e, t, n) => {
  if (!(e == null || t == null || n == null))
    return [t, n];
});
z([Rv, bC], df);
var xC = z([Pe, ff, gC, vC, wi, Oi], (e, t, n, r, i, o) => {
  if (!(e !== "centric" && e !== "radial" || t == null || n == null || r == null)) {
    var {
      cx: a,
      cy: s,
      startAngle: l,
      endAngle: c
    } = t;
    return {
      cx: hn(a, i, i / 2),
      cy: hn(s, o, o / 2),
      innerRadius: n,
      outerRadius: r,
      startAngle: l,
      endAngle: c,
      clockWise: !1
      // this property look useful, why not use it?
    };
  }
}), bt = (e, t) => t, Gl = (e, t, n) => n;
function $v(e) {
  return e?.id;
}
var Vt = (e) => {
  var t = Pe(e);
  return t === "horizontal" ? "xAxis" : t === "vertical" ? "yAxis" : t === "centric" ? "angleAxis" : "radiusAxis";
}, Ya = (e) => e.tooltip.settings.axisId, Zt = (e) => {
  var t = Vt(e), n = Ya(e);
  return Xl(e, t, n);
}, wC = z([Zt], (e) => e?.dataKey);
function OC(e, t, n) {
  var {
    chartData: r = []
  } = t, {
    allowDuplicatedCategory: i,
    dataKey: o
  } = n, a = /* @__PURE__ */ new Map();
  return e.forEach((s) => {
    var l, c = (l = s.data) !== null && l !== void 0 ? l : r;
    if (!(c == null || c.length === 0)) {
      var u = $v(s);
      c.forEach((d, p) => {
        var h = o == null || i ? p : String(ct(d, o, null)), g = ct(d, s.dataKey, 0), m;
        a.has(h) ? m = a.get(h) : m = {}, Object.assign(m, {
          [u]: g
        }), a.set(h, m);
      });
    }
  }), Array.from(a.values());
}
function pf(e) {
  return e.stackId != null && e.dataKey != null;
}
function cw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cw(Object(n), !0).forEach(function(r) {
      L6(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function L6(e, t, n) {
  return (t = F6(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function F6(e) {
  var t = B6(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function B6(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Fm = [0, "auto"], Rn = {
  allowDataOverflow: !1,
  allowDecimals: !0,
  allowDuplicatedCategory: !0,
  angle: 0,
  dataKey: void 0,
  domain: void 0,
  height: 30,
  hide: !0,
  id: 0,
  includeHidden: !1,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: !1,
  name: void 0,
  orientation: "bottom",
  padding: {
    left: 0,
    right: 0
  },
  reversed: !1,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "category",
  unit: void 0
}, SC = (e, t) => e.cartesianAxis.xAxis[t], Ei = (e, t) => {
  var n = SC(e, t);
  return n ?? Rn;
}, In = {
  allowDataOverflow: !1,
  allowDecimals: !0,
  allowDuplicatedCategory: !0,
  angle: 0,
  dataKey: void 0,
  domain: Fm,
  hide: !0,
  id: 0,
  includeHidden: !1,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: !1,
  name: void 0,
  orientation: "left",
  padding: {
    top: 0,
    bottom: 0
  },
  reversed: !1,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0,
  width: zl
}, EC = (e, t) => e.cartesianAxis.yAxis[t], _i = (e, t) => {
  var n = EC(e, t);
  return n ?? In;
}, z6 = {
  domain: [0, "auto"],
  includeHidden: !1,
  reversed: !1,
  allowDataOverflow: !1,
  allowDuplicatedCategory: !1,
  dataKey: void 0,
  id: 0,
  name: "",
  range: [64, 64],
  scale: "auto",
  type: "number",
  unit: ""
}, Lv = (e, t) => {
  var n = e.cartesianAxis.zAxis[t];
  return n ?? z6;
}, Dt = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return Ei(e, n);
    case "yAxis":
      return _i(e, n);
    case "zAxis":
      return Lv(e, n);
    case "angleAxis":
      return Dv(e, n);
    case "radiusAxis":
      return Rv(e, n);
    default:
      throw new Error("Unexpected axis type: ".concat(t));
  }
}, W6 = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return Ei(e, n);
    case "yAxis":
      return _i(e, n);
    default:
      throw new Error("Unexpected axis type: ".concat(t));
  }
}, Xl = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return Ei(e, n);
    case "yAxis":
      return _i(e, n);
    case "angleAxis":
      return Dv(e, n);
    case "radiusAxis":
      return Rv(e, n);
    default:
      throw new Error("Unexpected axis type: ".concat(t));
  }
}, _C = (e) => e.graphicalItems.cartesianItems.some((t) => t.type === "bar") || e.graphicalItems.polarItems.some((t) => t.type === "radialBar");
function Fv(e, t) {
  return (n) => {
    switch (e) {
      case "xAxis":
        return "xAxisId" in n && n.xAxisId === t;
      case "yAxis":
        return "yAxisId" in n && n.yAxisId === t;
      case "zAxis":
        return "zAxisId" in n && n.zAxisId === t;
      case "angleAxis":
        return "angleAxisId" in n && n.angleAxisId === t;
      case "radiusAxis":
        return "radiusAxisId" in n && n.radiusAxisId === t;
      default:
        return !1;
    }
  };
}
var hf = (e) => e.graphicalItems.cartesianItems, V6 = z([bt, Gl], Fv), Bv = (e, t, n) => e.filter(n).filter((r) => t?.includeHidden === !0 ? !0 : !r.hide), Zl = z([hf, Dt, V6], Bv), PC = z([Zl], (e) => e.filter((t) => t.type === "area" || t.type === "bar").filter(pf)), CC = (e) => e.filter((t) => !("stackId" in t) || t.stackId === void 0), TC = z([Zl], CC), zv = (e) => e.map((t) => t.data).filter(Boolean).flat(1), U6 = z([Zl], zv), Wv = (e, t) => {
  var {
    chartData: n = [],
    dataStartIndex: r,
    dataEndIndex: i
  } = t;
  return e.length > 0 ? e : n.slice(r, i + 1);
}, Vv = z([U6, cf], Wv), Uv = (e, t, n) => t?.dataKey != null ? e.map((r) => ({
  value: ct(r, t.dataKey)
})) : n.length > 0 ? n.map((r) => r.dataKey).flatMap((r) => e.map((i) => ({
  value: ct(i, r)
}))) : e.map((r) => ({
  value: r
})), mf = z([Vv, Dt, Zl], Uv);
function AC(e, t) {
  switch (e) {
    case "xAxis":
      return t.direction === "x";
    case "yAxis":
      return t.direction === "y";
    default:
      return !1;
  }
}
function Go(e) {
  return e.filter((t) => Vr(t) || t instanceof Date).map(Number).filter((t) => qn(t) === !1);
}
function H6(e, t, n) {
  return !n || typeof t != "number" || qn(t) ? [] : n.length ? Go(n.flatMap((r) => {
    var i = ct(e, r.dataKey), o, a;
    if (Array.isArray(i) ? [o, a] = i : o = a = i, !(!Yn(o) || !Yn(a)))
      return [t - o, t + a];
  })) : [];
}
var q6 = z([PC, cf, Zt], OC), kC = (e, t, n) => {
  var r = {}, i = t.reduce((o, a) => (a.stackId == null || (o[a.stackId] == null && (o[a.stackId] = []), o[a.stackId].push(a)), o), r);
  return Object.fromEntries(Object.entries(i).map((o) => {
    var [a, s] = o, l = s.map($v);
    return [a, {
      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that
      stackedData: cL(e, l, n),
      graphicalItems: s
    }];
  }));
}, Bm = z([q6, PC, Yl], kC), MC = (e, t, n) => {
  var {
    dataStartIndex: r,
    dataEndIndex: i
  } = t;
  if (n !== "zAxis") {
    var o = hL(e, r, i);
    if (!(o != null && o[0] === 0 && o[1] === 0))
      return o;
  }
}, K6 = z([Bm, eo, bt], MC), jC = (e, t, n, r, i) => n.length > 0 ? e.flatMap((o) => n.flatMap((a) => {
  var s, l, c = (s = r[a.id]) === null || s === void 0 ? void 0 : s.filter((d) => AC(i, d)), u = ct(o, (l = t.dataKey) !== null && l !== void 0 ? l : a.dataKey);
  return {
    value: u,
    errorDomain: H6(o, u, c)
  };
})).filter(Boolean) : t?.dataKey != null ? e.map((o) => ({
  value: ct(o, t.dataKey),
  errorDomain: []
})) : e.map((o) => ({
  value: o,
  errorDomain: []
})), gf = (e) => e.errorBars, NC = (e, t, n) => e.flatMap((r) => t[r.id]).filter(Boolean).filter((r) => AC(n, r));
z([TC, gf, bt], NC);
var Y6 = z([Vv, Dt, TC, gf, bt], jC);
function G6(e) {
  var {
    value: t
  } = e;
  if (Vr(t) || t instanceof Date)
    return t;
}
var uw = (e) => {
  var t = e.flatMap((r) => [r.value, r.errorDomain]).flat(1), n = Go(t);
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, X6 = (e, t, n) => {
  var r = e.map(G6).filter((i) => i != null);
  return n && (t.dataKey == null || t.allowDuplicatedCategory && F_(r)) ? y2(0, e.length) : t.allowDuplicatedCategory ? r : Array.from(new Set(r));
}, Hv = (e) => {
  var t;
  if (e == null || !("domain" in e))
    return Fm;
  if (e.domain != null)
    return e.domain;
  if (e.ticks != null) {
    if (e.type === "number") {
      var n = Go(e.ticks);
      return [Math.min(...n), Math.max(...n)];
    }
    if (e.type === "category")
      return e.ticks.map(String);
  }
  return (t = e?.domain) !== null && t !== void 0 ? t : Fm;
}, Xu = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  var i = n.filter(Boolean);
  if (i.length !== 0) {
    var o = i.flat(), a = Math.min(...o), s = Math.max(...o);
    return [a, s];
  }
}, DC = (e) => e.referenceElements.dots, Ga = (e, t, n) => e.filter((r) => r.ifOverflow === "extendDomain").filter((r) => t === "xAxis" ? r.xAxisId === n : r.yAxisId === n), Z6 = z([DC, bt, Gl], Ga), RC = (e) => e.referenceElements.areas, J6 = z([RC, bt, Gl], Ga), IC = (e) => e.referenceElements.lines, Q6 = z([IC, bt, Gl], Ga), $C = (e, t) => {
  var n = Go(e.map((r) => t === "xAxis" ? r.x : r.y));
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, e3 = z(Z6, bt, $C), LC = (e, t) => {
  var n = Go(e.flatMap((r) => [t === "xAxis" ? r.x1 : r.y1, t === "xAxis" ? r.x2 : r.y2]));
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, t3 = z([J6, bt], LC), FC = (e, t) => {
  var n = Go(e.map((r) => t === "xAxis" ? r.x : r.y));
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, n3 = z(Q6, bt, FC), r3 = z(e3, n3, t3, (e, t, n) => Xu(e, n, t)), BC = z([Dt], Hv), qv = (e, t, n, r, i, o, a) => {
  var s = y6(t, e.allowDataOverflow);
  if (s != null)
    return s;
  var l = o === "vertical" && a === "xAxis" || o === "horizontal" && a === "yAxis", c = l ? Xu(n, i, uw(r)) : Xu(i, uw(r));
  return b6(t, c, e.allowDataOverflow);
}, i3 = z([Dt, BC, K6, Y6, r3, Pe, bt], qv), o3 = [0, 1], Kv = (e, t, n, r, i, o, a) => {
  if (!((e == null || n == null || n.length === 0) && a === void 0)) {
    var {
      dataKey: s,
      type: l
    } = e, c = Xi(t, o);
    return c && s == null ? y2(0, n.length) : l === "category" ? X6(r, e, c) : i === "expand" ? o3 : a;
  }
}, Yv = z([Dt, Pe, Vv, mf, Yl, bt, i3], Kv), zC = (e, t, n, r, i) => {
  if (e != null) {
    var {
      scale: o,
      type: a
    } = e;
    if (o === "auto")
      return t === "radial" && i === "radiusAxis" ? "band" : t === "radial" && i === "angleAxis" ? "linear" : a === "category" && r && (r.indexOf("LineChart") >= 0 || r.indexOf("AreaChart") >= 0 || r.indexOf("ComposedChart") >= 0 && !n) ? "point" : a === "category" ? "band" : "linear";
    if (typeof o == "string") {
      var s = "scale".concat(Il(o));
      return s in Ns ? s : "point";
    }
  }
}, Xa = z([Dt, Pe, _C, Mv, bt], zC);
function a3(e) {
  if (e != null) {
    if (e in Ns)
      return Ns[e]();
    var t = "scale".concat(Il(e));
    if (t in Ns)
      return Ns[t]();
  }
}
function Gv(e, t, n, r) {
  if (!(n == null || r == null)) {
    if (typeof e.scale == "function")
      return e.scale.copy().domain(n).range(r);
    var i = a3(t);
    if (i != null) {
      var o = i.domain(n).range(r);
      return iL(o), o;
    }
  }
}
var Xv = (e, t, n) => {
  var r = Hv(t);
  if (!(n !== "auto" && n !== "linear")) {
    if (t != null && t.tickCount && Array.isArray(r) && (r[0] === "auto" || r[1] === "auto") && Da(e))
      return A6(e, t.tickCount, t.allowDecimals);
    if (t != null && t.tickCount && t.type === "number" && Da(e))
      return k6(e, t.tickCount, t.allowDecimals);
  }
}, Zv = z([Yv, Xl, Xa], Xv), Jv = (e, t, n, r) => {
  if (
    /*
     * Angle axis for some reason uses nice ticks when rendering axis tick labels,
     * but doesn't use nice ticks for extending domain like all the other axes do.
     * Not really sure why? Is there a good reason,
     * or is it just because someone added support for nice ticks to the other axes and forgot this one?
     */
    r !== "angleAxis" && e?.type === "number" && Da(t) && Array.isArray(n) && n.length > 0
  ) {
    var i = t[0], o = n[0], a = t[1], s = n[n.length - 1];
    return [Math.min(i, o), Math.max(a, s)];
  }
  return t;
}, s3 = z([Dt, Yv, Zv, bt], Jv), l3 = z(mf, Dt, (e, t) => {
  if (!(!t || t.type !== "number")) {
    var n = 1 / 0, r = Array.from(Go(e.map((s) => s.value))).sort((s, l) => s - l);
    if (r.length < 2)
      return 1 / 0;
    var i = r[r.length - 1] - r[0];
    if (i === 0)
      return 1 / 0;
    for (var o = 0; o < r.length - 1; o++) {
      var a = r[o + 1] - r[o];
      n = Math.min(n, a);
    }
    return n / i;
  }
}), WC = z(l3, Pe, hC, zt, (e, t, n, r) => r, (e, t, n, r, i) => {
  if (!Yn(e))
    return 0;
  var o = t === "vertical" ? r.height : r.width;
  if (i === "gap")
    return e * o / 2;
  if (i === "no-gap") {
    var a = hn(n, e * o), s = e * o / 2;
    return s - a - (s - a) / o * a;
  }
  return 0;
}), c3 = (e, t) => {
  var n = Ei(e, t);
  return n == null || typeof n.padding != "string" ? 0 : WC(e, "xAxis", t, n.padding);
}, u3 = (e, t) => {
  var n = _i(e, t);
  return n == null || typeof n.padding != "string" ? 0 : WC(e, "yAxis", t, n.padding);
}, d3 = z(Ei, c3, (e, t) => {
  var n, r;
  if (e == null)
    return {
      left: 0,
      right: 0
    };
  var {
    padding: i
  } = e;
  return typeof i == "string" ? {
    left: t,
    right: t
  } : {
    left: ((n = i.left) !== null && n !== void 0 ? n : 0) + t,
    right: ((r = i.right) !== null && r !== void 0 ? r : 0) + t
  };
}), f3 = z(_i, u3, (e, t) => {
  var n, r;
  if (e == null)
    return {
      top: 0,
      bottom: 0
    };
  var {
    padding: i
  } = e;
  return typeof i == "string" ? {
    top: t,
    bottom: t
  } : {
    top: ((n = i.top) !== null && n !== void 0 ? n : 0) + t,
    bottom: ((r = i.bottom) !== null && r !== void 0 ? r : 0) + t
  };
}), p3 = z([zt, d3, ef, Qd, (e, t, n) => n], (e, t, n, r, i) => {
  var {
    padding: o
  } = r;
  return i ? [o.left, n.width - o.right] : [e.left + t.left, e.left + e.width - t.right];
}), h3 = z([zt, Pe, f3, ef, Qd, (e, t, n) => n], (e, t, n, r, i, o) => {
  var {
    padding: a
  } = i;
  return o ? [r.height - a.bottom, a.top] : t === "horizontal" ? [e.top + e.height - n.bottom, e.top + n.top] : [e.top + n.top, e.top + e.height - n.bottom];
}), Jl = (e, t, n, r) => {
  var i;
  switch (t) {
    case "xAxis":
      return p3(e, n, r);
    case "yAxis":
      return h3(e, n, r);
    case "zAxis":
      return (i = Lv(e, n)) === null || i === void 0 ? void 0 : i.range;
    case "angleAxis":
      return yC(e);
    case "radiusAxis":
      return bC(e, n);
    default:
      return;
  }
}, VC = z([Dt, Jl], df), Za = z([Dt, Xa, s3, VC], Gv);
z([Zl, gf, bt], NC);
function UC(e, t) {
  return e.id < t.id ? -1 : e.id > t.id ? 1 : 0;
}
var vf = (e, t) => t, yf = (e, t, n) => n, m3 = z(Zd, vf, yf, (e, t, n) => e.filter((r) => r.orientation === t).filter((r) => r.mirror === n).sort(UC)), g3 = z(Jd, vf, yf, (e, t, n) => e.filter((r) => r.orientation === t).filter((r) => r.mirror === n).sort(UC)), HC = (e, t) => ({
  width: e.width,
  height: t.height
}), v3 = (e, t) => {
  var n = typeof t.width == "number" ? t.width : zl;
  return {
    width: n,
    height: e.height
  };
}, qC = z(zt, Ei, HC), y3 = (e, t, n) => {
  switch (t) {
    case "top":
      return e.top;
    case "bottom":
      return n - e.bottom;
    default:
      return 0;
  }
}, b3 = (e, t, n) => {
  switch (t) {
    case "left":
      return e.left;
    case "right":
      return n - e.right;
    default:
      return 0;
  }
}, x3 = z(Oi, zt, m3, vf, yf, (e, t, n, r, i) => {
  var o = {}, a;
  return n.forEach((s) => {
    var l = HC(t, s);
    a == null && (a = y3(t, r, e));
    var c = r === "top" && !i || r === "bottom" && i;
    o[s.id] = a - Number(c) * l.height, a += (c ? -1 : 1) * l.height;
  }), o;
}), w3 = z(wi, zt, g3, vf, yf, (e, t, n, r, i) => {
  var o = {}, a;
  return n.forEach((s) => {
    var l = v3(t, s);
    a == null && (a = b3(t, r, e));
    var c = r === "left" && !i || r === "right" && i;
    o[s.id] = a - Number(c) * l.width, a += (c ? -1 : 1) * l.width;
  }), o;
}), O3 = (e, t) => {
  var n = Ei(e, t);
  if (n != null)
    return x3(e, n.orientation, n.mirror);
}, S3 = z([zt, Ei, O3, (e, t) => t], (e, t, n, r) => {
  if (t != null) {
    var i = n?.[r];
    return i == null ? {
      x: e.left,
      y: 0
    } : {
      x: e.left,
      y: i
    };
  }
}), E3 = (e, t) => {
  var n = _i(e, t);
  if (n != null)
    return w3(e, n.orientation, n.mirror);
}, _3 = z([zt, _i, E3, (e, t) => t], (e, t, n, r) => {
  if (t != null) {
    var i = n?.[r];
    return i == null ? {
      x: 0,
      y: e.top
    } : {
      x: i,
      y: e.top
    };
  }
}), KC = z(zt, _i, (e, t) => {
  var n = typeof t.width == "number" ? t.width : zl;
  return {
    width: n,
    height: e.height
  };
}), dw = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return qC(e, n).width;
    case "yAxis":
      return KC(e, n).height;
    default:
      return;
  }
}, YC = (e, t, n, r) => {
  if (n != null) {
    var {
      allowDuplicatedCategory: i,
      type: o,
      dataKey: a
    } = n, s = Xi(e, r), l = t.map((c) => c.value);
    if (a && s && o === "category" && i && F_(l))
      return l;
  }
}, Qv = z([Pe, mf, Dt, bt], YC), GC = (e, t, n, r) => {
  if (!(n == null || n.dataKey == null)) {
    var {
      type: i,
      scale: o
    } = n, a = Xi(e, r);
    if (a && (i === "number" || o !== "auto"))
      return t.map((s) => s.value);
  }
}, ey = z([Pe, mf, Xl, bt], GC), fw = z([Pe, W6, Xa, Za, Qv, ey, Jl, Zv, bt], (e, t, n, r, i, o, a, s, l) => {
  if (t == null)
    return null;
  var c = Xi(e, l);
  return {
    angle: t.angle,
    interval: t.interval,
    minTickGap: t.minTickGap,
    orientation: t.orientation,
    tick: t.tick,
    tickCount: t.tickCount,
    tickFormatter: t.tickFormatter,
    ticks: t.ticks,
    type: t.type,
    unit: t.unit,
    axisType: l,
    categoricalDomain: o,
    duplicateDomain: i,
    isCategorical: c,
    niceTicks: s,
    range: a,
    realScaleType: n,
    scale: r
  };
}), P3 = (e, t, n, r, i, o, a, s, l) => {
  if (!(t == null || r == null)) {
    var c = Xi(e, l), {
      type: u,
      ticks: d,
      tickCount: p
    } = t, h = n === "scaleBand" && typeof r.bandwidth == "function" ? r.bandwidth() / 2 : 2, g = u === "category" && r.bandwidth ? r.bandwidth() / h : 0;
    g = l === "angleAxis" && o != null && o.length >= 2 ? Yt(o[0] - o[1]) * 2 * g : g;
    var m = d || i;
    if (m) {
      var v = m.map((y, S) => {
        var w = a ? a.indexOf(y) : y;
        return {
          index: S,
          // If the scaleContent is not a number, the coordinate will be NaN.
          // That could be the case for example with a PointScale and a string as domain.
          coordinate: r(w) + g,
          value: y,
          offset: g
        };
      });
      return v.filter((y) => !qn(y.coordinate));
    }
    return c && s ? s.map((y, S) => ({
      coordinate: r(y) + g,
      value: y,
      index: S,
      offset: g
    })) : r.ticks ? r.ticks(p).map((y) => ({
      coordinate: r(y) + g,
      value: y,
      offset: g
    })) : r.domain().map((y, S) => ({
      coordinate: r(y) + g,
      value: a ? a[y] : y,
      index: S,
      offset: g
    }));
  }
}, XC = z([Pe, Xl, Xa, Za, Zv, Jl, Qv, ey, bt], P3), C3 = (e, t, n, r, i, o, a) => {
  if (!(t == null || n == null || r == null || r[0] === r[1])) {
    var s = Xi(e, a), {
      tickCount: l
    } = t, c = 0;
    return c = a === "angleAxis" && r?.length >= 2 ? Yt(r[0] - r[1]) * 2 * c : c, s && o ? o.map((u, d) => ({
      coordinate: n(u) + c,
      value: u,
      index: d,
      offset: c
    })) : n.ticks ? n.ticks(l).map((u) => ({
      coordinate: n(u) + c,
      value: u,
      offset: c
    })) : n.domain().map((u, d) => ({
      coordinate: n(u) + c,
      value: i ? i[u] : u,
      index: d,
      offset: c
    }));
  }
}, Wi = z([Pe, Xl, Za, Jl, Qv, ey, bt], C3), Vi = z(Dt, Za, (e, t) => {
  if (!(e == null || t == null))
    return Gu(Gu({}, e), {}, {
      scale: t
    });
}), T3 = z([Dt, Xa, Yv, VC], Gv);
z((e, t, n) => Lv(e, n), T3, (e, t) => {
  if (!(e == null || t == null))
    return Gu(Gu({}, e), {}, {
      scale: t
    });
});
var A3 = z([Pe, Zd, Jd], (e, t, n) => {
  switch (e) {
    case "horizontal":
      return t.some((r) => r.reversed) ? "right-to-left" : "left-to-right";
    case "vertical":
      return n.some((r) => r.reversed) ? "bottom-to-top" : "top-to-bottom";
    // TODO: make this better. For now, right arrow triggers "forward", left arrow "back"
    // however, the tooltip moves an unintuitive direction because of how the indices are rendered
    case "centric":
    case "radial":
      return "left-to-right";
    default:
      return;
  }
}), ZC = (e) => e.options.defaultTooltipEventType, JC = (e) => e.options.validateTooltipEventTypes;
function QC(e, t, n) {
  if (e == null)
    return t;
  var r = e ? "axis" : "item";
  return n == null ? t : n.includes(r) ? r : t;
}
function ty(e, t) {
  var n = ZC(e), r = JC(e);
  return QC(t, n, r);
}
function k3(e) {
  return pe((t) => ty(t, e));
}
var eT = (e, t) => {
  var n, r = Number(t);
  if (!(qn(r) || t == null))
    return r >= 0 ? e == null || (n = e[r]) === null || n === void 0 ? void 0 : n.value : void 0;
}, M3 = (e) => e.tooltip.settings, ji = {
  active: !1,
  index: null,
  dataKey: void 0,
  coordinate: void 0
}, j3 = {
  itemInteraction: {
    click: ji,
    hover: ji
  },
  axisInteraction: {
    click: ji,
    hover: ji
  },
  keyboardInteraction: ji,
  syncInteraction: {
    active: !1,
    index: null,
    dataKey: void 0,
    label: void 0,
    coordinate: void 0
  },
  tooltipItemPayloads: [],
  settings: {
    shared: void 0,
    trigger: "hover",
    axisId: 0,
    active: !1,
    defaultIndex: void 0
  }
}, tT = Zn({
  name: "tooltip",
  initialState: j3,
  reducers: {
    addTooltipEntrySettings(e, t) {
      e.tooltipItemPayloads.push(t.payload);
    },
    removeTooltipEntrySettings(e, t) {
      var n = ui(e).tooltipItemPayloads.indexOf(t.payload);
      n > -1 && e.tooltipItemPayloads.splice(n, 1);
    },
    setTooltipSettingsState(e, t) {
      e.settings = t.payload;
    },
    setActiveMouseOverItemIndex(e, t) {
      e.syncInteraction.active = !1, e.keyboardInteraction.active = !1, e.itemInteraction.hover.active = !0, e.itemInteraction.hover.index = t.payload.activeIndex, e.itemInteraction.hover.dataKey = t.payload.activeDataKey, e.itemInteraction.hover.coordinate = t.payload.activeCoordinate;
    },
    mouseLeaveChart(e) {
      e.itemInteraction.hover.active = !1, e.axisInteraction.hover.active = !1;
    },
    mouseLeaveItem(e) {
      e.itemInteraction.hover.active = !1;
    },
    setActiveClickItemIndex(e, t) {
      e.syncInteraction.active = !1, e.itemInteraction.click.active = !0, e.keyboardInteraction.active = !1, e.itemInteraction.click.index = t.payload.activeIndex, e.itemInteraction.click.dataKey = t.payload.activeDataKey, e.itemInteraction.click.coordinate = t.payload.activeCoordinate;
    },
    setMouseOverAxisIndex(e, t) {
      e.syncInteraction.active = !1, e.axisInteraction.hover.active = !0, e.keyboardInteraction.active = !1, e.axisInteraction.hover.index = t.payload.activeIndex, e.axisInteraction.hover.dataKey = t.payload.activeDataKey, e.axisInteraction.hover.coordinate = t.payload.activeCoordinate;
    },
    setMouseClickAxisIndex(e, t) {
      e.syncInteraction.active = !1, e.keyboardInteraction.active = !1, e.axisInteraction.click.active = !0, e.axisInteraction.click.index = t.payload.activeIndex, e.axisInteraction.click.dataKey = t.payload.activeDataKey, e.axisInteraction.click.coordinate = t.payload.activeCoordinate;
    },
    setSyncInteraction(e, t) {
      e.syncInteraction = t.payload;
    },
    setKeyboardInteraction(e, t) {
      e.keyboardInteraction.active = t.payload.active, e.keyboardInteraction.index = t.payload.activeIndex, e.keyboardInteraction.coordinate = t.payload.activeCoordinate, e.keyboardInteraction.dataKey = t.payload.activeDataKey;
    }
  }
}), {
  addTooltipEntrySettings: N3,
  removeTooltipEntrySettings: D3,
  setTooltipSettingsState: R3,
  setActiveMouseOverItemIndex: nT,
  mouseLeaveItem: I3,
  mouseLeaveChart: rT,
  setActiveClickItemIndex: $3,
  setMouseOverAxisIndex: iT,
  setMouseClickAxisIndex: L3,
  setSyncInteraction: zm,
  setKeyboardInteraction: Wm
} = tT.actions, F3 = tT.reducer;
function pw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pw(Object(n), !0).forEach(function(r) {
      B3(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function B3(e, t, n) {
  return (t = z3(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function z3(e) {
  var t = W3(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function W3(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function V3(e, t, n) {
  return t === "axis" ? n === "click" ? e.axisInteraction.click : e.axisInteraction.hover : n === "click" ? e.itemInteraction.click : e.itemInteraction.hover;
}
function U3(e) {
  return e.index != null;
}
var oT = (e, t, n, r) => {
  if (t == null)
    return ji;
  var i = V3(e, t, n);
  if (i == null)
    return ji;
  if (i.active)
    return i;
  if (e.keyboardInteraction.active)
    return e.keyboardInteraction;
  if (e.syncInteraction.active && e.syncInteraction.index != null)
    return e.syncInteraction;
  var o = e.settings.active === !0;
  if (U3(i)) {
    if (o)
      return Nc(Nc({}, i), {}, {
        active: !0
      });
  } else if (r != null)
    return {
      active: !0,
      coordinate: void 0,
      dataKey: void 0,
      index: r
    };
  return Nc(Nc({}, ji), {}, {
    coordinate: i.coordinate
  });
}, ny = (e, t) => {
  var n = e?.index;
  if (n == null)
    return null;
  var r = Number(n);
  if (!Yn(r))
    return n;
  var i = 0, o = 1 / 0;
  return t.length > 0 && (o = t.length - 1), String(Math.max(i, Math.min(r, o)));
}, aT = (e, t, n, r, i, o, a, s) => {
  if (!(o == null || s == null)) {
    var l = a[0], c = l == null ? void 0 : s(l.positions, o);
    if (c != null)
      return c;
    var u = i?.[Number(o)];
    if (u)
      switch (n) {
        case "horizontal":
          return {
            x: u.coordinate,
            y: (r.top + t) / 2
          };
        default:
          return {
            x: (r.left + e) / 2,
            y: u.coordinate
          };
      }
  }
}, sT = (e, t, n, r) => {
  if (t === "axis")
    return e.tooltipItemPayloads;
  if (e.tooltipItemPayloads.length === 0)
    return [];
  var i;
  return n === "hover" ? i = e.itemInteraction.hover.dataKey : i = e.itemInteraction.click.dataKey, i == null && r != null ? [e.tooltipItemPayloads[0]] : e.tooltipItemPayloads.filter((o) => {
    var a;
    return ((a = o.settings) === null || a === void 0 ? void 0 : a.dataKey) === i;
  });
}, Ql = (e) => e.options.tooltipPayloadSearcher, Ja = (e) => e.tooltip;
function hw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hw(Object(n), !0).forEach(function(r) {
      H3(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function H3(e, t, n) {
  return (t = q3(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function q3(e) {
  var t = K3(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function K3(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Y3(e, t) {
  return e ?? t;
}
var lT = (e, t, n, r, i, o, a) => {
  if (!(t == null || o == null)) {
    var {
      chartData: s,
      computedData: l,
      dataStartIndex: c,
      dataEndIndex: u
    } = n, d = [];
    return e.reduce((p, h) => {
      var g, {
        dataDefinedOnItem: m,
        settings: v
      } = h, y = Y3(m, s), S = Array.isArray(y) ? ZP(y, c, u) : y, w = (g = v?.dataKey) !== null && g !== void 0 ? g : r, b = v?.nameKey, O;
      if (r && Array.isArray(S) && /*
       * findEntryInArray won't work for Scatter because Scatter provides an array of arrays
       * as tooltip payloads and findEntryInArray is not prepared to handle that.
       * Sad but also ScatterChart only allows 'item' tooltipEventType
       * and also this is only a problem if there are multiple Scatters and each has its own data array
       * so let's fix that some other time.
       */
      !Array.isArray(S[0]) && /*
       * If the tooltipEventType is 'axis', we should search for the dataKey in the sliced data
       * because thanks to allowDuplicatedCategory=false, the order of elements in the array
       * no longer matches the order of elements in the original data
       * and so we need to search by the active dataKey + label rather than by index.
       *
       * The same happens if multiple graphical items are present in the chart
       * and each of them has its own data array. Those arrays get concatenated
       * and again the tooltip index no longer matches the original data.
       *
       * On the other hand the tooltipEventType 'item' should always search by index
       * because we get the index from interacting over the individual elements
       * which is always accurate, irrespective of the allowDuplicatedCategory setting.
       */
      a === "axis" ? O = B_(S, r, i) : O = o(S, t, l, b), Array.isArray(O))
        O.forEach((C) => {
          var T = mw(mw({}, v), {}, {
            name: C.name,
            unit: C.unit,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            color: void 0,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            fill: void 0
          });
          p.push(Qx({
            tooltipEntrySettings: T,
            dataKey: C.dataKey,
            payload: C.payload,
            // @ts-expect-error getValueByDataKey does not validate the output type
            value: ct(C.payload, C.dataKey),
            name: C.name
          }));
        });
      else {
        var E;
        p.push(Qx({
          tooltipEntrySettings: v,
          dataKey: w,
          payload: O,
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: ct(O, w),
          // @ts-expect-error getValueByDataKey does not validate the output type
          name: (E = ct(O, b)) !== null && E !== void 0 ? E : v?.name
        }));
      }
      return p;
    }, d);
  }
}, ry = z([Zt, Pe, _C, Mv, Vt], zC), G3 = z([(e) => e.graphicalItems.cartesianItems, (e) => e.graphicalItems.polarItems], (e, t) => [...e, ...t]), X3 = z([Vt, Ya], Fv), ec = z([G3, Zt, X3], Bv), Z3 = z([ec], (e) => e.filter(pf)), J3 = z([ec], zv), Qa = z([J3, eo], Wv), Q3 = z([Z3, eo, Zt], OC), iy = z([Qa, Zt, ec], Uv), e8 = z([Zt], Hv), t8 = z([ec], (e) => e.filter(pf)), n8 = z([Q3, t8, Yl], kC), r8 = z([n8, eo, Vt], MC), i8 = z([ec], CC), o8 = z([Qa, Zt, i8, gf, Vt], jC), a8 = z([DC, Vt, Ya], Ga), s8 = z([a8, Vt], $C), l8 = z([RC, Vt, Ya], Ga), c8 = z([l8, Vt], LC), u8 = z([IC, Vt, Ya], Ga), d8 = z([u8, Vt], FC), f8 = z([s8, d8, c8], Xu), p8 = z([Zt, e8, r8, o8, f8, Pe, Vt], qv), cT = z([Zt, Pe, Qa, iy, Yl, Vt, p8], Kv), h8 = z([cT, Zt, ry], Xv), m8 = z([Zt, cT, h8, Vt], Jv), uT = (e) => {
  var t = Vt(e), n = Ya(e), r = !1;
  return Jl(e, t, n, r);
}, dT = z([Zt, uT], df), fT = z([Zt, ry, m8, dT], Gv), g8 = z([Pe, iy, Zt, Vt], YC), v8 = z([Pe, iy, Zt, Vt], GC), y8 = (e, t, n, r, i, o, a, s) => {
  if (t) {
    var {
      type: l
    } = t, c = Xi(e, s);
    if (r) {
      var u = n === "scaleBand" && r.bandwidth ? r.bandwidth() / 2 : 2, d = l === "category" && r.bandwidth ? r.bandwidth() / u : 0;
      return d = s === "angleAxis" && i != null && i?.length >= 2 ? Yt(i[0] - i[1]) * 2 * d : d, c && a ? a.map((p, h) => ({
        coordinate: r(p) + d,
        value: p,
        index: h,
        offset: d
      })) : r.domain().map((p, h) => ({
        coordinate: r(p) + d,
        value: o ? o[p] : p,
        index: h,
        offset: d
      }));
    }
  }
}, Pi = z([Pe, Zt, ry, fT, uT, g8, v8, Vt], y8), oy = z([ZC, JC, M3], (e, t, n) => QC(n.shared, e, t)), pT = (e) => e.tooltip.settings.trigger, ay = (e) => e.tooltip.settings.defaultIndex, bf = z([Ja, oy, pT, ay], oT), Ui = z([bf, Qa], ny), hT = z([Pi, Ui], eT), mT = z([bf], (e) => {
  if (e)
    return e.dataKey;
}), gT = z([Ja, oy, pT, ay], sT), b8 = z([wi, Oi, Pe, zt, Pi, ay, gT, Ql], aT), x8 = z([bf, b8], (e, t) => e != null && e.coordinate ? e.coordinate : t), w8 = z([bf], (e) => e.active), O8 = z([gT, Ui, eo, wC, hT, Ql, oy], lT), S8 = z([O8], (e) => {
  if (e != null) {
    var t = e.map((n) => n.payload).filter((n) => n != null);
    return Array.from(new Set(t));
  }
});
function gw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gw(Object(n), !0).forEach(function(r) {
      E8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function E8(e, t, n) {
  return (t = _8(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function _8(e) {
  var t = P8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function P8(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var C8 = () => pe(Zt), T8 = () => {
  var e = C8(), t = pe(Pi), n = pe(fT);
  return al(vw(vw({}, e), {}, {
    scale: n
  }), t);
}, A8 = () => pe(Mv), sy = (e, t) => t, vT = (e, t, n) => n, ly = (e, t, n, r) => r, k8 = z(Pi, (e) => qd(e, (t) => t.coordinate)), cy = z([Ja, sy, vT, ly], oT), yT = z([cy, Qa], ny), M8 = (e, t, n) => {
  if (t != null) {
    var r = Ja(e);
    return t === "axis" ? n === "hover" ? r.axisInteraction.hover.dataKey : r.axisInteraction.click.dataKey : n === "hover" ? r.itemInteraction.hover.dataKey : r.itemInteraction.click.dataKey;
  }
}, bT = z([Ja, sy, vT, ly], sT), Zu = z([wi, Oi, Pe, zt, Pi, ly, bT, Ql], aT), j8 = z([cy, Zu], (e, t) => {
  var n;
  return (n = e.coordinate) !== null && n !== void 0 ? n : t;
}), xT = z(Pi, yT, eT), N8 = z([bT, yT, eo, wC, xT, Ql, sy], lT), D8 = z([cy], (e) => ({
  isActive: e.active,
  activeIndex: e.index
})), R8 = (e, t, n, r, i, o, a, s) => {
  if (!(!e || !t || !r || !i || !o)) {
    var l = mL(e.chartX, e.chartY, t, n, s);
    if (l) {
      var c = vL(l, t), u = nL(c, a, o, r, i), d = gL(t, o, u, l);
      return {
        activeIndex: String(u),
        activeCoordinate: d
      };
    }
  }
};
function Vm() {
  return Vm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Vm.apply(null, arguments);
}
function yw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yw(Object(n), !0).forEach(function(r) {
      I8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function I8(e, t, n) {
  return (t = $8(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function $8(e) {
  var t = L8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function L8(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function F8(e) {
  var {
    coordinate: t,
    payload: n,
    index: r,
    offset: i,
    tooltipAxisBandSize: o,
    layout: a,
    cursor: s,
    tooltipEventType: l,
    chartName: c
  } = e, u = t, d = n, p = r;
  if (!s || !u || c !== "ScatterChart" && l !== "axis")
    return null;
  var h, g;
  if (c === "ScatterChart")
    h = u, g = iF;
  else if (c === "BarChart")
    h = oF(a, u, i, o), g = h2;
  else if (a === "radial") {
    var {
      cx: m,
      cy: v,
      radius: y,
      startAngle: S,
      endAngle: w
    } = m2(u);
    h = {
      cx: m,
      cy: v,
      startAngle: S,
      endAngle: w,
      innerRadius: y,
      outerRadius: y
    }, g = v2;
  } else
    h = {
      points: LF(a, u, i)
    }, g = iv;
  var b = typeof s == "object" && "className" in s ? s.className : void 0, O = Dc(Dc(Dc(Dc({
    stroke: "#ccc",
    pointerEvents: "none"
  }, i), h), wt(s, !1)), {}, {
    payload: d,
    payloadIndex: p,
    className: ie("recharts-tooltip-cursor", b)
  });
  return /* @__PURE__ */ bn(s) ? /* @__PURE__ */ cr(s, O) : /* @__PURE__ */ BE(g, O);
}
function B8(e) {
  var t = T8(), n = r2(), r = tf(), i = A8();
  return /* @__PURE__ */ _.createElement(F8, Vm({}, e, {
    coordinate: e.coordinate,
    index: e.index,
    payload: e.payload,
    offset: n,
    layout: r,
    tooltipAxisBandSize: t,
    chartName: i
  }));
}
var wT = /* @__PURE__ */ gr(null), z8 = () => Kr(wT), hh = { exports: {} }, bw;
function W8() {
  return bw || (bw = 1, (function(e) {
    var t = Object.prototype.hasOwnProperty, n = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
    function i(l, c, u) {
      this.fn = l, this.context = c, this.once = u || !1;
    }
    function o(l, c, u, d, p) {
      if (typeof u != "function")
        throw new TypeError("The listener must be a function");
      var h = new i(u, d || l, p), g = n ? n + c : c;
      return l._events[g] ? l._events[g].fn ? l._events[g] = [l._events[g], h] : l._events[g].push(h) : (l._events[g] = h, l._eventsCount++), l;
    }
    function a(l, c) {
      --l._eventsCount === 0 ? l._events = new r() : delete l._events[c];
    }
    function s() {
      this._events = new r(), this._eventsCount = 0;
    }
    s.prototype.eventNames = function() {
      var c = [], u, d;
      if (this._eventsCount === 0) return c;
      for (d in u = this._events)
        t.call(u, d) && c.push(n ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;
    }, s.prototype.listeners = function(c) {
      var u = n ? n + c : c, d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var p = 0, h = d.length, g = new Array(h); p < h; p++)
        g[p] = d[p].fn;
      return g;
    }, s.prototype.listenerCount = function(c) {
      var u = n ? n + c : c, d = this._events[u];
      return d ? d.fn ? 1 : d.length : 0;
    }, s.prototype.emit = function(c, u, d, p, h, g) {
      var m = n ? n + c : c;
      if (!this._events[m]) return !1;
      var v = this._events[m], y = arguments.length, S, w;
      if (v.fn) {
        switch (v.once && this.removeListener(c, v.fn, void 0, !0), y) {
          case 1:
            return v.fn.call(v.context), !0;
          case 2:
            return v.fn.call(v.context, u), !0;
          case 3:
            return v.fn.call(v.context, u, d), !0;
          case 4:
            return v.fn.call(v.context, u, d, p), !0;
          case 5:
            return v.fn.call(v.context, u, d, p, h), !0;
          case 6:
            return v.fn.call(v.context, u, d, p, h, g), !0;
        }
        for (w = 1, S = new Array(y - 1); w < y; w++)
          S[w - 1] = arguments[w];
        v.fn.apply(v.context, S);
      } else {
        var b = v.length, O;
        for (w = 0; w < b; w++)
          switch (v[w].once && this.removeListener(c, v[w].fn, void 0, !0), y) {
            case 1:
              v[w].fn.call(v[w].context);
              break;
            case 2:
              v[w].fn.call(v[w].context, u);
              break;
            case 3:
              v[w].fn.call(v[w].context, u, d);
              break;
            case 4:
              v[w].fn.call(v[w].context, u, d, p);
              break;
            default:
              if (!S) for (O = 1, S = new Array(y - 1); O < y; O++)
                S[O - 1] = arguments[O];
              v[w].fn.apply(v[w].context, S);
          }
      }
      return !0;
    }, s.prototype.on = function(c, u, d) {
      return o(this, c, u, d, !1);
    }, s.prototype.once = function(c, u, d) {
      return o(this, c, u, d, !0);
    }, s.prototype.removeListener = function(c, u, d, p) {
      var h = n ? n + c : c;
      if (!this._events[h]) return this;
      if (!u)
        return a(this, h), this;
      var g = this._events[h];
      if (g.fn)
        g.fn === u && (!p || g.once) && (!d || g.context === d) && a(this, h);
      else {
        for (var m = 0, v = [], y = g.length; m < y; m++)
          (g[m].fn !== u || p && !g[m].once || d && g[m].context !== d) && v.push(g[m]);
        v.length ? this._events[h] = v.length === 1 ? v[0] : v : a(this, h);
      }
      return this;
    }, s.prototype.removeAllListeners = function(c) {
      var u;
      return c ? (u = n ? n + c : c, this._events[u] && a(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
    }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, e.exports = s;
  })(hh)), hh.exports;
}
var V8 = W8();
const U8 = /* @__PURE__ */ xi(V8);
var pl = new U8(), Um = "recharts.syncEvent.tooltip", xw = "recharts.syncEvent.brush";
function uy(e, t) {
  if (t) {
    var n = Number.parseInt(t, 10);
    if (!qn(n))
      return e?.[n];
  }
}
var H8 = {
  chartName: "",
  tooltipPayloadSearcher: void 0,
  eventEmitter: void 0,
  defaultTooltipEventType: "axis"
}, OT = Zn({
  name: "options",
  initialState: H8,
  reducers: {
    createEventEmitter: (e) => {
      e.eventEmitter == null && (e.eventEmitter = Symbol("rechartsEventEmitter"));
    }
  }
}), q8 = OT.reducer, {
  createEventEmitter: K8
} = OT.actions;
function Y8(e) {
  return e.tooltip.syncInteraction;
}
var G8 = {
  chartData: void 0,
  computedData: void 0,
  dataStartIndex: 0,
  dataEndIndex: 0
}, ST = Zn({
  name: "chartData",
  initialState: G8,
  reducers: {
    setChartData(e, t) {
      if (e.chartData = t.payload, t.payload == null) {
        e.dataStartIndex = 0, e.dataEndIndex = 0;
        return;
      }
      t.payload.length > 0 && e.dataEndIndex !== t.payload.length - 1 && (e.dataEndIndex = t.payload.length - 1);
    },
    setComputedData(e, t) {
      e.computedData = t.payload;
    },
    setDataStartEndIndexes(e, t) {
      var {
        startIndex: n,
        endIndex: r
      } = t.payload;
      n != null && (e.dataStartIndex = n), r != null && (e.dataEndIndex = r);
    }
  }
}), {
  setChartData: ww,
  setDataStartEndIndexes: X8,
  setComputedData: Hte
} = ST.actions, Z8 = ST.reducer, J8 = ["x", "y"];
function Ow(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ow(Object(n), !0).forEach(function(r) {
      Q8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ow(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Q8(e, t, n) {
  return (t = ez(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function ez(e) {
  var t = tz(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function tz(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function nz(e, t) {
  if (e == null) return {};
  var n, r, i = rz(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function rz(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var ET = () => {
};
function iz() {
  var e = pe(jv), t = pe(Nv), n = Nt(), r = pe(mC), i = pe(Pi), o = tf(), a = rv(), s = pe((l) => l.rootProps.className);
  De(() => {
    if (e == null)
      return ET;
    var l = (c, u, d) => {
      if (t !== d && e === c) {
        if (r === "index") {
          var p;
          if (a && u !== null && u !== void 0 && (p = u.payload) !== null && p !== void 0 && p.coordinate) {
            var h = u.payload.coordinate, {
              x: g,
              y: m
            } = h, v = nz(h, J8), y = lo(lo(lo({}, v), typeof g == "number" && {
              x: Math.max(a.x, Math.min(g, a.x + a.width))
            }), typeof m == "number" && {
              y: Math.max(a.y, Math.min(m, a.y + a.height))
            }), S = lo(lo({}, u), {}, {
              payload: lo(lo({}, u.payload), {}, {
                coordinate: y
              })
            });
            n(S);
          } else
            n(u);
          return;
        }
        if (i != null) {
          var w;
          if (typeof r == "function") {
            var b = {
              activeTooltipIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
              isTooltipActive: u.payload.active,
              activeIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
              activeLabel: u.payload.label,
              activeDataKey: u.payload.dataKey,
              activeCoordinate: u.payload.coordinate
            }, O = r(i, b);
            w = i[O];
          } else r === "value" && (w = i.find((R) => String(R.value) === u.payload.label));
          var {
            coordinate: E
          } = u.payload;
          if (w == null || u.payload.active === !1 || E == null || a == null) {
            n(zm({
              active: !1,
              coordinate: void 0,
              dataKey: void 0,
              index: null,
              label: void 0
            }));
            return;
          }
          var {
            x: C,
            y: T
          } = E, j = Math.min(C, a.x + a.width), A = Math.min(T, a.y + a.height), M = {
            x: o === "horizontal" ? w.coordinate : j,
            y: o === "horizontal" ? A : w.coordinate
          }, P = zm({
            active: u.payload.active,
            coordinate: M,
            dataKey: u.payload.dataKey,
            index: String(w.index),
            label: u.payload.label
          });
          n(P);
        }
      }
    };
    return pl.on(Um, l), () => {
      pl.off(Um, l);
    };
  }, [s, n, t, e, r, i, o, a]);
}
function oz() {
  var e = pe(jv), t = pe(Nv), n = Nt();
  De(() => {
    if (e == null)
      return ET;
    var r = (i, o, a) => {
      t !== a && e === i && n(X8(o));
    };
    return pl.on(xw, r), () => {
      pl.off(xw, r);
    };
  }, [n, t, e]);
}
function az() {
  var e = Nt();
  De(() => {
    e(K8());
  }, [e]), iz(), oz();
}
function sz(e, t, n, r, i, o) {
  var a = pe((p) => M8(p, e, t)), s = pe(Nv), l = pe(jv), c = pe(mC), u = pe(Y8), d = u?.active;
  De(() => {
    if (!d && l != null && s != null) {
      var p = zm({
        active: o,
        coordinate: n,
        dataKey: a,
        index: i,
        label: typeof r == "number" ? String(r) : r
      });
      pl.emit(Um, l, p, s);
    }
  }, [d, n, a, i, r, s, l, c, o]);
}
function Sw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ew(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sw(Object(n), !0).forEach(function(r) {
      lz(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function lz(e, t, n) {
  return (t = cz(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function cz(e) {
  var t = uz(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function uz(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dz(e) {
  return e.dataKey;
}
function fz(e, t) {
  return /* @__PURE__ */ _.isValidElement(e) ? /* @__PURE__ */ _.cloneElement(e, t) : typeof e == "function" ? /* @__PURE__ */ _.createElement(e, t) : /* @__PURE__ */ _.createElement(IL, t);
}
var _w = [], pz = {
  allowEscapeViewBox: {
    x: !1,
    y: !1
  },
  animationDuration: 400,
  animationEasing: "ease",
  axisId: 0,
  contentStyle: {},
  cursor: !0,
  filterNull: !0,
  isAnimationActive: !Zi.isSsr,
  itemSorter: "name",
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: !1,
    y: !1
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  wrapperStyle: {}
};
function Xo(e) {
  var t = on(e, pz), {
    active: n,
    allowEscapeViewBox: r,
    animationDuration: i,
    animationEasing: o,
    content: a,
    filterNull: s,
    isAnimationActive: l,
    offset: c,
    payloadUniqBy: u,
    position: d,
    reverseDirection: p,
    useTranslate3d: h,
    wrapperStyle: g,
    cursor: m,
    shared: v,
    trigger: y,
    defaultIndex: S,
    portal: w,
    axisId: b
  } = t, O = Nt(), E = typeof S == "number" ? String(S) : S;
  De(() => {
    O(R3({
      shared: v,
      trigger: y,
      axisId: b,
      active: n,
      defaultIndex: E
    }));
  }, [O, v, y, b, n, E]);
  var C = rv(), T = c2(), j = k3(v), {
    activeIndex: A,
    isActive: M
  } = pe((G) => D8(G, j, y, E)), P = pe((G) => N8(G, j, y, E)), R = pe((G) => xT(G, j, y, E)), N = pe((G) => j8(G, j, y, E)), D = P, $ = z8(), F = n ?? M, [q, B] = N$([D, F]), L = j === "axis" ? R : void 0;
  sz(j, y, N, L, A, F);
  var Y = w ?? $;
  if (Y == null)
    return null;
  var K = D ?? _w;
  F || (K = _w), s && K.length && (K = t$(D.filter((G) => G.value != null && (G.hide !== !0 || t.includeHidden)), u, dz));
  var te = K.length > 0, J = /* @__PURE__ */ _.createElement(VL, {
    allowEscapeViewBox: r,
    animationDuration: i,
    animationEasing: o,
    isAnimationActive: l,
    active: F,
    coordinate: N,
    hasPayload: te,
    offset: c,
    position: d,
    reverseDirection: p,
    useTranslate3d: h,
    viewBox: C,
    wrapperStyle: g,
    lastBoundingBox: q,
    innerRef: B,
    hasPortalFromProps: !!w
  }, fz(a, Ew(Ew({}, t), {}, {
    // @ts-expect-error renderContent method expects the payload to be mutable, TODO make it immutable
    payload: K,
    label: L,
    active: F,
    coordinate: N,
    accessibilityLayer: T
  })));
  return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ VE(J, Y), F && /* @__PURE__ */ _.createElement(B8, {
    cursor: m,
    tooltipEventType: j,
    coordinate: N,
    payload: D,
    index: A
  }));
}
var mh = {}, gh = {}, vh = {}, Pw;
function hz() {
  return Pw || (Pw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r, { signal: i, edges: o } = {}) {
      let a, s = null;
      const l = o != null && o.includes("leading"), c = o == null || o.includes("trailing"), u = () => {
        s !== null && (n.apply(a, s), a = void 0, s = null);
      }, d = () => {
        c && u(), m();
      };
      let p = null;
      const h = () => {
        p != null && clearTimeout(p), p = setTimeout(() => {
          p = null, d();
        }, r);
      }, g = () => {
        p !== null && (clearTimeout(p), p = null);
      }, m = () => {
        g(), a = void 0, s = null;
      }, v = () => {
        u();
      }, y = function(...S) {
        if (i?.aborted)
          return;
        a = this, s = S;
        const w = p == null;
        h(), l && w && u();
      };
      return y.schedule = h, y.cancel = m, y.flush = v, i?.addEventListener("abort", m, { once: !0 }), y;
    }
    e.debounce = t;
  })(vh)), vh;
}
var Cw;
function mz() {
  return Cw || (Cw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ hz();
    function n(r, i = 0, o = {}) {
      typeof o != "object" && (o = {});
      const { leading: a = !1, trailing: s = !0, maxWait: l } = o, c = Array(2);
      a && (c[0] = "leading"), s && (c[1] = "trailing");
      let u, d = null;
      const p = t.debounce(function(...m) {
        u = r.apply(this, m), d = null;
      }, i, { edges: c }), h = function(...m) {
        return l != null && (d === null && (d = Date.now()), Date.now() - d >= l) ? (u = r.apply(this, m), d = Date.now(), p.cancel(), p.schedule(), u) : (p.apply(this, m), u);
      }, g = () => (p.flush(), u);
      return h.cancel = p.cancel, h.flush = g, h;
    }
    e.debounce = n;
  })(gh)), gh;
}
var Tw;
function gz() {
  return Tw || (Tw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ mz();
    function n(r, i = 0, o = {}) {
      const { leading: a = !0, trailing: s = !0 } = o;
      return t.debounce(r, i, {
        leading: a,
        maxWait: i,
        trailing: s
      });
    }
    e.throttle = n;
  })(mh)), mh;
}
var yh, Aw;
function vz() {
  return Aw || (Aw = 1, yh = gz().throttle), yh;
}
var yz = /* @__PURE__ */ vz();
const bz = /* @__PURE__ */ xi(yz);
var xz = process.env.NODE_ENV !== "production", Ws = function(t, n) {
  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
    i[o - 2] = arguments[o];
  if (xz && typeof console < "u" && console.warn && (n === void 0 && console.warn("LogUtils requires an error message argument"), !t))
    if (n === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var a = 0;
      console.warn(n.replace(/%s/g, () => i[a++]));
    }
};
function kw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kw(Object(n), !0).forEach(function(r) {
      wz(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function wz(e, t, n) {
  return (t = Oz(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Oz(e) {
  var t = Sz(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Sz(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Zo = /* @__PURE__ */ rn((e, t) => {
  var {
    aspect: n,
    initialDimension: r = {
      width: -1,
      height: -1
    },
    width: i = "100%",
    height: o = "100%",
    /*
     * default min-width to 0 if not specified - 'auto' causes issues with flexbox
     * https://github.com/recharts/recharts/issues/172
     */
    minWidth: a = 0,
    minHeight: s,
    maxHeight: l,
    children: c,
    debounce: u = 0,
    id: d,
    className: p,
    onResize: h,
    style: g = {}
  } = e, m = Ne(null), v = Ne();
  v.current = h, zE(t, () => m.current);
  var [y, S] = Ke({
    containerWidth: r.width,
    containerHeight: r.height
  }), w = xt((O, E) => {
    S((C) => {
      var T = Math.round(O), j = Math.round(E);
      return C.containerWidth === T && C.containerHeight === j ? C : {
        containerWidth: T,
        containerHeight: j
      };
    });
  }, []);
  De(() => {
    var O = (j) => {
      var A, {
        width: M,
        height: P
      } = j[0].contentRect;
      w(M, P), (A = v.current) === null || A === void 0 || A.call(v, M, P);
    };
    u > 0 && (O = bz(O, u, {
      trailing: !0,
      leading: !1
    }));
    var E = new ResizeObserver(O), {
      width: C,
      height: T
    } = m.current.getBoundingClientRect();
    return w(C, T), E.observe(m.current), () => {
      E.disconnect();
    };
  }, [w, u]);
  var b = Un(() => {
    var {
      containerWidth: O,
      containerHeight: E
    } = y;
    if (O < 0 || E < 0)
      return null;
    Ws(So(i) || So(o), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, i, o), Ws(!n || n > 0, "The aspect(%s) must be greater than zero.", n);
    var C = So(i) ? O : i, T = So(o) ? E : o;
    return n && n > 0 && (C ? T = C / n : T && (C = T * n), l && T > l && (T = l)), Ws(C > 0 || T > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, C, T, i, o, a, s, n), _.Children.map(c, (j) => /* @__PURE__ */ cr(j, {
      width: C,
      height: T,
      // calculate the actual size and override it.
      style: bh({
        width: C,
        height: T
      }, j.props.style)
    }));
  }, [n, c, o, l, s, a, y, i]);
  return /* @__PURE__ */ _.createElement("div", {
    id: d ? "".concat(d) : void 0,
    className: ie("recharts-responsive-container", p),
    style: bh(bh({}, g), {}, {
      width: i,
      height: o,
      minWidth: a,
      minHeight: s,
      maxHeight: l
    }),
    ref: m
  }, /* @__PURE__ */ _.createElement("div", {
    style: {
      width: 0,
      height: 0,
      overflow: "visible"
    }
  }, b));
}), Hr = (e) => null;
Hr.displayName = "Cell";
function Ez(e, t, n) {
  return (t = _z(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function _z(e) {
  var t = Pz(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Pz(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
class Cz {
  constructor(t) {
    Ez(this, "cache", /* @__PURE__ */ new Map()), this.maxSize = t;
  }
  get(t) {
    var n = this.cache.get(t);
    return n !== void 0 && (this.cache.delete(t), this.cache.set(t, n)), n;
  }
  set(t, n) {
    if (this.cache.has(t))
      this.cache.delete(t);
    else if (this.cache.size >= this.maxSize) {
      var r = this.cache.keys().next().value;
      this.cache.delete(r);
    }
    this.cache.set(t, n);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
}
function Mw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Mw(Object(n), !0).forEach(function(r) {
      Az(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Az(e, t, n) {
  return (t = kz(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function kz(e) {
  var t = Mz(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Mz(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var jz = {
  cacheSize: 2e3,
  enableCache: !0
}, _T = Tz({}, jz), jw = new Cz(_T.cacheSize), Nz = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
}, Nw = "recharts_measurement_span";
function Dz(e, t) {
  var n = t.fontSize || "", r = t.fontFamily || "", i = t.fontWeight || "", o = t.fontStyle || "", a = t.letterSpacing || "", s = t.textTransform || "";
  return "".concat(e, "|").concat(n, "|").concat(r, "|").concat(i, "|").concat(o, "|").concat(a, "|").concat(s);
}
var Dw = (e, t) => {
  try {
    var n = document.getElementById(Nw);
    n || (n = document.createElement("span"), n.setAttribute("id", Nw), n.setAttribute("aria-hidden", "true"), document.body.appendChild(n)), Object.assign(n.style, Nz, t), n.textContent = "".concat(e);
    var r = n.getBoundingClientRect();
    return {
      width: r.width,
      height: r.height
    };
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
}, Vs = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (t == null || Zi.isSsr)
    return {
      width: 0,
      height: 0
    };
  if (!_T.enableCache)
    return Dw(t, n);
  var r = Dz(t, n), i = jw.get(r);
  if (i)
    return i;
  var o = Dw(t, n);
  return jw.set(r, o), o;
}, Rw = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, Iw = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, Rz = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, Iz = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/, PT = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
}, $z = Object.keys(PT), ga = "NaN";
function Lz(e, t) {
  return e * PT[t];
}
class _n {
  static parse(t) {
    var n, [, r, i] = (n = Iz.exec(t)) !== null && n !== void 0 ? n : [];
    return new _n(parseFloat(r), i ?? "");
  }
  constructor(t, n) {
    this.num = t, this.unit = n, this.num = t, this.unit = n, qn(t) && (this.unit = ""), n !== "" && !Rz.test(n) && (this.num = NaN, this.unit = ""), $z.includes(n) && (this.num = Lz(t, n), this.unit = "px");
  }
  add(t) {
    return this.unit !== t.unit ? new _n(NaN, "") : new _n(this.num + t.num, this.unit);
  }
  subtract(t) {
    return this.unit !== t.unit ? new _n(NaN, "") : new _n(this.num - t.num, this.unit);
  }
  multiply(t) {
    return this.unit !== "" && t.unit !== "" && this.unit !== t.unit ? new _n(NaN, "") : new _n(this.num * t.num, this.unit || t.unit);
  }
  divide(t) {
    return this.unit !== "" && t.unit !== "" && this.unit !== t.unit ? new _n(NaN, "") : new _n(this.num / t.num, this.unit || t.unit);
  }
  toString() {
    return "".concat(this.num).concat(this.unit);
  }
  isNaN() {
    return qn(this.num);
  }
}
function CT(e) {
  if (e.includes(ga))
    return ga;
  for (var t = e; t.includes("*") || t.includes("/"); ) {
    var n, [, r, i, o] = (n = Rw.exec(t)) !== null && n !== void 0 ? n : [], a = _n.parse(r ?? ""), s = _n.parse(o ?? ""), l = i === "*" ? a.multiply(s) : a.divide(s);
    if (l.isNaN())
      return ga;
    t = t.replace(Rw, l.toString());
  }
  for (; t.includes("+") || /.-\d+(?:\.\d+)?/.test(t); ) {
    var c, [, u, d, p] = (c = Iw.exec(t)) !== null && c !== void 0 ? c : [], h = _n.parse(u ?? ""), g = _n.parse(p ?? ""), m = d === "+" ? h.add(g) : h.subtract(g);
    if (m.isNaN())
      return ga;
    t = t.replace(Iw, m.toString());
  }
  return t;
}
var $w = /\(([^()]*)\)/;
function Fz(e) {
  for (var t = e, n; (n = $w.exec(t)) != null; ) {
    var [, r] = n;
    t = t.replace($w, CT(r));
  }
  return t;
}
function Bz(e) {
  var t = e.replace(/\s+/g, "");
  return t = Fz(t), t = CT(t), t;
}
function zz(e) {
  try {
    return Bz(e);
  } catch {
    return ga;
  }
}
function xh(e) {
  var t = zz(e.slice(5, -1));
  return t === ga ? "" : t;
}
var Wz = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], Vz = ["dx", "dy", "angle", "className", "breakAll"];
function Hm() {
  return Hm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Hm.apply(null, arguments);
}
function Lw(e, t) {
  if (e == null) return {};
  var n, r, i = Uz(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function Uz(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var TT = /[ \f\n\r\t\v\u2028\u2029]+/, AT = (e) => {
  var {
    children: t,
    breakAll: n,
    style: r
  } = e;
  try {
    var i = [];
    yt(t) || (n ? i = t.toString().split("") : i = t.toString().split(TT));
    var o = i.map((s) => ({
      word: s,
      width: Vs(s, r).width
    })), a = n ? 0 : Vs("", r).width;
    return {
      wordsWithComputedWidth: o,
      spaceWidth: a
    };
  } catch {
    return null;
  }
}, Hz = (e, t, n, r, i) => {
  var {
    maxLines: o,
    children: a,
    style: s,
    breakAll: l
  } = e, c = me(o), u = a, d = function() {
    var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return M.reduce((P, R) => {
      var {
        word: N,
        width: D
      } = R, $ = P[P.length - 1];
      if ($ && (r == null || i || $.width + D + n < Number(r)))
        $.words.push(N), $.width += D + n;
      else {
        var F = {
          words: [N],
          width: D
        };
        P.push(F);
      }
      return P;
    }, []);
  }, p = d(t), h = (A) => A.reduce((M, P) => M.width > P.width ? M : P);
  if (!c || i)
    return p;
  var g = p.length > o || h(p).width > Number(r);
  if (!g)
    return p;
  for (var m = "", v = (A) => {
    var M = u.slice(0, A), P = AT({
      breakAll: l,
      style: s,
      children: M + m
    }).wordsWithComputedWidth, R = d(P), N = R.length > o || h(R).width > Number(r);
    return [N, R];
  }, y = 0, S = u.length - 1, w = 0, b; y <= S && w <= u.length - 1; ) {
    var O = Math.floor((y + S) / 2), E = O - 1, [C, T] = v(E), [j] = v(O);
    if (!C && !j && (y = O + 1), C && j && (S = O - 1), !C && j) {
      b = T;
      break;
    }
    w++;
  }
  return b || p;
}, Fw = (e) => {
  var t = yt(e) ? [] : e.toString().split(TT);
  return [{
    words: t
  }];
}, qz = (e) => {
  var {
    width: t,
    scaleToFit: n,
    children: r,
    style: i,
    breakAll: o,
    maxLines: a
  } = e;
  if ((t || n) && !Zi.isSsr) {
    var s, l, c = AT({
      breakAll: o,
      children: r,
      style: i
    });
    if (c) {
      var {
        wordsWithComputedWidth: u,
        spaceWidth: d
      } = c;
      s = u, l = d;
    } else
      return Fw(r);
    return Hz({
      breakAll: o,
      children: r,
      maxLines: a,
      style: i
    }, s, l, t, n);
  }
  return Fw(r);
}, Bw = "#808080", xf = /* @__PURE__ */ rn((e, t) => {
  var {
    x: n = 0,
    y: r = 0,
    lineHeight: i = "1em",
    // Magic number from d3
    capHeight: o = "0.71em",
    scaleToFit: a = !1,
    textAnchor: s = "start",
    // Maintain compat with existing charts / default SVG behavior
    verticalAnchor: l = "end",
    fill: c = Bw
  } = e, u = Lw(e, Wz), d = Un(() => qz({
    breakAll: u.breakAll,
    children: u.children,
    maxLines: u.maxLines,
    scaleToFit: a,
    style: u.style,
    width: u.width
  }), [u.breakAll, u.children, u.maxLines, a, u.style, u.width]), {
    dx: p,
    dy: h,
    angle: g,
    className: m,
    breakAll: v
  } = u, y = Lw(u, Vz);
  if (!Vr(n) || !Vr(r) || d.length === 0)
    return null;
  var S = n + (me(p) ? p : 0), w = r + (me(h) ? h : 0), b;
  switch (l) {
    case "start":
      b = xh("calc(".concat(o, ")"));
      break;
    case "middle":
      b = xh("calc(".concat((d.length - 1) / 2, " * -").concat(i, " + (").concat(o, " / 2))"));
      break;
    default:
      b = xh("calc(".concat(d.length - 1, " * -").concat(i, ")"));
      break;
  }
  var O = [];
  if (a) {
    var E = d[0].width, {
      width: C
    } = u;
    O.push("scale(".concat(me(C) ? C / E : 1, ")"));
  }
  return g && O.push("rotate(".concat(g, ", ").concat(S, ", ").concat(w, ")")), O.length && (y.transform = O.join(" ")), /* @__PURE__ */ _.createElement("text", Hm({}, wt(y, !0), {
    ref: t,
    x: S,
    y: w,
    className: ie("recharts-text", m),
    textAnchor: s,
    fill: c.includes("url") ? Bw : c
  }), d.map((T, j) => {
    var A = T.words.join(v ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ _.createElement("tspan", {
        x: S,
        dy: j === 0 ? b : i,
        key: "".concat(A, "-").concat(j)
      }, A)
    );
  }));
});
xf.displayName = "Text";
var Kz = ["labelRef"];
function Yz(e, t) {
  if (e == null) return {};
  var n, r, i = Gz(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function Gz(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function zw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zw(Object(n), !0).forEach(function(r) {
      Xz(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Xz(e, t, n) {
  return (t = Zz(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Zz(e) {
  var t = Jz(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Jz(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function oi() {
  return oi = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, oi.apply(null, arguments);
}
var kT = /* @__PURE__ */ gr(null), Qz = (e) => {
  var {
    x: t,
    y: n,
    width: r,
    height: i,
    children: o
  } = e, a = Un(() => ({
    x: t,
    y: n,
    width: r,
    height: i
  }), [t, n, r, i]);
  return /* @__PURE__ */ _.createElement(kT.Provider, {
    value: a
  }, o);
}, MT = () => {
  var e = Kr(kT), t = rv();
  return e || t;
}, eW = /* @__PURE__ */ gr(null), tW = () => {
  var e = Kr(eW), t = pe(xC);
  return e || t;
}, nW = (e) => {
  var {
    value: t,
    formatter: n
  } = e, r = yt(e.children) ? t : e.children;
  return typeof n == "function" ? n(r) : r;
}, dy = (e) => e != null && typeof e == "function", rW = (e, t) => {
  var n = Yt(t - e), r = Math.min(Math.abs(t - e), 360);
  return n * r;
}, iW = (e, t, n, r, i) => {
  var {
    offset: o,
    className: a
  } = e, {
    cx: s,
    cy: l,
    innerRadius: c,
    outerRadius: u,
    startAngle: d,
    endAngle: p,
    clockWise: h
  } = i, g = (c + u) / 2, m = rW(d, p), v = m >= 0 ? 1 : -1, y, S;
  switch (t) {
    case "insideStart":
      y = d + v * o, S = h;
      break;
    case "insideEnd":
      y = p - v * o, S = !h;
      break;
    case "end":
      y = p + v * o, S = h;
      break;
    default:
      throw new Error("Unsupported position ".concat(t));
  }
  S = m <= 0 ? S : !S;
  var w = $t(s, l, g, y), b = $t(s, l, g, y + (S ? 1 : -1) * 359), O = "M".concat(w.x, ",").concat(w.y, `
    A`).concat(g, ",").concat(g, ",0,1,").concat(S ? 0 : 1, `,
    `).concat(b.x, ",").concat(b.y), E = yt(e.id) ? rl("recharts-radial-line-") : e.id;
  return /* @__PURE__ */ _.createElement("text", oi({}, r, {
    dominantBaseline: "central",
    className: ie("recharts-radial-bar-label", a)
  }), /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement("path", {
    id: E,
    d: O
  })), /* @__PURE__ */ _.createElement("textPath", {
    xlinkHref: "#".concat(E)
  }, n));
}, oW = (e, t, n) => {
  var {
    cx: r,
    cy: i,
    innerRadius: o,
    outerRadius: a,
    startAngle: s,
    endAngle: l
  } = e, c = (s + l) / 2;
  if (n === "outside") {
    var {
      x: u,
      y: d
    } = $t(r, i, a + t, c);
    return {
      x: u,
      y: d,
      textAnchor: u >= r ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (n === "center")
    return {
      x: r,
      y: i,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  if (n === "centerTop")
    return {
      x: r,
      y: i,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  if (n === "centerBottom")
    return {
      x: r,
      y: i,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  var p = (o + a) / 2, {
    x: h,
    y: g
  } = $t(r, i, p, c);
  return {
    x: h,
    y: g,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
}, jT = (e) => "cx" in e && me(e.cx), aW = (e, t) => {
  var {
    parentViewBox: n,
    offset: r,
    position: i
  } = e, o;
  n != null && !jT(n) && (o = n);
  var {
    x: a,
    y: s,
    width: l,
    height: c
  } = t, u = c >= 0 ? 1 : -1, d = u * r, p = u > 0 ? "end" : "start", h = u > 0 ? "start" : "end", g = l >= 0 ? 1 : -1, m = g * r, v = g > 0 ? "end" : "start", y = g > 0 ? "start" : "end";
  if (i === "top") {
    var S = {
      x: a + l / 2,
      y: s - u * r,
      textAnchor: "middle",
      verticalAnchor: p
    };
    return kt(kt({}, S), o ? {
      height: Math.max(s - o.y, 0),
      width: l
    } : {});
  }
  if (i === "bottom") {
    var w = {
      x: a + l / 2,
      y: s + c + d,
      textAnchor: "middle",
      verticalAnchor: h
    };
    return kt(kt({}, w), o ? {
      height: Math.max(o.y + o.height - (s + c), 0),
      width: l
    } : {});
  }
  if (i === "left") {
    var b = {
      x: a - m,
      y: s + c / 2,
      textAnchor: v,
      verticalAnchor: "middle"
    };
    return kt(kt({}, b), o ? {
      width: Math.max(b.x - o.x, 0),
      height: c
    } : {});
  }
  if (i === "right") {
    var O = {
      x: a + l + m,
      y: s + c / 2,
      textAnchor: y,
      verticalAnchor: "middle"
    };
    return kt(kt({}, O), o ? {
      width: Math.max(o.x + o.width - O.x, 0),
      height: c
    } : {});
  }
  var E = o ? {
    width: l,
    height: c
  } : {};
  return i === "insideLeft" ? kt({
    x: a + m,
    y: s + c / 2,
    textAnchor: y,
    verticalAnchor: "middle"
  }, E) : i === "insideRight" ? kt({
    x: a + l - m,
    y: s + c / 2,
    textAnchor: v,
    verticalAnchor: "middle"
  }, E) : i === "insideTop" ? kt({
    x: a + l / 2,
    y: s + d,
    textAnchor: "middle",
    verticalAnchor: h
  }, E) : i === "insideBottom" ? kt({
    x: a + l / 2,
    y: s + c - d,
    textAnchor: "middle",
    verticalAnchor: p
  }, E) : i === "insideTopLeft" ? kt({
    x: a + m,
    y: s + d,
    textAnchor: y,
    verticalAnchor: h
  }, E) : i === "insideTopRight" ? kt({
    x: a + l - m,
    y: s + d,
    textAnchor: v,
    verticalAnchor: h
  }, E) : i === "insideBottomLeft" ? kt({
    x: a + m,
    y: s + c - d,
    textAnchor: y,
    verticalAnchor: p
  }, E) : i === "insideBottomRight" ? kt({
    x: a + l - m,
    y: s + c - d,
    textAnchor: v,
    verticalAnchor: p
  }, E) : i && typeof i == "object" && (me(i.x) || So(i.x)) && (me(i.y) || So(i.y)) ? kt({
    x: a + hn(i.x, l),
    y: s + hn(i.y, c),
    textAnchor: "end",
    verticalAnchor: "end"
  }, E) : kt({
    x: a + l / 2,
    y: s + c / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, E);
}, sW = {
  offset: 5
};
function Mi(e) {
  var t = on(e, sW), {
    viewBox: n,
    position: r,
    value: i,
    children: o,
    content: a,
    className: s = "",
    textBreakAll: l,
    labelRef: c
  } = t, u = tW(), d = MT(), p = r === "center" ? d : u ?? d, h = n || p;
  if (!h || yt(i) && yt(o) && !/* @__PURE__ */ bn(a) && typeof a != "function")
    return null;
  var g = kt(kt({}, t), {}, {
    viewBox: h
  });
  if (/* @__PURE__ */ bn(a)) {
    var {
      labelRef: m
    } = g, v = Yz(g, Kz);
    return /* @__PURE__ */ cr(a, v);
  }
  var y;
  if (typeof a == "function") {
    if (y = /* @__PURE__ */ BE(a, g), /* @__PURE__ */ bn(y))
      return y;
  } else
    y = nW(t);
  var S = jT(h), w = wt(t, !0);
  if (S && (r === "insideStart" || r === "insideEnd" || r === "end"))
    return iW(t, r, y, w, h);
  var b = S ? oW(h, t.offset, t.position) : aW(t, h);
  return /* @__PURE__ */ _.createElement(xf, oi({
    ref: c,
    className: ie("recharts-label", s)
  }, w, b, {
    breakAll: l
  }), y);
}
Mi.displayName = "Label";
var lW = (e, t, n) => {
  if (!e)
    return null;
  var r = {
    viewBox: t,
    labelRef: n
  };
  return e === !0 ? /* @__PURE__ */ _.createElement(Mi, oi({
    key: "label-implicit"
  }, r)) : Vr(e) ? /* @__PURE__ */ _.createElement(Mi, oi({
    key: "label-implicit",
    value: e
  }, r)) : /* @__PURE__ */ bn(e) ? e.type === Mi ? /* @__PURE__ */ cr(e, kt({
    key: "label-implicit"
  }, r)) : /* @__PURE__ */ _.createElement(Mi, oi({
    key: "label-implicit",
    content: e
  }, r)) : dy(e) ? /* @__PURE__ */ _.createElement(Mi, oi({
    key: "label-implicit",
    content: e
  }, r)) : e && typeof e == "object" ? /* @__PURE__ */ _.createElement(Mi, oi({}, e, {
    key: "label-implicit"
  }, r)) : null;
};
function cW(e) {
  var {
    label: t
  } = e, n = MT();
  return lW(t, n) || null;
}
var wh = {}, Oh = {}, Ww;
function uW() {
  return Ww || (Ww = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n[n.length - 1];
    }
    e.last = t;
  })(Oh)), Oh;
}
var Sh = {}, Vw;
function dW() {
  return Vw || (Vw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return Array.isArray(n) ? n : Array.from(n);
    }
    e.toArray = t;
  })(Sh)), Sh;
}
var Uw;
function fW() {
  return Uw || (Uw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ uW(), n = /* @__PURE__ */ dW(), r = /* @__PURE__ */ Yg();
    function i(o) {
      if (r.isArrayLike(o))
        return t.last(n.toArray(o));
    }
    e.last = i;
  })(wh)), wh;
}
var Eh, Hw;
function pW() {
  return Hw || (Hw = 1, Eh = fW().last), Eh;
}
var hW = /* @__PURE__ */ pW();
const mW = /* @__PURE__ */ xi(hW);
var gW = ["valueAccessor"], vW = ["dataKey", "clockWise", "id", "textBreakAll"];
function Ju() {
  return Ju = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ju.apply(null, arguments);
}
function qw(e, t) {
  if (e == null) return {};
  var n, r, i = yW(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function yW(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var bW = (e) => Array.isArray(e.value) ? mW(e.value) : e.value, NT = /* @__PURE__ */ gr(void 0), DT = NT.Provider, RT = /* @__PURE__ */ gr(void 0), xW = RT.Provider;
function wW() {
  return Kr(NT);
}
function OW() {
  return Kr(RT);
}
function uu(e) {
  var {
    valueAccessor: t = bW
  } = e, n = qw(e, gW), {
    dataKey: r,
    clockWise: i,
    id: o,
    textBreakAll: a
  } = n, s = qw(n, vW), l = wW(), c = OW(), u = l || c;
  return !u || !u.length ? null : /* @__PURE__ */ _.createElement(nn, {
    className: "recharts-label-list"
  }, u.map((d, p) => {
    var h, g = yt(r) ? t(d, p) : ct(d && d.payload, r), m = yt(o) ? {} : {
      id: "".concat(o, "-").concat(p)
    };
    return /* @__PURE__ */ _.createElement(Mi, Ju({}, wt(d, !0), s, m, {
      /*
       * Prefer to use the explicit fill from LabelList props.
       * Only in an absence of that, fall back to the fill of the entry.
       * The entry fill can be quite difficult to see especially in Bar, Pie, RadialBar in inside positions.
       * On the other hand it's quite convenient in Scatter, Line, or when the position is outside the Bar, Pie filled shapes.
       */
      fill: (h = n.fill) !== null && h !== void 0 ? h : d.fill,
      parentViewBox: d.parentViewBox,
      value: g,
      textBreakAll: a,
      viewBox: d.viewBox,
      key: "label-".concat(p),
      index: p
    }));
  }));
}
uu.displayName = "LabelList";
function fy(e) {
  var {
    label: t
  } = e;
  return t ? t === !0 ? /* @__PURE__ */ _.createElement(uu, {
    key: "labelList-implicit"
  }) : /* @__PURE__ */ _.isValidElement(t) || dy(t) ? /* @__PURE__ */ _.createElement(uu, {
    key: "labelList-implicit",
    content: t
  }) : typeof t == "object" ? /* @__PURE__ */ _.createElement(uu, Ju({
    key: "labelList-implicit"
  }, t, {
    type: String(t.type)
  })) : null : null;
}
function qm() {
  return qm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, qm.apply(null, arguments);
}
var IT = (e) => {
  var {
    cx: t,
    cy: n,
    r,
    className: i
  } = e, o = ie("recharts-dot", i);
  return t === +t && n === +n && r === +r ? /* @__PURE__ */ _.createElement("circle", qm({}, Yr(e), Vg(e), {
    className: o,
    cx: t,
    cy: n,
    r
  })) : null;
}, $T = (e) => e.graphicalItems.polarItems, SW = z([bt, Gl], Fv), py = z([$T, Dt, SW], Bv), EW = z([py], zv), hy = z([EW, Tv], Wv), _W = z([hy, Dt, py], Uv), PW = z([hy, Dt, py], (e, t, n) => n.length > 0 ? e.flatMap((r) => n.flatMap((i) => {
  var o, a = ct(r, (o = t.dataKey) !== null && o !== void 0 ? o : i.dataKey);
  return {
    value: a,
    errorDomain: []
    // polar charts do not have error bars
  };
})).filter(Boolean) : t?.dataKey != null ? e.map((r) => ({
  value: ct(r, t.dataKey),
  errorDomain: []
})) : e.map((r) => ({
  value: r,
  errorDomain: []
}))), Kw = () => {
}, CW = z([Dt, BC, Kw, PW, Kw, Pe, bt], qv), LT = z([Dt, Pe, hy, _W, Yl, bt, CW], Kv), TW = z([LT, Dt, Xa], Xv);
z([Dt, LT, TW, bt], Jv);
var AW = {
  radiusAxis: {},
  angleAxis: {}
}, FT = Zn({
  name: "polarAxis",
  initialState: AW,
  reducers: {
    addRadiusAxis(e, t) {
      e.radiusAxis[t.payload.id] = t.payload;
    },
    removeRadiusAxis(e, t) {
      delete e.radiusAxis[t.payload.id];
    },
    addAngleAxis(e, t) {
      e.angleAxis[t.payload.id] = t.payload;
    },
    removeAngleAxis(e, t) {
      delete e.angleAxis[t.payload.id];
    }
  }
}), {
  addRadiusAxis: qte,
  removeRadiusAxis: Kte,
  addAngleAxis: Yte,
  removeAngleAxis: Gte
} = FT.actions, kW = FT.reducer;
function Yw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yw(Object(n), !0).forEach(function(r) {
      MW(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function MW(e, t, n) {
  return (t = jW(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function jW(e) {
  var t = NW(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function NW(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var DW = (e, t) => t, my = z([$T, DW], (e, t) => e.filter((n) => n.type === "pie").find((n) => n.id === t)), RW = [], gy = (e, t, n) => n?.length === 0 ? RW : n, BT = z([Tv, my, gy], (e, t, n) => {
  var {
    chartData: r
  } = e;
  if (t != null) {
    var i;
    if (t?.data != null && t.data.length > 0 ? i = t.data : i = r, (!i || !i.length) && n != null && (i = n.map((o) => Gw(Gw({}, t.presentationProps), o.props))), i != null)
      return i;
  }
}), IW = z([BT, my, gy], (e, t, n) => {
  if (!(e == null || t == null))
    return e.map((r, i) => {
      var o, a = ct(r, t.nameKey, t.name), s;
      return n != null && (o = n[i]) !== null && o !== void 0 && (o = o.props) !== null && o !== void 0 && o.fill ? s = n[i].props.fill : typeof r == "object" && r != null && "fill" in r ? s = r.fill : s = t.fill, {
        value: Ua(a, t.dataKey),
        color: s,
        payload: r,
        type: t.legendType
      };
    });
}), $W = z([BT, my, gy, zt], (e, t, n, r) => {
  if (!(t == null || e == null))
    return DV({
      offset: r,
      pieSettings: t,
      displayedData: e,
      cells: n
    });
}), _h = {}, Xw;
function LW() {
  return Xw || (Xw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      if (typeof n != "object" || n == null)
        return !1;
      if (Object.getPrototypeOf(n) === null)
        return !0;
      if (Object.prototype.toString.call(n) !== "[object Object]") {
        const i = n[Symbol.toStringTag];
        return i == null || !Object.getOwnPropertyDescriptor(n, Symbol.toStringTag)?.writable ? !1 : n.toString() === `[object ${i}]`;
      }
      let r = n;
      for (; Object.getPrototypeOf(r) !== null; )
        r = Object.getPrototypeOf(r);
      return Object.getPrototypeOf(n) === r;
    }
    e.isPlainObject = t;
  })(_h)), _h;
}
var Ph, Zw;
function FW() {
  return Zw || (Zw = 1, Ph = LW().isPlainObject), Ph;
}
var BW = /* @__PURE__ */ FW();
const zW = /* @__PURE__ */ xi(BW);
function Jw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jw(Object(n), !0).forEach(function(r) {
      WW(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function WW(e, t, n) {
  return (t = VW(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function VW(e) {
  var t = UW(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function UW(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Qu() {
  return Qu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Qu.apply(null, arguments);
}
var eO = (e, t, n, r, i) => {
  var o = n - r, a;
  return a = "M ".concat(e, ",").concat(t), a += "L ".concat(e + n, ",").concat(t), a += "L ".concat(e + n - o / 2, ",").concat(t + i), a += "L ".concat(e + n - o / 2 - r, ",").concat(t + i), a += "L ".concat(e, ",").concat(t, " Z"), a;
}, HW = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, qW = (e) => {
  var t = on(e, HW), {
    x: n,
    y: r,
    upperWidth: i,
    lowerWidth: o,
    height: a,
    className: s
  } = t, {
    animationEasing: l,
    animationDuration: c,
    animationBegin: u,
    isUpdateAnimationActive: d
  } = t, p = Ne(), [h, g] = Ke(-1), m = Ne(i), v = Ne(o), y = Ne(a), S = Ne(n), w = Ne(r), b = Vl(e, "trapezoid-");
  if (De(() => {
    if (p.current && p.current.getTotalLength)
      try {
        var N = p.current.getTotalLength();
        N && g(N);
      } catch {
      }
  }, []), n !== +n || r !== +r || i !== +i || o !== +o || a !== +a || i === 0 && o === 0 || a === 0)
    return null;
  var O = ie("recharts-trapezoid", s);
  if (!d)
    return /* @__PURE__ */ _.createElement("g", null, /* @__PURE__ */ _.createElement("path", Qu({}, wt(t, !0), {
      className: O,
      d: eO(n, r, i, o, a)
    })));
  var E = m.current, C = v.current, T = y.current, j = S.current, A = w.current, M = "0px ".concat(h === -1 ? 1 : h, "px"), P = "".concat(h, "px 0px"), R = u2(["strokeDasharray"], c, l);
  return /* @__PURE__ */ _.createElement(Wl, {
    animationId: b,
    key: b,
    canBegin: h > 0,
    duration: c,
    easing: l,
    isActive: d,
    begin: u
  }, (N) => {
    var D = _t(E, i, N), $ = _t(C, o, N), F = _t(T, a, N), q = _t(j, n, N), B = _t(A, r, N);
    p.current && (m.current = D, v.current = $, y.current = F, S.current = q, w.current = B);
    var L = N > 0 ? {
      transition: R,
      strokeDasharray: P
    } : {
      strokeDasharray: M
    };
    return /* @__PURE__ */ _.createElement("path", Qu({}, wt(t, !0), {
      className: O,
      d: eO(q, B, D, $, F),
      ref: p,
      style: Qw(Qw({}, L), t.style)
    }));
  });
}, KW = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function YW(e, t) {
  if (e == null) return {};
  var n, r, i = GW(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function GW(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function tO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ed(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tO(Object(n), !0).forEach(function(r) {
      XW(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function XW(e, t, n) {
  return (t = ZW(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function ZW(e) {
  var t = JW(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function JW(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function QW(e, t) {
  return ed(ed({}, t), e);
}
function eV(e, t) {
  return e === "symbols";
}
function nO(e) {
  var {
    shapeType: t,
    elementProps: n
  } = e;
  switch (t) {
    case "rectangle":
      return /* @__PURE__ */ _.createElement(h2, n);
    case "trapezoid":
      return /* @__PURE__ */ _.createElement(qW, n);
    case "sector":
      return /* @__PURE__ */ _.createElement(v2, n);
    case "symbols":
      if (eV(t))
        return /* @__PURE__ */ _.createElement(lP, n);
      break;
    default:
      return null;
  }
}
function tV(e) {
  return /* @__PURE__ */ bn(e) ? e.props : e;
}
function zT(e) {
  var {
    option: t,
    shapeType: n,
    propTransformer: r = QW,
    activeClassName: i = "recharts-active-shape",
    isActive: o
  } = e, a = YW(e, KW), s;
  if (/* @__PURE__ */ bn(t))
    s = /* @__PURE__ */ cr(t, ed(ed({}, a), tV(t)));
  else if (typeof t == "function")
    s = t(a);
  else if (zW(t) && typeof t != "boolean") {
    var l = r(t, a);
    s = /* @__PURE__ */ _.createElement(nO, {
      shapeType: n,
      elementProps: l
    });
  } else {
    var c = a;
    s = /* @__PURE__ */ _.createElement(nO, {
      shapeType: n,
      elementProps: c
    });
  }
  return o ? /* @__PURE__ */ _.createElement(nn, {
    className: i
  }, s) : s;
}
var vy = (e, t) => {
  var n = Nt();
  return (r, i) => (o) => {
    e?.(r, i, o), n(nT({
      activeIndex: String(i),
      activeDataKey: t,
      activeCoordinate: r.tooltipPosition
    }));
  };
}, yy = (e) => {
  var t = Nt();
  return (n, r) => (i) => {
    e?.(n, r, i), t(I3());
  };
}, by = (e, t) => {
  var n = Nt();
  return (r, i) => (o) => {
    e?.(r, i, o), n($3({
      activeIndex: String(i),
      activeDataKey: t,
      activeCoordinate: r.tooltipPosition
    }));
  };
};
function xy(e) {
  var {
    fn: t,
    args: n
  } = e, r = Nt(), i = Nn();
  return De(() => {
    if (!i) {
      var o = t(n);
      return r(N3(o)), () => {
        r(D3(o));
      };
    }
  }, [t, n, r, i]), null;
}
var WT = () => {
};
function VT(e) {
  var {
    legendPayload: t
  } = e, n = Nt(), r = Nn();
  return De(() => r ? WT : (n(s2(t)), () => {
    n(l2(t));
  }), [n, r, t]), null;
}
function nV(e) {
  var {
    legendPayload: t
  } = e, n = Nt(), r = pe(Pe);
  return De(() => r !== "centric" && r !== "radial" ? WT : (n(s2(t)), () => {
    n(l2(t));
  }), [n, r, t]), null;
}
var Ch, rV = () => {
  var [e] = _.useState(() => rl("uid-"));
  return e;
}, iV = (Ch = _.useId) !== null && Ch !== void 0 ? Ch : rV;
function oV(e, t) {
  var n = iV();
  return t || (e ? "".concat(e, "-").concat(n) : n);
}
var aV = /* @__PURE__ */ gr(void 0), wy = (e) => {
  var {
    id: t,
    type: n,
    children: r
  } = e, i = oV("recharts-".concat(n), t);
  return /* @__PURE__ */ _.createElement(aV.Provider, {
    value: i
  }, r(i));
}, sV = {
  cartesianItems: [],
  polarItems: []
}, UT = Zn({
  name: "graphicalItems",
  initialState: sV,
  reducers: {
    addCartesianGraphicalItem(e, t) {
      e.cartesianItems.push(t.payload);
    },
    replaceCartesianGraphicalItem(e, t) {
      var {
        prev: n,
        next: r
      } = t.payload, i = ui(e).cartesianItems.indexOf(n);
      i > -1 && (e.cartesianItems[i] = r);
    },
    removeCartesianGraphicalItem(e, t) {
      var n = ui(e).cartesianItems.indexOf(t.payload);
      n > -1 && e.cartesianItems.splice(n, 1);
    },
    addPolarGraphicalItem(e, t) {
      e.polarItems.push(t.payload);
    },
    removePolarGraphicalItem(e, t) {
      var n = ui(e).polarItems.indexOf(t.payload);
      n > -1 && e.polarItems.splice(n, 1);
    }
  }
}), {
  addCartesianGraphicalItem: lV,
  replaceCartesianGraphicalItem: cV,
  removeCartesianGraphicalItem: uV,
  addPolarGraphicalItem: dV,
  removePolarGraphicalItem: fV
} = UT.actions, pV = UT.reducer;
function HT(e) {
  var t = Nt(), n = Ne(null);
  return De(() => {
    n.current === null ? t(lV(e)) : n.current !== e && t(cV({
      prev: n.current,
      next: e
    })), n.current = e;
  }, [t, e]), De(() => () => {
    n.current && (t(uV(n.current)), n.current = null);
  }, [t]), null;
}
function hV(e) {
  var t = Nt();
  return De(() => (t(dV(e)), () => {
    t(fV(e));
  }), [t, e]), null;
}
var mV = ["onMouseEnter", "onClick", "onMouseLeave"], gV = ["id"], vV = ["id"];
function Oy(e, t) {
  if (e == null) return {};
  var n, r, i = yV(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function yV(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function rO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rO(Object(n), !0).forEach(function(r) {
      bV(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bV(e, t, n) {
  return (t = xV(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function xV(e) {
  var t = wV(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function wV(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Hi() {
  return Hi = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Hi.apply(null, arguments);
}
function OV(e) {
  var t = Un(() => Ug(e.children, Hr), [e.children]), n = pe((r) => IW(r, e.id, t));
  return n == null ? null : /* @__PURE__ */ _.createElement(nV, {
    legendPayload: n
  });
}
function SV(e) {
  var {
    dataKey: t,
    nameKey: n,
    sectors: r,
    stroke: i,
    strokeWidth: o,
    fill: a,
    name: s,
    hide: l,
    tooltipType: c
  } = e;
  return {
    dataDefinedOnItem: r.map((u) => u.tooltipPayload),
    positions: r.map((u) => u.tooltipPosition),
    settings: {
      stroke: i,
      strokeWidth: o,
      fill: a,
      dataKey: t,
      nameKey: n,
      name: Ua(s, t),
      hide: l,
      type: c,
      color: a,
      unit: ""
      // why doesn't Pie support unit?
    }
  };
}
var EV = (e, t) => e > t ? "start" : e < t ? "end" : "middle", _V = (e, t, n) => hn(typeof t == "function" ? t(e) : t, n, n * 0.8), PV = (e, t, n) => {
  var {
    top: r,
    left: i,
    width: o,
    height: a
  } = t, s = XP(o, a), l = i + hn(e.cx, o, o / 2), c = r + hn(e.cy, a, a / 2), u = hn(e.innerRadius, s, 0), d = _V(n, e.outerRadius, s), p = e.maxRadius || Math.sqrt(o * o + a * a) / 2;
  return {
    cx: l,
    cy: c,
    innerRadius: u,
    outerRadius: d,
    maxRadius: p
  };
}, CV = (e, t) => {
  var n = Yt(t - e), r = Math.min(Math.abs(t - e), 360);
  return n * r;
};
function TV(e) {
  return e && typeof e == "object" && "className" in e && typeof e.className == "string" ? e.className : "";
}
var AV = (e, t) => {
  if (/* @__PURE__ */ _.isValidElement(e))
    return /* @__PURE__ */ _.cloneElement(e, t);
  if (typeof e == "function")
    return e(t);
  var n = ie("recharts-pie-label-line", typeof e != "boolean" ? e.className : "");
  return /* @__PURE__ */ _.createElement(iv, Hi({}, t, {
    type: "linear",
    className: n
  }));
}, kV = (e, t, n) => {
  if (/* @__PURE__ */ _.isValidElement(e))
    return /* @__PURE__ */ _.cloneElement(e, t);
  var r = n;
  if (typeof e == "function" && (r = e(t), /* @__PURE__ */ _.isValidElement(r)))
    return r;
  var i = ie("recharts-pie-label-text", TV(e));
  return /* @__PURE__ */ _.createElement(xf, Hi({}, t, {
    alignmentBaseline: "middle",
    className: i
  }), r);
};
function MV(e) {
  var {
    sectors: t,
    props: n,
    showLabels: r
  } = e, {
    label: i,
    labelLine: o,
    dataKey: a
  } = n;
  if (!r || !i || !t)
    return null;
  var s = Yr(n), l = wt(i, !1), c = wt(o, !1), u = typeof i == "object" && "offsetRadius" in i && typeof i.offsetRadius == "number" && i.offsetRadius || 20, d = t.map((p, h) => {
    var g = (p.startAngle + p.endAngle) / 2, m = $t(p.cx, p.cy, p.outerRadius + u, g), v = gt(gt(gt(gt({}, s), p), {}, {
      stroke: "none"
    }, l), {}, {
      index: h,
      textAnchor: EV(m.x, p.cx)
    }, m), y = gt(gt(gt(gt({}, s), p), {}, {
      fill: "none",
      stroke: p.fill
    }, c), {}, {
      index: h,
      points: [$t(p.cx, p.cy, p.outerRadius, g), m],
      key: "line"
    });
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ _.createElement(nn, {
        key: "label-".concat(p.startAngle, "-").concat(p.endAngle, "-").concat(p.midAngle, "-").concat(h)
      }, o && AV(o, y), kV(i, v, ct(p, a)))
    );
  });
  return /* @__PURE__ */ _.createElement(nn, {
    className: "recharts-pie-labels"
  }, d);
}
function jV(e) {
  var {
    sectors: t,
    props: n,
    showLabels: r
  } = e, {
    label: i
  } = n;
  return typeof i == "object" && i != null && "position" in i ? /* @__PURE__ */ _.createElement(fy, {
    label: i
  }) : /* @__PURE__ */ _.createElement(MV, {
    sectors: t,
    props: n,
    showLabels: r
  });
}
function NV(e) {
  var {
    sectors: t,
    activeShape: n,
    inactiveShape: r,
    allOtherPieProps: i
  } = e, o = pe(Ui), {
    onMouseEnter: a,
    onClick: s,
    onMouseLeave: l
  } = i, c = Oy(i, mV), u = vy(a, i.dataKey), d = yy(l), p = by(s, i.dataKey);
  return t == null || t.length === 0 ? null : /* @__PURE__ */ _.createElement(_.Fragment, null, t.map((h, g) => {
    if (h?.startAngle === 0 && h?.endAngle === 0 && t.length !== 1) return null;
    var m = n && String(g) === o, v = o ? r : null, y = m ? n : v, S = gt(gt({}, h), {}, {
      stroke: h.stroke,
      tabIndex: -1,
      [t2]: g,
      [n2]: i.dataKey
    });
    return /* @__PURE__ */ _.createElement(nn, Hi({
      tabIndex: -1,
      className: "recharts-pie-sector"
    }, Wd(c, h, g), {
      // @ts-expect-error the types need a bit of attention
      onMouseEnter: u(h, g),
      onMouseLeave: d(h, g),
      onClick: p(h, g),
      key: "sector-".concat(h?.startAngle, "-").concat(h?.endAngle, "-").concat(h.midAngle, "-").concat(g)
    }), /* @__PURE__ */ _.createElement(zT, Hi({
      option: y,
      isActive: m,
      shapeType: "sector"
    }, S)));
  }));
}
function DV(e) {
  var t, {
    pieSettings: n,
    displayedData: r,
    cells: i,
    offset: o
  } = e, {
    cornerRadius: a,
    startAngle: s,
    endAngle: l,
    dataKey: c,
    nameKey: u,
    tooltipType: d
  } = n, p = Math.abs(n.minAngle), h = CV(s, l), g = Math.abs(h), m = r.length <= 1 ? 0 : (t = n.paddingAngle) !== null && t !== void 0 ? t : 0, v = r.filter((E) => ct(E, c, 0) !== 0).length, y = (g >= 360 ? v : v - 1) * m, S = g - v * p - y, w = r.reduce((E, C) => {
    var T = ct(C, c, 0);
    return E + (me(T) ? T : 0);
  }, 0), b;
  if (w > 0) {
    var O;
    b = r.map((E, C) => {
      var T = ct(E, c, 0), j = ct(E, u, C), A = PV(n, o, E), M = (me(T) ? T : 0) / w, P, R = gt(gt({}, E), i && i[C] && i[C].props);
      C ? P = O.endAngle + Yt(h) * m * (T !== 0 ? 1 : 0) : P = s;
      var N = P + Yt(h) * ((T !== 0 ? p : 0) + M * S), D = (P + N) / 2, $ = (A.innerRadius + A.outerRadius) / 2, F = [{
        name: j,
        value: T,
        payload: R,
        dataKey: c,
        type: d
      }], q = $t(A.cx, A.cy, $, D);
      return O = gt(gt(gt(gt({}, n.presentationProps), {}, {
        percent: M,
        cornerRadius: a,
        name: j,
        tooltipPayload: F,
        midAngle: D,
        middleRadius: $,
        tooltipPosition: q
      }, R), A), {}, {
        value: T,
        startAngle: P,
        endAngle: N,
        payload: R,
        paddingAngle: Yt(h) * m
      }), O;
    });
  }
  return b;
}
function RV(e) {
  var {
    showLabels: t,
    sectors: n,
    children: r
  } = e, i = Un(() => !t || !n ? [] : n.map((o) => ({
    value: o.value,
    payload: o.payload,
    clockWise: !1,
    parentViewBox: void 0,
    viewBox: {
      cx: o.cx,
      cy: o.cy,
      innerRadius: o.innerRadius,
      outerRadius: o.outerRadius,
      startAngle: o.startAngle,
      endAngle: o.endAngle,
      clockWise: !1
    },
    fill: o.fill
  })), [n, t]);
  return /* @__PURE__ */ _.createElement(xW, {
    value: t ? i : void 0
  }, r);
}
function IV(e) {
  var {
    props: t,
    previousSectorsRef: n
  } = e, {
    sectors: r,
    isAnimationActive: i,
    animationBegin: o,
    animationDuration: a,
    animationEasing: s,
    activeShape: l,
    inactiveShape: c,
    onAnimationStart: u,
    onAnimationEnd: d
  } = t, p = Vl(t, "recharts-pie-"), h = n.current, [g, m] = Ke(!1), v = xt(() => {
    typeof d == "function" && d(), m(!1);
  }, [d]), y = xt(() => {
    typeof u == "function" && u(), m(!0);
  }, [u]);
  return /* @__PURE__ */ _.createElement(RV, {
    showLabels: !g,
    sectors: r
  }, /* @__PURE__ */ _.createElement(Wl, {
    animationId: p,
    begin: o,
    duration: a,
    isActive: i,
    easing: s,
    onAnimationStart: y,
    onAnimationEnd: v,
    key: p
  }, (S) => {
    var w = [], b = r && r[0], O = b?.startAngle;
    return r?.forEach((E, C) => {
      var T = h && h[C], j = C > 0 ? Io(E, "paddingAngle", 0) : 0;
      if (T) {
        var A = _t(T.endAngle - T.startAngle, E.endAngle - E.startAngle, S), M = gt(gt({}, E), {}, {
          startAngle: O + j,
          endAngle: O + A + j
        });
        w.push(M), O = M.endAngle;
      } else {
        var {
          endAngle: P,
          startAngle: R
        } = E, N = _t(0, P - R, S), D = gt(gt({}, E), {}, {
          startAngle: O + j,
          endAngle: O + N + j
        });
        w.push(D), O = D.endAngle;
      }
    }), n.current = w, /* @__PURE__ */ _.createElement(nn, null, /* @__PURE__ */ _.createElement(NV, {
      sectors: w,
      activeShape: l,
      inactiveShape: c,
      allOtherPieProps: t
    }));
  }), /* @__PURE__ */ _.createElement(jV, {
    showLabels: !g,
    sectors: r,
    props: t
  }), t.children);
}
var $V = {
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  cx: "50%",
  cy: "50%",
  dataKey: "value",
  endAngle: 360,
  fill: "#808080",
  hide: !1,
  innerRadius: 0,
  isAnimationActive: !Zi.isSsr,
  labelLine: !0,
  legendType: "rect",
  minAngle: 0,
  nameKey: "name",
  outerRadius: "80%",
  paddingAngle: 0,
  rootTabIndex: 0,
  startAngle: 0,
  stroke: "#fff"
};
function LV(e) {
  var {
    id: t
  } = e, n = Oy(e, gV), {
    hide: r,
    className: i,
    rootTabIndex: o
  } = e, a = Un(() => Ug(e.children, Hr), [e.children]), s = pe((u) => $W(u, t, a)), l = Ne(null), c = ie("recharts-pie", i);
  return r || s == null ? (l.current = null, /* @__PURE__ */ _.createElement(nn, {
    tabIndex: o,
    className: c
  })) : /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(xy, {
    fn: SV,
    args: gt(gt({}, e), {}, {
      sectors: s
    })
  }), /* @__PURE__ */ _.createElement(nn, {
    tabIndex: o,
    className: c
  }, /* @__PURE__ */ _.createElement(IV, {
    props: gt(gt({}, n), {}, {
      sectors: s
    }),
    previousSectorsRef: l
  })));
}
function tc(e) {
  var t = on(e, $V), {
    id: n
  } = t, r = Oy(t, vV), i = Yr(r);
  return /* @__PURE__ */ _.createElement(wy, {
    id: n,
    type: "pie"
  }, (o) => /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(hV, {
    type: "pie",
    id: o,
    data: r.data,
    dataKey: r.dataKey,
    hide: r.hide,
    angleAxisId: 0,
    radiusAxisId: 0,
    name: r.name,
    nameKey: r.nameKey,
    tooltipType: r.tooltipType,
    legendType: r.legendType,
    fill: r.fill,
    cx: r.cx,
    cy: r.cy,
    startAngle: r.startAngle,
    endAngle: r.endAngle,
    paddingAngle: r.paddingAngle,
    minAngle: r.minAngle,
    innerRadius: r.innerRadius,
    outerRadius: r.outerRadius,
    cornerRadius: r.cornerRadius,
    presentationProps: i,
    maxRadius: t.maxRadius
  }), /* @__PURE__ */ _.createElement(OV, Hi({}, r, {
    id: o
  })), /* @__PURE__ */ _.createElement(LV, Hi({}, r, {
    id: o
  }))));
}
tc.displayName = "Pie";
function iO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iO(Object(n), !0).forEach(function(r) {
      FV(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function FV(e, t, n) {
  return (t = BV(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function BV(e) {
  var t = zV(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function zV(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var WV = {
  xAxis: {},
  yAxis: {},
  zAxis: {}
}, qT = Zn({
  name: "cartesianAxis",
  initialState: WV,
  reducers: {
    addXAxis(e, t) {
      e.xAxis[t.payload.id] = t.payload;
    },
    removeXAxis(e, t) {
      delete e.xAxis[t.payload.id];
    },
    addYAxis(e, t) {
      e.yAxis[t.payload.id] = t.payload;
    },
    removeYAxis(e, t) {
      delete e.yAxis[t.payload.id];
    },
    addZAxis(e, t) {
      e.zAxis[t.payload.id] = t.payload;
    },
    removeZAxis(e, t) {
      delete e.zAxis[t.payload.id];
    },
    updateYAxisWidth(e, t) {
      var {
        id: n,
        width: r
      } = t.payload;
      e.yAxis[n] && (e.yAxis[n] = oO(oO({}, e.yAxis[n]), {}, {
        width: r
      }));
    }
  }
}), {
  addXAxis: VV,
  removeXAxis: UV,
  addYAxis: HV,
  removeYAxis: qV,
  addZAxis: Xte,
  removeZAxis: Zte,
  updateYAxisWidth: KV
} = qT.actions, YV = qT.reducer, GV = z([zt], (e) => {
  if (e)
    return {
      top: e.top,
      bottom: e.bottom,
      left: e.left,
      right: e.right
    };
}), XV = z([GV, wi, Oi], (e, t, n) => {
  if (!(!e || t == null || n == null))
    return {
      x: e.left,
      y: e.top,
      width: Math.max(0, t - e.left - e.right),
      height: Math.max(0, n - e.top - e.bottom)
    };
}), Sy = () => pe(XV), ZV = () => pe(S8);
function aO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aO(Object(n), !0).forEach(function(r) {
      JV(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function JV(e, t, n) {
  return (t = QV(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function QV(e) {
  var t = e7(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function e7(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var t7 = (e) => {
  var {
    point: t,
    childIndex: n,
    mainColor: r,
    activeDot: i,
    dataKey: o
  } = e;
  if (i === !1 || t.x == null || t.y == null)
    return null;
  var a = sO(sO({
    index: n,
    dataKey: o,
    cx: t.x,
    cy: t.y,
    r: 4,
    fill: r ?? "none",
    strokeWidth: 2,
    stroke: "#fff",
    payload: t.payload,
    value: t.value
  }, wt(i, !1)), Vg(i)), s;
  return /* @__PURE__ */ bn(i) ? s = /* @__PURE__ */ cr(i, a) : typeof i == "function" ? s = i(a) : s = /* @__PURE__ */ _.createElement(IT, a), /* @__PURE__ */ _.createElement(nn, {
    className: "recharts-active-dot"
  }, s);
};
function n7(e) {
  var {
    points: t,
    mainColor: n,
    activeDot: r,
    itemDataKey: i
  } = e, o = pe(Ui), a = ZV();
  if (t == null || a == null)
    return null;
  var s = t.find((l) => a.includes(l.payload));
  return yt(s) ? null : t7({
    point: s,
    childIndex: Number(o),
    mainColor: n,
    dataKey: i,
    activeDot: r
  });
}
var r7 = process.env.NODE_ENV === "production", Th = "Invariant failed";
function lO(e, t) {
  if (r7)
    throw new Error(Th);
  var n = typeof t == "function" ? t() : t, r = n ? "".concat(Th, ": ").concat(n) : Th;
  throw new Error(r);
}
var i7 = ["x", "y"];
function Km() {
  return Km = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Km.apply(null, arguments);
}
function cO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cO(Object(n), !0).forEach(function(r) {
      o7(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function o7(e, t, n) {
  return (t = a7(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function a7(e) {
  var t = s7(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function s7(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function l7(e, t) {
  if (e == null) return {};
  var n, r, i = c7(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function c7(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function u7(e, t) {
  var {
    x: n,
    y: r
  } = e, i = l7(e, i7), o = "".concat(n), a = parseInt(o, 10), s = "".concat(r), l = parseInt(s, 10), c = "".concat(t.height || i.height), u = parseInt(c, 10), d = "".concat(t.width || i.width), p = parseInt(d, 10);
  return vs(vs(vs(vs(vs({}, t), i), a ? {
    x: a
  } : {}), l ? {
    y: l
  } : {}), {}, {
    height: u,
    width: p,
    name: t.name,
    radius: t.radius
  });
}
function Ey(e) {
  return /* @__PURE__ */ _.createElement(zT, Km({
    shapeType: "rectangle",
    propTransformer: u7,
    activeClassName: "recharts-active-bar"
  }, e));
}
var d7 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (r, i) => {
    if (me(t)) return t;
    var o = me(r) || yt(r);
    return o ? t(r, i) : (o || (process.env.NODE_ENV !== "production" ? lO(!1, "minPointSize callback function received a value with type of ".concat(typeof r, ". Currently only numbers or null/undefined are supported.")) : lO()), n);
  };
}, f7 = {}, KT = Zn({
  name: "errorBars",
  initialState: f7,
  reducers: {
    addErrorBar: (e, t) => {
      var {
        itemId: n,
        errorBar: r
      } = t.payload;
      e[n] || (e[n] = []), e[n].push(r);
    },
    replaceErrorBar: (e, t) => {
      var {
        itemId: n,
        prev: r,
        next: i
      } = t.payload;
      e[n] && (e[n] = e[n].map((o) => o.dataKey === r.dataKey && o.direction === r.direction ? i : o));
    },
    removeErrorBar: (e, t) => {
      var {
        itemId: n,
        errorBar: r
      } = t.payload;
      e[n] && (e[n] = e[n].filter((i) => i.dataKey !== r.dataKey || i.direction !== r.direction));
    }
  }
}), {
  addErrorBar: Jte,
  replaceErrorBar: Qte,
  removeErrorBar: ene
} = KT.actions, p7 = KT.reducer, h7 = ["children"];
function m7(e, t) {
  if (e == null) return {};
  var n, r, i = g7(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function g7(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var v7 = {
  data: [],
  xAxisId: "xAxis-0",
  yAxisId: "yAxis-0",
  dataPointFormatter: () => ({
    x: 0,
    y: 0,
    value: 0
  }),
  errorBarOffset: 0
}, y7 = /* @__PURE__ */ gr(v7);
function YT(e) {
  var {
    children: t
  } = e, n = m7(e, h7);
  return /* @__PURE__ */ _.createElement(y7.Provider, {
    value: n
  }, t);
}
function _y(e, t) {
  var n, r, i = pe((c) => Ei(c, e)), o = pe((c) => _i(c, t)), a = (n = i?.allowDataOverflow) !== null && n !== void 0 ? n : Rn.allowDataOverflow, s = (r = o?.allowDataOverflow) !== null && r !== void 0 ? r : In.allowDataOverflow, l = a || s;
  return {
    needClip: l,
    needClipX: a,
    needClipY: s
  };
}
function GT(e) {
  var {
    xAxisId: t,
    yAxisId: n,
    clipPathId: r
  } = e, i = Sy(), {
    needClipX: o,
    needClipY: a,
    needClip: s
  } = _y(t, n);
  if (!s)
    return null;
  var {
    x: l,
    y: c,
    width: u,
    height: d
  } = i;
  return /* @__PURE__ */ _.createElement("clipPath", {
    id: "clipPath-".concat(r)
  }, /* @__PURE__ */ _.createElement("rect", {
    x: o ? l : l - u / 2,
    y: a ? c : c - d / 2,
    width: o ? u : u * 2,
    height: a ? d : d * 2
  }));
}
var b7 = ["onMouseEnter", "onMouseLeave", "onClick"], x7 = ["value", "background", "tooltipPosition"], w7 = ["id"], O7 = ["onMouseEnter", "onClick", "onMouseLeave"];
function qi() {
  return qi = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, qi.apply(null, arguments);
}
function uO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uO(Object(n), !0).forEach(function(r) {
      S7(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function S7(e, t, n) {
  return (t = E7(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function E7(e) {
  var t = _7(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function _7(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function td(e, t) {
  if (e == null) return {};
  var n, r, i = P7(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function P7(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var C7 = (e) => {
  var {
    dataKey: t,
    name: n,
    fill: r,
    legendType: i,
    hide: o
  } = e;
  return [{
    inactive: o,
    dataKey: t,
    type: i,
    color: r,
    value: Ua(n, t),
    payload: e
  }];
};
function T7(e) {
  var {
    dataKey: t,
    stroke: n,
    strokeWidth: r,
    fill: i,
    name: o,
    hide: a,
    unit: s
  } = e;
  return {
    dataDefinedOnItem: void 0,
    positions: void 0,
    settings: {
      stroke: n,
      strokeWidth: r,
      fill: i,
      dataKey: t,
      nameKey: void 0,
      name: Ua(o, t),
      hide: a,
      type: e.tooltipType,
      color: e.fill,
      unit: s
    }
  };
}
function A7(e) {
  var t = pe(Ui), {
    data: n,
    dataKey: r,
    background: i,
    allOtherBarProps: o
  } = e, {
    onMouseEnter: a,
    onMouseLeave: s,
    onClick: l
  } = o, c = td(o, b7), u = vy(a, r), d = yy(s), p = by(l, r);
  if (!i || n == null)
    return null;
  var h = wt(i, !1);
  return /* @__PURE__ */ _.createElement(_.Fragment, null, n.map((g, m) => {
    var {
      value: v,
      background: y,
      tooltipPosition: S
    } = g, w = td(g, x7);
    if (!y)
      return null;
    var b = u(g, m), O = d(g, m), E = p(g, m), C = vn(vn(vn(vn(vn({
      option: i,
      isActive: String(m) === t
    }, w), {}, {
      // @ts-expect-error BarRectangle props do not accept `fill` property.
      fill: "#eee"
    }, y), h), Wd(c, g, m)), {}, {
      onMouseEnter: b,
      onMouseLeave: O,
      onClick: E,
      dataKey: r,
      index: m,
      className: "recharts-bar-background-rectangle"
    });
    return /* @__PURE__ */ _.createElement(Ey, qi({
      key: "background-bar-".concat(C.index)
    }, C));
  }));
}
function k7(e) {
  var {
    showLabels: t,
    children: n,
    rects: r
  } = e, i = r?.map((o) => {
    var a = {
      x: o.x,
      y: o.y,
      width: o.width,
      height: o.height
    };
    return vn(vn({}, a), {}, {
      value: o.value,
      payload: o.payload,
      parentViewBox: o.parentViewBox,
      viewBox: a,
      fill: o.fill
    });
  });
  return /* @__PURE__ */ _.createElement(DT, {
    value: t ? i : void 0
  }, n);
}
function M7(e) {
  var {
    shape: t,
    activeBar: n,
    baseProps: r,
    entry: i,
    index: o,
    dataKey: a
  } = e, s = pe(Ui), l = pe(mT), c = n && String(o) === s && (l == null || a === l), u = c ? n : t;
  return /* @__PURE__ */ _.createElement(Ey, qi({}, r, i, {
    isActive: c,
    option: u,
    index: o,
    dataKey: a
  }));
}
function j7(e) {
  var {
    shape: t,
    baseProps: n,
    entry: r,
    index: i,
    dataKey: o
  } = e;
  return /* @__PURE__ */ _.createElement(Ey, qi({}, n, r, {
    isActive: !1,
    option: t,
    index: i,
    dataKey: o
  }));
}
function N7(e) {
  var {
    data: t,
    props: n
  } = e, r = Yr(n), {
    id: i
  } = r, o = td(r, w7), {
    shape: a,
    dataKey: s,
    activeBar: l
  } = n, {
    onMouseEnter: c,
    onClick: u,
    onMouseLeave: d
  } = n, p = td(n, O7), h = vy(c, s), g = yy(d), m = by(u, s);
  return t ? /* @__PURE__ */ _.createElement(_.Fragment, null, t.map((v, y) => /* @__PURE__ */ _.createElement(nn, qi({
    className: "recharts-bar-rectangle"
  }, Wd(p, v, y), {
    // @ts-expect-error BarRectangleItem type definition says it's missing properties, but I can see them present in debugger!
    onMouseEnter: h(v, y),
    onMouseLeave: g(v, y),
    onClick: m(v, y),
    key: "rectangle-".concat(v?.x, "-").concat(v?.y, "-").concat(v?.value, "-").concat(y)
  }), l ? /* @__PURE__ */ _.createElement(M7, {
    shape: a,
    activeBar: l,
    baseProps: o,
    entry: v,
    index: y,
    dataKey: s
  }) : (
    /*
     * If the `activeBar` prop is falsy, then let's call the variant without hooks.
     * Using the `selectActiveTooltipIndex` selector is usually fast
     * but in charts with large-ish amount of data even the few nanoseconds add up to a noticeable jank.
     * If the activeBar is false then we don't need to know which index is active - because we won't use it anyway.
     * So let's just skip the hooks altogether. That way, React can skip rendering the component,
     * and can skip the tree reconciliation for its children too.
     * Because we can't call hooks conditionally, we need to have a separate component for that.
     */
    /* @__PURE__ */ _.createElement(j7, {
      shape: a,
      baseProps: o,
      entry: v,
      index: y,
      dataKey: s
    })
  )))) : null;
}
function D7(e) {
  var {
    props: t,
    previousRectanglesRef: n
  } = e, {
    data: r,
    layout: i,
    isAnimationActive: o,
    animationBegin: a,
    animationDuration: s,
    animationEasing: l,
    onAnimationEnd: c,
    onAnimationStart: u
  } = t, d = n.current, p = Vl(t, "recharts-bar-"), [h, g] = Ke(!1), m = !h, v = xt(() => {
    typeof c == "function" && c(), g(!1);
  }, [c]), y = xt(() => {
    typeof u == "function" && u(), g(!0);
  }, [u]);
  return /* @__PURE__ */ _.createElement(k7, {
    showLabels: m,
    rects: r
  }, /* @__PURE__ */ _.createElement(Wl, {
    animationId: p,
    begin: a,
    duration: s,
    isActive: o,
    easing: l,
    onAnimationEnd: v,
    onAnimationStart: y,
    key: p
  }, (S) => {
    var w = S === 1 ? r : r?.map((b, O) => {
      var E = d && d[O];
      if (E)
        return vn(vn({}, b), {}, {
          x: _t(E.x, b.x, S),
          y: _t(E.y, b.y, S),
          width: _t(E.width, b.width, S),
          height: _t(E.height, b.height, S)
        });
      if (i === "horizontal") {
        var C = _t(0, b.height, S);
        return vn(vn({}, b), {}, {
          y: b.y + b.height - C,
          height: C
        });
      }
      var T = _t(0, b.width, S);
      return vn(vn({}, b), {}, {
        width: T
      });
    });
    return S > 0 && (n.current = w ?? null), w == null ? null : /* @__PURE__ */ _.createElement(nn, null, /* @__PURE__ */ _.createElement(N7, {
      props: t,
      data: w
    }));
  }), /* @__PURE__ */ _.createElement(fy, {
    label: t.label
  }), t.children);
}
function R7(e) {
  var t = Ne(null);
  return /* @__PURE__ */ _.createElement(D7, {
    previousRectanglesRef: t,
    props: e
  });
}
var XT = 0, I7 = (e, t) => {
  var n = Array.isArray(e.value) ? e.value[1] : e.value;
  return {
    x: e.x,
    y: e.y,
    value: n,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: ct(e, t)
  };
};
class $7 extends FE {
  render() {
    var {
      hide: t,
      data: n,
      dataKey: r,
      className: i,
      xAxisId: o,
      yAxisId: a,
      needClip: s,
      background: l,
      id: c
    } = this.props;
    if (t || n == null)
      return null;
    var u = ie("recharts-bar", i), d = c;
    return /* @__PURE__ */ _.createElement(nn, {
      className: u,
      id: c
    }, s && /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement(GT, {
      clipPathId: d,
      xAxisId: o,
      yAxisId: a
    })), /* @__PURE__ */ _.createElement(nn, {
      className: "recharts-bar-rectangles",
      clipPath: s ? "url(#clipPath-".concat(d, ")") : void 0
    }, /* @__PURE__ */ _.createElement(A7, {
      data: n,
      dataKey: r,
      background: l,
      allOtherBarProps: this.props
    }), /* @__PURE__ */ _.createElement(R7, this.props)));
  }
}
var L7 = {
  activeBar: !1,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease",
  hide: !1,
  isAnimationActive: !Zi.isSsr,
  legendType: "rect",
  minPointSize: XT,
  xAxisId: 0,
  yAxisId: 0
};
function F7(e) {
  var {
    xAxisId: t,
    yAxisId: n,
    hide: r,
    legendType: i,
    minPointSize: o,
    activeBar: a,
    animationBegin: s,
    animationDuration: l,
    animationEasing: c,
    isAnimationActive: u
  } = e, {
    needClip: d
  } = _y(t, n), p = tf(), h = Nn(), g = Ug(e.children, Hr), m = pe((S) => p9(S, t, n, h, e.id, g));
  if (p !== "vertical" && p !== "horizontal")
    return null;
  var v, y = m?.[0];
  return y == null || y.height == null || y.width == null ? v = 0 : v = p === "vertical" ? y.height / 2 : y.width / 2, /* @__PURE__ */ _.createElement(YT, {
    xAxisId: t,
    yAxisId: n,
    data: m,
    dataPointFormatter: I7,
    errorBarOffset: v
  }, /* @__PURE__ */ _.createElement($7, qi({}, e, {
    layout: p,
    needClip: d,
    data: m,
    xAxisId: t,
    yAxisId: n,
    hide: r,
    legendType: i,
    minPointSize: o,
    activeBar: a,
    animationBegin: s,
    animationDuration: l,
    animationEasing: c,
    isAnimationActive: u
  })));
}
function B7(e) {
  var {
    layout: t,
    barSettings: {
      dataKey: n,
      minPointSize: r
    },
    pos: i,
    bandSize: o,
    xAxis: a,
    yAxis: s,
    xAxisTicks: l,
    yAxisTicks: c,
    stackedData: u,
    displayedData: d,
    offset: p,
    cells: h,
    parentViewBox: g
  } = e, m = t === "horizontal" ? s : a, v = u ? m.scale.domain() : null, y = dL({
    numericAxis: m
  });
  return d.map((S, w) => {
    var b, O, E, C, T, j;
    u ? b = oL(u[w], v) : (b = ct(S, n), Array.isArray(b) || (b = [y, b]));
    var A = d7(r, XT)(b[1], w);
    if (t === "horizontal") {
      var M, [P, R] = [s.scale(b[0]), s.scale(b[1])];
      O = Xx({
        axis: a,
        ticks: l,
        bandSize: o,
        offset: i.offset,
        entry: S,
        index: w
      }), E = (M = R ?? P) !== null && M !== void 0 ? M : void 0, C = i.size;
      var N = P - R;
      if (T = qn(N) ? 0 : N, j = {
        x: O,
        y: p.top,
        width: C,
        height: p.height
      }, Math.abs(A) > 0 && Math.abs(T) < Math.abs(A)) {
        var D = Yt(T || A) * (Math.abs(A) - Math.abs(T));
        E -= D, T += D;
      }
    } else {
      var [$, F] = [a.scale(b[0]), a.scale(b[1])];
      if (O = $, E = Xx({
        axis: s,
        ticks: c,
        bandSize: o,
        offset: i.offset,
        entry: S,
        index: w
      }), C = F - $, T = i.size, j = {
        x: p.left,
        y: E,
        width: p.width,
        height: T
      }, Math.abs(A) > 0 && Math.abs(C) < Math.abs(A)) {
        var q = Yt(C || A) * (Math.abs(A) - Math.abs(C));
        C += q;
      }
    }
    if (O == null || E == null || C == null || T == null)
      return null;
    var B = vn(vn({}, S), {}, {
      x: O,
      y: E,
      width: C,
      height: T,
      value: u ? b : b[1],
      payload: S,
      background: j,
      tooltipPosition: {
        x: O + C / 2,
        y: E + T / 2
      },
      parentViewBox: g
    }, h && h[w] && h[w].props);
    return B;
  }).filter(Boolean);
}
function z7(e) {
  var t = on(e, L7), n = Nn();
  return /* @__PURE__ */ _.createElement(wy, {
    id: t.id,
    type: "bar"
  }, (r) => /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(VT, {
    legendPayload: C7(t)
  }), /* @__PURE__ */ _.createElement(xy, {
    fn: T7,
    args: t
  }), /* @__PURE__ */ _.createElement(HT, {
    type: "bar",
    id: r,
    data: void 0,
    xAxisId: t.xAxisId,
    yAxisId: t.yAxisId,
    zAxisId: 0,
    dataKey: t.dataKey,
    stackId: uL(t.stackId),
    hide: t.hide,
    barSize: t.barSize,
    minPointSize: t.minPointSize,
    maxBarSize: t.maxBarSize,
    isPanorama: n
  }), /* @__PURE__ */ _.createElement(F7, qi({}, t, {
    id: r
  }))));
}
var ZT = /* @__PURE__ */ _.memo(z7);
ZT.displayName = "Bar";
function dO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dO(Object(n), !0).forEach(function(r) {
      W7(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function W7(e, t, n) {
  return (t = V7(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function V7(e) {
  var t = U7(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function U7(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var H7 = (e, t) => t, q7 = (e, t, n) => n, K7 = (e, t, n, r) => r, Y7 = (e, t, n, r, i) => i, nc = z([hf, Y7], (e, t) => e.filter((n) => n.type === "bar").find((n) => n.id === t)), G7 = z([nc], (e) => e?.maxBarSize), X7 = (e, t, n, r, i, o) => o, fO = (e, t, n) => {
  var r = n ?? e;
  if (!yt(r))
    return hn(r, t, 0);
}, Z7 = z([Pe, hf, H7, q7, K7], (e, t, n, r, i) => t.filter((o) => e === "horizontal" ? o.xAxisId === n : o.yAxisId === r).filter((o) => o.isPanorama === i).filter((o) => o.hide === !1).filter((o) => o.type === "bar")), J7 = (e, t, n, r) => {
  var i = Pe(e);
  return i === "horizontal" ? Bm(e, "yAxis", n, r) : Bm(e, "xAxis", t, r);
}, Q7 = (e, t, n) => {
  var r = Pe(e);
  return r === "horizontal" ? dw(e, "xAxis", t) : dw(e, "yAxis", n);
}, e9 = (e, t, n) => {
  var r = {}, i = e.filter(pf), o = e.filter((c) => c.stackId == null), a = i.reduce((c, u) => (c[u.stackId] || (c[u.stackId] = []), c[u.stackId].push(u), c), r), s = Object.entries(a).map((c) => {
    var [u, d] = c, p = d.map((g) => g.dataKey), h = fO(t, n, d[0].barSize);
    return {
      stackId: u,
      dataKeys: p,
      barSize: h
    };
  }), l = o.map((c) => {
    var u = [c.dataKey].filter((p) => p != null), d = fO(t, n, c.barSize);
    return {
      stackId: void 0,
      dataKeys: u,
      barSize: d
    };
  });
  return [...s, ...l];
}, t9 = z([Z7, j6, Q7], e9), n9 = (e, t, n, r, i) => {
  var o, a, s = nc(e, t, n, r, i);
  if (s != null) {
    var l = Pe(e), c = pC(e), {
      maxBarSize: u
    } = s, d = yt(u) ? c : u, p, h;
    return l === "horizontal" ? (p = Vi(e, "xAxis", t, r), h = Wi(e, "xAxis", t, r)) : (p = Vi(e, "yAxis", n, r), h = Wi(e, "yAxis", n, r)), (o = (a = al(p, h, !0)) !== null && a !== void 0 ? a : d) !== null && o !== void 0 ? o : 0;
  }
}, JT = (e, t, n, r) => {
  var i = Pe(e), o, a;
  return i === "horizontal" ? (o = Vi(e, "xAxis", t, r), a = Wi(e, "xAxis", t, r)) : (o = Vi(e, "yAxis", n, r), a = Wi(e, "yAxis", n, r)), al(o, a);
};
function r9(e, t, n, r, i) {
  var o = r.length;
  if (!(o < 1)) {
    var a = hn(e, n, 0, !0), s, l = [];
    if (Yn(r[0].barSize)) {
      var c = !1, u = n / o, d = r.reduce((y, S) => y + (S.barSize || 0), 0);
      d += (o - 1) * a, d >= n && (d -= (o - 1) * a, a = 0), d >= n && u > 0 && (c = !0, u *= 0.9, d = o * u);
      var p = (n - d) / 2 >> 0, h = {
        offset: p - a,
        size: 0
      };
      s = r.reduce((y, S) => {
        var w, b = {
          stackId: S.stackId,
          dataKeys: S.dataKeys,
          position: {
            offset: h.offset + h.size + a,
            size: c ? u : (w = S.barSize) !== null && w !== void 0 ? w : 0
          }
        }, O = [...y, b];
        return h = O[O.length - 1].position, O;
      }, l);
    } else {
      var g = hn(t, n, 0, !0);
      n - 2 * g - (o - 1) * a <= 0 && (a = 0);
      var m = (n - 2 * g - (o - 1) * a) / o;
      m > 1 && (m >>= 0);
      var v = Yn(i) ? Math.min(m, i) : m;
      s = r.reduce((y, S, w) => [...y, {
        stackId: S.stackId,
        dataKeys: S.dataKeys,
        position: {
          offset: g + (m + a) * w + (m - v) / 2,
          size: v
        }
      }], l);
    }
    return s;
  }
}
var i9 = (e, t, n, r, i, o, a) => {
  var s = yt(a) ? t : a, l = r9(n, r, i !== o ? i : o, e, s);
  return i !== o && l != null && (l = l.map((c) => Rc(Rc({}, c), {}, {
    position: Rc(Rc({}, c.position), {}, {
      offset: c.position.offset - i / 2
    })
  }))), l;
}, o9 = z([t9, pC, M6, hC, n9, JT, G7], i9), a9 = (e, t, n, r) => Vi(e, "xAxis", t, r), s9 = (e, t, n, r) => Vi(e, "yAxis", n, r), l9 = (e, t, n, r) => Wi(e, "xAxis", t, r), c9 = (e, t, n, r) => Wi(e, "yAxis", n, r), u9 = z([o9, nc], (e, t) => {
  if (!(e == null || t == null)) {
    var n = e.find((r) => r.stackId === t.stackId && t.dataKey != null && r.dataKeys.includes(t.dataKey));
    if (n != null)
      return n.position;
  }
}), d9 = (e, t) => {
  var n = $v(t);
  if (!(!e || n == null || t == null)) {
    var {
      stackId: r
    } = t;
    if (r != null) {
      var i = e[r];
      if (i) {
        var {
          stackedData: o
        } = i;
        if (o)
          return o.find((a) => a.key === n);
      }
    }
  }
}, f9 = z([J7, nc], d9), p9 = z([zt, nv, a9, s9, l9, c9, u9, Pe, cf, JT, f9, nc, X7], (e, t, n, r, i, o, a, s, l, c, u, d, p) => {
  var {
    chartData: h,
    dataStartIndex: g,
    dataEndIndex: m
  } = l;
  if (!(d == null || a == null || t == null || s !== "horizontal" && s !== "vertical" || n == null || r == null || i == null || o == null || c == null)) {
    var {
      data: v
    } = d, y;
    if (v != null && v.length > 0 ? y = v : y = h?.slice(g, m + 1), y != null)
      return B7({
        layout: s,
        barSettings: d,
        pos: a,
        parentViewBox: t,
        bandSize: c,
        xAxis: n,
        yAxis: r,
        xAxisTicks: i,
        yAxisTicks: o,
        stackedData: u,
        displayedData: y,
        offset: e,
        cells: p
      });
  }
}), QT = (e) => {
  var {
    chartData: t
  } = e, n = Nt(), r = Nn();
  return De(() => r ? () => {
  } : (n(ww(t)), () => {
    n(ww(void 0));
  }), [t, n, r]), null;
}, pO = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
}, eA = Zn({
  name: "brush",
  initialState: pO,
  reducers: {
    setBrushSettings(e, t) {
      return t.payload == null ? pO : t.payload;
    }
  }
}), {
  setBrushSettings: tne
} = eA.actions, h9 = eA.reducer;
function m9(e, t, n) {
  return (t = g9(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function g9(e) {
  var t = v9(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function v9(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
class Py {
  static create(t) {
    return new Py(t);
  }
  constructor(t) {
    this.scale = t;
  }
  get domain() {
    return this.scale.domain;
  }
  get range() {
    return this.scale.range;
  }
  get rangeMin() {
    return this.range()[0];
  }
  get rangeMax() {
    return this.range()[1];
  }
  get bandwidth() {
    return this.scale.bandwidth;
  }
  apply(t) {
    var {
      bandAware: n,
      position: r
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (t !== void 0) {
      if (r)
        switch (r) {
          case "start":
            return this.scale(t);
          case "middle": {
            var i = this.bandwidth ? this.bandwidth() / 2 : 0;
            return this.scale(t) + i;
          }
          case "end": {
            var o = this.bandwidth ? this.bandwidth() : 0;
            return this.scale(t) + o;
          }
          default:
            return this.scale(t);
        }
      if (n) {
        var a = this.bandwidth ? this.bandwidth() / 2 : 0;
        return this.scale(t) + a;
      }
      return this.scale(t);
    }
  }
  isInRange(t) {
    var n = this.range(), r = n[0], i = n[n.length - 1];
    return r <= i ? t >= r && t <= i : t >= i && t <= r;
  }
}
m9(Py, "EPS", 1e-4);
function y9(e) {
  return (e % 180 + 180) % 180;
}
var b9 = function(t) {
  var {
    width: n,
    height: r
  } = t, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = y9(i), a = o * Math.PI / 180, s = Math.atan(r / n), l = a > s && a < Math.PI - s ? r / Math.sin(a) : n / Math.cos(a);
  return Math.abs(l);
}, x9 = {
  dots: [],
  areas: [],
  lines: []
}, tA = Zn({
  name: "referenceElements",
  initialState: x9,
  reducers: {
    addDot: (e, t) => {
      e.dots.push(t.payload);
    },
    removeDot: (e, t) => {
      var n = ui(e).dots.findIndex((r) => r === t.payload);
      n !== -1 && e.dots.splice(n, 1);
    },
    addArea: (e, t) => {
      e.areas.push(t.payload);
    },
    removeArea: (e, t) => {
      var n = ui(e).areas.findIndex((r) => r === t.payload);
      n !== -1 && e.areas.splice(n, 1);
    },
    addLine: (e, t) => {
      e.lines.push(t.payload);
    },
    removeLine: (e, t) => {
      var n = ui(e).lines.findIndex((r) => r === t.payload);
      n !== -1 && e.lines.splice(n, 1);
    }
  }
}), {
  addDot: nne,
  removeDot: rne,
  addArea: ine,
  removeArea: one,
  addLine: ane,
  removeLine: sne
} = tA.actions, w9 = tA.reducer, O9 = /* @__PURE__ */ gr(void 0), S9 = (e) => {
  var {
    children: t
  } = e, [n] = Ke("".concat(rl("recharts"), "-clip")), r = Sy();
  if (r == null)
    return null;
  var {
    x: i,
    y: o,
    width: a,
    height: s
  } = r;
  return /* @__PURE__ */ _.createElement(O9.Provider, {
    value: n
  }, /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement("clipPath", {
    id: n
  }, /* @__PURE__ */ _.createElement("rect", {
    x: i,
    y: o,
    height: s,
    width: a
  }))), t);
};
function Ra(e, t) {
  for (var n in e)
    if ({}.hasOwnProperty.call(e, n) && (!{}.hasOwnProperty.call(t, n) || e[n] !== t[n]))
      return !1;
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r) && !{}.hasOwnProperty.call(e, r))
      return !1;
  return !0;
}
function nA(e, t, n) {
  if (t < 1)
    return [];
  if (t === 1 && n === void 0)
    return e;
  for (var r = [], i = 0; i < e.length; i += t)
    r.push(e[i]);
  return r;
}
function E9(e, t, n) {
  var r = {
    width: e.width + t.width,
    height: e.height + t.height
  };
  return b9(r, n);
}
function _9(e, t, n) {
  var r = n === "width", {
    x: i,
    y: o,
    width: a,
    height: s
  } = e;
  return t === 1 ? {
    start: r ? i : o,
    end: r ? i + a : o + s
  } : {
    start: r ? i + a : o + s,
    end: r ? i : o
  };
}
function nd(e, t, n, r, i) {
  if (e * t < e * r || e * t > e * i)
    return !1;
  var o = n();
  return e * (t - e * o / 2 - r) >= 0 && e * (t + e * o / 2 - i) <= 0;
}
function P9(e, t) {
  return nA(e, t + 1);
}
function C9(e, t, n, r, i) {
  for (var o = (r || []).slice(), {
    start: a,
    end: s
  } = t, l = 0, c = 1, u = a, d = function() {
    var g = r?.[l];
    if (g === void 0)
      return {
        v: nA(r, c)
      };
    var m = l, v, y = () => (v === void 0 && (v = n(g, m)), v), S = g.coordinate, w = l === 0 || nd(e, S, y, u, s);
    w || (l = 0, u = a, c += 1), w && (u = S + e * (y() / 2 + i), l += c);
  }, p; c <= o.length; )
    if (p = d(), p) return p.v;
  return [];
}
function hO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function un(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hO(Object(n), !0).forEach(function(r) {
      T9(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function T9(e, t, n) {
  return (t = A9(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function A9(e) {
  var t = k9(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function k9(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function M9(e, t, n, r, i) {
  for (var o = (r || []).slice(), a = o.length, {
    start: s
  } = t, {
    end: l
  } = t, c = function(p) {
    var h = o[p], g, m = () => (g === void 0 && (g = n(h, p)), g);
    if (p === a - 1) {
      var v = e * (h.coordinate + e * m() / 2 - l);
      o[p] = h = un(un({}, h), {}, {
        tickCoord: v > 0 ? h.coordinate - v * e : h.coordinate
      });
    } else
      o[p] = h = un(un({}, h), {}, {
        tickCoord: h.coordinate
      });
    var y = nd(e, h.tickCoord, m, s, l);
    y && (l = h.tickCoord - e * (m() / 2 + i), o[p] = un(un({}, h), {}, {
      isShow: !0
    }));
  }, u = a - 1; u >= 0; u--)
    c(u);
  return o;
}
function j9(e, t, n, r, i, o) {
  var a = (r || []).slice(), s = a.length, {
    start: l,
    end: c
  } = t;
  if (o) {
    var u = r[s - 1], d = n(u, s - 1), p = e * (u.coordinate + e * d / 2 - c);
    a[s - 1] = u = un(un({}, u), {}, {
      tickCoord: p > 0 ? u.coordinate - p * e : u.coordinate
    });
    var h = nd(e, u.tickCoord, () => d, l, c);
    h && (c = u.tickCoord - e * (d / 2 + i), a[s - 1] = un(un({}, u), {}, {
      isShow: !0
    }));
  }
  for (var g = o ? s - 1 : s, m = function(S) {
    var w = a[S], b, O = () => (b === void 0 && (b = n(w, S)), b);
    if (S === 0) {
      var E = e * (w.coordinate - e * O() / 2 - l);
      a[S] = w = un(un({}, w), {}, {
        tickCoord: E < 0 ? w.coordinate - E * e : w.coordinate
      });
    } else
      a[S] = w = un(un({}, w), {}, {
        tickCoord: w.coordinate
      });
    var C = nd(e, w.tickCoord, O, l, c);
    C && (l = w.tickCoord + e * (O() / 2 + i), a[S] = un(un({}, w), {}, {
      isShow: !0
    }));
  }, v = 0; v < g; v++)
    m(v);
  return a;
}
function Cy(e, t, n) {
  var {
    tick: r,
    ticks: i,
    viewBox: o,
    minTickGap: a,
    orientation: s,
    interval: l,
    tickFormatter: c,
    unit: u,
    angle: d
  } = e;
  if (!i || !i.length || !r)
    return [];
  if (me(l) || Zi.isSsr) {
    var p;
    return (p = P9(i, me(l) ? l : 0)) !== null && p !== void 0 ? p : [];
  }
  var h = [], g = s === "top" || s === "bottom" ? "width" : "height", m = u && g === "width" ? Vs(u, {
    fontSize: t,
    letterSpacing: n
  }) : {
    width: 0,
    height: 0
  }, v = (w, b) => {
    var O = typeof c == "function" ? c(w.value, b) : w.value;
    return g === "width" ? E9(Vs(O, {
      fontSize: t,
      letterSpacing: n
    }), m, d) : Vs(O, {
      fontSize: t,
      letterSpacing: n
    })[g];
  }, y = i.length >= 2 ? Yt(i[1].coordinate - i[0].coordinate) : 1, S = _9(o, y, g);
  return l === "equidistantPreserveStart" ? C9(y, S, v, i, a) : (l === "preserveStart" || l === "preserveStartEnd" ? h = j9(y, S, v, i, a, l === "preserveStartEnd") : h = M9(y, S, v, i, a), h.filter((w) => w.isShow));
}
var N9 = (e) => {
  var {
    ticks: t,
    label: n,
    labelGapWithTick: r = 5,
    // Default gap between label and tick
    tickSize: i = 0,
    tickMargin: o = 0
  } = e, a = 0;
  if (t) {
    t.forEach((u) => {
      if (u) {
        var d = u.getBoundingClientRect();
        d.width > a && (a = d.width);
      }
    });
    var s = n ? n.getBoundingClientRect().width : 0, l = i + o, c = a + l + s + (n ? r : 0);
    return Math.round(c);
  }
  return 0;
}, D9 = ["axisLine", "width", "height", "className", "hide", "ticks"], R9 = ["viewBox"], I9 = ["viewBox"];
function Ym(e, t) {
  if (e == null) return {};
  var n, r, i = $9(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function $9(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Bo() {
  return Bo = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Bo.apply(null, arguments);
}
function mO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ft(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mO(Object(n), !0).forEach(function(r) {
      L9(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function L9(e, t, n) {
  return (t = F9(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function F9(e) {
  var t = B9(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function B9(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Ty = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
};
function z9(e) {
  var {
    x: t,
    y: n,
    width: r,
    height: i,
    orientation: o,
    mirror: a,
    axisLine: s,
    otherSvgProps: l
  } = e;
  if (!s)
    return null;
  var c = Ft(Ft(Ft({}, l), wt(s, !1)), {}, {
    fill: "none"
  });
  if (o === "top" || o === "bottom") {
    var u = +(o === "top" && !a || o === "bottom" && a);
    c = Ft(Ft({}, c), {}, {
      x1: t,
      y1: n + u * i,
      x2: t + r,
      y2: n + u * i
    });
  } else {
    var d = +(o === "left" && !a || o === "right" && a);
    c = Ft(Ft({}, c), {}, {
      x1: t + d * r,
      y1: n,
      x2: t + d * r,
      y2: n + i
    });
  }
  return /* @__PURE__ */ _.createElement("line", Bo({}, c, {
    className: ie("recharts-cartesian-axis-line", Io(s, "className"))
  }));
}
function W9(e, t, n, r, i, o, a, s, l) {
  var c, u, d, p, h, g, m = s ? -1 : 1, v = e.tickSize || a, y = me(e.tickCoord) ? e.tickCoord : e.coordinate;
  switch (o) {
    case "top":
      c = u = e.coordinate, p = n + +!s * i, d = p - m * v, g = d - m * l, h = y;
      break;
    case "left":
      d = p = e.coordinate, u = t + +!s * r, c = u - m * v, h = c - m * l, g = y;
      break;
    case "right":
      d = p = e.coordinate, u = t + +s * r, c = u + m * v, h = c + m * l, g = y;
      break;
    default:
      c = u = e.coordinate, p = n + +s * i, d = p + m * v, g = d + m * l, h = y;
      break;
  }
  return {
    line: {
      x1: c,
      y1: d,
      x2: u,
      y2: p
    },
    tick: {
      x: h,
      y: g
    }
  };
}
function V9(e, t) {
  switch (e) {
    case "left":
      return t ? "start" : "end";
    case "right":
      return t ? "end" : "start";
    default:
      return "middle";
  }
}
function U9(e, t) {
  switch (e) {
    case "left":
    case "right":
      return "middle";
    case "top":
      return t ? "start" : "end";
    default:
      return t ? "end" : "start";
  }
}
function H9(e) {
  var {
    option: t,
    tickProps: n,
    value: r
  } = e, i, o = ie(n.className, "recharts-cartesian-axis-tick-value");
  if (/* @__PURE__ */ _.isValidElement(t))
    i = /* @__PURE__ */ _.cloneElement(t, Ft(Ft({}, n), {}, {
      className: o
    }));
  else if (typeof t == "function")
    i = t(Ft(Ft({}, n), {}, {
      className: o
    }));
  else {
    var a = "recharts-cartesian-axis-tick-value";
    typeof t != "boolean" && (a = ie(a, t?.className)), i = /* @__PURE__ */ _.createElement(xf, Bo({}, n, {
      className: a
    }), r);
  }
  return i;
}
function q9(e) {
  var {
    ticks: t = [],
    tick: n,
    tickLine: r,
    stroke: i,
    tickFormatter: o,
    unit: a,
    padding: s,
    tickTextProps: l,
    orientation: c,
    mirror: u,
    x: d,
    y: p,
    width: h,
    height: g,
    tickSize: m,
    tickMargin: v,
    fontSize: y,
    letterSpacing: S,
    getTicksConfig: w,
    events: b
  } = e, O = Cy(Ft(Ft({}, w), {}, {
    ticks: t
  }), y, S), E = V9(c, u), C = U9(c, u), T = Yr(w), j = wt(n, !1), A = Ft(Ft({}, T), {}, {
    fill: "none"
  }, wt(r, !1)), M = O.map((P, R) => {
    var {
      line: N,
      tick: D
    } = W9(P, d, p, h, g, c, m, u, v), $ = Ft(Ft(Ft(Ft({
      // @ts-expect-error textAnchor from axisProps is typed as `string` but Text wants type `TextAnchor`
      textAnchor: E,
      verticalAnchor: C
    }, T), {}, {
      stroke: "none",
      fill: i
    }, j), D), {}, {
      index: R,
      payload: P,
      visibleTicksCount: O.length,
      tickFormatter: o,
      padding: s
    }, l);
    return /* @__PURE__ */ _.createElement(nn, Bo({
      className: "recharts-cartesian-axis-tick",
      key: "tick-".concat(P.value, "-").concat(P.coordinate, "-").concat(P.tickCoord)
    }, Wd(b, P, R)), r && // @ts-expect-error recharts scale is not compatible with SVG scale
    /* @__PURE__ */ _.createElement("line", Bo({}, A, N, {
      className: ie("recharts-cartesian-axis-tick-line", Io(r, "className"))
    })), n && /* @__PURE__ */ _.createElement(H9, {
      option: n,
      tickProps: $,
      value: "".concat(typeof o == "function" ? o(P.value, R) : P.value).concat(a || "")
    }));
  });
  return M.length > 0 ? /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-axis-ticks"
  }, M) : null;
}
var K9 = /* @__PURE__ */ rn((e, t) => {
  var {
    axisLine: n,
    width: r,
    height: i,
    className: o,
    hide: a,
    ticks: s
  } = e, l = Ym(e, D9), [c, u] = Ke(""), [d, p] = Ke(""), h = Ne([]);
  zE(t, () => ({
    getCalculatedWidth: () => {
      var m;
      return N9({
        ticks: h.current,
        label: (m = e.labelRef) === null || m === void 0 ? void 0 : m.current,
        labelGapWithTick: 5,
        tickSize: e.tickSize,
        tickMargin: e.tickMargin
      });
    }
  }));
  var g = xt((m) => {
    if (m) {
      var v = m.getElementsByClassName("recharts-cartesian-axis-tick-value");
      h.current = Array.from(v);
      var y = v[0];
      if (y) {
        var S = window.getComputedStyle(y), w = S.fontSize, b = S.letterSpacing;
        (w !== c || b !== d) && (u(w), p(b));
      }
    }
  }, [c, d]);
  return a || r != null && r <= 0 || i != null && i <= 0 ? null : /* @__PURE__ */ _.createElement(nn, {
    className: ie("recharts-cartesian-axis", o),
    ref: g
  }, /* @__PURE__ */ _.createElement(z9, {
    x: e.x,
    y: e.y,
    width: r,
    height: i,
    orientation: e.orientation,
    mirror: e.mirror,
    axisLine: n,
    otherSvgProps: Yr(e)
  }), /* @__PURE__ */ _.createElement(q9, {
    ticks: s,
    tick: e.tick,
    tickLine: e.tickLine,
    stroke: e.stroke,
    tickFormatter: e.tickFormatter,
    unit: e.unit,
    padding: e.padding,
    tickTextProps: e.tickTextProps,
    orientation: e.orientation,
    mirror: e.mirror,
    x: e.x,
    y: e.y,
    width: e.width,
    height: e.height,
    tickSize: e.tickSize,
    tickMargin: e.tickMargin,
    fontSize: c,
    letterSpacing: d,
    getTicksConfig: e,
    events: l
  }), /* @__PURE__ */ _.createElement(Qz, {
    x: e.x,
    y: e.y,
    width: e.width,
    height: e.height
  }, /* @__PURE__ */ _.createElement(cW, {
    label: e.label
  }), e.children));
}), Y9 = /* @__PURE__ */ _.memo(K9, (e, t) => {
  var {
    viewBox: n
  } = e, r = Ym(e, R9), {
    viewBox: i
  } = t, o = Ym(t, I9);
  return Ra(n, i) && Ra(r, o);
}), Ay = /* @__PURE__ */ _.forwardRef((e, t) => {
  var n = on(e, Ty);
  return /* @__PURE__ */ _.createElement(Y9, Bo({}, n, {
    ref: t
  }));
});
Ay.displayName = "CartesianAxis";
var G9 = ["x1", "y1", "x2", "y2", "key"], X9 = ["offset"], Z9 = ["xAxisId", "yAxisId"], J9 = ["xAxisId", "yAxisId"];
function gO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gO(Object(n), !0).forEach(function(r) {
      Q9(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Q9(e, t, n) {
  return (t = eU(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function eU(e) {
  var t = tU(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function tU(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Po() {
  return Po = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Po.apply(null, arguments);
}
function rd(e, t) {
  if (e == null) return {};
  var n, r, i = nU(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function nU(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var rU = (e) => {
  var {
    fill: t
  } = e;
  if (!t || t === "none")
    return null;
  var {
    fillOpacity: n,
    x: r,
    y: i,
    width: o,
    height: a,
    ry: s
  } = e;
  return /* @__PURE__ */ _.createElement("rect", {
    x: r,
    y: i,
    ry: s,
    width: o,
    height: a,
    stroke: "none",
    fill: t,
    fillOpacity: n,
    className: "recharts-cartesian-grid-bg"
  });
};
function rA(e, t) {
  var n;
  if (/* @__PURE__ */ _.isValidElement(e))
    n = /* @__PURE__ */ _.cloneElement(e, t);
  else if (typeof e == "function")
    n = e(t);
  else {
    var {
      x1: r,
      y1: i,
      x2: o,
      y2: a,
      key: s
    } = t, l = rd(t, G9), c = Yr(l), {
      offset: u
    } = c, d = rd(c, X9);
    n = /* @__PURE__ */ _.createElement("line", Po({}, d, {
      x1: r,
      y1: i,
      x2: o,
      y2: a,
      fill: "none",
      key: s
    }));
  }
  return n;
}
function iU(e) {
  var {
    x: t,
    width: n,
    horizontal: r = !0,
    horizontalPoints: i
  } = e;
  if (!r || !i || !i.length)
    return null;
  var {
    xAxisId: o,
    yAxisId: a
  } = e, s = rd(e, Z9), l = i.map((c, u) => {
    var d = dn(dn({}, s), {}, {
      x1: t,
      y1: c,
      x2: t + n,
      y2: c,
      key: "line-".concat(u),
      index: u
    });
    return rA(r, d);
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, l);
}
function oU(e) {
  var {
    y: t,
    height: n,
    vertical: r = !0,
    verticalPoints: i
  } = e;
  if (!r || !i || !i.length)
    return null;
  var {
    xAxisId: o,
    yAxisId: a
  } = e, s = rd(e, J9), l = i.map((c, u) => {
    var d = dn(dn({}, s), {}, {
      x1: c,
      y1: t,
      x2: c,
      y2: t + n,
      key: "line-".concat(u),
      index: u
    });
    return rA(r, d);
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, l);
}
function aU(e) {
  var {
    horizontalFill: t,
    fillOpacity: n,
    x: r,
    y: i,
    width: o,
    height: a,
    horizontalPoints: s,
    horizontal: l = !0
  } = e;
  if (!l || !t || !t.length)
    return null;
  var c = s.map((d) => Math.round(d + i - i)).sort((d, p) => d - p);
  i !== c[0] && c.unshift(0);
  var u = c.map((d, p) => {
    var h = !c[p + 1], g = h ? i + a - d : c[p + 1] - d;
    if (g <= 0)
      return null;
    var m = p % t.length;
    return /* @__PURE__ */ _.createElement("rect", {
      key: "react-".concat(p),
      y: d,
      x: r,
      height: g,
      width: o,
      stroke: "none",
      fill: t[m],
      fillOpacity: n,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, u);
}
function sU(e) {
  var {
    vertical: t = !0,
    verticalFill: n,
    fillOpacity: r,
    x: i,
    y: o,
    width: a,
    height: s,
    verticalPoints: l
  } = e;
  if (!t || !n || !n.length)
    return null;
  var c = l.map((d) => Math.round(d + i - i)).sort((d, p) => d - p);
  i !== c[0] && c.unshift(0);
  var u = c.map((d, p) => {
    var h = !c[p + 1], g = h ? i + a - d : c[p + 1] - d;
    if (g <= 0)
      return null;
    var m = p % n.length;
    return /* @__PURE__ */ _.createElement("rect", {
      key: "react-".concat(p),
      x: d,
      y: o,
      width: g,
      height: s,
      stroke: "none",
      fill: n[m],
      fillOpacity: r,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, u);
}
var lU = (e, t) => {
  var {
    xAxis: n,
    width: r,
    height: i,
    offset: o
  } = e;
  return JP(Cy(dn(dn(dn({}, Ty), n), {}, {
    ticks: QP(n),
    viewBox: {
      x: 0,
      y: 0,
      width: r,
      height: i
    }
  })), o.left, o.left + o.width, t);
}, cU = (e, t) => {
  var {
    yAxis: n,
    width: r,
    height: i,
    offset: o
  } = e;
  return JP(Cy(dn(dn(dn({}, Ty), n), {}, {
    ticks: QP(n),
    viewBox: {
      x: 0,
      y: 0,
      width: r,
      height: i
    }
  })), o.top, o.top + o.height, t);
}, uU = {
  horizontal: !0,
  vertical: !0,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: [],
  xAxisId: 0,
  yAxisId: 0
};
function wf(e) {
  var t = i2(), n = o2(), r = r2(), i = dn(dn({}, on(e, uU)), {}, {
    x: me(e.x) ? e.x : r.left,
    y: me(e.y) ? e.y : r.top,
    width: me(e.width) ? e.width : r.width,
    height: me(e.height) ? e.height : r.height
  }), {
    xAxisId: o,
    yAxisId: a,
    x: s,
    y: l,
    width: c,
    height: u,
    syncWithTicks: d,
    horizontalValues: p,
    verticalValues: h
  } = i, g = Nn(), m = pe((j) => fw(j, "xAxis", o, g)), v = pe((j) => fw(j, "yAxis", a, g));
  if (!me(c) || c <= 0 || !me(u) || u <= 0 || !me(s) || s !== +s || !me(l) || l !== +l)
    return null;
  var y = i.verticalCoordinatesGenerator || lU, S = i.horizontalCoordinatesGenerator || cU, {
    horizontalPoints: w,
    verticalPoints: b
  } = i;
  if ((!w || !w.length) && typeof S == "function") {
    var O = p && p.length, E = S({
      yAxis: v ? dn(dn({}, v), {}, {
        ticks: O ? p : v.ticks
      }) : void 0,
      width: t,
      height: n,
      offset: r
    }, O ? !0 : d);
    Ws(Array.isArray(E), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof E, "]")), Array.isArray(E) && (w = E);
  }
  if ((!b || !b.length) && typeof y == "function") {
    var C = h && h.length, T = y({
      xAxis: m ? dn(dn({}, m), {}, {
        ticks: C ? h : m.ticks
      }) : void 0,
      width: t,
      height: n,
      offset: r
    }, C ? !0 : d);
    Ws(Array.isArray(T), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof T, "]")), Array.isArray(T) && (b = T);
  }
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-grid"
  }, /* @__PURE__ */ _.createElement(rU, {
    fill: i.fill,
    fillOpacity: i.fillOpacity,
    x: i.x,
    y: i.y,
    width: i.width,
    height: i.height,
    ry: i.ry
  }), /* @__PURE__ */ _.createElement(aU, Po({}, i, {
    horizontalPoints: w
  })), /* @__PURE__ */ _.createElement(sU, Po({}, i, {
    verticalPoints: b
  })), /* @__PURE__ */ _.createElement(iU, Po({}, i, {
    offset: r,
    horizontalPoints: w,
    xAxis: m,
    yAxis: v
  })), /* @__PURE__ */ _.createElement(oU, Po({}, i, {
    offset: r,
    verticalPoints: b,
    xAxis: m,
    yAxis: v
  })));
}
wf.displayName = "CartesianGrid";
var iA = (e, t, n, r) => Vi(e, "xAxis", t, r), oA = (e, t, n, r) => Wi(e, "xAxis", t, r), aA = (e, t, n, r) => Vi(e, "yAxis", n, r), sA = (e, t, n, r) => Wi(e, "yAxis", n, r), dU = z([Pe, iA, aA, oA, sA], (e, t, n, r, i) => Xi(e, "xAxis") ? al(t, r, !1) : al(n, i, !1)), fU = (e, t, n, r, i) => i;
function pU(e) {
  return e.type === "line";
}
var hU = z([hf, fU], (e, t) => e.filter(pU).find((n) => n.id === t)), mU = z([Pe, iA, aA, oA, sA, hU, dU, cf], (e, t, n, r, i, o, a, s) => {
  var {
    chartData: l,
    dataStartIndex: c,
    dataEndIndex: u
  } = s;
  if (!(o == null || t == null || n == null || r == null || i == null || r.length === 0 || i.length === 0 || a == null)) {
    var {
      dataKey: d,
      data: p
    } = o, h;
    if (p != null && p.length > 0 ? h = p : h = l?.slice(c, u + 1), h != null)
      return $U({
        layout: e,
        xAxis: t,
        yAxis: n,
        xAxisTicks: r,
        yAxisTicks: i,
        dataKey: d,
        bandSize: a,
        displayedData: h
      });
  }
}), gU = ["id"], vU = ["type", "layout", "connectNulls", "needClip"], yU = ["activeDot", "animateNewValues", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "hide", "isAnimationActive", "label", "legendType", "xAxisId", "yAxisId", "id"];
function vO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vO(Object(n), !0).forEach(function(r) {
      bU(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bU(e, t, n) {
  return (t = xU(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function xU(e) {
  var t = wU(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function wU(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ky(e, t) {
  if (e == null) return {};
  var n, r, i = OU(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function OU(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function zo() {
  return zo = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, zo.apply(null, arguments);
}
var SU = (e) => {
  var {
    dataKey: t,
    name: n,
    stroke: r,
    legendType: i,
    hide: o
  } = e;
  return [{
    inactive: o,
    dataKey: t,
    type: i,
    color: r,
    value: Ua(n, t),
    payload: e
  }];
};
function EU(e) {
  var {
    dataKey: t,
    data: n,
    stroke: r,
    strokeWidth: i,
    fill: o,
    name: a,
    hide: s,
    unit: l
  } = e;
  return {
    dataDefinedOnItem: n,
    positions: void 0,
    settings: {
      stroke: r,
      strokeWidth: i,
      fill: o,
      dataKey: t,
      nameKey: void 0,
      name: Ua(a, t),
      hide: s,
      type: e.tooltipType,
      color: e.stroke,
      unit: l
    }
  };
}
var lA = (e, t) => "".concat(t, "px ").concat(e - t, "px");
function _U(e, t) {
  for (var n = e.length % 2 !== 0 ? [...e, 0] : e, r = [], i = 0; i < t; ++i)
    r = [...r, ...n];
  return r;
}
var PU = (e, t, n) => {
  var r = n.reduce((d, p) => d + p);
  if (!r)
    return lA(t, e);
  for (var i = Math.floor(e / r), o = e % r, a = t - e, s = [], l = 0, c = 0; l < n.length; c += n[l], ++l)
    if (c + n[l] > o) {
      s = [...n.slice(0, l), o - c];
      break;
    }
  var u = s.length % 2 === 0 ? [0, a] : [a];
  return [..._U(n, i), ...s, ...u].map((d) => "".concat(d, "px")).join(", ");
};
function CU(e, t) {
  var n;
  if (/* @__PURE__ */ _.isValidElement(e))
    n = /* @__PURE__ */ _.cloneElement(e, t);
  else if (typeof e == "function")
    n = e(t);
  else {
    var r = ie("recharts-line-dot", typeof e != "boolean" ? e.className : "");
    n = /* @__PURE__ */ _.createElement(IT, zo({}, t, {
      className: r
    }));
  }
  return n;
}
function TU(e, t) {
  return e == null ? !1 : t ? !0 : e.length === 1;
}
function AU(e) {
  var {
    clipPathId: t,
    points: n,
    props: r
  } = e, {
    dot: i,
    dataKey: o,
    needClip: a
  } = r;
  if (!TU(n, i))
    return null;
  var {
    id: s
  } = r, l = ky(r, gU), c = V_(i), u = Yr(l), d = wt(i, !0), p = n.map((g, m) => {
    var v = Fn(Fn(Fn({
      key: "dot-".concat(m),
      r: 3
    }, u), d), {}, {
      index: m,
      cx: g.x,
      cy: g.y,
      dataKey: o,
      value: g.value,
      payload: g.payload,
      points: n
    });
    return CU(i, v);
  }), h = {
    clipPath: a ? "url(#clipPath-".concat(c ? "" : "dots-").concat(t, ")") : void 0
  };
  return /* @__PURE__ */ _.createElement(nn, zo({
    className: "recharts-line-dots",
    key: "dots"
  }, h), p);
}
function kU(e) {
  var {
    showLabels: t,
    children: n,
    points: r
  } = e, i = Un(() => r?.map((o) => {
    var a = {
      x: o.x,
      y: o.y,
      width: 0,
      height: 0
    };
    return Fn(Fn({}, a), {}, {
      value: o.value,
      payload: o.payload,
      viewBox: a,
      /*
       * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?
       * Or should this just be the root chart viewBox?
       */
      parentViewBox: void 0,
      fill: void 0
    });
  }), [r]);
  return /* @__PURE__ */ _.createElement(DT, {
    value: t ? i : null
  }, n);
}
function yO(e) {
  var {
    clipPathId: t,
    pathRef: n,
    points: r,
    strokeDasharray: i,
    props: o
  } = e, {
    type: a,
    layout: s,
    connectNulls: l,
    needClip: c
  } = o, u = ky(o, vU), d = Fn(Fn({}, wt(u, !0)), {}, {
    fill: "none",
    className: "recharts-line-curve",
    clipPath: c ? "url(#clipPath-".concat(t, ")") : void 0,
    points: r,
    type: a,
    layout: s,
    connectNulls: l,
    strokeDasharray: i ?? o.strokeDasharray
  });
  return /* @__PURE__ */ _.createElement(_.Fragment, null, r?.length > 1 && /* @__PURE__ */ _.createElement(iv, zo({}, d, {
    pathRef: n
  })), /* @__PURE__ */ _.createElement(AU, {
    points: r,
    clipPathId: t,
    props: o
  }));
}
function MU(e) {
  try {
    return e && e.getTotalLength && e.getTotalLength() || 0;
  } catch {
    return 0;
  }
}
function jU(e) {
  var {
    clipPathId: t,
    props: n,
    pathRef: r,
    previousPointsRef: i,
    longestAnimatedLengthRef: o
  } = e, {
    points: a,
    strokeDasharray: s,
    isAnimationActive: l,
    animationBegin: c,
    animationDuration: u,
    animationEasing: d,
    animateNewValues: p,
    width: h,
    height: g,
    onAnimationEnd: m,
    onAnimationStart: v
  } = n, y = i.current, S = Vl(n, "recharts-line-"), [w, b] = Ke(!1), O = !w, E = xt(() => {
    typeof m == "function" && m(), b(!1);
  }, [m]), C = xt(() => {
    typeof v == "function" && v(), b(!0);
  }, [v]), T = MU(r.current), j = o.current;
  return /* @__PURE__ */ _.createElement(kU, {
    points: a,
    showLabels: O
  }, n.children, /* @__PURE__ */ _.createElement(Wl, {
    animationId: S,
    begin: c,
    duration: u,
    isActive: l,
    easing: d,
    onAnimationEnd: E,
    onAnimationStart: C,
    key: S
  }, (A) => {
    var M = _t(j, T + j, A), P = Math.min(M, T), R;
    if (l)
      if (s) {
        var N = "".concat(s).split(/[,\s]+/gim).map((F) => parseFloat(F));
        R = PU(P, T, N);
      } else
        R = lA(T, P);
    else
      R = s == null ? void 0 : String(s);
    if (y) {
      var D = y.length / a.length, $ = A === 1 ? a : a.map((F, q) => {
        var B = Math.floor(q * D);
        if (y[B]) {
          var L = y[B];
          return Fn(Fn({}, F), {}, {
            x: _t(L.x, F.x, A),
            y: _t(L.y, F.y, A)
          });
        }
        return p ? Fn(Fn({}, F), {}, {
          x: _t(h * 2, F.x, A),
          y: _t(g / 2, F.y, A)
        }) : Fn(Fn({}, F), {}, {
          x: F.x,
          y: F.y
        });
      });
      return i.current = $, /* @__PURE__ */ _.createElement(yO, {
        props: n,
        points: $,
        clipPathId: t,
        pathRef: r,
        strokeDasharray: R
      });
    }
    return A > 0 && T > 0 && (i.current = a, o.current = P), /* @__PURE__ */ _.createElement(yO, {
      props: n,
      points: a,
      clipPathId: t,
      pathRef: r,
      strokeDasharray: R
    });
  }), /* @__PURE__ */ _.createElement(fy, {
    label: n.label
  }));
}
function NU(e) {
  var {
    clipPathId: t,
    props: n
  } = e, r = Ne(null), i = Ne(0), o = Ne(null);
  return /* @__PURE__ */ _.createElement(jU, {
    props: n,
    clipPathId: t,
    previousPointsRef: r,
    longestAnimatedLengthRef: i,
    pathRef: o
  });
}
var DU = (e, t) => ({
  x: e.x,
  y: e.y,
  value: e.value,
  // @ts-expect-error getValueByDataKey does not validate the output type
  errorVal: ct(e.payload, t)
});
class RU extends NM {
  render() {
    var t, {
      hide: n,
      dot: r,
      points: i,
      className: o,
      xAxisId: a,
      yAxisId: s,
      top: l,
      left: c,
      width: u,
      height: d,
      id: p,
      needClip: h
    } = this.props;
    if (n)
      return null;
    var g = ie("recharts-line", o), m = p, {
      r: v = 3,
      strokeWidth: y = 2
    } = (t = wt(r, !1)) !== null && t !== void 0 ? t : {
      r: 3,
      strokeWidth: 2
    }, S = V_(r), w = v * 2 + y;
    return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(nn, {
      className: g
    }, h && /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement(GT, {
      clipPathId: m,
      xAxisId: a,
      yAxisId: s
    }), !S && /* @__PURE__ */ _.createElement("clipPath", {
      id: "clipPath-dots-".concat(m)
    }, /* @__PURE__ */ _.createElement("rect", {
      x: c - w / 2,
      y: l - w / 2,
      width: u + w,
      height: d + w
    }))), /* @__PURE__ */ _.createElement(YT, {
      xAxisId: a,
      yAxisId: s,
      data: i,
      dataPointFormatter: DU,
      errorBarOffset: 0
    }, /* @__PURE__ */ _.createElement(NU, {
      props: this.props,
      clipPathId: m
    }))), /* @__PURE__ */ _.createElement(n7, {
      activeDot: this.props.activeDot,
      points: i,
      mainColor: this.props.stroke,
      itemDataKey: this.props.dataKey
    }));
  }
}
var cA = {
  activeDot: !0,
  animateNewValues: !0,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  connectNulls: !1,
  dot: !0,
  fill: "#fff",
  hide: !1,
  isAnimationActive: !Zi.isSsr,
  label: !1,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  xAxisId: 0,
  yAxisId: 0
};
function IU(e) {
  var t = on(e, cA), {
    activeDot: n,
    animateNewValues: r,
    animationBegin: i,
    animationDuration: o,
    animationEasing: a,
    connectNulls: s,
    dot: l,
    hide: c,
    isAnimationActive: u,
    label: d,
    legendType: p,
    xAxisId: h,
    yAxisId: g,
    id: m
  } = t, v = ky(t, yU), {
    needClip: y
  } = _y(h, g), S = Sy(), w = tf(), b = Nn(), O = pe((A) => mU(A, h, g, b, m));
  if (w !== "horizontal" && w !== "vertical" || O == null || S == null)
    return null;
  var {
    height: E,
    width: C,
    x: T,
    y: j
  } = S;
  return /* @__PURE__ */ _.createElement(RU, zo({}, v, {
    id: m,
    connectNulls: s,
    dot: l,
    activeDot: n,
    animateNewValues: r,
    animationBegin: i,
    animationDuration: o,
    animationEasing: a,
    isAnimationActive: u,
    hide: c,
    label: d,
    legendType: p,
    xAxisId: h,
    yAxisId: g,
    points: O,
    layout: w,
    height: E,
    width: C,
    left: T,
    top: j,
    needClip: y
  }));
}
function $U(e) {
  var {
    layout: t,
    xAxis: n,
    yAxis: r,
    xAxisTicks: i,
    yAxisTicks: o,
    dataKey: a,
    bandSize: s,
    displayedData: l
  } = e;
  return l.map((c, u) => {
    var d = ct(c, a);
    if (t === "horizontal") {
      var p = Gx({
        axis: n,
        ticks: i,
        bandSize: s,
        entry: c,
        index: u
      }), h = yt(d) ? null : r.scale(d);
      return {
        x: p,
        y: h,
        value: d,
        payload: c
      };
    }
    var g = yt(d) ? null : n.scale(d), m = Gx({
      axis: r,
      ticks: o,
      bandSize: s,
      entry: c,
      index: u
    });
    return g == null || m == null ? null : {
      x: g,
      y: m,
      value: d,
      payload: c
    };
  }).filter(Boolean);
}
function LU(e) {
  var t = on(e, cA), n = Nn();
  return /* @__PURE__ */ _.createElement(wy, {
    id: t.id,
    type: "line"
  }, (r) => /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(VT, {
    legendPayload: SU(t)
  }), /* @__PURE__ */ _.createElement(xy, {
    fn: EU,
    args: t
  }), /* @__PURE__ */ _.createElement(HT, {
    type: "line",
    id: r,
    data: t.data,
    xAxisId: t.xAxisId,
    yAxisId: t.yAxisId,
    zAxisId: 0,
    dataKey: t.dataKey,
    hide: t.hide,
    isPanorama: n
  }), /* @__PURE__ */ _.createElement(IU, zo({}, t, {
    id: r
  }))));
}
var Sa = /* @__PURE__ */ _.memo(LU);
Sa.displayName = "Line";
var FU = ["dangerouslySetInnerHTML", "ticks"], BU = ["id"], zU = ["domain"], WU = ["domain"];
function Gm() {
  return Gm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Gm.apply(null, arguments);
}
function id(e, t) {
  if (e == null) return {};
  var n, r, i = VU(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function VU(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function UU(e) {
  var t = Nt();
  return De(() => (t(VV(e)), () => {
    t(UV(e));
  }), [e, t]), null;
}
var HU = (e) => {
  var {
    xAxisId: t,
    className: n
  } = e, r = pe(nv), i = Nn(), o = "xAxis", a = pe((v) => Za(v, o, t, i)), s = pe((v) => XC(v, o, t, i)), l = pe((v) => qC(v, t)), c = pe((v) => S3(v, t)), u = pe((v) => SC(v, t));
  if (l == null || c == null || u == null)
    return null;
  var {
    dangerouslySetInnerHTML: d,
    ticks: p
  } = e, h = id(e, FU), {
    id: g
  } = u, m = id(u, BU);
  return /* @__PURE__ */ _.createElement(Ay, Gm({}, h, m, {
    scale: a,
    x: c.x,
    y: c.y,
    width: l.width,
    height: l.height,
    className: ie("recharts-".concat(o, " ").concat(o), n),
    viewBox: r,
    ticks: s
  }));
}, qU = {
  allowDataOverflow: Rn.allowDataOverflow,
  allowDecimals: Rn.allowDecimals,
  allowDuplicatedCategory: Rn.allowDuplicatedCategory,
  height: Rn.height,
  hide: !1,
  mirror: Rn.mirror,
  orientation: Rn.orientation,
  padding: Rn.padding,
  reversed: Rn.reversed,
  scale: Rn.scale,
  tickCount: Rn.tickCount,
  type: Rn.type,
  xAxisId: 0
}, KU = (e) => {
  var t, n, r, i, o, a = on(e, qU);
  return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(UU, {
    interval: (t = a.interval) !== null && t !== void 0 ? t : "preserveEnd",
    id: a.xAxisId,
    scale: a.scale,
    type: a.type,
    padding: a.padding,
    allowDataOverflow: a.allowDataOverflow,
    domain: a.domain,
    dataKey: a.dataKey,
    allowDuplicatedCategory: a.allowDuplicatedCategory,
    allowDecimals: a.allowDecimals,
    tickCount: a.tickCount,
    includeHidden: (n = a.includeHidden) !== null && n !== void 0 ? n : !1,
    reversed: a.reversed,
    ticks: a.ticks,
    height: a.height,
    orientation: a.orientation,
    mirror: a.mirror,
    hide: a.hide,
    unit: a.unit,
    name: a.name,
    angle: (r = a.angle) !== null && r !== void 0 ? r : 0,
    minTickGap: (i = a.minTickGap) !== null && i !== void 0 ? i : 5,
    tick: (o = a.tick) !== null && o !== void 0 ? o : !0,
    tickFormatter: a.tickFormatter
  }), /* @__PURE__ */ _.createElement(HU, a));
}, YU = (e, t) => {
  var {
    domain: n
  } = e, r = id(e, zU), {
    domain: i
  } = t, o = id(t, WU);
  return Ra(r, o) ? Array.isArray(n) && n.length === 2 && Array.isArray(i) && i.length === 2 ? n[0] === i[0] && n[1] === i[1] : Ra({
    domain: n
  }, {
    domain: i
  }) : !1;
}, Of = /* @__PURE__ */ _.memo(KU, YU);
Of.displayName = "XAxis";
var GU = ["dangerouslySetInnerHTML", "ticks"], XU = ["id"], ZU = ["domain"], JU = ["domain"];
function Xm() {
  return Xm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Xm.apply(null, arguments);
}
function od(e, t) {
  if (e == null) return {};
  var n, r, i = QU(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function QU(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function eH(e) {
  var t = Nt();
  return De(() => (t(HV(e)), () => {
    t(qV(e));
  }), [e, t]), null;
}
var tH = (e) => {
  var {
    yAxisId: t,
    className: n,
    width: r,
    label: i
  } = e, o = Ne(null), a = Ne(null), s = pe(nv), l = Nn(), c = Nt(), u = "yAxis", d = pe((O) => Za(O, u, t, l)), p = pe((O) => KC(O, t)), h = pe((O) => _3(O, t)), g = pe((O) => XC(O, u, t, l)), m = pe((O) => EC(O, t));
  if (WE(() => {
    if (!(r !== "auto" || !p || dy(i) || /* @__PURE__ */ bn(i) || m == null)) {
      var O = o.current;
      if (O) {
        var E = O.getCalculatedWidth();
        Math.round(p.width) !== Math.round(E) && c(KV({
          id: t,
          width: E
        }));
      }
    }
  }, [
    // The dependency on cartesianAxisRef.current is not needed because useLayoutEffect will run after every render.
    // The ref will be populated by then.
    // To re-run this effect when ticks change, we can depend on the ticks array from the store.
    g,
    p,
    c,
    i,
    t,
    r,
    m
  ]), p == null || h == null || m == null)
    return null;
  var {
    dangerouslySetInnerHTML: v,
    ticks: y
  } = e, S = od(e, GU), {
    id: w
  } = m, b = od(m, XU);
  return /* @__PURE__ */ _.createElement(Ay, Xm({}, S, b, {
    ref: o,
    labelRef: a,
    scale: d,
    x: h.x,
    y: h.y,
    tickTextProps: r === "auto" ? {
      width: void 0
    } : {
      width: r
    },
    width: p.width,
    height: p.height,
    className: ie("recharts-".concat(u, " ").concat(u), n),
    viewBox: s,
    ticks: g
  }));
}, nH = {
  allowDataOverflow: In.allowDataOverflow,
  allowDecimals: In.allowDecimals,
  allowDuplicatedCategory: In.allowDuplicatedCategory,
  hide: !1,
  mirror: In.mirror,
  orientation: In.orientation,
  padding: In.padding,
  reversed: In.reversed,
  scale: In.scale,
  tickCount: In.tickCount,
  type: In.type,
  width: In.width,
  yAxisId: 0
}, rH = (e) => {
  var t, n, r, i, o, a = on(e, nH);
  return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(eH, {
    interval: (t = a.interval) !== null && t !== void 0 ? t : "preserveEnd",
    id: a.yAxisId,
    scale: a.scale,
    type: a.type,
    domain: a.domain,
    allowDataOverflow: a.allowDataOverflow,
    dataKey: a.dataKey,
    allowDuplicatedCategory: a.allowDuplicatedCategory,
    allowDecimals: a.allowDecimals,
    tickCount: a.tickCount,
    padding: a.padding,
    includeHidden: (n = a.includeHidden) !== null && n !== void 0 ? n : !1,
    reversed: a.reversed,
    ticks: a.ticks,
    width: a.width,
    orientation: a.orientation,
    mirror: a.mirror,
    hide: a.hide,
    unit: a.unit,
    name: a.name,
    angle: (r = a.angle) !== null && r !== void 0 ? r : 0,
    minTickGap: (i = a.minTickGap) !== null && i !== void 0 ? i : 5,
    tick: (o = a.tick) !== null && o !== void 0 ? o : !0,
    tickFormatter: a.tickFormatter
  }), /* @__PURE__ */ _.createElement(tH, a));
}, iH = (e, t) => {
  var {
    domain: n
  } = e, r = od(e, ZU), {
    domain: i
  } = t, o = od(t, JU);
  return Ra(r, o) ? Array.isArray(n) && n.length === 2 && Array.isArray(i) && i.length === 2 ? n[0] === i[0] && n[1] === i[1] : Ra({
    domain: n
  }, {
    domain: i
  }) : !1;
}, hl = /* @__PURE__ */ _.memo(rH, iH);
hl.displayName = "YAxis";
var Ic = { exports: {} }, Ah = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bO;
function oH() {
  if (bO) return Ah;
  bO = 1;
  var e = Ye;
  function t(l, c) {
    return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useSyncExternalStore, i = e.useRef, o = e.useEffect, a = e.useMemo, s = e.useDebugValue;
  return Ah.useSyncExternalStoreWithSelector = function(l, c, u, d, p) {
    var h = i(null);
    if (h.current === null) {
      var g = { hasValue: !1, value: null };
      h.current = g;
    } else g = h.current;
    h = a(
      function() {
        function v(O) {
          if (!y) {
            if (y = !0, S = O, O = d(O), p !== void 0 && g.hasValue) {
              var E = g.value;
              if (p(E, O))
                return w = E;
            }
            return w = O;
          }
          if (E = w, n(S, O)) return E;
          var C = d(O);
          return p !== void 0 && p(E, C) ? (S = O, E) : (S = O, w = C);
        }
        var y = !1, S, w, b = u === void 0 ? null : u;
        return [
          function() {
            return v(c());
          },
          b === null ? void 0 : function() {
            return v(b());
          }
        ];
      },
      [c, u, d, p]
    );
    var m = r(l, h[0], h[1]);
    return o(
      function() {
        g.hasValue = !0, g.value = m;
      },
      [m]
    ), s(m), m;
  }, Ah;
}
var kh = {};
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xO;
function aH() {
  return xO || (xO = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(l, c) {
      return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = Ye, n = typeof Object.is == "function" ? Object.is : e, r = t.useSyncExternalStore, i = t.useRef, o = t.useEffect, a = t.useMemo, s = t.useDebugValue;
    kh.useSyncExternalStoreWithSelector = function(l, c, u, d, p) {
      var h = i(null);
      if (h.current === null) {
        var g = { hasValue: !1, value: null };
        h.current = g;
      } else g = h.current;
      h = a(
        function() {
          function v(O) {
            if (!y) {
              if (y = !0, S = O, O = d(O), p !== void 0 && g.hasValue) {
                var E = g.value;
                if (p(E, O))
                  return w = E;
              }
              return w = O;
            }
            if (E = w, n(S, O))
              return E;
            var C = d(O);
            return p !== void 0 && p(E, C) ? (S = O, E) : (S = O, w = C);
          }
          var y = !1, S, w, b = u === void 0 ? null : u;
          return [
            function() {
              return v(c());
            },
            b === null ? void 0 : function() {
              return v(b());
            }
          ];
        },
        [c, u, d, p]
      );
      var m = r(l, h[0], h[1]);
      return o(
        function() {
          g.hasValue = !0, g.value = m;
        },
        [m]
      ), s(m), m;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), kh;
}
var wO;
function sH() {
  return wO || (wO = 1, process.env.NODE_ENV === "production" ? Ic.exports = oH() : Ic.exports = aH()), Ic.exports;
}
sH();
function lH(e) {
  e();
}
function cH() {
  let e = null, t = null;
  return {
    clear() {
      e = null, t = null;
    },
    notify() {
      lH(() => {
        let n = e;
        for (; n; )
          n.callback(), n = n.next;
      });
    },
    get() {
      const n = [];
      let r = e;
      for (; r; )
        n.push(r), r = r.next;
      return n;
    },
    subscribe(n) {
      let r = !0;
      const i = t = {
        callback: n,
        next: null,
        prev: t
      };
      return i.prev ? i.prev.next = i : e = i, function() {
        !r || e === null || (r = !1, i.next ? i.next.prev = i.prev : t = i.prev, i.prev ? i.prev.next = i.next : e = i.next);
      };
    }
  };
}
var OO = {
  notify() {
  },
  get: () => []
};
function uH(e, t) {
  let n, r = OO, i = 0, o = !1;
  function a(m) {
    u();
    const v = r.subscribe(m);
    let y = !1;
    return () => {
      y || (y = !0, v(), d());
    };
  }
  function s() {
    r.notify();
  }
  function l() {
    g.onStateChange && g.onStateChange();
  }
  function c() {
    return o;
  }
  function u() {
    i++, n || (n = e.subscribe(l), r = cH());
  }
  function d() {
    i--, n && i === 0 && (n(), n = void 0, r.clear(), r = OO);
  }
  function p() {
    o || (o = !0, u());
  }
  function h() {
    o && (o = !1, d());
  }
  const g = {
    addNestedSub: a,
    notifyNestedSubs: s,
    handleChangeWrapper: l,
    isSubscribed: c,
    trySubscribe: p,
    tryUnsubscribe: h,
    getListeners: () => r
  };
  return g;
}
var dH = () => typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", fH = /* @__PURE__ */ dH(), pH = () => typeof navigator < "u" && navigator.product === "ReactNative", hH = /* @__PURE__ */ pH(), mH = () => fH || hH ? _.useLayoutEffect : _.useEffect, gH = /* @__PURE__ */ mH(), vH = /* @__PURE__ */ Symbol.for("react-redux-context"), yH = typeof globalThis < "u" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function bH() {
  if (!_.createContext) return {};
  const e = yH[vH] ??= /* @__PURE__ */ new Map();
  let t = e.get(_.createContext);
  return t || (t = _.createContext(
    null
  ), process.env.NODE_ENV !== "production" && (t.displayName = "ReactRedux"), e.set(_.createContext, t)), t;
}
var xH = /* @__PURE__ */ bH();
function wH(e) {
  const { children: t, context: n, serverState: r, store: i } = e, o = _.useMemo(() => {
    const l = uH(i), c = {
      store: i,
      subscription: l,
      getServerState: r ? () => r : void 0
    };
    if (process.env.NODE_ENV === "production")
      return c;
    {
      const { identityFunctionCheck: u = "once", stabilityCheck: d = "once" } = e;
      return /* @__PURE__ */ Object.assign(c, {
        stabilityCheck: d,
        identityFunctionCheck: u
      });
    }
  }, [i, r]), a = _.useMemo(() => i.getState(), [i]);
  gH(() => {
    const { subscription: l } = o;
    return l.onStateChange = l.notifyNestedSubs, l.trySubscribe(), a !== i.getState() && l.notifyNestedSubs(), () => {
      l.tryUnsubscribe(), l.onStateChange = void 0;
    };
  }, [o, a]);
  const s = n || xH;
  return /* @__PURE__ */ _.createElement(s.Provider, { value: o }, t);
}
var OH = wH, SH = (e, t) => t, My = z([SH, Pe, xC, Vt, dT, Pi, k8, zt], R8), jy = (e) => {
  var t = e.currentTarget.getBoundingClientRect(), n = t.width / e.currentTarget.offsetWidth, r = t.height / e.currentTarget.offsetHeight;
  return {
    /*
     * Here it's important to use:
     * - event.clientX and event.clientY to get the mouse position relative to the viewport, including scroll.
     * - pageX and pageY are not used because they are relative to the whole document, and ignore scroll.
     * - rect.left and rect.top are used to get the position of the chart relative to the viewport.
     * - offsetX and offsetY are not used because they are relative to the offset parent
     *  which may or may not be the same as the clientX and clientY, depending on the position of the chart in the DOM
     *  and surrounding element styles. CSS position: relative, absolute, fixed, will change the offset parent.
     * - scaleX and scaleY are necessary for when the chart element is scaled using CSS `transform: scale(N)`.
     */
    chartX: Math.round((e.clientX - t.left) / n),
    chartY: Math.round((e.clientY - t.top) / r)
  };
}, uA = dr("mouseClick"), dA = Bl();
dA.startListening({
  actionCreator: uA,
  effect: (e, t) => {
    var n = e.payload, r = My(t.getState(), jy(n));
    r?.activeIndex != null && t.dispatch(L3({
      activeIndex: r.activeIndex,
      activeDataKey: void 0,
      activeCoordinate: r.activeCoordinate
    }));
  }
});
var Zm = dr("mouseMove"), fA = Bl();
fA.startListening({
  actionCreator: Zm,
  effect: (e, t) => {
    var n = e.payload, r = t.getState(), i = ty(r, r.tooltip.settings.shared), o = My(r, jy(n));
    i === "axis" && (o?.activeIndex != null ? t.dispatch(iT({
      activeIndex: o.activeIndex,
      activeDataKey: void 0,
      activeCoordinate: o.activeCoordinate
    })) : t.dispatch(rT()));
  }
});
var SO = {
  accessibilityLayer: !0,
  barCategoryGap: "10%",
  barGap: 4,
  barSize: void 0,
  className: void 0,
  maxBarSize: void 0,
  stackOffset: "none",
  syncId: void 0,
  syncMethod: "index"
}, pA = Zn({
  name: "rootProps",
  initialState: SO,
  reducers: {
    updateOptions: (e, t) => {
      var n;
      e.accessibilityLayer = t.payload.accessibilityLayer, e.barCategoryGap = t.payload.barCategoryGap, e.barGap = (n = t.payload.barGap) !== null && n !== void 0 ? n : SO.barGap, e.barSize = t.payload.barSize, e.maxBarSize = t.payload.maxBarSize, e.stackOffset = t.payload.stackOffset, e.syncId = t.payload.syncId, e.syncMethod = t.payload.syncMethod, e.className = t.payload.className;
    }
  }
}), EH = pA.reducer, {
  updateOptions: _H
} = pA.actions, hA = Zn({
  name: "polarOptions",
  initialState: null,
  reducers: {
    updatePolarOptions: (e, t) => t.payload
  }
}), {
  updatePolarOptions: PH
} = hA.actions, CH = hA.reducer, mA = dr("keyDown"), gA = dr("focus"), Ny = Bl();
Ny.startListening({
  actionCreator: mA,
  effect: (e, t) => {
    var n = t.getState(), r = n.rootProps.accessibilityLayer !== !1;
    if (r) {
      var {
        keyboardInteraction: i
      } = n.tooltip, o = e.payload;
      if (!(o !== "ArrowRight" && o !== "ArrowLeft" && o !== "Enter")) {
        var a = Number(ny(i, Qa(n))), s = Pi(n);
        if (o === "Enter") {
          var l = Zu(n, "axis", "hover", String(i.index));
          t.dispatch(Wm({
            active: !i.active,
            activeIndex: i.index,
            activeDataKey: i.dataKey,
            activeCoordinate: l
          }));
          return;
        }
        var c = A3(n), u = c === "left-to-right" ? 1 : -1, d = o === "ArrowRight" ? 1 : -1, p = a + d * u;
        if (!(s == null || p >= s.length || p < 0)) {
          var h = Zu(n, "axis", "hover", String(p));
          t.dispatch(Wm({
            active: !0,
            activeIndex: p.toString(),
            activeDataKey: void 0,
            activeCoordinate: h
          }));
        }
      }
    }
  }
});
Ny.startListening({
  actionCreator: gA,
  effect: (e, t) => {
    var n = t.getState(), r = n.rootProps.accessibilityLayer !== !1;
    if (r) {
      var {
        keyboardInteraction: i
      } = n.tooltip;
      if (!i.active && i.index == null) {
        var o = "0", a = Zu(n, "axis", "hover", String(o));
        t.dispatch(Wm({
          activeDataKey: void 0,
          active: !0,
          activeIndex: o,
          activeCoordinate: a
        }));
      }
    }
  }
});
var ir = dr("externalEvent"), vA = Bl();
vA.startListening({
  actionCreator: ir,
  effect: (e, t) => {
    if (e.payload.handler != null) {
      var n = t.getState(), r = {
        activeCoordinate: x8(n),
        activeDataKey: mT(n),
        activeIndex: Ui(n),
        activeLabel: hT(n),
        activeTooltipIndex: Ui(n),
        isTooltipActive: w8(n)
      };
      e.payload.handler(r, e.payload.reactEvent);
    }
  }
});
var TH = z([Ja], (e) => e.tooltipItemPayloads), AH = z([TH, Ql, (e, t, n) => t, (e, t, n) => n], (e, t, n, r) => {
  var i = e.find((s) => s.settings.dataKey === r);
  if (i != null) {
    var {
      positions: o
    } = i;
    if (o != null) {
      var a = t(o, n);
      return a;
    }
  }
}), yA = dr("touchMove"), bA = Bl();
bA.startListening({
  actionCreator: yA,
  effect: (e, t) => {
    var n = e.payload, r = t.getState(), i = ty(r, r.tooltip.settings.shared);
    if (i === "axis") {
      var o = My(r, jy({
        clientX: n.touches[0].clientX,
        clientY: n.touches[0].clientY,
        currentTarget: n.currentTarget
      }));
      o?.activeIndex != null && t.dispatch(iT({
        activeIndex: o.activeIndex,
        activeDataKey: void 0,
        activeCoordinate: o.activeCoordinate
      }));
    } else if (i === "item") {
      var a, s = n.touches[0], l = document.elementFromPoint(s.clientX, s.clientY);
      if (!l || !l.getAttribute)
        return;
      var c = l.getAttribute(t2), u = (a = l.getAttribute(n2)) !== null && a !== void 0 ? a : void 0, d = AH(t.getState(), c, u);
      t.dispatch(nT({
        activeDataKey: u,
        activeIndex: c,
        activeCoordinate: d
      }));
    }
  }
});
var kH = SP({
  brush: h9,
  cartesianAxis: YV,
  chartData: Z8,
  errorBars: p7,
  graphicalItems: pV,
  layout: V5,
  legend: ML,
  options: q8,
  polarAxis: kW,
  polarOptions: CH,
  referenceElements: w9,
  rootProps: EH,
  tooltip: F3
}), MH = function(t) {
  return h5({
    reducer: kH,
    // redux-toolkit v1 types are unhappy with the preloadedState type. Remove the `as any` when bumping to v2
    preloadedState: t,
    // @ts-expect-error redux-toolkit v1 types are unhappy with the middleware array. Remove this comment when bumping to v2
    middleware: (n) => n({
      serializableCheck: !1
    }).concat([dA.middleware, fA.middleware, Ny.middleware, vA.middleware, bA.middleware]),
    devTools: Zi.devToolsEnabled
  });
};
function xA(e) {
  var {
    preloadedState: t,
    children: n,
    reduxStoreName: r
  } = e, i = Nn(), o = Ne(null);
  if (i)
    return n;
  o.current == null && (o.current = MH(t));
  var a = Xg;
  return /* @__PURE__ */ _.createElement(OH, {
    context: a,
    store: o.current
  }, n);
}
function wA(e) {
  var {
    layout: t,
    width: n,
    height: r,
    margin: i
  } = e, o = Nt(), a = Nn();
  return De(() => {
    a || (o(B5(t)), o(z5({
      width: n,
      height: r
    })), o(F5(i)));
  }, [o, a, t, n, r, i]), null;
}
function OA(e) {
  var t = Nt();
  return De(() => {
    t(_H(e));
  }, [t, e]), null;
}
var jH = ["children"];
function NH(e, t) {
  if (e == null) return {};
  var n, r, i = DH(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function DH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function ad() {
  return ad = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ad.apply(null, arguments);
}
var RH = {
  width: "100%",
  height: "100%"
}, IH = /* @__PURE__ */ rn((e, t) => {
  var n = i2(), r = o2(), i = c2();
  if (!ka(n) || !ka(r))
    return null;
  var {
    children: o,
    otherAttributes: a,
    title: s,
    desc: l
  } = e, c, u;
  return typeof a.tabIndex == "number" ? c = a.tabIndex : c = i ? 0 : void 0, typeof a.role == "string" ? u = a.role : u = i ? "application" : void 0, /* @__PURE__ */ _.createElement(U_, ad({}, a, {
    title: s,
    desc: l,
    role: u,
    tabIndex: c,
    width: n,
    height: r,
    style: RH,
    ref: t
  }), o);
}), $H = (e) => {
  var {
    children: t
  } = e, n = pe(ef);
  if (!n)
    return null;
  var {
    width: r,
    height: i,
    y: o,
    x: a
  } = n;
  return /* @__PURE__ */ _.createElement(U_, {
    width: r,
    height: i,
    x: a,
    y: o
  }, t);
}, EO = /* @__PURE__ */ rn((e, t) => {
  var {
    children: n
  } = e, r = NH(e, jH), i = Nn();
  return i ? /* @__PURE__ */ _.createElement($H, null, n) : /* @__PURE__ */ _.createElement(IH, ad({
    ref: t
  }, r), n);
});
function LH() {
  var e = Nt(), [t, n] = Ke(null), r = pe(yL);
  return De(() => {
    if (t != null) {
      var i = t.getBoundingClientRect(), o = i.width / t.offsetWidth;
      Yn(o) && o !== r && e(W5(o));
    }
  }, [t, e, r]), n;
}
function _O(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _O(Object(n), !0).forEach(function(r) {
      BH(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _O(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function BH(e, t, n) {
  return (t = zH(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function zH(e) {
  var t = WH(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function WH(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var VH = /* @__PURE__ */ rn((e, t) => {
  var {
    children: n,
    className: r,
    height: i,
    onClick: o,
    onContextMenu: a,
    onDoubleClick: s,
    onMouseDown: l,
    onMouseEnter: c,
    onMouseLeave: u,
    onMouseMove: d,
    onMouseUp: p,
    onTouchEnd: h,
    onTouchMove: g,
    onTouchStart: m,
    style: v,
    width: y
  } = e, S = Nt(), [w, b] = Ke(null), [O, E] = Ke(null);
  az();
  var C = LH(), T = xt((K) => {
    C(K), typeof t == "function" && t(K), b(K), E(K);
  }, [C, t, b, E]), j = xt((K) => {
    S(uA(K)), S(ir({
      handler: o,
      reactEvent: K
    }));
  }, [S, o]), A = xt((K) => {
    S(Zm(K)), S(ir({
      handler: c,
      reactEvent: K
    }));
  }, [S, c]), M = xt((K) => {
    S(rT()), S(ir({
      handler: u,
      reactEvent: K
    }));
  }, [S, u]), P = xt((K) => {
    S(Zm(K)), S(ir({
      handler: d,
      reactEvent: K
    }));
  }, [S, d]), R = xt(() => {
    S(gA());
  }, [S]), N = xt((K) => {
    S(mA(K.key));
  }, [S]), D = xt((K) => {
    S(ir({
      handler: a,
      reactEvent: K
    }));
  }, [S, a]), $ = xt((K) => {
    S(ir({
      handler: s,
      reactEvent: K
    }));
  }, [S, s]), F = xt((K) => {
    S(ir({
      handler: l,
      reactEvent: K
    }));
  }, [S, l]), q = xt((K) => {
    S(ir({
      handler: p,
      reactEvent: K
    }));
  }, [S, p]), B = xt((K) => {
    S(ir({
      handler: m,
      reactEvent: K
    }));
  }, [S, m]), L = xt((K) => {
    S(yA(K)), S(ir({
      handler: g,
      reactEvent: K
    }));
  }, [S, g]), Y = xt((K) => {
    S(ir({
      handler: h,
      reactEvent: K
    }));
  }, [S, h]);
  return /* @__PURE__ */ _.createElement(wT.Provider, {
    value: w
  }, /* @__PURE__ */ _.createElement(qR.Provider, {
    value: O
  }, /* @__PURE__ */ _.createElement("div", {
    className: ie("recharts-wrapper", r),
    style: FH({
      position: "relative",
      cursor: "default",
      width: y,
      height: i
    }, v),
    onClick: j,
    onContextMenu: D,
    onDoubleClick: $,
    onFocus: R,
    onKeyDown: N,
    onMouseDown: F,
    onMouseEnter: A,
    onMouseLeave: M,
    onMouseMove: P,
    onMouseUp: q,
    onTouchEnd: Y,
    onTouchMove: L,
    onTouchStart: B,
    ref: T
  }, n)));
}), UH = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function HH(e, t) {
  if (e == null) return {};
  var n, r, i = qH(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function qH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var SA = /* @__PURE__ */ rn((e, t) => {
  var {
    children: n,
    className: r,
    width: i,
    height: o,
    style: a,
    compact: s,
    title: l,
    desc: c
  } = e, u = HH(e, UH), d = Yr(u);
  return s ? /* @__PURE__ */ _.createElement(EO, {
    otherAttributes: d,
    title: l,
    desc: c
  }, n) : /* @__PURE__ */ _.createElement(VH, {
    className: r,
    style: a,
    width: i,
    height: o,
    onClick: e.onClick,
    onMouseLeave: e.onMouseLeave,
    onMouseEnter: e.onMouseEnter,
    onMouseMove: e.onMouseMove,
    onMouseDown: e.onMouseDown,
    onMouseUp: e.onMouseUp,
    onContextMenu: e.onContextMenu,
    onDoubleClick: e.onDoubleClick,
    onTouchStart: e.onTouchStart,
    onTouchMove: e.onTouchMove,
    onTouchEnd: e.onTouchEnd
  }, /* @__PURE__ */ _.createElement(EO, {
    otherAttributes: d,
    title: l,
    desc: c,
    ref: t
  }, /* @__PURE__ */ _.createElement(S9, null, n)));
}), KH = ["width", "height"];
function Jm() {
  return Jm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Jm.apply(null, arguments);
}
function YH(e, t) {
  if (e == null) return {};
  var n, r, i = GH(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function GH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var XH = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
}, ZH = {
  accessibilityLayer: !0,
  layout: "horizontal",
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: XH,
  reverseStackOrder: !1,
  syncMethod: "index"
}, EA = /* @__PURE__ */ rn(function(t, n) {
  var r, i = on(t.categoricalChartProps, ZH), {
    width: o,
    height: a
  } = i, s = YH(i, KH);
  if (!ka(o) || !ka(a))
    return null;
  var {
    chartName: l,
    defaultTooltipEventType: c,
    validateTooltipEventTypes: u,
    tooltipPayloadSearcher: d,
    categoricalChartProps: p
  } = t, h = {
    chartName: l,
    defaultTooltipEventType: c,
    validateTooltipEventTypes: u,
    tooltipPayloadSearcher: d,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ _.createElement(xA, {
    preloadedState: {
      options: h
    },
    reduxStoreName: (r = p.id) !== null && r !== void 0 ? r : l
  }, /* @__PURE__ */ _.createElement(QT, {
    chartData: p.data
  }), /* @__PURE__ */ _.createElement(wA, {
    width: o,
    height: a,
    layout: i.layout,
    margin: i.margin
  }), /* @__PURE__ */ _.createElement(OA, {
    accessibilityLayer: i.accessibilityLayer,
    barCategoryGap: i.barCategoryGap,
    maxBarSize: i.maxBarSize,
    stackOffset: i.stackOffset,
    barGap: i.barGap,
    barSize: i.barSize,
    syncId: i.syncId,
    syncMethod: i.syncMethod,
    className: i.className
  }), /* @__PURE__ */ _.createElement(SA, Jm({}, s, {
    width: o,
    height: a,
    ref: n
  })));
}), JH = ["axis"], _A = /* @__PURE__ */ rn((e, t) => /* @__PURE__ */ _.createElement(EA, {
  chartName: "LineChart",
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: JH,
  tooltipPayloadSearcher: uy,
  categoricalChartProps: e,
  ref: t
})), QH = ["axis", "item"], eq = /* @__PURE__ */ rn((e, t) => /* @__PURE__ */ _.createElement(EA, {
  chartName: "BarChart",
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: QH,
  tooltipPayloadSearcher: uy,
  categoricalChartProps: e,
  ref: t
}));
function tq(e) {
  var t = Nt();
  return De(() => {
    t(PH(e));
  }, [t, e]), null;
}
var nq = ["width", "height", "layout"];
function Qm() {
  return Qm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Qm.apply(null, arguments);
}
function rq(e, t) {
  if (e == null) return {};
  var n, r, i = iq(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function iq(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var oq = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
}, aq = {
  accessibilityLayer: !0,
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: oq,
  reverseStackOrder: !1,
  syncMethod: "index",
  layout: "radial"
}, sq = /* @__PURE__ */ rn(function(t, n) {
  var r, i = on(t.categoricalChartProps, aq), {
    width: o,
    height: a,
    layout: s
  } = i, l = rq(i, nq);
  if (!ka(o) || !ka(a))
    return null;
  var {
    chartName: c,
    defaultTooltipEventType: u,
    validateTooltipEventTypes: d,
    tooltipPayloadSearcher: p
  } = t, h = {
    chartName: c,
    defaultTooltipEventType: u,
    validateTooltipEventTypes: d,
    tooltipPayloadSearcher: p,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ _.createElement(xA, {
    preloadedState: {
      options: h
    },
    reduxStoreName: (r = i.id) !== null && r !== void 0 ? r : c
  }, /* @__PURE__ */ _.createElement(QT, {
    chartData: i.data
  }), /* @__PURE__ */ _.createElement(wA, {
    width: o,
    height: a,
    layout: s,
    margin: i.margin
  }), /* @__PURE__ */ _.createElement(OA, {
    accessibilityLayer: i.accessibilityLayer,
    barCategoryGap: i.barCategoryGap,
    maxBarSize: i.maxBarSize,
    stackOffset: i.stackOffset,
    barGap: i.barGap,
    barSize: i.barSize,
    syncId: i.syncId,
    syncMethod: i.syncMethod,
    className: i.className
  }), /* @__PURE__ */ _.createElement(tq, {
    cx: i.cx,
    cy: i.cy,
    startAngle: i.startAngle,
    endAngle: i.endAngle,
    innerRadius: i.innerRadius,
    outerRadius: i.outerRadius
  }), /* @__PURE__ */ _.createElement(SA, Qm({
    width: o,
    height: a
  }, l, {
    ref: n
  })));
}), lq = ["item"], cq = {
  layout: "centric",
  startAngle: 0,
  endAngle: 360,
  cx: "50%",
  cy: "50%",
  innerRadius: 0,
  outerRadius: "80%"
}, Sf = /* @__PURE__ */ rn((e, t) => {
  var n = on(e, cq);
  return /* @__PURE__ */ _.createElement(sq, {
    chartName: "PieChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: lq,
    tooltipPayloadSearcher: uy,
    categoricalChartProps: n,
    ref: t
  });
});
function es(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : function(...r) {
    return e(...r) || t(...r);
  };
}
function PA(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function eg(e, t) {
  return eg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, eg(e, t);
}
function CA(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, eg(e, t);
}
const PO = {
  disabled: !1
};
var uq = process.env.NODE_ENV !== "production" ? f.oneOfType([f.number, f.shape({
  enter: f.number,
  exit: f.number,
  appear: f.number
}).isRequired]) : null;
process.env.NODE_ENV !== "production" && f.oneOfType([f.string, f.shape({
  enter: f.string,
  exit: f.string,
  active: f.string
}), f.shape({
  enter: f.string,
  enterDone: f.string,
  enterActive: f.string,
  exit: f.string,
  exitDone: f.string,
  exitActive: f.string
})]);
const sd = Ye.createContext(null);
var dq = function(t) {
  return t.scrollTop;
}, Ds = "unmounted", vo = "exited", yo = "entering", ha = "entered", tg = "exiting", Gr = /* @__PURE__ */ (function(e) {
  CA(t, e);
  function t(r, i) {
    var o;
    o = e.call(this, r, i) || this;
    var a = i, s = a && !a.isMounting ? r.enter : r.appear, l;
    return o.appearStatus = null, r.in ? s ? (l = vo, o.appearStatus = yo) : l = ha : r.unmountOnExit || r.mountOnEnter ? l = Ds : l = vo, o.state = {
      status: l
    }, o.nextCallback = null, o;
  }
  t.getDerivedStateFromProps = function(i, o) {
    var a = i.in;
    return a && o.status === Ds ? {
      status: vo
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(i) {
    var o = null;
    if (i !== this.props) {
      var a = this.state.status;
      this.props.in ? a !== yo && a !== ha && (o = yo) : (a === yo || a === ha) && (o = tg);
    }
    this.updateStatus(!1, o);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var i = this.props.timeout, o, a, s;
    return o = a = s = i, i != null && typeof i != "number" && (o = i.exit, a = i.enter, s = i.appear !== void 0 ? i.appear : a), {
      exit: o,
      enter: a,
      appear: s
    };
  }, n.updateStatus = function(i, o) {
    if (i === void 0 && (i = !1), o !== null)
      if (this.cancelNextCallback(), o === yo) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var a = this.props.nodeRef ? this.props.nodeRef.current : cc.findDOMNode(this);
          a && dq(a);
        }
        this.performEnter(i);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === vo && this.setState({
      status: Ds
    });
  }, n.performEnter = function(i) {
    var o = this, a = this.props.enter, s = this.context ? this.context.isMounting : i, l = this.props.nodeRef ? [s] : [cc.findDOMNode(this), s], c = l[0], u = l[1], d = this.getTimeouts(), p = s ? d.appear : d.enter;
    if (!i && !a || PO.disabled) {
      this.safeSetState({
        status: ha
      }, function() {
        o.props.onEntered(c);
      });
      return;
    }
    this.props.onEnter(c, u), this.safeSetState({
      status: yo
    }, function() {
      o.props.onEntering(c, u), o.onTransitionEnd(p, function() {
        o.safeSetState({
          status: ha
        }, function() {
          o.props.onEntered(c, u);
        });
      });
    });
  }, n.performExit = function() {
    var i = this, o = this.props.exit, a = this.getTimeouts(), s = this.props.nodeRef ? void 0 : cc.findDOMNode(this);
    if (!o || PO.disabled) {
      this.safeSetState({
        status: vo
      }, function() {
        i.props.onExited(s);
      });
      return;
    }
    this.props.onExit(s), this.safeSetState({
      status: tg
    }, function() {
      i.props.onExiting(s), i.onTransitionEnd(a.exit, function() {
        i.safeSetState({
          status: vo
        }, function() {
          i.props.onExited(s);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(i, o) {
    o = this.setNextCallback(o), this.setState(i, o);
  }, n.setNextCallback = function(i) {
    var o = this, a = !0;
    return this.nextCallback = function(s) {
      a && (a = !1, o.nextCallback = null, i(s));
    }, this.nextCallback.cancel = function() {
      a = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(i, o) {
    this.setNextCallback(o);
    var a = this.props.nodeRef ? this.props.nodeRef.current : cc.findDOMNode(this), s = i == null && !this.props.addEndListener;
    if (!a || s) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var l = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], c = l[0], u = l[1];
      this.props.addEndListener(c, u);
    }
    i != null && setTimeout(this.nextCallback, i);
  }, n.render = function() {
    var i = this.state.status;
    if (i === Ds)
      return null;
    var o = this.props, a = o.children;
    o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
    var s = PA(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ Ye.createElement(sd.Provider, {
        value: null
      }, typeof a == "function" ? a(i, s) : Ye.cloneElement(Ye.Children.only(a), s))
    );
  }, t;
})(Ye.Component);
Gr.contextType = sd;
Gr.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: f.shape({
    current: typeof Element > "u" ? f.any : function(e, t, n, r, i, o) {
      var a = e[t];
      return f.instanceOf(a && "ownerDocument" in a ? a.ownerDocument.defaultView.Element : Element)(e, t, n, r, i, o);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: f.oneOfType([f.func.isRequired, f.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: f.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: f.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: f.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: f.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: f.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: f.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function(t) {
    var n = uq;
    t.addEndListener || (n = n.isRequired);
    for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      i[o - 1] = arguments[o];
    return n.apply(void 0, [t].concat(i));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: f.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: f.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: f.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: f.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: f.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: f.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: f.func
} : {};
function ca() {
}
Gr.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: ca,
  onEntering: ca,
  onEntered: ca,
  onExit: ca,
  onExiting: ca,
  onExited: ca
};
Gr.UNMOUNTED = Ds;
Gr.EXITED = vo;
Gr.ENTERING = yo;
Gr.ENTERED = ha;
Gr.EXITING = tg;
function fq(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Dy(e, t) {
  var n = function(o) {
    return t && bn(o) ? t(o) : o;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && LE.map(e, function(i) {
    return i;
  }).forEach(function(i) {
    r[i.key] = n(i);
  }), r;
}
function pq(e, t) {
  e = e || {}, t = t || {};
  function n(u) {
    return u in t ? t[u] : e[u];
  }
  var r = /* @__PURE__ */ Object.create(null), i = [];
  for (var o in e)
    o in t ? i.length && (r[o] = i, i = []) : i.push(o);
  var a, s = {};
  for (var l in t) {
    if (r[l])
      for (a = 0; a < r[l].length; a++) {
        var c = r[l][a];
        s[r[l][a]] = n(c);
      }
    s[l] = n(l);
  }
  for (a = 0; a < i.length; a++)
    s[i[a]] = n(i[a]);
  return s;
}
function Co(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function hq(e, t) {
  return Dy(e.children, function(n) {
    return cr(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Co(n, "appear", e),
      enter: Co(n, "enter", e),
      exit: Co(n, "exit", e)
    });
  });
}
function mq(e, t, n) {
  var r = Dy(e.children), i = pq(t, r);
  return Object.keys(i).forEach(function(o) {
    var a = i[o];
    if (bn(a)) {
      var s = o in t, l = o in r, c = t[o], u = bn(c) && !c.props.in;
      l && (!s || u) ? i[o] = cr(a, {
        onExited: n.bind(null, a),
        in: !0,
        exit: Co(a, "exit", e),
        enter: Co(a, "enter", e)
      }) : !l && s && !u ? i[o] = cr(a, {
        in: !1
      }) : l && s && bn(c) && (i[o] = cr(a, {
        onExited: n.bind(null, a),
        in: c.props.in,
        exit: Co(a, "exit", e),
        enter: Co(a, "enter", e)
      }));
    }
  }), i;
}
var gq = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, vq = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, Ry = /* @__PURE__ */ (function(e) {
  CA(t, e);
  function t(r, i) {
    var o;
    o = e.call(this, r, i) || this;
    var a = o.handleExited.bind(fq(o));
    return o.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: a,
      firstRender: !0
    }, o;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(i, o) {
    var a = o.children, s = o.handleExited, l = o.firstRender;
    return {
      children: l ? hq(i, s) : mq(i, a, s),
      firstRender: !1
    };
  }, n.handleExited = function(i, o) {
    var a = Dy(this.props.children);
    i.key in a || (i.props.onExited && i.props.onExited(o), this.mounted && this.setState(function(s) {
      var l = gu({}, s.children);
      return delete l[i.key], {
        children: l
      };
    }));
  }, n.render = function() {
    var i = this.props, o = i.component, a = i.childFactory, s = PA(i, ["component", "childFactory"]), l = this.state.contextValue, c = gq(this.state.children).map(a);
    return delete s.appear, delete s.enter, delete s.exit, o === null ? /* @__PURE__ */ Ye.createElement(sd.Provider, {
      value: l
    }, c) : /* @__PURE__ */ Ye.createElement(sd.Provider, {
      value: l
    }, /* @__PURE__ */ Ye.createElement(o, s, c));
  }, t;
})(Ye.Component);
Ry.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: f.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: f.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: f.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: f.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: f.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: f.func
} : {};
Ry.defaultProps = vq;
const CO = {};
function TA(e, t) {
  const n = _.useRef(CO);
  return n.current === CO && (n.current = e(t)), n;
}
const yq = [];
function bq(e) {
  _.useEffect(e, yq);
}
class Ef {
  static create() {
    return new Ef();
  }
  currentId = null;
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
  clear = () => {
    this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
  };
  disposeEffect = () => this.clear;
}
function va() {
  const e = TA(Ef.create).current;
  return bq(e.disposeEffect), e;
}
function xq(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function wq(e, t, n, r, i) {
  const o = e[t], a = i || t;
  if (o == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  return typeof o == "function" && !xq(o) && (s = "Did you accidentally provide a plain function component instead?"), s !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element type that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const Iy = es(f.elementType, wq), AA = (e) => e.scrollTop;
function ld(e, t) {
  const {
    timeout: n,
    easing: r,
    style: i = {}
  } = e;
  return {
    duration: i.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
    easing: i.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
    delay: i.transitionDelay
  };
}
function Oq(e) {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : Number.isFinite(e) ? e !== Math.floor(e) ? "float" : "number" : "Infinity";
    case "object":
      return e === null ? "null" : e.constructor.name;
    default:
      return t;
  }
}
function kA(e, t, n, r) {
  const i = e[t];
  if (i == null || !Number.isInteger(i)) {
    const o = Oq(i);
    return new RangeError(`Invalid ${r} \`${t}\` of type \`${o}\` supplied to \`${n}\`, expected \`integer\`.`);
  }
  return null;
}
function MA(e, t, n, r) {
  return e[t] === void 0 ? null : kA(e, t, n, r);
}
function ng() {
  return null;
}
MA.isRequired = kA;
ng.isRequired = ng;
const jA = process.env.NODE_ENV === "production" ? ng : MA;
function Sq(e) {
  return Je("MuiPaper", e);
}
Ge("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const Eq = (e) => {
  const {
    square: t,
    elevation: n,
    variant: r,
    classes: i
  } = e, o = {
    root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
  };
  return at(o, Sq, i);
}, _q = ge("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(Ct(({
  theme: e
}) => ({
  backgroundColor: (e.vars || e).palette.background.paper,
  color: (e.vars || e).palette.text.primary,
  transition: e.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: e.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(e.vars || e).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), NA = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiPaper"
  }), i = zd(), {
    className: o,
    component: a = "div",
    elevation: s = 1,
    square: l = !1,
    variant: c = "elevation",
    ...u
  } = r, d = {
    ...r,
    component: a,
    elevation: s,
    square: l,
    variant: c
  }, p = Eq(d);
  return process.env.NODE_ENV !== "production" && i.shadows[s] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${s}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${s}]\` is defined.`].join(`
`)), /* @__PURE__ */ x.jsx(_q, {
    as: a,
    ownerState: d,
    className: ie(p.root, o),
    ref: n,
    ...u,
    style: {
      ...c === "elevation" && {
        "--Paper-shadow": (i.vars || i).shadows[s],
        ...i.vars && {
          "--Paper-overlay": i.vars.overlays?.[s]
        },
        ...!i.vars && i.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${bu("#fff", om(s))}, ${bu("#fff", om(s))})`
        }
      },
      ...u.style
    }
  });
});
process.env.NODE_ENV !== "production" && (NA.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: es(jA, (e) => {
    const {
      elevation: t,
      variant: n
    } = e;
    return t > 0 && n === "outlined" ? new Error(`MUI: Combining \`elevation={${t}}\` with \`variant="${n}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: f.bool,
  /**
   * @ignore
   */
  style: f.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: f.oneOfType([f.oneOf(["elevation", "outlined"]), f.string])
});
function cd(e) {
  return typeof e == "string";
}
function DA(e, t, n) {
  return e === void 0 || cd(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function RA(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function IA(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function TO(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function $A(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: o
  } = e;
  if (!t) {
    const h = ie(n?.className, o, i?.className, r?.className), g = {
      ...n?.style,
      ...i?.style,
      ...r?.style
    }, m = {
      ...n,
      ...i,
      ...r
    };
    return h.length > 0 && (m.className = h), Object.keys(g).length > 0 && (m.style = g), {
      props: m,
      internalRef: void 0
    };
  }
  const a = IA({
    ...i,
    ...r
  }), s = TO(r), l = TO(i), c = t(a), u = ie(c?.className, n?.className, o, i?.className, r?.className), d = {
    ...c?.style,
    ...n?.style,
    ...i?.style,
    ...r?.style
  }, p = {
    ...c,
    ...n,
    ...l,
    ...s
  };
  return u.length > 0 && (p.className = u), Object.keys(d).length > 0 && (p.style = d), {
    props: p,
    internalRef: c.ref
  };
}
function lt(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: i,
    externalForwardedProps: o,
    internalForwardedProps: a,
    shouldForwardComponentProp: s = !1,
    ...l
  } = t, {
    component: c,
    slots: u = {
      [e]: void 0
    },
    slotProps: d = {
      [e]: void 0
    },
    ...p
  } = o, h = u[e] || r, g = RA(d[e], i), {
    props: {
      component: m,
      ...v
    },
    internalRef: y
  } = $A({
    className: n,
    ...l,
    externalForwardedProps: e === "root" ? p : void 0,
    externalSlotProps: g
  }), S = Gt(y, g?.ref, t.ref), w = e === "root" ? m || c : m, b = DA(h, {
    ...e === "root" && !c && !u[e] && a,
    ...e !== "root" && !u[e] && a,
    ...v,
    ...w && !s && {
      as: w
    },
    ...w && s && {
      component: w
    },
    ref: S
  }, i);
  return [h, b];
}
const br = f.oneOfType([f.func, f.object]);
function ud(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
    process.env.NODE_ENV !== "production" && !/jsdom/.test(window.navigator.userAgent) && console.warn(["MUI: The `:focus-visible` pseudo class is not supported in this browser.", "Some components rely on this feature to work properly."].join(`
`));
  }
  return !1;
}
class dd {
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new dd();
  }
  static use() {
    const t = TA(dd.create).current, [n, r] = _.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, _.useEffect(t.mountEffect, [n]), t;
  }
  constructor() {
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  mount() {
    return this.mounted || (this.mounted = Cq(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  mountEffect = () => {
    this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
  };
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function Pq() {
  return dd.use();
}
function Cq() {
  let e, t;
  const n = new Promise((r, i) => {
    e = r, t = i;
  });
  return n.resolve = e, n.reject = t, n;
}
function LA(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: i,
    rippleY: o,
    rippleSize: a,
    in: s,
    onExited: l,
    timeout: c
  } = e, [u, d] = _.useState(!1), p = ie(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), h = {
    width: a,
    height: a,
    top: -(a / 2) + o,
    left: -(a / 2) + i
  }, g = ie(n.child, u && n.childLeaving, r && n.childPulsate);
  return !s && !u && d(!0), _.useEffect(() => {
    if (!s && l != null) {
      const m = setTimeout(l, c);
      return () => {
        clearTimeout(m);
      };
    }
  }, [l, s, c]), /* @__PURE__ */ x.jsx("span", {
    className: p,
    style: h,
    children: /* @__PURE__ */ x.jsx("span", {
      className: g
    })
  });
}
process.env.NODE_ENV !== "production" && (LA.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object.isRequired,
  className: f.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: f.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: f.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: f.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: f.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: f.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: f.number,
  /**
   * exit delay
   */
  timeout: f.number.isRequired
});
const or = Ge("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), rg = 550, Tq = 80, Aq = kg`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, kq = kg`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, Mq = kg`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, jq = ge("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), Nq = ge(LA, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${or.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${Aq};
    animation-duration: ${rg}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${or.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${or.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${or.childLeaving} {
    opacity: 0;
    animation-name: ${kq};
    animation-duration: ${rg}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${or.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${Mq};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, FA = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: i = !1,
    classes: o = {},
    className: a,
    ...s
  } = r, [l, c] = _.useState([]), u = _.useRef(0), d = _.useRef(null);
  _.useEffect(() => {
    d.current && (d.current(), d.current = null);
  }, [l]);
  const p = _.useRef(!1), h = va(), g = _.useRef(null), m = _.useRef(null), v = _.useCallback((b) => {
    const {
      pulsate: O,
      rippleX: E,
      rippleY: C,
      rippleSize: T,
      cb: j
    } = b;
    c((A) => [...A, /* @__PURE__ */ x.jsx(Nq, {
      classes: {
        ripple: ie(o.ripple, or.ripple),
        rippleVisible: ie(o.rippleVisible, or.rippleVisible),
        ripplePulsate: ie(o.ripplePulsate, or.ripplePulsate),
        child: ie(o.child, or.child),
        childLeaving: ie(o.childLeaving, or.childLeaving),
        childPulsate: ie(o.childPulsate, or.childPulsate)
      },
      timeout: rg,
      pulsate: O,
      rippleX: E,
      rippleY: C,
      rippleSize: T
    }, u.current)]), u.current += 1, d.current = j;
  }, [o]), y = _.useCallback((b = {}, O = {}, E = () => {
  }) => {
    const {
      pulsate: C = !1,
      center: T = i || O.pulsate,
      fakeElement: j = !1
      // For test purposes
    } = O;
    if (b?.type === "mousedown" && p.current) {
      p.current = !1;
      return;
    }
    b?.type === "touchstart" && (p.current = !0);
    const A = j ? null : m.current, M = A ? A.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let P, R, N;
    if (T || b === void 0 || b.clientX === 0 && b.clientY === 0 || !b.clientX && !b.touches)
      P = Math.round(M.width / 2), R = Math.round(M.height / 2);
    else {
      const {
        clientX: D,
        clientY: $
      } = b.touches && b.touches.length > 0 ? b.touches[0] : b;
      P = Math.round(D - M.left), R = Math.round($ - M.top);
    }
    if (T)
      N = Math.sqrt((2 * M.width ** 2 + M.height ** 2) / 3), N % 2 === 0 && (N += 1);
    else {
      const D = Math.max(Math.abs((A ? A.clientWidth : 0) - P), P) * 2 + 2, $ = Math.max(Math.abs((A ? A.clientHeight : 0) - R), R) * 2 + 2;
      N = Math.sqrt(D ** 2 + $ ** 2);
    }
    b?.touches ? g.current === null && (g.current = () => {
      v({
        pulsate: C,
        rippleX: P,
        rippleY: R,
        rippleSize: N,
        cb: E
      });
    }, h.start(Tq, () => {
      g.current && (g.current(), g.current = null);
    })) : v({
      pulsate: C,
      rippleX: P,
      rippleY: R,
      rippleSize: N,
      cb: E
    });
  }, [i, v, h]), S = _.useCallback(() => {
    y({}, {
      pulsate: !0
    });
  }, [y]), w = _.useCallback((b, O) => {
    if (h.clear(), b?.type === "touchend" && g.current) {
      g.current(), g.current = null, h.start(0, () => {
        w(b, O);
      });
      return;
    }
    g.current = null, c((E) => E.length > 0 ? E.slice(1) : E), d.current = O;
  }, [h]);
  return _.useImperativeHandle(n, () => ({
    pulsate: S,
    start: y,
    stop: w
  }), [S, y, w]), /* @__PURE__ */ x.jsx(jq, {
    className: ie(or.root, o.root, a),
    ref: m,
    ...s,
    children: /* @__PURE__ */ x.jsx(Ry, {
      component: null,
      exit: !0,
      children: l
    })
  });
});
process.env.NODE_ENV !== "production" && (FA.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: f.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string
});
function Dq(e) {
  return Je("MuiButtonBase", e);
}
const Rq = Ge("MuiButtonBase", ["root", "disabled", "focusVisible"]), Iq = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: i
  } = e, a = at({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, Dq, i);
  return n && r && (a.root += ` ${r}`), a;
}, $q = ge("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${Rq.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), $y = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: i,
    centerRipple: o = !1,
    children: a,
    className: s,
    component: l = "button",
    disabled: c = !1,
    disableRipple: u = !1,
    disableTouchRipple: d = !1,
    focusRipple: p = !1,
    focusVisibleClassName: h,
    LinkComponent: g = "a",
    onBlur: m,
    onClick: v,
    onContextMenu: y,
    onDragLeave: S,
    onFocus: w,
    onFocusVisible: b,
    onKeyDown: O,
    onKeyUp: E,
    onMouseDown: C,
    onMouseLeave: T,
    onMouseUp: j,
    onTouchEnd: A,
    onTouchMove: M,
    onTouchStart: P,
    tabIndex: R = 0,
    TouchRippleProps: N,
    touchRippleRef: D,
    type: $,
    ...F
  } = r, q = _.useRef(null), B = Pq(), L = Gt(B.ref, D), [Y, K] = _.useState(!1);
  c && Y && K(!1), _.useImperativeHandle(i, () => ({
    focusVisible: () => {
      K(!0), q.current.focus();
    }
  }), []);
  const te = B.shouldMount && !u && !c;
  _.useEffect(() => {
    Y && p && !u && B.pulsate();
  }, [u, p, Y, B]);
  const J = Jr(B, "start", C, d), G = Jr(B, "stop", y, d), ee = Jr(B, "stop", S, d), re = Jr(B, "stop", j, d), oe = Jr(B, "stop", (ue) => {
    Y && ue.preventDefault(), T && T(ue);
  }, d), W = Jr(B, "start", P, d), U = Jr(B, "stop", A, d), Z = Jr(B, "stop", M, d), k = Jr(B, "stop", (ue) => {
    ud(ue.target) || K(!1), m && m(ue);
  }, !1), de = ci((ue) => {
    q.current || (q.current = ue.currentTarget), ud(ue.target) && (K(!0), b && b(ue)), w && w(ue);
  }), ne = () => {
    const ue = q.current;
    return l && l !== "button" && !(ue.tagName === "A" && ue.href);
  }, he = ci((ue) => {
    p && !ue.repeat && Y && ue.key === " " && B.stop(ue, () => {
      B.start(ue);
    }), ue.target === ue.currentTarget && ne() && ue.key === " " && ue.preventDefault(), O && O(ue), ue.target === ue.currentTarget && ne() && ue.key === "Enter" && !c && (ue.preventDefault(), v && v(ue));
  }), xe = ci((ue) => {
    p && ue.key === " " && Y && !ue.defaultPrevented && B.stop(ue, () => {
      B.pulsate(ue);
    }), E && E(ue), v && ue.target === ue.currentTarget && ne() && ue.key === " " && !ue.defaultPrevented && v(ue);
  });
  let Oe = l;
  Oe === "button" && (F.href || F.to) && (Oe = g);
  const Ee = {};
  Oe === "button" ? (Ee.type = $ === void 0 ? "button" : $, Ee.disabled = c) : (!F.href && !F.to && (Ee.role = "button"), c && (Ee["aria-disabled"] = c));
  const et = Gt(n, q), Ie = {
    ...r,
    centerRipple: o,
    component: l,
    disabled: c,
    disableRipple: u,
    disableTouchRipple: d,
    focusRipple: p,
    tabIndex: R,
    focusVisible: Y
  }, Ce = Iq(Ie);
  return /* @__PURE__ */ x.jsxs($q, {
    as: Oe,
    className: ie(Ce.root, s),
    ownerState: Ie,
    onBlur: k,
    onClick: v,
    onContextMenu: G,
    onFocus: de,
    onKeyDown: he,
    onKeyUp: xe,
    onMouseDown: J,
    onMouseLeave: oe,
    onMouseUp: re,
    onDragLeave: ee,
    onTouchEnd: U,
    onTouchMove: Z,
    onTouchStart: W,
    ref: et,
    tabIndex: c ? -1 : R,
    type: $,
    ...Ee,
    ...F,
    children: [a, te ? /* @__PURE__ */ x.jsx(FA, {
      ref: L,
      center: o,
      ...N
    }) : null]
  });
});
function Jr(e, t, n, r = !1) {
  return ci((i) => (n && n(i), r || e[t](i), !0));
}
process.env.NODE_ENV !== "production" && ($y.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: br,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: f.bool,
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: Iy,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: f.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: f.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: f.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: f.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: f.string,
  /**
   * @ignore
   */
  href: f.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: f.elementType,
  /**
   * @ignore
   */
  onBlur: f.func,
  /**
   * @ignore
   */
  onClick: f.func,
  /**
   * @ignore
   */
  onContextMenu: f.func,
  /**
   * @ignore
   */
  onDragLeave: f.func,
  /**
   * @ignore
   */
  onFocus: f.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: f.func,
  /**
   * @ignore
   */
  onKeyDown: f.func,
  /**
   * @ignore
   */
  onKeyUp: f.func,
  /**
   * @ignore
   */
  onMouseDown: f.func,
  /**
   * @ignore
   */
  onMouseLeave: f.func,
  /**
   * @ignore
   */
  onMouseUp: f.func,
  /**
   * @ignore
   */
  onTouchEnd: f.func,
  /**
   * @ignore
   */
  onTouchMove: f.func,
  /**
   * @ignore
   */
  onTouchStart: f.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * @default 0
   */
  tabIndex: f.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: f.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: f.oneOfType([f.func, f.shape({
    current: f.shape({
      pulsate: f.func.isRequired,
      start: f.func.isRequired,
      stop: f.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: f.oneOfType([f.oneOf(["button", "reset", "submit"]), f.string])
});
function Lq(e) {
  return typeof e.main == "string";
}
function Fq(e, t = []) {
  if (!Lq(e))
    return !1;
  for (const n of t)
    if (!e.hasOwnProperty(n) || typeof e[n] != "string")
      return !1;
  return !0;
}
function Wo(e = []) {
  return ([, t]) => t && Fq(t, e);
}
function Bq(e) {
  return Je("MuiTypography", e);
}
const AO = Ge("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), zq = {
  primary: !0,
  secondary: !0,
  error: !0,
  info: !0,
  success: !0,
  warning: !0,
  textPrimary: !0,
  textSecondary: !0,
  textDisabled: !0
}, Wq = sR(), Vq = (e) => {
  const {
    align: t,
    gutterBottom: n,
    noWrap: r,
    paragraph: i,
    variant: o,
    classes: a
  } = e, s = {
    root: ["root", o, e.align !== "inherit" && `align${Re(t)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"]
  };
  return at(s, Bq, a);
}, Uq = ge("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${Re(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
  }
})(Ct(({
  theme: e
}) => ({
  margin: 0,
  variants: [{
    props: {
      variant: "inherit"
    },
    style: {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  }, ...Object.entries(e.typography).filter(([t, n]) => t !== "inherit" && n && typeof n == "object").map(([t, n]) => ({
    props: {
      variant: t
    },
    style: n
  })), ...Object.entries(e.palette).filter(Wo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette?.text || {}).filter(([, t]) => typeof t == "string").map(([t]) => ({
    props: {
      color: `text${Re(t)}`
    },
    style: {
      color: (e.vars || e).palette.text[t]
    }
  })), {
    props: ({
      ownerState: t
    }) => t.align !== "inherit",
    style: {
      textAlign: "var(--Typography-textAlign)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.noWrap,
    style: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.gutterBottom,
    style: {
      marginBottom: "0.35em"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.paragraph,
    style: {
      marginBottom: 16
    }
  }]
}))), kO = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, Rs = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    color: r,
    ...i
  } = pt({
    props: t,
    name: "MuiTypography"
  }), o = !zq[r], a = Wq({
    ...i,
    ...o && {
      color: r
    }
  }), {
    align: s = "inherit",
    className: l,
    component: c,
    gutterBottom: u = !1,
    noWrap: d = !1,
    paragraph: p = !1,
    variant: h = "body1",
    variantMapping: g = kO,
    ...m
  } = a, v = {
    ...a,
    align: s,
    color: r,
    className: l,
    component: c,
    gutterBottom: u,
    noWrap: d,
    paragraph: p,
    variant: h,
    variantMapping: g
  }, y = c || (p ? "p" : g[h] || kO[h]) || "span", S = Vq(v);
  return /* @__PURE__ */ x.jsx(Uq, {
    as: y,
    ref: n,
    className: ie(S.root, l),
    ...m,
    ownerState: v,
    style: {
      ...s !== "inherit" && {
        "--Typography-textAlign": s
      },
      ...m.style
    }
  });
});
process.env.NODE_ENV !== "production" && (Rs.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: f.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: f.oneOfType([f.oneOf(["primary", "secondary", "success", "error", "info", "warning", "textPrimary", "textSecondary", "textDisabled"]), f.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: f.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: f.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   * @deprecated Use the `component` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  paragraph: f.bool,
  /**
   * @ignore
   */
  style: f.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: f.oneOfType([f.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), f.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: f.object
});
function yi(e, t, n, r, i) {
  if (process.env.NODE_ENV === "production")
    return null;
  const o = e[t], a = i || t;
  return o == null ? null : o && o.nodeType !== 1 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an HTMLElement.`) : null;
}
var kn = "top", pr = "bottom", hr = "right", Mn = "left", Ly = "auto", rc = [kn, pr, hr, Mn], Ia = "start", ml = "end", Hq = "clippingParents", BA = "viewport", ys = "popper", qq = "reference", MO = /* @__PURE__ */ rc.reduce(function(e, t) {
  return e.concat([t + "-" + Ia, t + "-" + ml]);
}, []), zA = /* @__PURE__ */ [].concat(rc, [Ly]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Ia, t + "-" + ml]);
}, []), Kq = "beforeRead", Yq = "read", Gq = "afterRead", Xq = "beforeMain", Zq = "main", Jq = "afterMain", Qq = "beforeWrite", eK = "write", tK = "afterWrite", nK = [Kq, Yq, Gq, Xq, Zq, Jq, Qq, eK, tK];
function qr(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Gn(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Vo(e) {
  var t = Gn(e).Element;
  return e instanceof t || e instanceof Element;
}
function ur(e) {
  var t = Gn(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function Fy(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Gn(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function rK(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, o = t.elements[n];
    !ur(o) || !qr(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function(a) {
      var s = i[a];
      s === !1 ? o.removeAttribute(a) : o.setAttribute(a, s === !0 ? "" : s);
    }));
  });
}
function iK(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], o = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), s = a.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !ur(i) || !qr(i) || (Object.assign(i.style, s), Object.keys(o).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const WA = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: rK,
  effect: iK,
  requires: ["computeStyles"]
};
function Fr(e) {
  return e.split("-")[0];
}
var Do = Math.max, fd = Math.min, $a = Math.round;
function ig() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function VA() {
  return !/^((?!chrome|android).)*safari/i.test(ig());
}
function La(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, o = 1;
  t && ur(e) && (i = e.offsetWidth > 0 && $a(r.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && $a(r.height) / e.offsetHeight || 1);
  var a = Vo(e) ? Gn(e) : window, s = a.visualViewport, l = !VA() && n, c = (r.left + (l && s ? s.offsetLeft : 0)) / i, u = (r.top + (l && s ? s.offsetTop : 0)) / o, d = r.width / i, p = r.height / o;
  return {
    width: d,
    height: p,
    top: u,
    right: c + d,
    bottom: u + p,
    left: c,
    x: c,
    y: u
  };
}
function By(e) {
  var t = La(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function UA(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Fy(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function bi(e) {
  return Gn(e).getComputedStyle(e);
}
function oK(e) {
  return ["table", "td", "th"].indexOf(qr(e)) >= 0;
}
function to(e) {
  return ((Vo(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function _f(e) {
  return qr(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (Fy(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    to(e)
  );
}
function jO(e) {
  return !ur(e) || // https://github.com/popperjs/popper-core/issues/837
  bi(e).position === "fixed" ? null : e.offsetParent;
}
function aK(e) {
  var t = /firefox/i.test(ig()), n = /Trident/i.test(ig());
  if (n && ur(e)) {
    var r = bi(e);
    if (r.position === "fixed")
      return null;
  }
  var i = _f(e);
  for (Fy(i) && (i = i.host); ur(i) && ["html", "body"].indexOf(qr(i)) < 0; ) {
    var o = bi(i);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function ic(e) {
  for (var t = Gn(e), n = jO(e); n && oK(n) && bi(n).position === "static"; )
    n = jO(n);
  return n && (qr(n) === "html" || qr(n) === "body" && bi(n).position === "static") ? t : n || aK(e) || t;
}
function zy(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Us(e, t, n) {
  return Do(e, fd(t, n));
}
function sK(e, t, n) {
  var r = Us(e, t, n);
  return r > n ? n : r;
}
function HA() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function qA(e) {
  return Object.assign({}, HA(), e);
}
function KA(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var lK = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, qA(typeof t != "number" ? t : KA(t, rc));
};
function cK(e) {
  var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, a = n.modifiersData.popperOffsets, s = Fr(n.placement), l = zy(s), c = [Mn, hr].indexOf(s) >= 0, u = c ? "height" : "width";
  if (!(!o || !a)) {
    var d = lK(i.padding, n), p = By(o), h = l === "y" ? kn : Mn, g = l === "y" ? pr : hr, m = n.rects.reference[u] + n.rects.reference[l] - a[l] - n.rects.popper[u], v = a[l] - n.rects.reference[l], y = ic(o), S = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, w = m / 2 - v / 2, b = d[h], O = S - p[u] - d[g], E = S / 2 - p[u] / 2 + w, C = Us(b, E, O), T = l;
    n.modifiersData[r] = (t = {}, t[T] = C, t.centerOffset = C - E, t);
  }
}
function uK(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || UA(t.elements.popper, i) && (t.elements.arrow = i));
}
const dK = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: cK,
  effect: uK,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Fa(e) {
  return e.split("-")[1];
}
var fK = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function pK(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: $a(n * i) / i || 0,
    y: $a(r * i) / i || 0
  };
}
function NO(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, a = e.offsets, s = e.position, l = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, d = e.isFixed, p = a.x, h = p === void 0 ? 0 : p, g = a.y, m = g === void 0 ? 0 : g, v = typeof u == "function" ? u({
    x: h,
    y: m
  }) : {
    x: h,
    y: m
  };
  h = v.x, m = v.y;
  var y = a.hasOwnProperty("x"), S = a.hasOwnProperty("y"), w = Mn, b = kn, O = window;
  if (c) {
    var E = ic(n), C = "clientHeight", T = "clientWidth";
    if (E === Gn(n) && (E = to(n), bi(E).position !== "static" && s === "absolute" && (C = "scrollHeight", T = "scrollWidth")), E = E, i === kn || (i === Mn || i === hr) && o === ml) {
      b = pr;
      var j = d && E === O && O.visualViewport ? O.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        E[C]
      );
      m -= j - r.height, m *= l ? 1 : -1;
    }
    if (i === Mn || (i === kn || i === pr) && o === ml) {
      w = hr;
      var A = d && E === O && O.visualViewport ? O.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        E[T]
      );
      h -= A - r.width, h *= l ? 1 : -1;
    }
  }
  var M = Object.assign({
    position: s
  }, c && fK), P = u === !0 ? pK({
    x: h,
    y: m
  }, Gn(n)) : {
    x: h,
    y: m
  };
  if (h = P.x, m = P.y, l) {
    var R;
    return Object.assign({}, M, (R = {}, R[b] = S ? "0" : "", R[w] = y ? "0" : "", R.transform = (O.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + m + "px)" : "translate3d(" + h + "px, " + m + "px, 0)", R));
  }
  return Object.assign({}, M, (t = {}, t[b] = S ? m + "px" : "", t[w] = y ? h + "px" : "", t.transform = "", t));
}
function hK(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, o = n.adaptive, a = o === void 0 ? !0 : o, s = n.roundOffsets, l = s === void 0 ? !0 : s, c = {
    placement: Fr(t.placement),
    variation: Fa(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, NO(Object.assign({}, c, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: a,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, NO(Object.assign({}, c, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const mK = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: hK,
  data: {}
};
var $c = {
  passive: !0
};
function gK(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, o = i === void 0 ? !0 : i, a = r.resize, s = a === void 0 ? !0 : a, l = Gn(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, $c);
  }), s && l.addEventListener("resize", n.update, $c), function() {
    o && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, $c);
    }), s && l.removeEventListener("resize", n.update, $c);
  };
}
const vK = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: gK,
  data: {}
};
var yK = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function du(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return yK[t];
  });
}
var bK = {
  start: "end",
  end: "start"
};
function DO(e) {
  return e.replace(/start|end/g, function(t) {
    return bK[t];
  });
}
function Wy(e) {
  var t = Gn(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function Vy(e) {
  return La(to(e)).left + Wy(e).scrollLeft;
}
function xK(e, t) {
  var n = Gn(e), r = to(e), i = n.visualViewport, o = r.clientWidth, a = r.clientHeight, s = 0, l = 0;
  if (i) {
    o = i.width, a = i.height;
    var c = VA();
    (c || !c && t === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: o,
    height: a,
    x: s + Vy(e),
    y: l
  };
}
function wK(e) {
  var t, n = to(e), r = Wy(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, o = Do(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = Do(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + Vy(e), l = -r.scrollTop;
  return bi(i || n).direction === "rtl" && (s += Do(n.clientWidth, i ? i.clientWidth : 0) - o), {
    width: o,
    height: a,
    x: s,
    y: l
  };
}
function Uy(e) {
  var t = bi(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function YA(e) {
  return ["html", "body", "#document"].indexOf(qr(e)) >= 0 ? e.ownerDocument.body : ur(e) && Uy(e) ? e : YA(_f(e));
}
function Hs(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = YA(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Gn(r), a = i ? [o].concat(o.visualViewport || [], Uy(r) ? r : []) : r, s = t.concat(a);
  return i ? s : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    s.concat(Hs(_f(a)))
  );
}
function og(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function OK(e, t) {
  var n = La(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function RO(e, t, n) {
  return t === BA ? og(xK(e, n)) : Vo(t) ? OK(t, n) : og(wK(to(e)));
}
function SK(e) {
  var t = Hs(_f(e)), n = ["absolute", "fixed"].indexOf(bi(e).position) >= 0, r = n && ur(e) ? ic(e) : e;
  return Vo(r) ? t.filter(function(i) {
    return Vo(i) && UA(i, r) && qr(i) !== "body";
  }) : [];
}
function EK(e, t, n, r) {
  var i = t === "clippingParents" ? SK(e) : [].concat(t), o = [].concat(i, [n]), a = o[0], s = o.reduce(function(l, c) {
    var u = RO(e, c, r);
    return l.top = Do(u.top, l.top), l.right = fd(u.right, l.right), l.bottom = fd(u.bottom, l.bottom), l.left = Do(u.left, l.left), l;
  }, RO(e, a, r));
  return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;
}
function GA(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? Fr(r) : null, o = r ? Fa(r) : null, a = t.x + t.width / 2 - n.width / 2, s = t.y + t.height / 2 - n.height / 2, l;
  switch (i) {
    case kn:
      l = {
        x: a,
        y: t.y - n.height
      };
      break;
    case pr:
      l = {
        x: a,
        y: t.y + t.height
      };
      break;
    case hr:
      l = {
        x: t.x + t.width,
        y: s
      };
      break;
    case Mn:
      l = {
        x: t.x - n.width,
        y: s
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var c = i ? zy(i) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (o) {
      case Ia:
        l[c] = l[c] - (t[u] / 2 - n[u] / 2);
        break;
      case ml:
        l[c] = l[c] + (t[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function gl(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, o = n.strategy, a = o === void 0 ? e.strategy : o, s = n.boundary, l = s === void 0 ? Hq : s, c = n.rootBoundary, u = c === void 0 ? BA : c, d = n.elementContext, p = d === void 0 ? ys : d, h = n.altBoundary, g = h === void 0 ? !1 : h, m = n.padding, v = m === void 0 ? 0 : m, y = qA(typeof v != "number" ? v : KA(v, rc)), S = p === ys ? qq : ys, w = e.rects.popper, b = e.elements[g ? S : p], O = EK(Vo(b) ? b : b.contextElement || to(e.elements.popper), l, u, a), E = La(e.elements.reference), C = GA({
    reference: E,
    element: w,
    placement: i
  }), T = og(Object.assign({}, w, C)), j = p === ys ? T : E, A = {
    top: O.top - j.top + y.top,
    bottom: j.bottom - O.bottom + y.bottom,
    left: O.left - j.left + y.left,
    right: j.right - O.right + y.right
  }, M = e.modifiersData.offset;
  if (p === ys && M) {
    var P = M[i];
    Object.keys(A).forEach(function(R) {
      var N = [hr, pr].indexOf(R) >= 0 ? 1 : -1, D = [kn, pr].indexOf(R) >= 0 ? "y" : "x";
      A[R] += P[D] * N;
    });
  }
  return A;
}
function _K(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, o = n.rootBoundary, a = n.padding, s = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? zA : l, u = Fa(r), d = u ? s ? MO : MO.filter(function(g) {
    return Fa(g) === u;
  }) : rc, p = d.filter(function(g) {
    return c.indexOf(g) >= 0;
  });
  p.length === 0 && (p = d);
  var h = p.reduce(function(g, m) {
    return g[m] = gl(e, {
      placement: m,
      boundary: i,
      rootBoundary: o,
      padding: a
    })[Fr(m)], g;
  }, {});
  return Object.keys(h).sort(function(g, m) {
    return h[g] - h[m];
  });
}
function PK(e) {
  if (Fr(e) === Ly)
    return [];
  var t = du(e);
  return [DO(e), t, DO(t)];
}
function CK(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, o = i === void 0 ? !0 : i, a = n.altAxis, s = a === void 0 ? !0 : a, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, p = n.altBoundary, h = n.flipVariations, g = h === void 0 ? !0 : h, m = n.allowedAutoPlacements, v = t.options.placement, y = Fr(v), S = y === v, w = l || (S || !g ? [du(v)] : PK(v)), b = [v].concat(w).reduce(function(J, G) {
      return J.concat(Fr(G) === Ly ? _K(t, {
        placement: G,
        boundary: u,
        rootBoundary: d,
        padding: c,
        flipVariations: g,
        allowedAutoPlacements: m
      }) : G);
    }, []), O = t.rects.reference, E = t.rects.popper, C = /* @__PURE__ */ new Map(), T = !0, j = b[0], A = 0; A < b.length; A++) {
      var M = b[A], P = Fr(M), R = Fa(M) === Ia, N = [kn, pr].indexOf(P) >= 0, D = N ? "width" : "height", $ = gl(t, {
        placement: M,
        boundary: u,
        rootBoundary: d,
        altBoundary: p,
        padding: c
      }), F = N ? R ? hr : Mn : R ? pr : kn;
      O[D] > E[D] && (F = du(F));
      var q = du(F), B = [];
      if (o && B.push($[P] <= 0), s && B.push($[F] <= 0, $[q] <= 0), B.every(function(J) {
        return J;
      })) {
        j = M, T = !1;
        break;
      }
      C.set(M, B);
    }
    if (T)
      for (var L = g ? 3 : 1, Y = function(G) {
        var ee = b.find(function(re) {
          var oe = C.get(re);
          if (oe)
            return oe.slice(0, G).every(function(W) {
              return W;
            });
        });
        if (ee)
          return j = ee, "break";
      }, K = L; K > 0; K--) {
        var te = Y(K);
        if (te === "break") break;
      }
    t.placement !== j && (t.modifiersData[r]._skip = !0, t.placement = j, t.reset = !0);
  }
}
const TK = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: CK,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function IO(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function $O(e) {
  return [kn, hr, pr, Mn].some(function(t) {
    return e[t] >= 0;
  });
}
function AK(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, o = t.modifiersData.preventOverflow, a = gl(t, {
    elementContext: "reference"
  }), s = gl(t, {
    altBoundary: !0
  }), l = IO(a, r), c = IO(s, i, o), u = $O(l), d = $O(c);
  t.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
const kK = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: AK
};
function MK(e, t, n) {
  var r = Fr(e), i = [Mn, kn].indexOf(r) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, a = o[0], s = o[1];
  return a = a || 0, s = (s || 0) * i, [Mn, hr].indexOf(r) >= 0 ? {
    x: s,
    y: a
  } : {
    x: a,
    y: s
  };
}
function jK(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, o = i === void 0 ? [0, 0] : i, a = zA.reduce(function(u, d) {
    return u[d] = MK(d, t.rects, o), u;
  }, {}), s = a[t.placement], l = s.x, c = s.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = a;
}
const NK = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: jK
};
function DK(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = GA({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const RK = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: DK,
  data: {}
};
function IK(e) {
  return e === "x" ? "y" : "x";
}
function $K(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, o = i === void 0 ? !0 : i, a = n.altAxis, s = a === void 0 ? !1 : a, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, p = n.tether, h = p === void 0 ? !0 : p, g = n.tetherOffset, m = g === void 0 ? 0 : g, v = gl(t, {
    boundary: l,
    rootBoundary: c,
    padding: d,
    altBoundary: u
  }), y = Fr(t.placement), S = Fa(t.placement), w = !S, b = zy(y), O = IK(b), E = t.modifiersData.popperOffsets, C = t.rects.reference, T = t.rects.popper, j = typeof m == "function" ? m(Object.assign({}, t.rects, {
    placement: t.placement
  })) : m, A = typeof j == "number" ? {
    mainAxis: j,
    altAxis: j
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, j), M = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, P = {
    x: 0,
    y: 0
  };
  if (E) {
    if (o) {
      var R, N = b === "y" ? kn : Mn, D = b === "y" ? pr : hr, $ = b === "y" ? "height" : "width", F = E[b], q = F + v[N], B = F - v[D], L = h ? -T[$] / 2 : 0, Y = S === Ia ? C[$] : T[$], K = S === Ia ? -T[$] : -C[$], te = t.elements.arrow, J = h && te ? By(te) : {
        width: 0,
        height: 0
      }, G = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : HA(), ee = G[N], re = G[D], oe = Us(0, C[$], J[$]), W = w ? C[$] / 2 - L - oe - ee - A.mainAxis : Y - oe - ee - A.mainAxis, U = w ? -C[$] / 2 + L + oe + re + A.mainAxis : K + oe + re + A.mainAxis, Z = t.elements.arrow && ic(t.elements.arrow), k = Z ? b === "y" ? Z.clientTop || 0 : Z.clientLeft || 0 : 0, de = (R = M?.[b]) != null ? R : 0, ne = F + W - de - k, he = F + U - de, xe = Us(h ? fd(q, ne) : q, F, h ? Do(B, he) : B);
      E[b] = xe, P[b] = xe - F;
    }
    if (s) {
      var Oe, Ee = b === "x" ? kn : Mn, et = b === "x" ? pr : hr, Ie = E[O], Ce = O === "y" ? "height" : "width", ue = Ie + v[Ee], Tt = Ie - v[et], tt = [kn, Mn].indexOf(y) !== -1, an = (Oe = M?.[O]) != null ? Oe : 0, Jt = tt ? ue : Ie - C[Ce] - T[Ce] - an + A.altAxis, sn = tt ? Ie + C[Ce] + T[Ce] - an - A.altAxis : Tt, wn = h && tt ? sK(Jt, Ie, sn) : Us(h ? Jt : ue, Ie, h ? sn : Tt);
      E[O] = wn, P[O] = wn - Ie;
    }
    t.modifiersData[r] = P;
  }
}
const LK = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: $K,
  requiresIfExists: ["offset"]
};
function FK(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function BK(e) {
  return e === Gn(e) || !ur(e) ? Wy(e) : FK(e);
}
function zK(e) {
  var t = e.getBoundingClientRect(), n = $a(t.width) / e.offsetWidth || 1, r = $a(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function WK(e, t, n) {
  n === void 0 && (n = !1);
  var r = ur(t), i = ur(t) && zK(t), o = to(t), a = La(e, i, n), s = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((qr(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Uy(o)) && (s = BK(t)), ur(t) ? (l = La(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = Vy(o))), {
    x: a.left + s.scrollLeft - l.x,
    y: a.top + s.scrollTop - l.y,
    width: a.width,
    height: a.height
  };
}
function VK(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function i(o) {
    n.add(o.name);
    var a = [].concat(o.requires || [], o.requiresIfExists || []);
    a.forEach(function(s) {
      if (!n.has(s)) {
        var l = t.get(s);
        l && i(l);
      }
    }), r.push(o);
  }
  return e.forEach(function(o) {
    n.has(o.name) || i(o);
  }), r;
}
function UK(e) {
  var t = VK(e);
  return nK.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function HK(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function qK(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var LO = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function FO() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function KK(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, o = i === void 0 ? LO : i;
  return function(s, l, c) {
    c === void 0 && (c = o);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, LO, o),
      modifiersData: {},
      elements: {
        reference: s,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], p = !1, h = {
      state: u,
      setOptions: function(y) {
        var S = typeof y == "function" ? y(u.options) : y;
        m(), u.options = Object.assign({}, o, u.options, S), u.scrollParents = {
          reference: Vo(s) ? Hs(s) : s.contextElement ? Hs(s.contextElement) : [],
          popper: Hs(l)
        };
        var w = UK(qK([].concat(r, u.options.modifiers)));
        return u.orderedModifiers = w.filter(function(b) {
          return b.enabled;
        }), g(), h.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!p) {
          var y = u.elements, S = y.reference, w = y.popper;
          if (FO(S, w)) {
            u.rects = {
              reference: WK(S, ic(w), u.options.strategy === "fixed"),
              popper: By(w)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(A) {
              return u.modifiersData[A.name] = Object.assign({}, A.data);
            });
            for (var b = 0; b < u.orderedModifiers.length; b++) {
              if (u.reset === !0) {
                u.reset = !1, b = -1;
                continue;
              }
              var O = u.orderedModifiers[b], E = O.fn, C = O.options, T = C === void 0 ? {} : C, j = O.name;
              typeof E == "function" && (u = E({
                state: u,
                options: T,
                name: j,
                instance: h
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: HK(function() {
        return new Promise(function(v) {
          h.forceUpdate(), v(u);
        });
      }),
      destroy: function() {
        m(), p = !0;
      }
    };
    if (!FO(s, l))
      return h;
    h.setOptions(c).then(function(v) {
      !p && c.onFirstUpdate && c.onFirstUpdate(v);
    });
    function g() {
      u.orderedModifiers.forEach(function(v) {
        var y = v.name, S = v.options, w = S === void 0 ? {} : S, b = v.effect;
        if (typeof b == "function") {
          var O = b({
            state: u,
            name: y,
            instance: h,
            options: w
          }), E = function() {
          };
          d.push(O || E);
        }
      });
    }
    function m() {
      d.forEach(function(v) {
        return v();
      }), d = [];
    }
    return h;
  };
}
var YK = [vK, RK, mK, WA, NK, TK, LK, dK, kK], XA = /* @__PURE__ */ KK({
  defaultModifiers: YK
});
function ZA(e) {
  const {
    elementType: t,
    externalSlotProps: n,
    ownerState: r,
    skipResolvingSlotProps: i = !1,
    ...o
  } = e, a = i ? {} : RA(n, r), {
    props: s,
    internalRef: l
  } = $A({
    ...o,
    externalSlotProps: a
  }), c = Gt(l, a?.ref, e.additionalProps?.ref);
  return DA(t, {
    ...s,
    ref: c
  }, r);
}
function ts(e) {
  return parseInt(_.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null;
}
function GK(e) {
  return typeof e == "function" ? e() : e;
}
const vl = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    children: r,
    container: i,
    disablePortal: o = !1
  } = t, [a, s] = _.useState(null), l = Gt(/* @__PURE__ */ _.isValidElement(r) ? ts(r) : null, n);
  if (Wr(() => {
    o || s(GK(i) || document.body);
  }, [i, o]), Wr(() => {
    if (a && !o)
      return g0(n, a), () => {
        g0(n, null);
      };
  }, [n, a, o]), o) {
    if (/* @__PURE__ */ _.isValidElement(r)) {
      const c = {
        ref: l
      };
      return /* @__PURE__ */ _.cloneElement(r, c);
    }
    return r;
  }
  return a && /* @__PURE__ */ DM.createPortal(r, a);
});
process.env.NODE_ENV !== "production" && (vl.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * The children to render into the `container`.
   */
  children: f.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: f.oneOfType([yi, f.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: f.bool
});
process.env.NODE_ENV !== "production" && (vl.propTypes = v_(vl.propTypes));
function XK(e) {
  return Je("MuiPopper", e);
}
Ge("MuiPopper", ["root"]);
function ZK(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function pd(e) {
  return typeof e == "function" ? e() : e;
}
function Pf(e) {
  return e.nodeType !== void 0;
}
function JK(e) {
  return !Pf(e);
}
const QK = (e) => {
  const {
    classes: t
  } = e;
  return at({
    root: ["root"]
  }, XK, t);
}, eY = {}, tY = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: i,
    direction: o,
    disablePortal: a,
    modifiers: s,
    open: l,
    placement: c,
    popperOptions: u,
    popperRef: d,
    slotProps: p = {},
    slots: h = {},
    TransitionProps: g,
    // @ts-ignore internal logic
    ownerState: m,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...v
  } = t, y = _.useRef(null), S = Gt(y, n), w = _.useRef(null), b = Gt(w, d), O = _.useRef(b);
  Wr(() => {
    O.current = b;
  }, [b]), _.useImperativeHandle(d, () => w.current, []);
  const E = ZK(c, o), [C, T] = _.useState(E), [j, A] = _.useState(pd(r));
  _.useEffect(() => {
    w.current && w.current.forceUpdate();
  }), _.useEffect(() => {
    r && A(pd(r));
  }, [r]), Wr(() => {
    if (!j || !l)
      return;
    const D = (q) => {
      T(q.placement);
    };
    if (process.env.NODE_ENV !== "production" && j && Pf(j) && j.nodeType === 1) {
      const q = j.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && q.top === 0 && q.left === 0 && q.right === 0 && q.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    let $ = [{
      name: "preventOverflow",
      options: {
        altBoundary: a
      }
    }, {
      name: "flip",
      options: {
        altBoundary: a
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: q
      }) => {
        D(q);
      }
    }];
    s != null && ($ = $.concat(s)), u && u.modifiers != null && ($ = $.concat(u.modifiers));
    const F = XA(j, y.current, {
      placement: E,
      ...u,
      modifiers: $
    });
    return O.current(F), () => {
      F.destroy(), O.current(null);
    };
  }, [j, a, s, l, u, E]);
  const M = {
    placement: C
  };
  g !== null && (M.TransitionProps = g);
  const P = QK(t), R = h.root ?? "div", N = ZA({
    elementType: R,
    externalSlotProps: p.root,
    externalForwardedProps: v,
    additionalProps: {
      role: "tooltip",
      ref: S
    },
    ownerState: t,
    className: P.root
  });
  return /* @__PURE__ */ x.jsx(R, {
    ...N,
    children: typeof i == "function" ? i(M) : i
  });
}), JA = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: i,
    container: o,
    direction: a = "ltr",
    disablePortal: s = !1,
    keepMounted: l = !1,
    modifiers: c,
    open: u,
    placement: d = "bottom",
    popperOptions: p = eY,
    popperRef: h,
    style: g,
    transition: m = !1,
    slotProps: v = {},
    slots: y = {},
    ...S
  } = t, [w, b] = _.useState(!0), O = () => {
    b(!1);
  }, E = () => {
    b(!0);
  };
  if (!l && !u && (!m || w))
    return null;
  let C;
  if (o)
    C = o;
  else if (r) {
    const A = pd(r);
    C = A && Pf(A) ? Hn(A).body : Hn(null).body;
  }
  const T = !u && l && (!m || w) ? "none" : void 0, j = m ? {
    in: u,
    onEnter: O,
    onExited: E
  } : void 0;
  return /* @__PURE__ */ x.jsx(vl, {
    disablePortal: s,
    container: C,
    children: /* @__PURE__ */ x.jsx(tY, {
      anchorEl: r,
      direction: a,
      disablePortal: s,
      modifiers: c,
      ref: n,
      open: m ? !w : u,
      placement: d,
      popperOptions: p,
      popperRef: h,
      slotProps: v,
      slots: y,
      ...S,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: T,
        ...g
      },
      TransitionProps: j,
      children: i
    })
  });
});
process.env.NODE_ENV !== "production" && (JA.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: es(f.oneOfType([yi, f.object, f.func]), (e) => {
    if (e.open) {
      const t = pd(e.anchorEl);
      if (t && Pf(t) && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else if (!t || typeof t.getBoundingClientRect != "function" || JK(t) && t.contextElement != null && t.contextElement.nodeType !== 1)
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: f.oneOfType([f.node, f.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: f.oneOfType([yi, f.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: f.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: f.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: f.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: f.arrayOf(f.shape({
    data: f.object,
    effect: f.func,
    enabled: f.bool,
    fn: f.func,
    name: f.any,
    options: f.object,
    phase: f.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: f.arrayOf(f.string),
    requiresIfExists: f.arrayOf(f.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: f.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: f.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: f.shape({
    modifiers: f.array,
    onFirstUpdate: f.func,
    placement: f.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: f.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: br,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: f.shape({
    root: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: f.shape({
    root: f.elementType
  }),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: f.bool
});
const nY = ge(JA, {
  name: "MuiPopper",
  slot: "Root"
})({}), Hy = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = Ng(), i = pt({
    props: t,
    name: "MuiPopper"
  }), {
    anchorEl: o,
    component: a,
    components: s,
    componentsProps: l,
    container: c,
    disablePortal: u,
    keepMounted: d,
    modifiers: p,
    open: h,
    placement: g,
    popperOptions: m,
    popperRef: v,
    transition: y,
    slots: S,
    slotProps: w,
    ...b
  } = i, O = S?.root ?? s?.Root, E = {
    anchorEl: o,
    container: c,
    disablePortal: u,
    keepMounted: d,
    modifiers: p,
    open: h,
    placement: g,
    popperOptions: m,
    popperRef: v,
    transition: y,
    ...b
  };
  return /* @__PURE__ */ x.jsx(nY, {
    as: a,
    direction: r ? "rtl" : "ltr",
    slots: {
      root: O
    },
    slotProps: w ?? l,
    ...E,
    ref: n
  });
});
process.env.NODE_ENV !== "production" && (Hy.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: f.oneOfType([yi, f.object, f.func]),
  /**
   * Popper render function or node.
   */
  children: f.oneOfType([f.node, f.func]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: f.shape({
    Root: f.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: f.shape({
    root: f.oneOfType([f.func, f.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: f.oneOfType([yi, f.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: f.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: f.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: f.arrayOf(f.shape({
    data: f.object,
    effect: f.func,
    enabled: f.bool,
    fn: f.func,
    name: f.any,
    options: f.object,
    phase: f.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: f.arrayOf(f.string),
    requiresIfExists: f.arrayOf(f.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: f.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: f.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: f.shape({
    modifiers: f.array,
    onFirstUpdate: f.func,
    placement: f.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: f.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: br,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: f.shape({
    root: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: f.shape({
    root: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: f.bool
});
function Lc(e) {
  return parseInt(e, 10) || 0;
}
const rY = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function iY(e) {
  for (const t in e)
    return !1;
  return !0;
}
function BO(e) {
  return iY(e) || e.outerHeightStyle === 0 && !e.overflowing;
}
const QA = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    onChange: r,
    maxRows: i,
    minRows: o = 1,
    style: a,
    value: s,
    ...l
  } = t, {
    current: c
  } = _.useRef(s != null), u = _.useRef(null), d = Gt(n, u), p = _.useRef(null), h = _.useRef(null), g = _.useCallback(() => {
    const w = u.current, b = h.current;
    if (!w || !b)
      return;
    const E = pi(w).getComputedStyle(w);
    if (E.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    b.style.width = E.width, b.value = w.value || t.placeholder || "x", b.value.slice(-1) === `
` && (b.value += " ");
    const C = E.boxSizing, T = Lc(E.paddingBottom) + Lc(E.paddingTop), j = Lc(E.borderBottomWidth) + Lc(E.borderTopWidth), A = b.scrollHeight;
    b.value = "x";
    const M = b.scrollHeight;
    let P = A;
    o && (P = Math.max(Number(o) * M, P)), i && (P = Math.min(Number(i) * M, P)), P = Math.max(P, M);
    const R = P + (C === "border-box" ? T + j : 0), N = Math.abs(P - A) <= 1;
    return {
      outerHeightStyle: R,
      overflowing: N
    };
  }, [i, o, t.placeholder]), m = ci(() => {
    const w = u.current, b = g();
    if (!w || !b || BO(b))
      return !1;
    const O = b.outerHeightStyle;
    return p.current != null && p.current !== O;
  }), v = _.useCallback(() => {
    const w = u.current, b = g();
    if (!w || !b || BO(b))
      return;
    const O = b.outerHeightStyle;
    p.current !== O && (p.current = O, w.style.height = `${O}px`), w.style.overflow = b.overflowing ? "hidden" : "";
  }, [g]), y = _.useRef(-1);
  Wr(() => {
    const w = P_(v), b = u?.current;
    if (!b)
      return;
    const O = pi(b);
    O.addEventListener("resize", w);
    let E;
    return typeof ResizeObserver < "u" && (E = new ResizeObserver(() => {
      m() && (E.unobserve(b), cancelAnimationFrame(y.current), v(), y.current = requestAnimationFrame(() => {
        E.observe(b);
      }));
    }), E.observe(b)), () => {
      w.clear(), cancelAnimationFrame(y.current), O.removeEventListener("resize", w), E && E.disconnect();
    };
  }, [g, v, m]), Wr(() => {
    v();
  });
  const S = (w) => {
    c || v();
    const b = w.target, O = b.value.length, E = b.value.endsWith(`
`), C = b.selectionStart === O;
    E && C && b.setSelectionRange(O, O), r && r(w);
  };
  return /* @__PURE__ */ x.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ x.jsx("textarea", {
      value: s,
      onChange: S,
      ref: d,
      rows: o,
      style: a,
      ...l
    }), /* @__PURE__ */ x.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: h,
      tabIndex: -1,
      style: {
        ...rY.shadow,
        ...a,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
process.env.NODE_ENV !== "production" && (QA.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  className: f.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: f.oneOfType([f.number, f.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: f.oneOfType([f.number, f.string]),
  /**
   * @ignore
   */
  onChange: f.func,
  /**
   * @ignore
   */
  placeholder: f.string,
  /**
   * @ignore
   */
  style: f.object,
  /**
   * @ignore
   */
  value: f.oneOfType([f.arrayOf(f.string), f.number, f.string])
});
function ns({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, i) => (r[i] = e[i], n && typeof e[i] > "u" && (r[i] = n[i]), r), {});
}
const Cf = /* @__PURE__ */ _.createContext(void 0);
process.env.NODE_ENV !== "production" && (Cf.displayName = "FormControlContext");
function Jo() {
  return _.useContext(Cf);
}
function zO(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function hd(e, t = !1) {
  return e && (zO(e.value) && e.value !== "" || t && zO(e.defaultValue) && e.defaultValue !== "");
}
function oY(e) {
  return e.startAdornment;
}
function aY(e) {
  return Je("MuiInputBase", e);
}
const Ba = Ge("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var WO;
const Tf = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${Re(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, Af = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, sY = (e) => {
  const {
    classes: t,
    color: n,
    disabled: r,
    error: i,
    endAdornment: o,
    focused: a,
    formControl: s,
    fullWidth: l,
    hiddenLabel: c,
    multiline: u,
    readOnly: d,
    size: p,
    startAdornment: h,
    type: g
  } = e, m = {
    root: ["root", `color${Re(n)}`, r && "disabled", i && "error", l && "fullWidth", a && "focused", s && "formControl", p && p !== "medium" && `size${Re(p)}`, u && "multiline", h && "adornedStart", o && "adornedEnd", c && "hiddenLabel", d && "readOnly"],
    input: ["input", r && "disabled", g === "search" && "inputTypeSearch", u && "inputMultiline", p === "small" && "inputSizeSmall", c && "inputHiddenLabel", h && "inputAdornedStart", o && "inputAdornedEnd", d && "readOnly"]
  };
  return at(m, aY, t);
}, kf = ge("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: Tf
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body1,
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Ba.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: n
    }) => t.multiline && n === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), Mf = ge("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: Af
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = {
    color: "currentColor",
    ...e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }, r = {
    opacity: "0 !important"
  }, i = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": n,
    "&::-moz-placeholder": n,
    // Firefox 19+
    "&::-ms-input-placeholder": n,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Ba.formControl} &`]: {
      "&::-webkit-input-placeholder": r,
      "&::-moz-placeholder": r,
      // Firefox 19+
      "&::-ms-input-placeholder": r,
      // Edge
      "&:focus::-webkit-input-placeholder": i,
      "&:focus::-moz-placeholder": i,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": i
      // Edge
    },
    [`&.${Ba.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: o
      }) => !o.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: o
      }) => o.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), VO = aR({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), jf = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": i,
    autoComplete: o,
    autoFocus: a,
    className: s,
    color: l,
    components: c = {},
    componentsProps: u = {},
    defaultValue: d,
    disabled: p,
    disableInjectingGlobalStyles: h,
    endAdornment: g,
    error: m,
    fullWidth: v = !1,
    id: y,
    inputComponent: S = "input",
    inputProps: w = {},
    inputRef: b,
    margin: O,
    maxRows: E,
    minRows: C,
    multiline: T = !1,
    name: j,
    onBlur: A,
    onChange: M,
    onClick: P,
    onFocus: R,
    onKeyDown: N,
    onKeyUp: D,
    placeholder: $,
    readOnly: F,
    renderSuffix: q,
    rows: B,
    size: L,
    slotProps: Y = {},
    slots: K = {},
    startAdornment: te,
    type: J = "text",
    value: G,
    ...ee
  } = r, re = w.value != null ? w.value : G, {
    current: oe
  } = _.useRef(re != null), W = _.useRef(), U = _.useCallback((ve) => {
    process.env.NODE_ENV !== "production" && ve && ve.nodeName !== "INPUT" && !ve.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), Z = Gt(W, b, w.ref, U), [k, de] = _.useState(!1), ne = Jo();
  process.env.NODE_ENV !== "production" && _.useEffect(() => {
    if (ne)
      return ne.registerEffect();
  }, [ne]);
  const he = ns({
    props: r,
    muiFormControl: ne,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  he.focused = ne ? ne.focused : k, _.useEffect(() => {
    !ne && p && k && (de(!1), A && A());
  }, [ne, p, k, A]);
  const xe = ne && ne.onFilled, Oe = ne && ne.onEmpty, Ee = _.useCallback((ve) => {
    hd(ve) ? xe && xe() : Oe && Oe();
  }, [xe, Oe]);
  Wr(() => {
    oe && Ee({
      value: re
    });
  }, [re, Ee, oe]);
  const et = (ve) => {
    R && R(ve), w.onFocus && w.onFocus(ve), ne && ne.onFocus ? ne.onFocus(ve) : de(!0);
  }, Ie = (ve) => {
    A && A(ve), w.onBlur && w.onBlur(ve), ne && ne.onBlur ? ne.onBlur(ve) : de(!1);
  }, Ce = (ve, ...ln) => {
    if (!oe) {
      const Ht = ve.target || W.current;
      if (Ht == null)
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : zr(1));
      Ee({
        value: Ht.value
      });
    }
    w.onChange && w.onChange(ve, ...ln), M && M(ve, ...ln);
  };
  _.useEffect(() => {
    Ee(W.current);
  }, []);
  const ue = (ve) => {
    W.current && ve.currentTarget === ve.target && W.current.focus(), P && P(ve);
  };
  let Tt = S, tt = w;
  T && Tt === "input" && (B ? (process.env.NODE_ENV !== "production" && (C || E) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), tt = {
    type: void 0,
    minRows: B,
    maxRows: B,
    ...tt
  }) : tt = {
    type: void 0,
    maxRows: E,
    minRows: C,
    ...tt
  }, Tt = QA);
  const an = (ve) => {
    Ee(ve.animationName === "mui-auto-fill-cancel" ? W.current : {
      value: "x"
    });
  };
  _.useEffect(() => {
    ne && ne.setAdornedStart(!!te);
  }, [ne, te]);
  const Jt = {
    ...r,
    color: he.color || "primary",
    disabled: he.disabled,
    endAdornment: g,
    error: he.error,
    focused: he.focused,
    formControl: ne,
    fullWidth: v,
    hiddenLabel: he.hiddenLabel,
    multiline: T,
    size: he.size,
    startAdornment: te,
    type: J
  }, sn = sY(Jt), wn = K.root || c.Root || kf, Ut = Y.root || u.root || {}, On = K.input || c.Input || Mf;
  return tt = {
    ...tt,
    ...Y.input ?? u.input
  }, /* @__PURE__ */ x.jsxs(_.Fragment, {
    children: [!h && typeof VO == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (WO || (WO = /* @__PURE__ */ x.jsx(VO, {}))), /* @__PURE__ */ x.jsxs(wn, {
      ...Ut,
      ref: n,
      onClick: ue,
      ...ee,
      ...!cd(wn) && {
        ownerState: {
          ...Jt,
          ...Ut.ownerState
        }
      },
      className: ie(sn.root, Ut.className, s, F && "MuiInputBase-readOnly"),
      children: [te, /* @__PURE__ */ x.jsx(Cf.Provider, {
        value: null,
        children: /* @__PURE__ */ x.jsx(On, {
          "aria-invalid": he.error,
          "aria-describedby": i,
          autoComplete: o,
          autoFocus: a,
          defaultValue: d,
          disabled: he.disabled,
          id: y,
          onAnimationStart: an,
          name: j,
          placeholder: $,
          readOnly: F,
          required: he.required,
          rows: B,
          value: re,
          onKeyDown: N,
          onKeyUp: D,
          type: J,
          ...tt,
          ...!cd(On) && {
            as: Tt,
            ownerState: {
              ...Jt,
              ...tt.ownerState
            }
          },
          ref: Z,
          className: ie(sn.input, tt.className, F && "MuiInputBase-readOnly"),
          onBlur: Ie,
          onChange: Ce,
          onFocus: et
        })
      }), g, q ? q({
        ...he,
        startAdornment: te
      }) : null]
    })]
  });
});
process.env.NODE_ENV !== "production" && (jf.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * @ignore
   */
  "aria-describedby": f.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: f.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: f.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: f.oneOfType([f.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), f.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: f.shape({
    Input: f.elementType,
    Root: f.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: f.shape({
    input: f.object,
    root: f.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: f.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: f.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: f.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: f.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: f.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: f.bool,
  /**
   * The id of the `input` element.
   */
  id: f.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: Iy,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: f.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: br,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: f.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: f.oneOfType([f.number, f.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: f.oneOfType([f.number, f.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: f.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: f.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: f.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: f.func,
  /**
   * @ignore
   */
  onClick: f.func,
  /**
   * @ignore
   */
  onFocus: f.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: f.func,
  /**
   * @ignore
   */
  onKeyDown: f.func,
  /**
   * @ignore
   */
  onKeyUp: f.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: f.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: f.bool,
  /**
   * @ignore
   */
  renderSuffix: f.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: f.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: f.oneOfType([f.number, f.string]),
  /**
   * The size of the component.
   */
  size: f.oneOfType([f.oneOf(["medium", "small"]), f.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: f.shape({
    input: f.object,
    root: f.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: f.shape({
    input: f.elementType,
    root: f.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: f.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: f.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: f.any
});
function lY(e) {
  return Je("MuiInput", e);
}
const bs = {
  ...Ba,
  ...Ge("MuiInput", ["root", "underline", "input"])
};
function cY(e) {
  return Je("MuiOutlinedInput", e);
}
const Tr = {
  ...Ba,
  ...Ge("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function uY(e) {
  return Je("MuiFilledInput", e);
}
const co = {
  ...Ba,
  ...Ge("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, dY = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
function fY(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function ek(e, t, n, r, i) {
  const o = e[t], a = i || t;
  if (o == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  const l = o.type;
  return typeof l == "function" && !fY(l) && (s = "Did you accidentally use a plain function component for an element instead?"), s !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const rs = es(f.element, ek);
rs.isRequired = es(f.element.isRequired, ek);
const pY = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, tk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = zd(), i = {
    enter: r.transitions.duration.enteringScreen,
    exit: r.transitions.duration.leavingScreen
  }, {
    addEndListener: o,
    appear: a = !0,
    children: s,
    easing: l,
    in: c,
    onEnter: u,
    onEntered: d,
    onEntering: p,
    onExit: h,
    onExited: g,
    onExiting: m,
    style: v,
    timeout: y = i,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: S = Gr,
    ...w
  } = t, b = _.useRef(null), O = Gt(b, ts(s), n), E = (N) => (D) => {
    if (N) {
      const $ = b.current;
      D === void 0 ? N($) : N($, D);
    }
  }, C = E(p), T = E((N, D) => {
    AA(N);
    const $ = ld({
      style: v,
      timeout: y,
      easing: l
    }, {
      mode: "enter"
    });
    N.style.webkitTransition = r.transitions.create("opacity", $), N.style.transition = r.transitions.create("opacity", $), u && u(N, D);
  }), j = E(d), A = E(m), M = E((N) => {
    const D = ld({
      style: v,
      timeout: y,
      easing: l
    }, {
      mode: "exit"
    });
    N.style.webkitTransition = r.transitions.create("opacity", D), N.style.transition = r.transitions.create("opacity", D), h && h(N);
  }), P = E(g), R = (N) => {
    o && o(b.current, N);
  };
  return /* @__PURE__ */ x.jsx(S, {
    appear: a,
    in: c,
    nodeRef: b,
    onEnter: T,
    onEntered: j,
    onEntering: C,
    onExit: M,
    onExited: P,
    onExiting: A,
    addEndListener: R,
    timeout: y,
    ...w,
    children: (N, {
      ownerState: D,
      ...$
    }) => /* @__PURE__ */ _.cloneElement(s, {
      style: {
        opacity: 0,
        visibility: N === "exited" && !c ? "hidden" : void 0,
        ...pY[N],
        ...v,
        ...s.props.style
      },
      ref: O,
      ...$
    })
  });
});
process.env.NODE_ENV !== "production" && (tk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: f.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: f.bool,
  /**
   * A single child content element.
   */
  children: rs.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: f.oneOfType([f.shape({
    enter: f.string,
    exit: f.string
  }), f.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: f.bool,
  /**
   * @ignore
   */
  onEnter: f.func,
  /**
   * @ignore
   */
  onEntered: f.func,
  /**
   * @ignore
   */
  onEntering: f.func,
  /**
   * @ignore
   */
  onExit: f.func,
  /**
   * @ignore
   */
  onExited: f.func,
  /**
   * @ignore
   */
  onExiting: f.func,
  /**
   * @ignore
   */
  style: f.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: f.oneOfType([f.number, f.shape({
    appear: f.number,
    enter: f.number,
    exit: f.number
  })])
});
function hY(e) {
  return Je("MuiBackdrop", e);
}
Ge("MuiBackdrop", ["root", "invisible"]);
const mY = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return at({
    root: ["root", n && "invisible"]
  }, hY, t);
}, gY = ge("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), nk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: i,
    className: o,
    component: a = "div",
    invisible: s = !1,
    open: l,
    components: c = {},
    componentsProps: u = {},
    slotProps: d = {},
    slots: p = {},
    TransitionComponent: h,
    transitionDuration: g,
    ...m
  } = r, v = {
    ...r,
    component: a,
    invisible: s
  }, y = mY(v), S = {
    transition: h,
    root: c.Root,
    ...p
  }, w = {
    ...u,
    ...d
  }, b = {
    component: a,
    slots: S,
    slotProps: w
  }, [O, E] = lt("root", {
    elementType: gY,
    externalForwardedProps: b,
    className: ie(y.root, o),
    ownerState: v
  }), [C, T] = lt("transition", {
    elementType: tk,
    externalForwardedProps: b,
    ownerState: v
  });
  return /* @__PURE__ */ x.jsx(C, {
    in: l,
    timeout: g,
    ...m,
    ...T,
    children: /* @__PURE__ */ x.jsx(O, {
      "aria-hidden": !0,
      ...E,
      classes: y,
      ref: n,
      children: i
    })
  });
});
process.env.NODE_ENV !== "production" && (nk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: f.shape({
    Root: f.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: f.shape({
    root: f.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: f.bool,
  /**
   * If `true`, the component is shown.
   */
  open: f.bool.isRequired,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    root: f.oneOfType([f.func, f.object]),
    transition: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    root: f.elementType,
    transition: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   * @deprecated Use `slots.transition` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  TransitionComponent: f.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: f.oneOfType([f.number, f.shape({
    appear: f.number,
    enter: f.number,
    exit: f.number
  })])
});
function vY(e) {
  return Je("PrivateSwitchBase", e);
}
Ge("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const yY = (e) => {
  const {
    classes: t,
    checked: n,
    disabled: r,
    edge: i
  } = e, o = {
    root: ["root", n && "checked", r && "disabled", i && `edge${Re(i)}`],
    input: ["input"]
  };
  return at(o, vY, t);
}, bY = ge($y, {
  name: "MuiSwitchBase"
})({
  padding: 9,
  borderRadius: "50%",
  variants: [{
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: ({
      edge: e,
      ownerState: t
    }) => e === "start" && t.size !== "small",
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }, {
    props: ({
      edge: e,
      ownerState: t
    }) => e === "end" && t.size !== "small",
    style: {
      marginRight: -12
    }
  }]
}), xY = ge("input", {
  name: "MuiSwitchBase",
  shouldForwardProp: Xn
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
}), rk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    autoFocus: r,
    checked: i,
    checkedIcon: o,
    defaultChecked: a,
    disabled: s,
    disableFocusRipple: l = !1,
    edge: c = !1,
    icon: u,
    id: d,
    inputProps: p,
    inputRef: h,
    name: g,
    onBlur: m,
    onChange: v,
    onFocus: y,
    readOnly: S,
    required: w = !1,
    tabIndex: b,
    type: O,
    value: E,
    slots: C = {},
    slotProps: T = {},
    ...j
  } = t, [A, M] = wu({
    controlled: i,
    default: !!a,
    name: "SwitchBase",
    state: "checked"
  }), P = Jo(), R = (G) => {
    y && y(G), P && P.onFocus && P.onFocus(G);
  }, N = (G) => {
    m && m(G), P && P.onBlur && P.onBlur(G);
  }, D = (G) => {
    if (G.nativeEvent.defaultPrevented)
      return;
    const ee = G.target.checked;
    M(ee), v && v(G, ee);
  };
  let $ = s;
  P && typeof $ > "u" && ($ = P.disabled);
  const F = O === "checkbox" || O === "radio", q = {
    ...t,
    checked: A,
    disabled: $,
    disableFocusRipple: l,
    edge: c
  }, B = yY(q), L = {
    slots: C,
    slotProps: {
      input: p,
      ...T
    }
  }, [Y, K] = lt("root", {
    ref: n,
    elementType: bY,
    className: B.root,
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      ...L,
      component: "span",
      ...j
    },
    getSlotProps: (G) => ({
      ...G,
      onFocus: (ee) => {
        G.onFocus?.(ee), R(ee);
      },
      onBlur: (ee) => {
        G.onBlur?.(ee), N(ee);
      }
    }),
    ownerState: q,
    additionalProps: {
      centerRipple: !0,
      focusRipple: !l,
      disabled: $,
      role: void 0,
      tabIndex: null
    }
  }), [te, J] = lt("input", {
    ref: h,
    elementType: xY,
    className: B.input,
    externalForwardedProps: L,
    getSlotProps: (G) => ({
      ...G,
      onChange: (ee) => {
        G.onChange?.(ee), D(ee);
      }
    }),
    ownerState: q,
    additionalProps: {
      autoFocus: r,
      checked: i,
      defaultChecked: a,
      disabled: $,
      id: F ? d : void 0,
      name: g,
      readOnly: S,
      required: w,
      tabIndex: b,
      type: O,
      ...O === "checkbox" && E === void 0 ? {} : {
        value: E
      }
    }
  });
  return /* @__PURE__ */ x.jsxs(Y, {
    ...K,
    children: [/* @__PURE__ */ x.jsx(te, {
      ...J
    }), A ? o : u]
  });
});
process.env.NODE_ENV !== "production" && (rk.propTypes = {
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: f.bool,
  /**
   * If `true`, the component is checked.
   */
  checked: f.bool,
  /**
   * The icon to display when the component is checked.
   */
  checkedIcon: f.node.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * @ignore
   */
  defaultChecked: f.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: f.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: f.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: f.oneOf(["end", "start", !1]),
  /**
   * The icon to display when the component is unchecked.
   */
  icon: f.node.isRequired,
  /**
   * The id of the `input` element.
   */
  id: f.string,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   */
  inputProps: f.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: br,
  /*
   * @ignore
   */
  name: f.string,
  /**
   * @ignore
   */
  onBlur: f.func,
  /**
   * Callback fired when the state is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: f.func,
  /**
   * @ignore
   */
  onFocus: f.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: f.bool,
  /**
   * If `true`, the `input` element is required.
   */
  required: f.bool,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    input: f.oneOfType([f.func, f.object]),
    root: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    input: f.elementType,
    root: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.object,
  /**
   * @ignore
   */
  tabIndex: f.oneOfType([f.number, f.string]),
  /**
   * The input component prop `type`.
   */
  type: f.string.isRequired,
  /**
   * The value of the component.
   */
  value: f.any
});
const wY = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank"), OY = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox"), SY = Gi(/* @__PURE__ */ x.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function EY(e) {
  return Je("MuiCheckbox", e);
}
const Mh = Ge("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), _Y = (e) => {
  const {
    classes: t,
    indeterminate: n,
    color: r,
    size: i
  } = e, o = {
    root: ["root", n && "indeterminate", `color${Re(r)}`, `size${Re(i)}`]
  }, a = at(o, EY, t);
  return {
    ...t,
    // forward the disabled and checked classes to the SwitchBase
    ...a
  };
}, PY = ge(rk, {
  shouldForwardProp: (e) => Xn(e) || e === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.indeterminate && t.indeterminate, t[`size${Re(n.size)}`], n.color !== "default" && t[`color${Re(n.color)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  variants: [{
    props: {
      color: "default",
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(e.palette).filter(Wo()).map(([t]) => ({
    props: {
      color: t,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(e.palette).filter(Wo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${Mh.checked}, &.${Mh.indeterminate}`]: {
        color: (e.vars || e).palette[t].main
      },
      [`&.${Mh.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: !1
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
}))), CY = /* @__PURE__ */ x.jsx(OY, {}), TY = /* @__PURE__ */ x.jsx(wY, {}), AY = /* @__PURE__ */ x.jsx(SY, {}), ag = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiCheckbox"
  }), {
    checkedIcon: i = CY,
    color: o = "primary",
    icon: a = TY,
    indeterminate: s = !1,
    indeterminateIcon: l = AY,
    inputProps: c,
    size: u = "medium",
    disableRipple: d = !1,
    className: p,
    slots: h = {},
    slotProps: g = {},
    ...m
  } = r, v = s ? l : a, y = s ? l : i, S = {
    ...r,
    disableRipple: d,
    color: o,
    indeterminate: s,
    size: u
  }, w = _Y(S), b = g.input ?? c, [O, E] = lt("root", {
    ref: n,
    elementType: PY,
    className: ie(w.root, p),
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      slots: h,
      slotProps: g,
      ...m
    },
    ownerState: S,
    additionalProps: {
      type: "checkbox",
      icon: /* @__PURE__ */ _.cloneElement(v, {
        fontSize: v.props.fontSize ?? u
      }),
      checkedIcon: /* @__PURE__ */ _.cloneElement(y, {
        fontSize: y.props.fontSize ?? u
      }),
      disableRipple: d,
      slots: h,
      slotProps: {
        input: C_(typeof b == "function" ? b(S) : b, {
          "data-indeterminate": s
        })
      }
    }
  });
  return /* @__PURE__ */ x.jsx(O, {
    ...E,
    classes: w
  });
});
process.env.NODE_ENV !== "production" && (ag.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, the component is checked.
   */
  checked: f.bool,
  /**
   * The icon to display when the component is checked.
   * @default <CheckBoxIcon />
   */
  checkedIcon: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: f.oneOfType([f.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), f.string]),
  /**
   * The default checked state. Use when the component is not controlled.
   */
  defaultChecked: f.bool,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: f.bool,
  /**
   * If `true`, the ripple effect is disabled.
   * @default false
   */
  disableRipple: f.bool,
  /**
   * The icon to display when the component is unchecked.
   * @default <CheckBoxOutlineBlankIcon />
   */
  icon: f.node,
  /**
   * The id of the `input` element.
   */
  id: f.string,
  /**
   * If `true`, the component appears indeterminate.
   * This does not set the native input element to indeterminate due
   * to inconsistent behavior across browsers.
   * However, we set a `data-indeterminate` attribute on the `input`.
   * @default false
   */
  indeterminate: f.bool,
  /**
   * The icon to display when the component is indeterminate.
   * @default <IndeterminateCheckBoxIcon />
   */
  indeterminateIcon: f.node,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @deprecated Use `slotProps.input` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  inputProps: f.object,
  /**
   * Callback fired when the state is changed.
   *
   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: f.func,
  /**
   * If `true`, the `input` element is required.
   * @default false
   */
  required: f.bool,
  /**
   * The size of the component.
   * `small` is equivalent to the dense checkbox styling.
   * @default 'medium'
   */
  size: f.oneOfType([f.oneOf(["medium", "small"]), f.string]),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    input: f.oneOfType([f.func, f.object]),
    root: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    input: f.elementType,
    root: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The value of the component. The DOM API casts this to a string.
   * The browser uses "on" as the default value.
   */
  value: f.any
});
function ik(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function kY(e) {
  const t = Hn(e);
  return t.body === e ? pi(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function qs(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function UO(e) {
  return parseInt(pi(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function MY(e) {
  const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return n || r;
}
function HO(e, t, n, r, i) {
  const o = [t, n, ...r];
  [].forEach.call(e.children, (a) => {
    const s = !o.includes(a), l = !MY(a);
    s && l && qs(a, i);
  });
}
function jh(e, t) {
  let n = -1;
  return e.some((r, i) => t(r) ? (n = i, !0) : !1), n;
}
function jY(e, t) {
  const n = [], r = e.container;
  if (!t.disableScrollLock) {
    if (kY(r)) {
      const a = ik(pi(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${UO(r) + a}px`;
      const s = Hn(r).querySelectorAll(".mui-fixed");
      [].forEach.call(s, (l) => {
        n.push({
          value: l.style.paddingRight,
          property: "padding-right",
          el: l
        }), l.style.paddingRight = `${UO(l) + a}px`;
      });
    }
    let o;
    if (r.parentNode instanceof DocumentFragment)
      o = Hn(r).body;
    else {
      const a = r.parentElement, s = pi(r);
      o = a?.nodeName === "HTML" && s.getComputedStyle(a).overflowY === "scroll" ? a : r;
    }
    n.push({
      value: o.style.overflow,
      property: "overflow",
      el: o
    }, {
      value: o.style.overflowX,
      property: "overflow-x",
      el: o
    }, {
      value: o.style.overflowY,
      property: "overflow-y",
      el: o
    }), o.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: o,
      el: a,
      property: s
    }) => {
      o ? a.style.setProperty(s, o) : a.style.removeProperty(s);
    });
  };
}
function NY(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class DY {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1)
      return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && qs(t.modalRef, !1);
    const i = NY(n);
    HO(n, t.mount, t.modalRef, i, !0);
    const o = jh(this.containers, (a) => a.container === n);
    return o !== -1 ? (this.containers[o].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: i
    }), r);
  }
  mount(t, n) {
    const r = jh(this.containers, (o) => o.modals.includes(t)), i = this.containers[r];
    i.restore || (i.restore = jY(i, n));
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1)
      return r;
    const i = jh(this.containers, (a) => a.modals.includes(t)), o = this.containers[i];
    if (o.modals.splice(o.modals.indexOf(t), 1), this.modals.splice(r, 1), o.modals.length === 0)
      o.restore && o.restore(), t.modalRef && qs(t.modalRef, n), HO(o.container, t.mount, t.modalRef, o.hiddenSiblings, !1), this.containers.splice(i, 1);
    else {
      const a = o.modals[o.modals.length - 1];
      a.modalRef && qs(a.modalRef, !1);
    }
    return r;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const RY = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function IY(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function $Y(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function LY(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || $Y(e));
}
function FY(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(RY)).forEach((r, i) => {
    const o = IY(r);
    o === -1 || !LY(r) || (o === 0 ? t.push(r) : n.push({
      documentOrder: i,
      tabIndex: o,
      node: r
    }));
  }), n.sort((r, i) => r.tabIndex === i.tabIndex ? r.documentOrder - i.documentOrder : r.tabIndex - i.tabIndex).map((r) => r.node).concat(t);
}
function BY() {
  return !0;
}
function md(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: i = !1,
    getTabbable: o = FY,
    isEnabled: a = BY,
    open: s
  } = e, l = _.useRef(!1), c = _.useRef(null), u = _.useRef(null), d = _.useRef(null), p = _.useRef(null), h = _.useRef(!1), g = _.useRef(null), m = Gt(ts(t), g), v = _.useRef(null);
  _.useEffect(() => {
    !s || !g.current || (h.current = !n);
  }, [n, s]), _.useEffect(() => {
    if (!s || !g.current)
      return;
    const w = Hn(g.current);
    return g.current.contains(w.activeElement) || (g.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), g.current.setAttribute("tabIndex", "-1")), h.current && g.current.focus()), () => {
      i || (d.current && d.current.focus && (l.current = !0, d.current.focus()), d.current = null);
    };
  }, [s]), _.useEffect(() => {
    if (!s || !g.current)
      return;
    const w = Hn(g.current), b = (C) => {
      v.current = C, !(r || !a() || C.key !== "Tab") && w.activeElement === g.current && C.shiftKey && (l.current = !0, u.current && u.current.focus());
    }, O = () => {
      const C = g.current;
      if (C === null)
        return;
      if (!w.hasFocus() || !a() || l.current) {
        l.current = !1;
        return;
      }
      if (C.contains(w.activeElement) || r && w.activeElement !== c.current && w.activeElement !== u.current)
        return;
      if (w.activeElement !== p.current)
        p.current = null;
      else if (p.current !== null)
        return;
      if (!h.current)
        return;
      let T = [];
      if ((w.activeElement === c.current || w.activeElement === u.current) && (T = o(g.current)), T.length > 0) {
        const j = !!(v.current?.shiftKey && v.current?.key === "Tab"), A = T[0], M = T[T.length - 1];
        typeof A != "string" && typeof M != "string" && (j ? M.focus() : A.focus());
      } else
        C.focus();
    };
    w.addEventListener("focusin", O), w.addEventListener("keydown", b, !0);
    const E = setInterval(() => {
      w.activeElement && w.activeElement.tagName === "BODY" && O();
    }, 50);
    return () => {
      clearInterval(E), w.removeEventListener("focusin", O), w.removeEventListener("keydown", b, !0);
    };
  }, [n, r, i, a, s, o]);
  const y = (w) => {
    d.current === null && (d.current = w.relatedTarget), h.current = !0, p.current = w.target;
    const b = t.props.onFocus;
    b && b(w);
  }, S = (w) => {
    d.current === null && (d.current = w.relatedTarget), h.current = !0;
  };
  return /* @__PURE__ */ x.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ x.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: S,
      ref: c,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ _.cloneElement(t, {
      ref: m,
      onFocus: y
    }), /* @__PURE__ */ x.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: S,
      ref: u,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && (md.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * A single child content element.
   */
  children: rs,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: f.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: f.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: f.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: f.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: f.func,
  /**
   * If `true`, focus is locked.
   */
  open: f.bool.isRequired
});
process.env.NODE_ENV !== "production" && (md.propTypes = v_(md.propTypes));
function zY(e) {
  return typeof e == "function" ? e() : e;
}
function WY(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const qO = () => {
}, Fc = new DY();
function VY(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: r = !1,
    closeAfterTransition: i = !1,
    onTransitionEnter: o,
    onTransitionExited: a,
    children: s,
    onClose: l,
    open: c,
    rootRef: u
  } = e, d = _.useRef({}), p = _.useRef(null), h = _.useRef(null), g = Gt(h, u), [m, v] = _.useState(!c), y = WY(s);
  let S = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (S = !1);
  const w = () => Hn(p.current), b = () => (d.current.modalRef = h.current, d.current.mount = p.current, d.current), O = () => {
    Fc.mount(b(), {
      disableScrollLock: r
    }), h.current && (h.current.scrollTop = 0);
  }, E = ci(() => {
    const D = zY(t) || w().body;
    Fc.add(b(), D), h.current && O();
  }), C = () => Fc.isTopModal(b()), T = ci((D) => {
    p.current = D, D && (c && C() ? O() : h.current && qs(h.current, S));
  }), j = _.useCallback(() => {
    Fc.remove(b(), S);
  }, [S]);
  _.useEffect(() => () => {
    j();
  }, [j]), _.useEffect(() => {
    c ? E() : (!y || !i) && j();
  }, [c, j, y, i, E]);
  const A = (D) => ($) => {
    D.onKeyDown?.($), !($.key !== "Escape" || $.which === 229 || // Wait until IME is settled.
    !C()) && (n || ($.stopPropagation(), l && l($, "escapeKeyDown")));
  }, M = (D) => ($) => {
    D.onClick?.($), $.target === $.currentTarget && l && l($, "backdropClick");
  };
  return {
    getRootProps: (D = {}) => {
      const $ = IA(e);
      delete $.onTransitionEnter, delete $.onTransitionExited;
      const F = {
        ...$,
        ...D
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...F,
        onKeyDown: A(F),
        ref: g
      };
    },
    getBackdropProps: (D = {}) => {
      const $ = D;
      return {
        "aria-hidden": !0,
        ...$,
        onClick: M($),
        open: c
      };
    },
    getTransitionProps: () => {
      const D = () => {
        v(!1), o && o();
      }, $ = () => {
        v(!0), a && a(), i && j();
      };
      return {
        onEnter: Eb(D, s?.props.onEnter ?? qO),
        onExited: Eb($, s?.props.onExited ?? qO)
      };
    },
    rootRef: g,
    portalRef: T,
    isTopModal: C,
    exited: m,
    hasTransition: y
  };
}
function UY(e) {
  return Je("MuiModal", e);
}
Ge("MuiModal", ["root", "hidden", "backdrop"]);
const HY = (e) => {
  const {
    open: t,
    exited: n,
    classes: r
  } = e;
  return at({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, UY, r);
}, qY = ge("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(Ct(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), KY = ge(nk, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
}), ok = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: i = KY,
    BackdropProps: o,
    classes: a,
    className: s,
    closeAfterTransition: l = !1,
    children: c,
    container: u,
    component: d,
    components: p = {},
    componentsProps: h = {},
    disableAutoFocus: g = !1,
    disableEnforceFocus: m = !1,
    disableEscapeKeyDown: v = !1,
    disablePortal: y = !1,
    disableRestoreFocus: S = !1,
    disableScrollLock: w = !1,
    hideBackdrop: b = !1,
    keepMounted: O = !1,
    onClose: E,
    onTransitionEnter: C,
    onTransitionExited: T,
    open: j,
    slotProps: A = {},
    slots: M = {},
    // eslint-disable-next-line react/prop-types
    theme: P,
    ...R
  } = r, N = {
    ...r,
    closeAfterTransition: l,
    disableAutoFocus: g,
    disableEnforceFocus: m,
    disableEscapeKeyDown: v,
    disablePortal: y,
    disableRestoreFocus: S,
    disableScrollLock: w,
    hideBackdrop: b,
    keepMounted: O
  }, {
    getRootProps: D,
    getBackdropProps: $,
    getTransitionProps: F,
    portalRef: q,
    isTopModal: B,
    exited: L,
    hasTransition: Y
  } = VY({
    ...N,
    rootRef: n
  }), K = {
    ...N,
    exited: L
  }, te = HY(K), J = {};
  if (c.props.tabIndex === void 0 && (J.tabIndex = "-1"), Y) {
    const {
      onEnter: U,
      onExited: Z
    } = F();
    J.onEnter = U, J.onExited = Z;
  }
  const G = {
    slots: {
      root: p.Root,
      backdrop: p.Backdrop,
      ...M
    },
    slotProps: {
      ...h,
      ...A
    }
  }, [ee, re] = lt("root", {
    ref: n,
    elementType: qY,
    externalForwardedProps: {
      ...G,
      ...R,
      component: d
    },
    getSlotProps: D,
    ownerState: K,
    className: ie(s, te?.root, !K.open && K.exited && te?.hidden)
  }), [oe, W] = lt("backdrop", {
    ref: o?.ref,
    elementType: i,
    externalForwardedProps: G,
    shouldForwardComponentProp: !0,
    additionalProps: o,
    getSlotProps: (U) => $({
      ...U,
      onClick: (Z) => {
        U?.onClick && U.onClick(Z);
      }
    }),
    className: ie(o?.className, te?.backdrop),
    ownerState: K
  });
  return !O && !j && (!Y || L) ? null : /* @__PURE__ */ x.jsx(vl, {
    ref: q,
    container: u,
    disablePortal: y,
    children: /* @__PURE__ */ x.jsxs(ee, {
      ...re,
      children: [!b && i ? /* @__PURE__ */ x.jsx(oe, {
        ...W
      }) : null, /* @__PURE__ */ x.jsx(md, {
        disableEnforceFocus: m,
        disableAutoFocus: g,
        disableRestoreFocus: S,
        isEnabled: B,
        open: j,
        children: /* @__PURE__ */ _.cloneElement(c, J)
      })]
    })
  });
});
process.env.NODE_ENV !== "production" && (ok.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: f.elementType,
  /**
   * Props applied to the [`Backdrop`](https://mui.com/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: f.object,
  /**
   * A single child content element.
   */
  children: rs.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: f.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: f.shape({
    Backdrop: f.elementType,
    Root: f.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: f.shape({
    backdrop: f.oneOfType([f.func, f.object]),
    root: f.oneOfType([f.func, f.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: f.oneOfType([yi, f.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: f.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: f.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: f.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: f.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: f.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: f.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: f.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: f.bool,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: f.func,
  /**
   * A function called when a transition enters.
   */
  onTransitionEnter: f.func,
  /**
   * A function called when a transition has exited.
   */
  onTransitionExited: f.func,
  /**
   * If `true`, the component is shown.
   */
  open: f.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: f.shape({
    backdrop: f.oneOfType([f.func, f.object]),
    root: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: f.shape({
    backdrop: f.elementType,
    root: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object])
});
const KO = Ge("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), YY = (e) => {
  const {
    classes: t,
    disableUnderline: n,
    startAdornment: r,
    endAdornment: i,
    size: o,
    hiddenLabel: a,
    multiline: s
  } = e, l = {
    root: ["root", !n && "underline", r && "adornedStart", i && "adornedEnd", o === "small" && `size${Re(o)}`, a && "hiddenLabel", s && "multiline"],
    input: ["input"]
  }, c = at(l, uY, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...c
  };
}, GY = ge(kf, {
  shouldForwardProp: (e) => Xn(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...Tf(e, t), !n.disableUnderline && t.underline];
  }
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", i = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", o = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : i,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      }
    },
    [`&.${co.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
    },
    [`&.${co.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : o
    },
    variants: [{
      props: ({
        ownerState: a
      }) => !a.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${co.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${co.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${co.disabled}, .${co.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
        },
        [`&.${co.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Wo()).map(([a]) => ({
      props: {
        disableUnderline: !1,
        color: a
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[a]?.main}`
        }
      }
    })), {
      props: ({
        ownerState: a
      }) => a.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: a,
        size: s
      }) => a.multiline && s === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel && a.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), XY = ge(Mf, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: Af
})(Ct(({
  theme: e
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), Nf = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiFilledInput"
  }), {
    disableUnderline: i = !1,
    components: o = {},
    componentsProps: a,
    fullWidth: s = !1,
    hiddenLabel: l,
    // declare here to prevent spreading to DOM
    inputComponent: c = "input",
    multiline: u = !1,
    slotProps: d,
    slots: p = {},
    type: h = "text",
    ...g
  } = r, m = {
    ...r,
    disableUnderline: i,
    fullWidth: s,
    inputComponent: c,
    multiline: u,
    type: h
  }, v = YY(r), y = {
    root: {
      ownerState: m
    },
    input: {
      ownerState: m
    }
  }, S = d ?? a ? pn(y, d ?? a) : y, w = p.root ?? o.Root ?? GY, b = p.input ?? o.Input ?? XY;
  return /* @__PURE__ */ x.jsx(jf, {
    slots: {
      root: w,
      input: b
    },
    slotProps: S,
    fullWidth: s,
    inputComponent: c,
    multiline: u,
    ref: n,
    type: h,
    ...g,
    classes: v
  });
});
process.env.NODE_ENV !== "production" && (Nf.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: f.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: f.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: f.oneOfType([f.oneOf(["primary", "secondary"]), f.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: f.shape({
    Input: f.elementType,
    Root: f.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: f.shape({
    input: f.object,
    root: f.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: f.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: f.bool,
  /**
   * If `true`, the input will not have an underline.
   * @default false
   */
  disableUnderline: f.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: f.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: f.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: f.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: f.bool,
  /**
   * The id of the `input` element.
   */
  id: f.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: f.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: f.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: br,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: f.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: f.oneOfType([f.number, f.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: f.oneOfType([f.number, f.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: f.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: f.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: f.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: f.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: f.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: f.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: f.oneOfType([f.number, f.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: f.shape({
    input: f.object,
    root: f.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: f.shape({
    input: f.elementType,
    root: f.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: f.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: f.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: f.any
});
Nf.muiName = "Input";
function ZY(e) {
  return Je("MuiFormControl", e);
}
Ge("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const JY = (e) => {
  const {
    classes: t,
    margin: n,
    fullWidth: r
  } = e, i = {
    root: ["root", n !== "none" && `margin${Re(n)}`, r && "fullWidth"]
  };
  return at(i, ZY, t);
}, QY = ge("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`margin${Re(n.margin)}`], n.fullWidth && t.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), qy = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiFormControl"
  }), {
    children: i,
    className: o,
    color: a = "primary",
    component: s = "div",
    disabled: l = !1,
    error: c = !1,
    focused: u,
    fullWidth: d = !1,
    hiddenLabel: p = !1,
    margin: h = "none",
    required: g = !1,
    size: m = "medium",
    variant: v = "outlined",
    ...y
  } = r, S = {
    ...r,
    color: a,
    component: s,
    disabled: l,
    error: c,
    fullWidth: d,
    hiddenLabel: p,
    margin: h,
    required: g,
    size: m,
    variant: v
  }, w = JY(S), [b, O] = _.useState(() => {
    let $ = !1;
    return i && _.Children.forEach(i, (F) => {
      if (!Qf(F, ["Input", "Select"]))
        return;
      const q = Qf(F, ["Select"]) ? F.props.input : F;
      q && oY(q.props) && ($ = !0);
    }), $;
  }), [E, C] = _.useState(() => {
    let $ = !1;
    return i && _.Children.forEach(i, (F) => {
      Qf(F, ["Input", "Select"]) && (hd(F.props, !0) || hd(F.props.inputProps, !0)) && ($ = !0);
    }), $;
  }), [T, j] = _.useState(!1);
  l && T && j(!1);
  const A = u !== void 0 && !l ? u : T;
  let M;
  const P = _.useRef(!1);
  process.env.NODE_ENV !== "production" && (M = () => (P.current && console.error(["MUI: There are multiple `InputBase` components inside a FormControl.", "This creates visual inconsistencies, only use one `InputBase`."].join(`
`)), P.current = !0, () => {
    P.current = !1;
  }));
  const R = _.useCallback(() => {
    C(!0);
  }, []), N = _.useCallback(() => {
    C(!1);
  }, []), D = _.useMemo(() => ({
    adornedStart: b,
    setAdornedStart: O,
    color: a,
    disabled: l,
    error: c,
    filled: E,
    focused: A,
    fullWidth: d,
    hiddenLabel: p,
    size: m,
    onBlur: () => {
      j(!1);
    },
    onFocus: () => {
      j(!0);
    },
    onEmpty: N,
    onFilled: R,
    registerEffect: M,
    required: g,
    variant: v
  }), [b, a, l, c, E, A, d, p, M, N, R, g, m, v]);
  return /* @__PURE__ */ x.jsx(Cf.Provider, {
    value: D,
    children: /* @__PURE__ */ x.jsx(QY, {
      as: s,
      ownerState: S,
      className: ie(w.root, o),
      ref: n,
      ...y,
      children: i
    })
  });
});
process.env.NODE_ENV !== "production" && (qy.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: f.oneOfType([f.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), f.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   * @default false
   */
  disabled: f.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: f.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: f.bool,
  /**
   * If `true`, the component will take up the full width of its container.
   * @default false
   */
  fullWidth: f.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: f.bool,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: f.oneOf(["dense", "none", "normal"]),
  /**
   * If `true`, the label will indicate that the `input` is required.
   * @default false
   */
  required: f.bool,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: f.oneOfType([f.oneOf(["medium", "small"]), f.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: f.oneOf(["filled", "outlined", "standard"])
});
function eG(e) {
  return Je("MuiFormHelperText", e);
}
const YO = Ge("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var GO;
const tG = (e) => {
  const {
    classes: t,
    contained: n,
    size: r,
    disabled: i,
    error: o,
    filled: a,
    focused: s,
    required: l
  } = e, c = {
    root: ["root", i && "disabled", o && "error", r && `size${Re(r)}`, n && "contained", s && "focused", a && "filled", l && "required"]
  };
  return at(c, eG, t);
}, nG = ge("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size && t[`size${Re(n.size)}`], n.contained && t.contained, n.filled && t.filled];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${YO.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${YO.error}`]: {
    color: (e.vars || e).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
}))), ak = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiFormHelperText"
  }), {
    children: i,
    className: o,
    component: a = "p",
    disabled: s,
    error: l,
    filled: c,
    focused: u,
    margin: d,
    required: p,
    variant: h,
    ...g
  } = r, m = Jo(), v = ns({
    props: r,
    muiFormControl: m,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), y = {
    ...r,
    component: a,
    contained: v.variant === "filled" || v.variant === "outlined",
    variant: v.variant,
    size: v.size,
    disabled: v.disabled,
    error: v.error,
    filled: v.filled,
    focused: v.focused,
    required: v.required
  };
  delete y.ownerState;
  const S = tG(y);
  return /* @__PURE__ */ x.jsx(nG, {
    as: a,
    className: ie(S.root, o),
    ref: n,
    ...g,
    ownerState: y,
    children: i === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      GO || (GO = /* @__PURE__ */ x.jsx("span", {
        className: "notranslate",
        "aria-hidden": !0,
        children: ""
      }))
    ) : i
  });
});
process.env.NODE_ENV !== "production" && (ak.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   *
   * If `' '` is provided, the component reserves one line height for displaying a future message.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * If `true`, the helper text should be displayed in a disabled state.
   */
  disabled: f.bool,
  /**
   * If `true`, helper text should be displayed in an error state.
   */
  error: f.bool,
  /**
   * If `true`, the helper text should use filled classes key.
   */
  filled: f.bool,
  /**
   * If `true`, the helper text should use focused classes key.
   */
  focused: f.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: f.oneOf(["dense"]),
  /**
   * If `true`, the helper text should use required classes key.
   */
  required: f.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The variant to use.
   */
  variant: f.oneOfType([f.oneOf(["filled", "outlined", "standard"]), f.string])
});
function rG(e) {
  return Je("MuiFormLabel", e);
}
const Ks = Ge("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), iG = (e) => {
  const {
    classes: t,
    color: n,
    focused: r,
    disabled: i,
    error: o,
    filled: a,
    required: s
  } = e, l = {
    root: ["root", `color${Re(n)}`, i && "disabled", o && "error", a && "filled", r && "focused", s && "required"],
    asterisk: ["asterisk", o && "error"]
  };
  return at(l, rG, t);
}, oG = ge("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(e.palette).filter(Wo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${Ks.focused}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${Ks.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      },
      [`&.${Ks.error}`]: {
        color: (e.vars || e).palette.error.main
      }
    }
  }]
}))), aG = ge("span", {
  name: "MuiFormLabel",
  slot: "Asterisk"
})(Ct(({
  theme: e
}) => ({
  [`&.${Ks.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), sk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiFormLabel"
  }), {
    children: i,
    className: o,
    color: a,
    component: s = "label",
    disabled: l,
    error: c,
    filled: u,
    focused: d,
    required: p,
    ...h
  } = r, g = Jo(), m = ns({
    props: r,
    muiFormControl: g,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), v = {
    ...r,
    color: m.color || "primary",
    component: s,
    disabled: m.disabled,
    error: m.error,
    filled: m.filled,
    focused: m.focused,
    required: m.required
  }, y = iG(v);
  return /* @__PURE__ */ x.jsxs(oG, {
    as: s,
    ownerState: v,
    className: ie(y.root, o),
    ref: n,
    ...h,
    children: [i, m.required && /* @__PURE__ */ x.jsxs(aG, {
      ownerState: v,
      "aria-hidden": !0,
      className: y.asterisk,
      children: ["", "*"]
    })]
  });
});
process.env.NODE_ENV !== "production" && (sk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: f.oneOfType([f.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), f.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * If `true`, the label should be displayed in a disabled state.
   */
  disabled: f.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: f.bool,
  /**
   * If `true`, the label should use filled classes key.
   */
  filled: f.bool,
  /**
   * If `true`, the input of this label is focused (used by `FormGroup` components).
   */
  focused: f.bool,
  /**
   * If `true`, the label will indicate that the `input` is required.
   */
  required: f.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object])
});
function sg(e) {
  return `scale(${e}, ${e ** 2})`;
}
const sG = {
  entering: {
    opacity: 1,
    transform: sg(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, Nh = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), yl = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    addEndListener: r,
    appear: i = !0,
    children: o,
    easing: a,
    in: s,
    onEnter: l,
    onEntered: c,
    onEntering: u,
    onExit: d,
    onExited: p,
    onExiting: h,
    style: g,
    timeout: m = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: v = Gr,
    ...y
  } = t, S = va(), w = _.useRef(), b = zd(), O = _.useRef(null), E = Gt(O, ts(o), n), C = (D) => ($) => {
    if (D) {
      const F = O.current;
      $ === void 0 ? D(F) : D(F, $);
    }
  }, T = C(u), j = C((D, $) => {
    AA(D);
    const {
      duration: F,
      delay: q,
      easing: B
    } = ld({
      style: g,
      timeout: m,
      easing: a
    }, {
      mode: "enter"
    });
    let L;
    m === "auto" ? (L = b.transitions.getAutoHeightDuration(D.clientHeight), w.current = L) : L = F, D.style.transition = [b.transitions.create("opacity", {
      duration: L,
      delay: q
    }), b.transitions.create("transform", {
      duration: Nh ? L : L * 0.666,
      delay: q,
      easing: B
    })].join(","), l && l(D, $);
  }), A = C(c), M = C(h), P = C((D) => {
    const {
      duration: $,
      delay: F,
      easing: q
    } = ld({
      style: g,
      timeout: m,
      easing: a
    }, {
      mode: "exit"
    });
    let B;
    m === "auto" ? (B = b.transitions.getAutoHeightDuration(D.clientHeight), w.current = B) : B = $, D.style.transition = [b.transitions.create("opacity", {
      duration: B,
      delay: F
    }), b.transitions.create("transform", {
      duration: Nh ? B : B * 0.666,
      delay: Nh ? F : F || B * 0.333,
      easing: q
    })].join(","), D.style.opacity = 0, D.style.transform = sg(0.75), d && d(D);
  }), R = C(p), N = (D) => {
    m === "auto" && S.start(w.current || 0, D), r && r(O.current, D);
  };
  return /* @__PURE__ */ x.jsx(v, {
    appear: i,
    in: s,
    nodeRef: O,
    onEnter: j,
    onEntered: A,
    onEntering: T,
    onExit: P,
    onExited: R,
    onExiting: M,
    addEndListener: N,
    timeout: m === "auto" ? null : m,
    ...y,
    children: (D, {
      ownerState: $,
      ...F
    }) => /* @__PURE__ */ _.cloneElement(o, {
      style: {
        opacity: 0,
        transform: sg(0.75),
        visibility: D === "exited" && !s ? "hidden" : void 0,
        ...sG[D],
        ...g,
        ...o.props.style
      },
      ref: E,
      ...F
    })
  });
});
process.env.NODE_ENV !== "production" && (yl.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: f.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: f.bool,
  /**
   * A single child content element.
   */
  children: rs.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: f.oneOfType([f.shape({
    enter: f.string,
    exit: f.string
  }), f.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: f.bool,
  /**
   * @ignore
   */
  onEnter: f.func,
  /**
   * @ignore
   */
  onEntered: f.func,
  /**
   * @ignore
   */
  onEntering: f.func,
  /**
   * @ignore
   */
  onExit: f.func,
  /**
   * @ignore
   */
  onExited: f.func,
  /**
   * @ignore
   */
  onExiting: f.func,
  /**
   * @ignore
   */
  style: f.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: f.oneOfType([f.oneOf(["auto"]), f.number, f.shape({
    appear: f.number,
    enter: f.number,
    exit: f.number
  })])
});
yl && (yl.muiSupportAuto = !0);
const lG = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, i = at({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, lY, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...i
  };
}, cG = ge(kf, {
  shouldForwardProp: (e) => Xn(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...Tf(e, t), !n.disableUnderline && t.underline];
  }
})(Ct(({
  theme: e
}) => {
  let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (n = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: r
      }) => r.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: r
      }) => !r.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${bs.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${bs.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${bs.disabled}, .${bs.error}):before`]: {
          borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${n}`
          }
        },
        [`&.${bs.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Wo()).map(([r]) => ({
      props: {
        color: r,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[r].main}`
        }
      }
    }))]
  };
})), uG = ge(Mf, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: Af
})({}), Df = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: i = !1,
    components: o = {},
    componentsProps: a,
    fullWidth: s = !1,
    inputComponent: l = "input",
    multiline: c = !1,
    slotProps: u,
    slots: d = {},
    type: p = "text",
    ...h
  } = r, g = lG(r), v = {
    root: {
      ownerState: {
        disableUnderline: i
      }
    }
  }, y = u ?? a ? pn(u ?? a, v) : v, S = d.root ?? o.Root ?? cG, w = d.input ?? o.Input ?? uG;
  return /* @__PURE__ */ x.jsx(jf, {
    slots: {
      root: S,
      input: w
    },
    slotProps: y,
    fullWidth: s,
    inputComponent: l,
    multiline: c,
    ref: n,
    type: p,
    ...h,
    classes: g
  });
});
process.env.NODE_ENV !== "production" && (Df.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: f.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: f.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: f.oneOfType([f.oneOf(["primary", "secondary"]), f.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: f.shape({
    Input: f.elementType,
    Root: f.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: f.shape({
    input: f.object,
    root: f.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: f.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: f.bool,
  /**
   * If `true`, the `input` will not have an underline.
   * @default false
   */
  disableUnderline: f.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: f.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: f.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: f.bool,
  /**
   * The id of the `input` element.
   */
  id: f.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: f.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: f.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: br,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: f.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: f.oneOfType([f.number, f.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: f.oneOfType([f.number, f.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: f.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: f.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: f.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: f.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: f.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: f.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: f.oneOfType([f.number, f.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: f.shape({
    input: f.object,
    root: f.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: f.shape({
    input: f.elementType,
    root: f.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: f.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: f.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: f.any
});
Df.muiName = "Input";
function dG(e) {
  return Je("MuiInputLabel", e);
}
Ge("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const fG = (e) => {
  const {
    classes: t,
    formControl: n,
    size: r,
    shrink: i,
    disableAnimation: o,
    variant: a,
    required: s
  } = e, l = {
    root: ["root", n && "formControl", !o && "animated", i && "shrink", r && r !== "medium" && `size${Re(r)}`, a],
    asterisk: [s && "asterisk"]
  }, c = at(l, dG, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...c
  };
}, pG = ge(sk, {
  shouldForwardProp: (e) => Xn(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Ks.asterisk}`]: t.asterisk
    }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
  }
})(Ct(({
  theme: e
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: e.transitions.create(["color", "transform", "max-width"], {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "filled" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n,
      size: r
    }) => t === "filled" && n.shrink && r === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "outlined" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), lk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: i = !1,
    margin: o,
    shrink: a,
    variant: s,
    className: l,
    ...c
  } = r, u = Jo();
  let d = a;
  typeof d > "u" && u && (d = u.filled || u.focused || u.adornedStart);
  const p = ns({
    props: r,
    muiFormControl: u,
    states: ["size", "variant", "required", "focused"]
  }), h = {
    ...r,
    disableAnimation: i,
    formControl: u,
    shrink: d,
    size: p.size,
    variant: p.variant,
    required: p.required,
    focused: p.focused
  }, g = fG(h);
  return /* @__PURE__ */ x.jsx(pG, {
    "data-shrink": d,
    ref: n,
    className: ie(g.root, l),
    ...c,
    ownerState: h,
    classes: g
  });
});
process.env.NODE_ENV !== "production" && (lk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: f.oneOfType([f.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), f.string]),
  /**
   * If `true`, the transition animation is disabled.
   * @default false
   */
  disableAnimation: f.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: f.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: f.bool,
  /**
   * If `true`, the `input` of this label is focused.
   */
  focused: f.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: f.oneOf(["dense"]),
  /**
   * if `true`, the label will indicate that the `input` is required.
   */
  required: f.bool,
  /**
   * If `true`, the label is shrunk.
   */
  shrink: f.bool,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: f.oneOfType([f.oneOf(["medium", "small"]), f.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The variant to use.
   */
  variant: f.oneOf(["filled", "outlined", "standard"])
});
const bl = /* @__PURE__ */ _.createContext({});
process.env.NODE_ENV !== "production" && (bl.displayName = "ListContext");
function hG(e) {
  return Je("MuiList", e);
}
Ge("MuiList", ["root", "padding", "dense", "subheader"]);
const mG = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: r,
    subheader: i
  } = e;
  return at({
    root: ["root", !n && "padding", r && "dense", i && "subheader"]
  }, hG, t);
}, gG = ge("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: e
    }) => !e.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: e
    }) => e.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), ck = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiList"
  }), {
    children: i,
    className: o,
    component: a = "ul",
    dense: s = !1,
    disablePadding: l = !1,
    subheader: c,
    ...u
  } = r, d = _.useMemo(() => ({
    dense: s
  }), [s]), p = {
    ...r,
    component: a,
    dense: s,
    disablePadding: l
  }, h = mG(p);
  return /* @__PURE__ */ x.jsx(bl.Provider, {
    value: d,
    children: /* @__PURE__ */ x.jsxs(gG, {
      as: a,
      className: ie(h.root, o),
      ref: n,
      ownerState: p,
      ...u,
      children: [c, i]
    })
  });
});
process.env.NODE_ENV !== "production" && (ck.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: f.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: f.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: f.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object])
});
const XO = Ge("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
function vG(e) {
  return Je("MuiListItemText", e);
}
const ya = Ge("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), yG = (e) => {
  const {
    classes: t,
    inset: n,
    primary: r,
    secondary: i,
    dense: o
  } = e;
  return at({
    root: ["root", n && "inset", o && "dense", r && i && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  }, vG, t);
}, bG = ge("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${ya.primary}`]: t.primary
    }, {
      [`& .${ya.secondary}`]: t.secondary
    }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${AO.root}:where(& .${ya.primary})`]: {
    display: "block"
  },
  [`.${AO.root}:where(& .${ya.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState: e
    }) => e.primary && e.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState: e
    }) => e.inset,
    style: {
      paddingLeft: 56
    }
  }]
}), fu = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiListItemText"
  }), {
    children: i,
    className: o,
    disableTypography: a = !1,
    inset: s = !1,
    primary: l,
    primaryTypographyProps: c,
    secondary: u,
    secondaryTypographyProps: d,
    slots: p = {},
    slotProps: h = {},
    ...g
  } = r, {
    dense: m
  } = _.useContext(bl);
  let v = l ?? i, y = u;
  const S = {
    ...r,
    disableTypography: a,
    inset: s,
    primary: !!v,
    secondary: !!y,
    dense: m
  }, w = yG(S), b = {
    slots: p,
    slotProps: {
      primary: c,
      secondary: d,
      ...h
    }
  }, [O, E] = lt("root", {
    className: ie(w.root, o),
    elementType: bG,
    externalForwardedProps: {
      ...b,
      ...g
    },
    ownerState: S,
    ref: n
  }), [C, T] = lt("primary", {
    className: w.primary,
    elementType: Rs,
    externalForwardedProps: b,
    ownerState: S
  }), [j, A] = lt("secondary", {
    className: w.secondary,
    elementType: Rs,
    externalForwardedProps: b,
    ownerState: S
  });
  return v != null && v.type !== Rs && !a && (v = /* @__PURE__ */ x.jsx(C, {
    variant: m ? "body2" : "body1",
    component: T?.variant ? void 0 : "span",
    ...T,
    children: v
  })), y != null && y.type !== Rs && !a && (y = /* @__PURE__ */ x.jsx(j, {
    variant: "body2",
    color: "textSecondary",
    ...A,
    children: y
  })), /* @__PURE__ */ x.jsxs(O, {
    ...E,
    children: [v, y]
  });
});
process.env.NODE_ENV !== "production" && (fu.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Alias for the `primary` prop.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * If `true`, the children won't be wrapped by a Typography component.
   * This can be useful to render an alternative Typography variant by wrapping
   * the `children` (or `primary`) text, and optional `secondary` text
   * with the Typography component.
   * @default false
   */
  disableTypography: f.bool,
  /**
   * If `true`, the children are indented.
   * This should be used if there is no left avatar or left icon.
   * @default false
   */
  inset: f.bool,
  /**
   * The main content element.
   */
  primary: f.node,
  /**
   * These props will be forwarded to the primary typography component
   * (as long as disableTypography is not `true`).
   * @deprecated Use `slotProps.primary` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  primaryTypographyProps: f.object,
  /**
   * The secondary content element.
   */
  secondary: f.node,
  /**
   * These props will be forwarded to the secondary typography component
   * (as long as disableTypography is not `true`).
   * @deprecated Use `slotProps.secondary` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  secondaryTypographyProps: f.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    primary: f.oneOfType([f.func, f.object]),
    root: f.oneOfType([f.func, f.object]),
    secondary: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    primary: f.elementType,
    root: f.elementType,
    secondary: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object])
});
function Dh(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function ZO(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function uk(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
}
function xs(e, t, n, r, i, o) {
  let a = !1, s = i(e, t, t ? n : !1);
  for (; s; ) {
    if (s === e.firstChild) {
      if (a)
        return !1;
      a = !0;
    }
    const l = r ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
    if (!s.hasAttribute("tabindex") || !uk(s, o) || l)
      s = i(e, s, n);
    else
      return s.focus(), !0;
  }
  return !1;
}
const dk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: r,
    autoFocus: i = !1,
    autoFocusItem: o = !1,
    children: a,
    className: s,
    disabledItemsFocusable: l = !1,
    disableListWrap: c = !1,
    onKeyDown: u,
    variant: d = "selectedMenu",
    ...p
  } = t, h = _.useRef(null), g = _.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  Wr(() => {
    i && h.current.focus();
  }, [i]), _.useImperativeHandle(r, () => ({
    adjustStyleForScrollbar: (w, {
      direction: b
    }) => {
      const O = !h.current.style.width;
      if (w.clientHeight < h.current.clientHeight && O) {
        const E = `${ik(pi(w))}px`;
        h.current.style[b === "rtl" ? "paddingLeft" : "paddingRight"] = E, h.current.style.width = `calc(100% + ${E})`;
      }
      return h.current;
    }
  }), []);
  const m = (w) => {
    const b = h.current, O = w.key;
    if (w.ctrlKey || w.metaKey || w.altKey) {
      u && u(w);
      return;
    }
    const C = Hn(b).activeElement;
    if (O === "ArrowDown")
      w.preventDefault(), xs(b, C, c, l, Dh);
    else if (O === "ArrowUp")
      w.preventDefault(), xs(b, C, c, l, ZO);
    else if (O === "Home")
      w.preventDefault(), xs(b, null, c, l, Dh);
    else if (O === "End")
      w.preventDefault(), xs(b, null, c, l, ZO);
    else if (O.length === 1) {
      const T = g.current, j = O.toLowerCase(), A = performance.now();
      T.keys.length > 0 && (A - T.lastTime > 500 ? (T.keys = [], T.repeating = !0, T.previousKeyMatched = !0) : T.repeating && j !== T.keys[0] && (T.repeating = !1)), T.lastTime = A, T.keys.push(j);
      const M = C && !T.repeating && uk(C, T);
      T.previousKeyMatched && (M || xs(b, C, !1, l, Dh, T)) ? w.preventDefault() : T.previousKeyMatched = !1;
    }
    u && u(w);
  }, v = Gt(h, n);
  let y = -1;
  _.Children.forEach(a, (w, b) => {
    if (!/* @__PURE__ */ _.isValidElement(w)) {
      y === b && (y += 1, y >= a.length && (y = -1));
      return;
    }
    process.env.NODE_ENV !== "production" && Bi.isFragment(w) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), w.props.disabled || (d === "selectedMenu" && w.props.selected || y === -1) && (y = b), y === b && (w.props.disabled || w.props.muiSkipListHighlight || w.type.muiSkipListHighlight) && (y += 1, y >= a.length && (y = -1));
  });
  const S = _.Children.map(a, (w, b) => {
    if (b === y) {
      const O = {};
      return o && (O.autoFocus = !0), w.props.tabIndex === void 0 && d === "selectedMenu" && (O.tabIndex = 0), /* @__PURE__ */ _.cloneElement(w, O);
    }
    return w;
  });
  return /* @__PURE__ */ x.jsx(ck, {
    role: "menu",
    ref: v,
    className: s,
    onKeyDown: m,
    tabIndex: i ? 0 : -1,
    ...p,
    children: S
  });
});
process.env.NODE_ENV !== "production" && (dk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: f.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: f.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: f.node,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: f.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: f.bool,
  /**
   * @ignore
   */
  onKeyDown: f.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: f.oneOf(["menu", "selectedMenu"])
});
function xG(e) {
  return Je("MuiPopover", e);
}
Ge("MuiPopover", ["root", "paper"]);
function JO(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function QO(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function eS(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function Is(e) {
  return typeof e == "function" ? e() : e;
}
const wG = (e) => {
  const {
    classes: t
  } = e;
  return at({
    root: ["root"],
    paper: ["paper"]
  }, xG, t);
}, OG = ge(ok, {
  name: "MuiPopover",
  slot: "Root"
})({}), fk = ge(NA, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), pk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiPopover"
  }), {
    action: i,
    anchorEl: o,
    anchorOrigin: a = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: s,
    anchorReference: l = "anchorEl",
    children: c,
    className: u,
    container: d,
    elevation: p = 8,
    marginThreshold: h = 16,
    open: g,
    PaperProps: m = {},
    // TODO: remove in v7
    slots: v = {},
    slotProps: y = {},
    transformOrigin: S = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: w,
    // TODO: remove in v7
    transitionDuration: b = "auto",
    TransitionProps: O = {},
    // TODO: remove in v7
    disableScrollLock: E = !1,
    ...C
  } = r, T = _.useRef(), j = {
    ...r,
    anchorOrigin: a,
    anchorReference: l,
    elevation: p,
    marginThreshold: h,
    transformOrigin: S,
    TransitionComponent: w,
    transitionDuration: b,
    TransitionProps: O
  }, A = wG(j), M = _.useCallback(() => {
    if (l === "anchorPosition")
      return process.env.NODE_ENV !== "production" && (s || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.')), s;
    const U = Is(o), Z = U && U.nodeType === 1 ? U : Hn(T.current).body, k = Z.getBoundingClientRect();
    if (process.env.NODE_ENV !== "production") {
      const de = Z.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && de.top === 0 && de.left === 0 && de.right === 0 && de.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: k.top + JO(k, a.vertical),
      left: k.left + QO(k, a.horizontal)
    };
  }, [o, a.horizontal, a.vertical, s, l]), P = _.useCallback((U) => ({
    vertical: JO(U, S.vertical),
    horizontal: QO(U, S.horizontal)
  }), [S.horizontal, S.vertical]), R = _.useCallback((U) => {
    const Z = {
      width: U.offsetWidth,
      height: U.offsetHeight
    }, k = P(Z);
    if (l === "none")
      return {
        top: null,
        left: null,
        transformOrigin: eS(k)
      };
    const de = M();
    let ne = de.top - k.vertical, he = de.left - k.horizontal;
    const xe = ne + Z.height, Oe = he + Z.width, Ee = pi(Is(o)), et = Ee.innerHeight - h, Ie = Ee.innerWidth - h;
    if (h !== null && ne < h) {
      const Ce = ne - h;
      ne -= Ce, k.vertical += Ce;
    } else if (h !== null && xe > et) {
      const Ce = xe - et;
      ne -= Ce, k.vertical += Ce;
    }
    if (process.env.NODE_ENV !== "production" && Z.height > et && Z.height && et && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${Z.height - et}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), h !== null && he < h) {
      const Ce = he - h;
      he -= Ce, k.horizontal += Ce;
    } else if (Oe > Ie) {
      const Ce = Oe - Ie;
      he -= Ce, k.horizontal += Ce;
    }
    return {
      top: `${Math.round(ne)}px`,
      left: `${Math.round(he)}px`,
      transformOrigin: eS(k)
    };
  }, [o, l, M, P, h]), [N, D] = _.useState(g), $ = _.useCallback(() => {
    const U = T.current;
    if (!U)
      return;
    const Z = R(U);
    Z.top !== null && U.style.setProperty("top", Z.top), Z.left !== null && (U.style.left = Z.left), U.style.transformOrigin = Z.transformOrigin, D(!0);
  }, [R]);
  _.useEffect(() => (E && window.addEventListener("scroll", $), () => window.removeEventListener("scroll", $)), [o, E, $]);
  const F = () => {
    $();
  }, q = () => {
    D(!1);
  };
  _.useEffect(() => {
    g && $();
  }), _.useImperativeHandle(i, () => g ? {
    updatePosition: () => {
      $();
    }
  } : null, [g, $]), _.useEffect(() => {
    if (!g)
      return;
    const U = P_(() => {
      $();
    }), Z = pi(Is(o));
    return Z.addEventListener("resize", U), () => {
      U.clear(), Z.removeEventListener("resize", U);
    };
  }, [o, g, $]);
  let B = b;
  const L = {
    slots: {
      transition: w,
      ...v
    },
    slotProps: {
      transition: O,
      paper: m,
      ...y
    }
  }, [Y, K] = lt("transition", {
    elementType: yl,
    externalForwardedProps: L,
    ownerState: j,
    getSlotProps: (U) => ({
      ...U,
      onEntering: (Z, k) => {
        U.onEntering?.(Z, k), F();
      },
      onExited: (Z) => {
        U.onExited?.(Z), q();
      }
    }),
    additionalProps: {
      appear: !0,
      in: g
    }
  });
  b === "auto" && !Y.muiSupportAuto && (B = void 0);
  const te = d || (o ? Hn(Is(o)).body : void 0), [J, {
    slots: G,
    slotProps: ee,
    ...re
  }] = lt("root", {
    ref: n,
    elementType: OG,
    externalForwardedProps: {
      ...L,
      ...C
    },
    shouldForwardComponentProp: !0,
    additionalProps: {
      slots: {
        backdrop: v.backdrop
      },
      slotProps: {
        backdrop: C_(typeof y.backdrop == "function" ? y.backdrop(j) : y.backdrop, {
          invisible: !0
        })
      },
      container: te,
      open: g
    },
    ownerState: j,
    className: ie(A.root, u)
  }), [oe, W] = lt("paper", {
    ref: T,
    className: A.paper,
    elementType: fk,
    externalForwardedProps: L,
    shouldForwardComponentProp: !0,
    additionalProps: {
      elevation: p,
      style: N ? void 0 : {
        opacity: 0
      }
    },
    ownerState: j
  });
  return /* @__PURE__ */ x.jsx(J, {
    ...re,
    ...!cd(J) && {
      slots: G,
      slotProps: ee,
      disableScrollLock: E
    },
    children: /* @__PURE__ */ x.jsx(Y, {
      ...K,
      timeout: B,
      children: /* @__PURE__ */ x.jsx(oe, {
        ...W,
        children: c
      })
    })
  });
});
process.env.NODE_ENV !== "production" && (pk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: br,
  /**
   * An HTML element, [PopoverVirtualElement](https://mui.com/material-ui/react-popover/#virtual-element),
   * or a function that returns either.
   * It's used to set the position of the popover.
   */
  anchorEl: es(f.oneOfType([yi, f.func]), (e) => {
    if (e.open && (!e.anchorReference || e.anchorReference === "anchorEl")) {
      const t = Is(e.anchorEl);
      if (t && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element or PopoverVirtualElement instance but it's \`${t}\` instead.`].join(`
`));
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: f.shape({
    horizontal: f.oneOfType([f.oneOf(["center", "left", "right"]), f.number]).isRequired,
    vertical: f.oneOfType([f.oneOf(["bottom", "center", "top"]), f.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: f.shape({
    left: f.number.isRequired,
    top: f.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: f.oneOf(["anchorEl", "anchorPosition", "none"]),
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: f.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  BackdropProps: f.object,
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: f.oneOfType([yi, f.func]),
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: f.bool,
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: jA,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * If null, the popover will not be constrained by the window.
   * @default 16
   */
  marginThreshold: f.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: f.func,
  /**
   * If `true`, the component is shown.
   */
  open: f.bool.isRequired,
  /**
   * Props applied to the [`Paper`](https://mui.com/material-ui/api/paper/) element.
   *
   * This prop is an alias for `slotProps.paper` and will be overridden by it if both are used.
   * @deprecated Use `slotProps.paper` instead.
   *
   * @default {}
   */
  PaperProps: f.shape({
    component: Iy
  }),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    backdrop: f.oneOfType([f.func, f.object]),
    paper: f.oneOfType([f.func, f.object]),
    root: f.oneOfType([f.func, f.object]),
    transition: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    backdrop: f.elementType,
    paper: f.elementType,
    root: f.elementType,
    transition: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: f.shape({
    horizontal: f.oneOfType([f.oneOf(["center", "left", "right"]), f.number]).isRequired,
    vertical: f.oneOfType([f.oneOf(["bottom", "center", "top"]), f.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @deprecated use the `slots.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default Grow
   */
  TransitionComponent: f.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: f.oneOfType([f.oneOf(["auto"]), f.number, f.shape({
    appear: f.number,
    enter: f.number,
    exit: f.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  TransitionProps: f.object
});
function SG(e) {
  return Je("MuiMenu", e);
}
Ge("MuiMenu", ["root", "paper", "list"]);
const EG = {
  vertical: "top",
  horizontal: "right"
}, _G = {
  vertical: "top",
  horizontal: "left"
}, PG = (e) => {
  const {
    classes: t
  } = e;
  return at({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, SG, t);
}, CG = ge(pk, {
  shouldForwardProp: (e) => Xn(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root"
})({}), TG = ge(fk, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), AG = ge(dk, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), hk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: i = !0,
    children: o,
    className: a,
    disableAutoFocusItem: s = !1,
    MenuListProps: l = {},
    onClose: c,
    open: u,
    PaperProps: d = {},
    PopoverClasses: p,
    transitionDuration: h = "auto",
    TransitionProps: {
      onEntering: g,
      ...m
    } = {},
    variant: v = "selectedMenu",
    slots: y = {},
    slotProps: S = {},
    ...w
  } = r, b = Ng(), O = {
    ...r,
    autoFocus: i,
    disableAutoFocusItem: s,
    MenuListProps: l,
    onEntering: g,
    PaperProps: d,
    transitionDuration: h,
    TransitionProps: m,
    variant: v
  }, E = PG(O), C = i && !s && u, T = _.useRef(null), j = (B, L) => {
    T.current && T.current.adjustStyleForScrollbar(B, {
      direction: b ? "rtl" : "ltr"
    }), g && g(B, L);
  }, A = (B) => {
    B.key === "Tab" && (B.preventDefault(), c && c(B, "tabKeyDown"));
  };
  let M = -1;
  _.Children.map(o, (B, L) => {
    /* @__PURE__ */ _.isValidElement(B) && (process.env.NODE_ENV !== "production" && Bi.isFragment(B) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), B.props.disabled || (v === "selectedMenu" && B.props.selected || M === -1) && (M = L));
  });
  const P = {
    slots: y,
    slotProps: {
      list: l,
      transition: m,
      paper: d,
      ...S
    }
  }, R = ZA({
    elementType: y.root,
    externalSlotProps: S.root,
    ownerState: O,
    className: [E.root, a]
  }), [N, D] = lt("paper", {
    className: E.paper,
    elementType: TG,
    externalForwardedProps: P,
    shouldForwardComponentProp: !0,
    ownerState: O
  }), [$, F] = lt("list", {
    className: ie(E.list, l.className),
    elementType: AG,
    shouldForwardComponentProp: !0,
    externalForwardedProps: P,
    getSlotProps: (B) => ({
      ...B,
      onKeyDown: (L) => {
        A(L), B.onKeyDown?.(L);
      }
    }),
    ownerState: O
  }), q = typeof P.slotProps.transition == "function" ? P.slotProps.transition(O) : P.slotProps.transition;
  return /* @__PURE__ */ x.jsx(CG, {
    onClose: c,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: b ? "right" : "left"
    },
    transformOrigin: b ? EG : _G,
    slots: {
      root: y.root,
      paper: N,
      backdrop: y.backdrop,
      ...y.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: y.transition
      }
    },
    slotProps: {
      root: R,
      paper: D,
      backdrop: typeof S.backdrop == "function" ? S.backdrop(O) : S.backdrop,
      transition: {
        ...q,
        onEntering: (...B) => {
          j(...B), q?.onEntering?.(...B);
        }
      }
    },
    open: u,
    ref: n,
    transitionDuration: h,
    ownerState: O,
    ...w,
    classes: p,
    children: /* @__PURE__ */ x.jsx($, {
      actions: T,
      autoFocus: i && (M === -1 || s),
      autoFocusItem: C,
      variant: v,
      ...F,
      children: o
    })
  });
});
process.env.NODE_ENV !== "production" && (hk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: f.oneOfType([yi, f.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: f.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: f.bool,
  /**
   * Props applied to the [`MenuList`](https://mui.com/material-ui/api/menu-list/) element.
   * @deprecated use the `slotProps.list` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  MenuListProps: f.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: f.func,
  /**
   * If `true`, the component is shown.
   */
  open: f.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: f.object,
  /**
   * `classes` prop applied to the [`Popover`](https://mui.com/material-ui/api/popover/) element.
   */
  PopoverClasses: f.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    backdrop: f.oneOfType([f.func, f.object]),
    list: f.oneOfType([f.func, f.object]),
    paper: f.oneOfType([f.func, f.object]),
    root: f.oneOfType([f.func, f.object]),
    transition: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    backdrop: f.elementType,
    list: f.elementType,
    paper: f.elementType,
    root: f.elementType,
    transition: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: f.oneOfType([f.oneOf(["auto"]), f.number, f.shape({
    appear: f.number,
    enter: f.number,
    exit: f.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  TransitionProps: f.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: f.oneOf(["menu", "selectedMenu"])
});
function kG(e) {
  return Je("MuiMenuItem", e);
}
const ws = Ge("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), MG = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, jG = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: r,
    disableGutters: i,
    selected: o,
    classes: a
  } = e, l = at({
    root: ["root", n && "dense", t && "disabled", !i && "gutters", r && "divider", o && "selected"]
  }, kG, a);
  return {
    ...a,
    ...l
  };
}, NG = ge($y, {
  shouldForwardProp: (e) => Xn(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: MG
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${ws.selected}`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
    [`&.${ws.focusVisible}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
    }
  },
  [`&.${ws.selected}:hover`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
    }
  },
  [`&.${ws.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${ws.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${KO.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${KO.inset}`]: {
    marginLeft: 52
  },
  [`& .${ya.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${ya.inset}`]: {
    paddingLeft: 36
  },
  [`& .${XO.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.dense,
    style: {
      [e.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...e.typography.body2,
      [`& .${XO.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
}))), $s = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: i = !1,
    component: o = "li",
    dense: a = !1,
    divider: s = !1,
    disableGutters: l = !1,
    focusVisibleClassName: c,
    role: u = "menuitem",
    tabIndex: d,
    className: p,
    ...h
  } = r, g = _.useContext(bl), m = _.useMemo(() => ({
    dense: a || g.dense || !1,
    disableGutters: l
  }), [g.dense, a, l]), v = _.useRef(null);
  Wr(() => {
    i && (v.current ? v.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [i]);
  const y = {
    ...r,
    dense: m.dense,
    divider: s,
    disableGutters: l
  }, S = jG(r), w = Gt(v, n);
  let b;
  return r.disabled || (b = d !== void 0 ? d : -1), /* @__PURE__ */ x.jsx(bl.Provider, {
    value: m,
    children: /* @__PURE__ */ x.jsx(NG, {
      ref: w,
      role: u,
      tabIndex: b,
      component: o,
      focusVisibleClassName: ie(S.focusVisible, c),
      className: ie(S.root, p),
      ...h,
      ownerState: y,
      classes: S
    })
  });
});
process.env.NODE_ENV !== "production" && ($s.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   */
  autoFocus: f.bool,
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: f.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent Menu component.
   * @default false
   */
  dense: f.bool,
  /**
   * @ignore
   */
  disabled: f.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: f.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the menu item.
   * @default false
   */
  divider: f.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: f.string,
  /**
   * @ignore
   */
  role: f.string,
  /**
   * If `true`, the component is selected.
   * @default false
   */
  selected: f.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * @default 0
   */
  tabIndex: f.number
});
function DG(e) {
  return Je("MuiNativeSelect", e);
}
const Ky = Ge("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), RG = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: o,
    error: a
  } = e, s = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${Re(n)}`, o && "iconOpen", r && "disabled"]
  };
  return at(s, DG, t);
}, mk = ge("select", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${Ky.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (e.vars || e).shape.borderRadius,
      "&:focus": {
        borderRadius: (e.vars || e).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), IG = ge(mk, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: Xn,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${Ky.multiple}`]: t.multiple
    }];
  }
})({}), gk = ge("svg", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (e.vars || e).palette.action.active,
  [`&.${Ky.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), $G = ge(gk, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${Re(n.variant)}`], n.open && t.iconOpen];
  }
})({}), vk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    className: r,
    disabled: i,
    error: o,
    IconComponent: a,
    inputRef: s,
    variant: l = "standard",
    ...c
  } = t, u = {
    ...t,
    disabled: i,
    variant: l,
    error: o
  }, d = RG(u);
  return /* @__PURE__ */ x.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ x.jsx(IG, {
      ownerState: u,
      className: ie(d.select, r),
      disabled: i,
      ref: s || n,
      ...c
    }), t.multiple ? null : /* @__PURE__ */ x.jsx($G, {
      as: a,
      ownerState: u,
      className: d.icon
    })]
  });
});
process.env.NODE_ENV !== "production" && (vk.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * The CSS class name of the select element.
   */
  className: f.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: f.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: f.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: f.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: br,
  /**
   * @ignore
   */
  multiple: f.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: f.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: f.func,
  /**
   * The input value.
   */
  value: f.any,
  /**
   * The variant to use.
   */
  variant: f.oneOf(["standard", "outlined", "filled"])
});
var tS;
const LG = ge("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Xn
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), FG = ge("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Xn
})(Ct(({
  theme: e
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: e.transitions.create("width", {
        duration: 150,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: e.transitions.create("max-width", {
        duration: 50,
        easing: e.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: e.transitions.create("max-width", {
        duration: 100,
        easing: e.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function yk(e) {
  const {
    children: t,
    classes: n,
    className: r,
    label: i,
    notched: o,
    ...a
  } = e, s = i != null && i !== "", l = {
    ...e,
    notched: o,
    withLabel: s
  };
  return /* @__PURE__ */ x.jsx(LG, {
    "aria-hidden": !0,
    className: r,
    ownerState: l,
    ...a,
    children: /* @__PURE__ */ x.jsx(FG, {
      ownerState: l,
      children: s ? /* @__PURE__ */ x.jsx("span", {
        children: i
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        tS || (tS = /* @__PURE__ */ x.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      )
    })
  });
}
process.env.NODE_ENV !== "production" && (yk.propTypes = {
  /**
   * The content of the component.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The label.
   */
  label: f.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: f.bool.isRequired,
  /**
   * @ignore
   */
  style: f.object
});
const BG = (e) => {
  const {
    classes: t
  } = e, r = at({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, cY, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...r
  };
}, zG = ge(kf, {
  shouldForwardProp: (e) => Xn(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: Tf
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${Tr.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${Tr.notchedOutline}`]: {
        borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
      }
    },
    [`&.${Tr.focused} .${Tr.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(e.palette).filter(Wo()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        [`&.${Tr.focused} .${Tr.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[n].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${Tr.error} .${Tr.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main
        },
        [`&.${Tr.disabled} .${Tr.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => n.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: n,
        size: r
      }) => n.multiline && r === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), WG = ge(yk, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
  };
})), VG = ge(Mf, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: Af
})(Ct(({
  theme: e
}) => ({
  padding: "16.5px 14px",
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), Rf = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: i = {},
    fullWidth: o = !1,
    inputComponent: a = "input",
    label: s,
    multiline: l = !1,
    notched: c,
    slots: u = {},
    slotProps: d = {},
    type: p = "text",
    ...h
  } = r, g = BG(r), m = Jo(), v = ns({
    props: r,
    muiFormControl: m,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), y = {
    ...r,
    color: v.color || "primary",
    disabled: v.disabled,
    error: v.error,
    focused: v.focused,
    formControl: m,
    fullWidth: o,
    hiddenLabel: v.hiddenLabel,
    multiline: l,
    size: v.size,
    type: p
  }, S = u.root ?? i.Root ?? zG, w = u.input ?? i.Input ?? VG, [b, O] = lt("notchedOutline", {
    elementType: WG,
    className: g.notchedOutline,
    shouldForwardComponentProp: !0,
    ownerState: y,
    externalForwardedProps: {
      slots: u,
      slotProps: d
    },
    additionalProps: {
      label: s != null && s !== "" && v.required ? /* @__PURE__ */ x.jsxs(_.Fragment, {
        children: [s, "", "*"]
      }) : s
    }
  });
  return /* @__PURE__ */ x.jsx(jf, {
    slots: {
      root: S,
      input: w
    },
    slotProps: d,
    renderSuffix: (E) => /* @__PURE__ */ x.jsx(b, {
      ...O,
      notched: typeof c < "u" ? c : !!(E.startAdornment || E.filled || E.focused)
    }),
    fullWidth: o,
    inputComponent: a,
    multiline: l,
    ref: n,
    type: p,
    ...h,
    classes: {
      ...g,
      notchedOutline: null
    }
  });
});
process.env.NODE_ENV !== "production" && (Rf.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: f.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: f.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: f.oneOfType([f.oneOf(["primary", "secondary"]), f.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: f.shape({
    Input: f.elementType,
    Root: f.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: f.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: f.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: f.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: f.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: f.bool,
  /**
   * The id of the `input` element.
   */
  id: f.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: f.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: f.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: br,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: f.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: f.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: f.oneOfType([f.number, f.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: f.oneOfType([f.number, f.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: f.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: f.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: f.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: f.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: f.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: f.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: f.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: f.oneOfType([f.number, f.string]),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    input: f.object,
    notchedOutline: f.oneOfType([f.func, f.object]),
    root: f.object
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    input: f.elementType,
    notchedOutline: f.elementType,
    root: f.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: f.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: f.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: f.any
});
Rf.muiName = "Input";
function bk(e) {
  return Je("MuiSelect", e);
}
const Os = Ge("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var nS;
const UG = ge(mk, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${Os.select}`]: t.select
      },
      {
        [`&.${Os.select}`]: t[n.variant]
      },
      {
        [`&.${Os.error}`]: t.error
      },
      {
        [`&.${Os.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${Os.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), HG = ge(gk, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${Re(n.variant)}`], n.open && t.iconOpen];
  }
})({}), qG = ge("input", {
  shouldForwardProp: (e) => __(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function rS(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function KG(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const YG = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: o,
    error: a
  } = e, s = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${Re(n)}`, o && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return at(s, bk, t);
}, xk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    "aria-describedby": r,
    "aria-label": i,
    autoFocus: o,
    autoWidth: a,
    children: s,
    className: l,
    defaultOpen: c,
    defaultValue: u,
    disabled: d,
    displayEmpty: p,
    error: h = !1,
    IconComponent: g,
    inputRef: m,
    labelId: v,
    MenuProps: y = {},
    multiple: S,
    name: w,
    onBlur: b,
    onChange: O,
    onClose: E,
    onFocus: C,
    onOpen: T,
    open: j,
    readOnly: A,
    renderValue: M,
    required: P,
    SelectDisplayProps: R = {},
    tabIndex: N,
    // catching `type` from Input which makes no sense for SelectInput
    type: D,
    value: $,
    variant: F = "standard",
    ...q
  } = t, [B, L] = wu({
    controlled: $,
    default: u,
    name: "Select"
  }), [Y, K] = wu({
    controlled: j,
    default: c,
    name: "Select"
  }), te = _.useRef(null), J = _.useRef(null), [G, ee] = _.useState(null), {
    current: re
  } = _.useRef(j != null), [oe, W] = _.useState(), U = Gt(n, m), Z = _.useCallback((X) => {
    J.current = X, X && ee(X);
  }, []), k = G?.parentNode;
  _.useImperativeHandle(U, () => ({
    focus: () => {
      J.current.focus();
    },
    node: te.current,
    value: B
  }), [B]), _.useEffect(() => {
    c && Y && G && !re && (W(a ? null : k.clientWidth), J.current.focus());
  }, [G, a]), _.useEffect(() => {
    o && J.current.focus();
  }, [o]), _.useEffect(() => {
    if (!v)
      return;
    const X = Hn(J.current).getElementById(v);
    if (X) {
      const le = () => {
        getSelection().isCollapsed && J.current.focus();
      };
      return X.addEventListener("click", le), () => {
        X.removeEventListener("click", le);
      };
    }
  }, [v]);
  const de = (X, le) => {
    X ? T && T(le) : E && E(le), re || (W(a ? null : k.clientWidth), K(X));
  }, ne = (X) => {
    X.button === 0 && (X.preventDefault(), J.current.focus(), de(!0, X));
  }, he = (X) => {
    de(!1, X);
  }, xe = _.Children.toArray(s), Oe = (X) => {
    const le = xe.find((fe) => fe.props.value === X.target.value);
    le !== void 0 && (L(le.props.value), O && O(X, le));
  }, Ee = (X) => (le) => {
    let fe;
    if (le.currentTarget.hasAttribute("tabindex")) {
      if (S) {
        fe = Array.isArray(B) ? B.slice() : [];
        const nt = B.indexOf(X.props.value);
        nt === -1 ? fe.push(X.props.value) : fe.splice(nt, 1);
      } else
        fe = X.props.value;
      if (X.props.onClick && X.props.onClick(le), B !== fe && (L(fe), O)) {
        const nt = le.nativeEvent || le, ht = new nt.constructor(nt.type, nt);
        Object.defineProperty(ht, "target", {
          writable: !0,
          value: {
            value: fe,
            name: w
          }
        }), O(ht, X);
      }
      S || de(!1, le);
    }
  }, et = (X) => {
    A || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(X.key) && (X.preventDefault(), de(!0, X));
  }, Ie = G !== null && Y, Ce = (X) => {
    !Ie && b && (Object.defineProperty(X, "target", {
      writable: !0,
      value: {
        value: B,
        name: w
      }
    }), b(X));
  };
  delete q["aria-invalid"];
  let ue, Tt;
  const tt = [];
  let an = !1, Jt = !1;
  (hd({
    value: B
  }) || p) && (M ? ue = M(B) : an = !0);
  const sn = xe.map((X) => {
    if (!/* @__PURE__ */ _.isValidElement(X))
      return null;
    process.env.NODE_ENV !== "production" && Bi.isFragment(X) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let le;
    if (S) {
      if (!Array.isArray(B))
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : zr(2));
      le = B.some((fe) => rS(fe, X.props.value)), le && an && tt.push(X.props.children);
    } else
      le = rS(B, X.props.value), le && an && (Tt = X.props.children);
    return le && (Jt = !0), /* @__PURE__ */ _.cloneElement(X, {
      "aria-selected": le ? "true" : "false",
      onClick: Ee(X),
      onKeyUp: (fe) => {
        fe.key === " " && fe.preventDefault(), X.props.onKeyUp && X.props.onKeyUp(fe);
      },
      role: "option",
      selected: le,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": X.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  process.env.NODE_ENV !== "production" && _.useEffect(() => {
    if (!Jt && !S && B !== "") {
      const X = xe.map((le) => le.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${B}\` for the select ${w ? `(name="${w}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${X.filter((le) => le != null).map((le) => `\`${le}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [Jt, xe, S, w, B]), an && (S ? tt.length === 0 ? ue = null : ue = tt.reduce((X, le, fe) => (X.push(le), fe < tt.length - 1 && X.push(", "), X), []) : ue = Tt);
  let wn = oe;
  !a && re && G && (wn = k.clientWidth);
  let Ut;
  typeof N < "u" ? Ut = N : Ut = d ? null : 0;
  const On = R.id || (w ? `mui-component-select-${w}` : void 0), ve = {
    ...t,
    variant: F,
    value: B,
    open: Ie,
    error: h
  }, ln = YG(ve), Ht = {
    ...y.PaperProps,
    ...typeof y.slotProps?.paper == "function" ? y.slotProps.paper(ve) : y.slotProps?.paper
  }, V = {
    ...y.MenuListProps,
    ...typeof y.slotProps?.list == "function" ? y.slotProps.list(ve) : y.slotProps?.list
  }, se = Dg();
  return /* @__PURE__ */ x.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ x.jsx(UG, {
      as: "div",
      ref: Z,
      tabIndex: Ut,
      role: "combobox",
      "aria-controls": Ie ? se : void 0,
      "aria-disabled": d ? "true" : void 0,
      "aria-expanded": Ie ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": i,
      "aria-labelledby": [v, On].filter(Boolean).join(" ") || void 0,
      "aria-describedby": r,
      "aria-required": P ? "true" : void 0,
      "aria-invalid": h ? "true" : void 0,
      onKeyDown: et,
      onMouseDown: d || A ? null : ne,
      onBlur: Ce,
      onFocus: C,
      ...R,
      ownerState: ve,
      className: ie(R.className, ln.select, l),
      id: On,
      children: KG(ue) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        nS || (nS = /* @__PURE__ */ x.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : ue
    }), /* @__PURE__ */ x.jsx(qG, {
      "aria-invalid": h,
      value: Array.isArray(B) ? B.join(",") : B,
      name: w,
      ref: te,
      "aria-hidden": !0,
      onChange: Oe,
      tabIndex: -1,
      disabled: d,
      className: ln.nativeInput,
      autoFocus: o,
      required: P,
      ...q,
      ownerState: ve
    }), /* @__PURE__ */ x.jsx(HG, {
      as: g,
      className: ln.icon,
      ownerState: ve
    }), /* @__PURE__ */ x.jsx(hk, {
      id: `menu-${w || ""}`,
      anchorEl: k,
      open: Ie,
      onClose: he,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...y,
      slotProps: {
        ...y.slotProps,
        list: {
          "aria-labelledby": v,
          role: "listbox",
          "aria-multiselectable": S ? "true" : void 0,
          disableListWrap: !0,
          id: se,
          ...V
        },
        paper: {
          ...Ht,
          style: {
            minWidth: wn,
            ...Ht != null ? Ht.style : null
          }
        }
      },
      children: sn
    })]
  });
});
process.env.NODE_ENV !== "production" && (xk.propTypes = {
  /**
   * @ignore
   */
  "aria-describedby": f.string,
  /**
   * @ignore
   */
  "aria-label": f.string,
  /**
   * @ignore
   */
  autoFocus: f.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: f.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * The CSS class name of the select element.
   */
  className: f.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: f.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: f.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: f.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: f.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: f.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: f.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: br,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: f.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: f.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: f.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: f.string,
  /**
   * @ignore
   */
  onBlur: f.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: f.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: f.func,
  /**
   * @ignore
   */
  onFocus: f.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: f.func,
  /**
   * If `true`, the component is shown.
   */
  open: f.bool,
  /**
   * @ignore
   */
  readOnly: f.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: f.func,
  /**
   * If `true`, the component is required.
   */
  required: f.bool,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: f.object,
  /**
   * @ignore
   */
  tabIndex: f.oneOfType([f.number, f.string]),
  /**
   * @ignore
   */
  type: f.any,
  /**
   * The input value.
   */
  value: f.any,
  /**
   * The variant to use.
   */
  variant: f.oneOf(["standard", "outlined", "filled"])
});
const GG = (e) => {
  const {
    classes: t
  } = e, r = at({
    root: ["root"]
  }, bk, t);
  return {
    ...t,
    ...r
  };
}, Yy = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (e) => Xn(e) && e !== "variant"
}, XG = ge(Df, Yy)(""), ZG = ge(Rf, Yy)(""), JG = ge(Nf, Yy)(""), If = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: i = !1,
    children: o,
    classes: a = {},
    className: s,
    defaultOpen: l = !1,
    displayEmpty: c = !1,
    IconComponent: u = dY,
    id: d,
    input: p,
    inputProps: h,
    label: g,
    labelId: m,
    MenuProps: v,
    multiple: y = !1,
    native: S = !1,
    onClose: w,
    onOpen: b,
    open: O,
    renderValue: E,
    SelectDisplayProps: C,
    variant: T = "outlined",
    ...j
  } = r, A = S ? vk : xk, M = Jo(), P = ns({
    props: r,
    muiFormControl: M,
    states: ["variant", "error"]
  }), R = P.variant || T, N = {
    ...r,
    variant: R,
    classes: a
  }, D = GG(N), {
    root: $,
    ...F
  } = D, q = p || {
    standard: /* @__PURE__ */ x.jsx(XG, {
      ownerState: N
    }),
    outlined: /* @__PURE__ */ x.jsx(ZG, {
      label: g,
      ownerState: N
    }),
    filled: /* @__PURE__ */ x.jsx(JG, {
      ownerState: N
    })
  }[R], B = Gt(n, ts(q));
  return /* @__PURE__ */ x.jsx(_.Fragment, {
    children: /* @__PURE__ */ _.cloneElement(q, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: A,
      inputProps: {
        children: o,
        error: P.error,
        IconComponent: u,
        variant: R,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: y,
        ...S ? {
          id: d
        } : {
          autoWidth: i,
          defaultOpen: l,
          displayEmpty: c,
          labelId: m,
          MenuProps: v,
          onClose: w,
          onOpen: b,
          open: O,
          renderValue: E,
          SelectDisplayProps: {
            id: d,
            ...C
          }
        },
        ...h,
        classes: h ? pn(F, h.classes) : F,
        ...p ? p.props.inputProps : {}
      },
      ...(y && S || c) && R === "outlined" ? {
        notched: !0
      } : {},
      ref: B,
      className: ie(q.props.className, s, D.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!p && {
        variant: R
      },
      ...j
    })
  });
});
process.env.NODE_ENV !== "production" && (If.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: f.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: f.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: f.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   *  When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: f.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: f.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: f.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: f.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: f.object,
  /**
   * See [OutlinedInput#label](https://mui.com/material-ui/api/outlined-input/#props)
   */
  label: f.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: f.string,
  /**
   * Props applied to the [`Menu`](https://mui.com/material-ui/api/menu/) element.
   */
  MenuProps: f.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: f.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: f.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<Value>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: f.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapses).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: f.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: f.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: f.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: f.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: f.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: f.oneOfType([f.oneOf([""]), f.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: f.oneOf(["filled", "outlined", "standard"])
});
If.muiName = "Select";
function QG(e) {
  return Je("MuiTooltip", e);
}
const Et = Ge("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function eX(e) {
  return Math.round(e * 1e5) / 1e5;
}
const tX = (e) => {
  const {
    classes: t,
    disableInteractive: n,
    arrow: r,
    touch: i,
    placement: o
  } = e, a = {
    popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
    tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${Re(o.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return at(a, QG, t);
}, nX = ge(Hy, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose];
  }
})(Ct(({
  theme: e
}) => ({
  zIndex: (e.vars || e).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open: t
    }) => !t,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${Et.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${Et.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${Et.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${Et.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${Et.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${Et.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${Et.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${Et.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
}))), rX = ge("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${Re(n.placement.split("-")[0])}`]];
  }
})(Ct(({
  theme: e
}) => ({
  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : e.alpha(e.palette.grey[700], 0.92),
  borderRadius: (e.vars || e).shape.borderRadius,
  color: (e.vars || e).palette.common.white,
  fontFamily: e.typography.fontFamily,
  padding: "4px 8px",
  fontSize: e.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: e.typography.fontWeightMedium,
  [`.${Et.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${Et.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${Et.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${Et.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      padding: "8px 16px",
      fontSize: e.typography.pxToRem(14),
      lineHeight: `${eX(16 / 14)}em`,
      fontWeight: e.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl,
    style: {
      [`.${Et.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${Et.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl && t.touch,
    style: {
      [`.${Et.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${Et.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl,
    style: {
      [`.${Et.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${Et.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl && t.touch,
    style: {
      [`.${Et.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${Et.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${Et.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${Et.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
}))), iX = ge("span", {
  name: "MuiTooltip",
  slot: "Arrow"
})(Ct(({
  theme: e
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: e.vars ? e.vars.palette.Tooltip.bg : e.alpha(e.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let Bc = !1;
const iS = new Ef();
let Ss = {
  x: 0,
  y: 0
};
function zc(e, t) {
  return (n, ...r) => {
    t && t(n, ...r), e(n, ...r);
  };
}
const lg = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiTooltip"
  }), {
    arrow: i = !1,
    children: o,
    classes: a,
    components: s = {},
    componentsProps: l = {},
    describeChild: c = !1,
    disableFocusListener: u = !1,
    disableHoverListener: d = !1,
    disableInteractive: p = !1,
    disableTouchListener: h = !1,
    enterDelay: g = 100,
    enterNextDelay: m = 0,
    enterTouchDelay: v = 700,
    followCursor: y = !1,
    id: S,
    leaveDelay: w = 0,
    leaveTouchDelay: b = 1500,
    onClose: O,
    onOpen: E,
    open: C,
    placement: T = "bottom",
    PopperComponent: j,
    PopperProps: A = {},
    slotProps: M = {},
    slots: P = {},
    title: R,
    TransitionComponent: N,
    TransitionProps: D,
    ...$
  } = r, F = /* @__PURE__ */ _.isValidElement(o) ? o : /* @__PURE__ */ x.jsx("span", {
    children: o
  }), q = zd(), B = Ng(), [L, Y] = _.useState(), [K, te] = _.useState(null), J = _.useRef(!1), G = p || y, ee = va(), re = va(), oe = va(), W = va(), [U, Z] = wu({
    controlled: C,
    default: !1,
    name: "Tooltip",
    state: "open"
  });
  let k = U;
  if (process.env.NODE_ENV !== "production") {
    const {
      current: ye
    } = _.useRef(C !== void 0);
    _.useEffect(() => {
      L && L.disabled && !ye && R !== "" && L.tagName.toLowerCase() === "button" && console.warn(["MUI: You are providing a disabled `button` child to the Tooltip component.", "A disabled element does not fire events.", "Tooltip needs to listen to the child element's events to display the title.", "", "Add a simple wrapper element, such as a `span`."].join(`
`));
    }, [R, L, ye]);
  }
  const de = Dg(S), ne = _.useRef(), he = ci(() => {
    ne.current !== void 0 && (document.body.style.WebkitUserSelect = ne.current, ne.current = void 0), W.clear();
  });
  _.useEffect(() => he, [he]);
  const xe = (ye) => {
    iS.clear(), Bc = !0, Z(!0), E && !k && E(ye);
  }, Oe = ci(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (ye) => {
      iS.start(800 + w, () => {
        Bc = !1;
      }), Z(!1), O && k && O(ye), ee.start(q.transitions.duration.shortest, () => {
        J.current = !1;
      });
    }
  ), Ee = (ye) => {
    J.current && ye.type !== "touchstart" || (L && L.removeAttribute("title"), re.clear(), oe.clear(), g || Bc && m ? re.start(Bc ? m : g, () => {
      xe(ye);
    }) : xe(ye));
  }, et = (ye) => {
    re.clear(), oe.start(w, () => {
      Oe(ye);
    });
  }, [, Ie] = _.useState(!1), Ce = (ye) => {
    ud(ye.target) || (Ie(!1), et(ye));
  }, ue = (ye) => {
    L || Y(ye.currentTarget), ud(ye.target) && (Ie(!0), Ee(ye));
  }, Tt = (ye) => {
    J.current = !0;
    const mn = F.props;
    mn.onTouchStart && mn.onTouchStart(ye);
  }, tt = (ye) => {
    Tt(ye), oe.clear(), ee.clear(), he(), ne.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", W.start(v, () => {
      document.body.style.WebkitUserSelect = ne.current, Ee(ye);
    });
  }, an = (ye) => {
    F.props.onTouchEnd && F.props.onTouchEnd(ye), he(), oe.start(b, () => {
      Oe(ye);
    });
  };
  _.useEffect(() => {
    if (!k)
      return;
    function ye(mn) {
      mn.key === "Escape" && Oe(mn);
    }
    return document.addEventListener("keydown", ye), () => {
      document.removeEventListener("keydown", ye);
    };
  }, [Oe, k]);
  const Jt = Gt(ts(F), Y, n);
  !R && R !== 0 && (k = !1);
  const sn = _.useRef(), wn = (ye) => {
    const mn = F.props;
    mn.onMouseMove && mn.onMouseMove(ye), Ss = {
      x: ye.clientX,
      y: ye.clientY
    }, sn.current && sn.current.update();
  }, Ut = {}, On = typeof R == "string";
  c ? (Ut.title = !k && On && !d ? R : null, Ut["aria-describedby"] = k ? de : null) : (Ut["aria-label"] = On ? R : null, Ut["aria-labelledby"] = k && !On ? de : null);
  const ve = {
    ...Ut,
    ...$,
    ...F.props,
    className: ie($.className, F.props.className),
    onTouchStart: Tt,
    ref: Jt,
    ...y ? {
      onMouseMove: wn
    } : {}
  };
  process.env.NODE_ENV !== "production" && (ve["data-mui-internal-clone-element"] = !0, _.useEffect(() => {
    L && !L.getAttribute("data-mui-internal-clone-element") && console.error(["MUI: The `children` component of the Tooltip is not forwarding its props correctly.", "Please make sure that props are spread on the same element that the ref is applied to."].join(`
`));
  }, [L]));
  const ln = {};
  h || (ve.onTouchStart = tt, ve.onTouchEnd = an), d || (ve.onMouseOver = zc(Ee, ve.onMouseOver), ve.onMouseLeave = zc(et, ve.onMouseLeave), G || (ln.onMouseOver = Ee, ln.onMouseLeave = et)), u || (ve.onFocus = zc(ue, ve.onFocus), ve.onBlur = zc(Ce, ve.onBlur), G || (ln.onFocus = ue, ln.onBlur = Ce)), process.env.NODE_ENV !== "production" && F.props.title && console.error(["MUI: You have provided a `title` prop to the child of <Tooltip />.", `Remove this title prop \`${F.props.title}\` or the Tooltip component.`].join(`
`));
  const Ht = {
    ...r,
    isRtl: B,
    arrow: i,
    disableInteractive: G,
    placement: T,
    PopperComponentProp: j,
    touch: J.current
  }, V = typeof M.popper == "function" ? M.popper(Ht) : M.popper, se = _.useMemo(() => {
    let ye = [{
      name: "arrow",
      enabled: !!K,
      options: {
        element: K,
        padding: 4
      }
    }];
    return A.popperOptions?.modifiers && (ye = ye.concat(A.popperOptions.modifiers)), V?.popperOptions?.modifiers && (ye = ye.concat(V.popperOptions.modifiers)), {
      ...A.popperOptions,
      ...V?.popperOptions,
      modifiers: ye
    };
  }, [K, A.popperOptions, V?.popperOptions]), X = tX(Ht), le = typeof M.transition == "function" ? M.transition(Ht) : M.transition, fe = {
    slots: {
      popper: s.Popper,
      transition: s.Transition ?? N,
      tooltip: s.Tooltip,
      arrow: s.Arrow,
      ...P
    },
    slotProps: {
      arrow: M.arrow ?? l.arrow,
      popper: {
        ...A,
        ...V ?? l.popper
      },
      // resolvedPopperProps can be spread because it's already an object
      tooltip: M.tooltip ?? l.tooltip,
      transition: {
        ...D,
        ...le ?? l.transition
      }
    }
  }, [nt, ht] = lt("popper", {
    elementType: nX,
    externalForwardedProps: fe,
    ownerState: Ht,
    className: ie(X.popper, A?.className)
  }), [Jn, Ci] = lt("transition", {
    elementType: yl,
    externalForwardedProps: fe,
    ownerState: Ht
  }), [Qn, oo] = lt("tooltip", {
    elementType: rX,
    className: X.tooltip,
    externalForwardedProps: fe,
    ownerState: Ht
  }), [Xr, Pr] = lt("arrow", {
    elementType: iX,
    className: X.arrow,
    externalForwardedProps: fe,
    ownerState: Ht,
    ref: te
  });
  return /* @__PURE__ */ x.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ _.cloneElement(F, ve), /* @__PURE__ */ x.jsx(nt, {
      as: j ?? Hy,
      placement: T,
      anchorEl: y ? {
        getBoundingClientRect: () => ({
          top: Ss.y,
          left: Ss.x,
          right: Ss.x,
          bottom: Ss.y,
          width: 0,
          height: 0
        })
      } : L,
      popperRef: sn,
      open: L ? k : !1,
      id: de,
      transition: !0,
      ...ln,
      ...ht,
      popperOptions: se,
      children: ({
        TransitionProps: ye
      }) => /* @__PURE__ */ x.jsx(Jn, {
        timeout: q.transitions.duration.shorter,
        ...ye,
        ...Ci,
        children: /* @__PURE__ */ x.jsxs(Qn, {
          ...oo,
          children: [R, i ? /* @__PURE__ */ x.jsx(Xr, {
            ...Pr
          }) : null]
        })
      })
    })]
  });
});
process.env.NODE_ENV !== "production" && (lg.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, adds an arrow to the tooltip.
   * @default false
   */
  arrow: f.bool,
  /**
   * Tooltip reference element.
   */
  children: rs.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: f.shape({
    Arrow: f.elementType,
    Popper: f.elementType,
    Tooltip: f.elementType,
    Transition: f.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: f.shape({
    arrow: f.object,
    popper: f.object,
    tooltip: f.object,
    transition: f.object
  }),
  /**
   * Set to `true` if the `title` acts as an accessible description.
   * By default the `title` acts as an accessible label for the child.
   * @default false
   */
  describeChild: f.bool,
  /**
   * Do not respond to focus-visible events.
   * @default false
   */
  disableFocusListener: f.bool,
  /**
   * Do not respond to hover events.
   * @default false
   */
  disableHoverListener: f.bool,
  /**
   * Makes a tooltip not interactive, i.e. it will close when the user
   * hovers over the tooltip before the `leaveDelay` is expired.
   * @default false
   */
  disableInteractive: f.bool,
  /**
   * Do not respond to long press touch events.
   * @default false
   */
  disableTouchListener: f.bool,
  /**
   * The number of milliseconds to wait before showing the tooltip.
   * This prop won't impact the enter touch delay (`enterTouchDelay`).
   * @default 100
   */
  enterDelay: f.number,
  /**
   * The number of milliseconds to wait before showing the tooltip when one was already recently opened.
   * @default 0
   */
  enterNextDelay: f.number,
  /**
   * The number of milliseconds a user must touch the element before showing the tooltip.
   * @default 700
   */
  enterTouchDelay: f.number,
  /**
   * If `true`, the tooltip follow the cursor over the wrapped element.
   * @default false
   */
  followCursor: f.bool,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: f.string,
  /**
   * The number of milliseconds to wait before hiding the tooltip.
   * This prop won't impact the leave touch delay (`leaveTouchDelay`).
   * @default 0
   */
  leaveDelay: f.number,
  /**
   * The number of milliseconds after the user stops touching an element before hiding the tooltip.
   * @default 1500
   */
  leaveTouchDelay: f.number,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onClose: f.func,
  /**
   * Callback fired when the component requests to be open.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onOpen: f.func,
  /**
   * If `true`, the component is shown.
   */
  open: f.bool,
  /**
   * Tooltip placement.
   * @default 'bottom'
   */
  placement: f.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * The component used for the popper.
   * @deprecated use the `slots.popper` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  PopperComponent: f.elementType,
  /**
   * Props applied to the [`Popper`](https://mui.com/material-ui/api/popper/) element.
   * @deprecated use the `slotProps.popper` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  PopperProps: f.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    arrow: f.oneOfType([f.func, f.object]),
    popper: f.oneOfType([f.func, f.object]),
    tooltip: f.oneOfType([f.func, f.object]),
    transition: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    arrow: f.elementType,
    popper: f.elementType,
    tooltip: f.elementType,
    transition: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.
   */
  title: f.node,
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @deprecated use the `slots.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  TransitionComponent: f.elementType,
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  TransitionProps: f.object
});
function oX(e) {
  return Je("MuiTextField", e);
}
Ge("MuiTextField", ["root"]);
const aX = {
  standard: Df,
  filled: Nf,
  outlined: Rf
}, sX = (e) => {
  const {
    classes: t
  } = e;
  return at({
    root: ["root"]
  }, oX, t);
}, lX = ge(qy, {
  name: "MuiTextField",
  slot: "Root"
})({}), wk = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = pt({
    props: t,
    name: "MuiTextField"
  }), {
    autoComplete: i,
    autoFocus: o = !1,
    children: a,
    className: s,
    color: l = "primary",
    defaultValue: c,
    disabled: u = !1,
    error: d = !1,
    FormHelperTextProps: p,
    fullWidth: h = !1,
    helperText: g,
    id: m,
    InputLabelProps: v,
    inputProps: y,
    InputProps: S,
    inputRef: w,
    label: b,
    maxRows: O,
    minRows: E,
    multiline: C = !1,
    name: T,
    onBlur: j,
    onChange: A,
    onFocus: M,
    placeholder: P,
    required: R = !1,
    rows: N,
    select: D = !1,
    SelectProps: $,
    slots: F = {},
    slotProps: q = {},
    type: B,
    value: L,
    variant: Y = "outlined",
    ...K
  } = r, te = {
    ...r,
    autoFocus: o,
    color: l,
    disabled: u,
    error: d,
    fullWidth: h,
    multiline: C,
    required: R,
    select: D,
    variant: Y
  }, J = sX(te);
  process.env.NODE_ENV !== "production" && D && !a && console.error("MUI: `children` must be passed when using the `TextField` component with `select`.");
  const G = Dg(m), ee = g && G ? `${G}-helper-text` : void 0, re = b && G ? `${G}-label` : void 0, oe = aX[Y], W = {
    slots: F,
    slotProps: {
      input: S,
      inputLabel: v,
      htmlInput: y,
      formHelperText: p,
      select: $,
      ...q
    }
  }, U = {}, Z = W.slotProps.inputLabel;
  Y === "outlined" && (Z && typeof Z.shrink < "u" && (U.notched = Z.shrink), U.label = b), D && ((!$ || !$.native) && (U.id = void 0), U["aria-describedby"] = void 0);
  const [k, de] = lt("root", {
    elementType: lX,
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      ...W,
      ...K
    },
    ownerState: te,
    className: ie(J.root, s),
    ref: n,
    additionalProps: {
      disabled: u,
      error: d,
      fullWidth: h,
      required: R,
      color: l,
      variant: Y
    }
  }), [ne, he] = lt("input", {
    elementType: oe,
    externalForwardedProps: W,
    additionalProps: U,
    ownerState: te
  }), [xe, Oe] = lt("inputLabel", {
    elementType: lk,
    externalForwardedProps: W,
    ownerState: te
  }), [Ee, et] = lt("htmlInput", {
    elementType: "input",
    externalForwardedProps: W,
    ownerState: te
  }), [Ie, Ce] = lt("formHelperText", {
    elementType: ak,
    externalForwardedProps: W,
    ownerState: te
  }), [ue, Tt] = lt("select", {
    elementType: If,
    externalForwardedProps: W,
    ownerState: te
  }), tt = /* @__PURE__ */ x.jsx(ne, {
    "aria-describedby": ee,
    autoComplete: i,
    autoFocus: o,
    defaultValue: c,
    fullWidth: h,
    multiline: C,
    name: T,
    rows: N,
    maxRows: O,
    minRows: E,
    type: B,
    value: L,
    id: G,
    inputRef: w,
    onBlur: j,
    onChange: A,
    onFocus: M,
    placeholder: P,
    inputProps: et,
    slots: {
      input: F.htmlInput ? Ee : void 0
    },
    ...he
  });
  return /* @__PURE__ */ x.jsxs(k, {
    ...de,
    children: [b != null && b !== "" && /* @__PURE__ */ x.jsx(xe, {
      htmlFor: G,
      id: re,
      ...Oe,
      children: b
    }), D ? /* @__PURE__ */ x.jsx(ue, {
      "aria-describedby": ee,
      id: G,
      labelId: re,
      value: L,
      input: tt,
      ...Tt,
      children: a
    }) : tt, g && /* @__PURE__ */ x.jsx(Ie, {
      id: ee,
      ...Ce,
      children: g
    })]
  });
});
process.env.NODE_ENV !== "production" && (wk.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: f.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: f.bool,
  /**
   * @ignore
   */
  children: f.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: f.object,
  /**
   * @ignore
   */
  className: f.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: f.oneOfType([f.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), f.string]),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: f.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: f.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: f.bool,
  /**
   * Props applied to the [`FormHelperText`](https://mui.com/material-ui/api/form-helper-text/) element.
   * @deprecated Use `slotProps.formHelperText` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  FormHelperTextProps: f.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: f.bool,
  /**
   * The helper text content.
   */
  helperText: f.node,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: f.string,
  /**
   * Props applied to the [`InputLabel`](https://mui.com/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   * @deprecated Use `slotProps.inputLabel` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  InputLabelProps: f.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @deprecated Use `slotProps.htmlInput` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  inputProps: f.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](https://mui.com/material-ui/api/filled-input/),
   * [`OutlinedInput`](https://mui.com/material-ui/api/outlined-input/) or [`Input`](https://mui.com/material-ui/api/input/)
   * component depending on the `variant` prop value.
   * @deprecated Use `slotProps.input` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  InputProps: f.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: br,
  /**
   * The label content.
   */
  label: f.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: f.oneOf(["dense", "none", "normal"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: f.oneOfType([f.number, f.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: f.oneOfType([f.number, f.string]),
  /**
   * If `true`, a `textarea` element is rendered instead of an input.
   * @default false
   */
  multiline: f.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: f.string,
  /**
   * @ignore
   */
  onBlur: f.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: f.func,
  /**
   * @ignore
   */
  onFocus: f.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: f.string,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: f.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: f.oneOfType([f.number, f.string]),
  /**
   * Render a [`Select`](https://mui.com/material-ui/api/select/) element while passing the Input element to `Select` as `input` parameter.
   * If this option is set you must pass the options of the select as children.
   * @default false
   */
  select: f.bool,
  /**
   * Props applied to the [`Select`](https://mui.com/material-ui/api/select/) element.
   * @deprecated Use `slotProps.select` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  SelectProps: f.object,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: f.oneOfType([f.oneOf(["medium", "small"]), f.string]),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: f.shape({
    formHelperText: f.oneOfType([f.func, f.object]),
    htmlInput: f.oneOfType([f.func, f.object]),
    input: f.oneOfType([f.func, f.object]),
    inputLabel: f.oneOfType([f.func, f.object]),
    select: f.oneOfType([f.func, f.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: f.shape({
    formHelperText: f.elementType,
    htmlInput: f.elementType,
    input: f.elementType,
    inputLabel: f.elementType,
    root: f.elementType,
    select: f.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: f.oneOfType([f.arrayOf(f.oneOfType([f.func, f.object, f.bool])), f.func, f.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   */
  type: f.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: f.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: f.oneOf(["filled", "outlined", "standard"])
});
function cX(e) {
  return Qe({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Box_List" }, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M6.562,8.062h-2a1.5,1.5,0,0,1-1.5-1.5v-2a1.5,1.5,0,0,1,1.5-1.5h2a1.5,1.5,0,0,1,1.5,1.5v2A1.5,1.5,0,0,1,6.562,8.062Zm-2-4a.5.5,0,0,0-.5.5v2a.5.5,0,0,0,.5.5h2a.5.5,0,0,0,.5-.5v-2a.5.5,0,0,0-.5-.5Z" }, child: [] }, { tag: "path", attr: { d: "M6.562,20.938h-2a1.5,1.5,0,0,1-1.5-1.5v-2a1.5,1.5,0,0,1,1.5-1.5h2a1.5,1.5,0,0,1,1.5,1.5v2A1.5,1.5,0,0,1,6.562,20.938Zm-2-4a.5.5,0,0,0-.5.5v2a.5.5,0,0,0,.5.5h2a.5.5,0,0,0,.5-.5v-2a.5.5,0,0,0-.5-.5Z" }, child: [] }, { tag: "path", attr: { d: "M6.562,14.5h-2a1.5,1.5,0,0,1-1.5-1.5V11a1.5,1.5,0,0,1,1.5-1.5h2a1.5,1.5,0,0,1,1.5,1.5v2A1.5,1.5,0,0,1,6.562,14.5Zm-2-4a.5.5,0,0,0-.5.5v2a.5.5,0,0,0,.5.5h2a.5.5,0,0,0,.5-.5V11a.5.5,0,0,0-.5-.5Z" }, child: [] }, { tag: "path", attr: { d: "M20.438,6.062h-9a.5.5,0,0,1,0-1h9a.5.5,0,0,1,0,1Z" }, child: [] }, { tag: "path", attr: { d: "M20.438,12.5h-9a.5.5,0,0,1,0-1h9a.5.5,0,0,1,0,1Z" }, child: [] }, { tag: "path", attr: { d: "M20.438,18.935h-9a.5.5,0,1,1,0-1h9a.5.5,0,0,1,0,1Z" }, child: [] }] }] }] })(e);
}
function uX(e) {
  return Qe({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Export" }, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M5.552,20.968a2.577,2.577,0,0,1-2.5-2.73c-.012-2.153,0-4.306,0-6.459a.5.5,0,0,1,1,0c0,2.2-.032,4.4,0,6.6.016,1.107.848,1.589,1.838,1.589H18.353A1.546,1.546,0,0,0,19.825,19a3.023,3.023,0,0,0,.1-1.061V11.779h0a.5.5,0,0,1,1,0c0,2.224.085,4.465,0,6.687a2.567,2.567,0,0,1-2.67,2.5Z" }, child: [] }, { tag: "path", attr: { d: "M12.337,3.176a.455.455,0,0,0-.311-.138c-.015,0-.028,0-.043-.006s-.027,0-.041.006a.457.457,0,0,0-.312.138L7.961,6.845a.5.5,0,0,0,.707.707l2.816-2.815V15.479a.5.5,0,0,0,1,0V4.737L15.3,7.552a.5.5,0,0,0,.707-.707Z" }, child: [] }] }] }] })(e);
}
function dX(e) {
  return Qe({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Warning" }, child: [{ tag: "g", attr: {}, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M12.5,8.752a.5.5,0,0,0-1,0h0v6a.5.5,0,0,0,1,0Z" }, child: [] }, { tag: "circle", attr: { cx: "11.999", cy: "16.736", r: "0.5" }, child: [] }] }, { tag: "path", attr: { d: "M18.642,20.934H5.385A2.5,2.5,0,0,1,3.163,17.29L9.792,4.421a2.5,2.5,0,0,1,4.444,0L20.865,17.29a2.5,2.5,0,0,1-2.223,3.644ZM12.014,4.065a1.478,1.478,0,0,0-1.334.814L4.052,17.748a1.5,1.5,0,0,0,1.333,2.186H18.642a1.5,1.5,0,0,0,1.334-2.186L13.348,4.879A1.478,1.478,0,0,0,12.014,4.065Z" }, child: [] }] }] }] })(e);
}
const fX = yu(If)(() => ({
  width: "fit-content",
  maxWidth: "100px",
  height: "28px",
  padding: "0 6px",
  display: "flex",
  fontSize: "12px",
  alignItems: "center",
  "& .MuiSelect-select": { padding: 0 },
  // Normal border
  "& .MuiOutlinedInput-notchedOutline": {
    borderColor: "#C6C6C6",
    transition: "all 0.2s ease"
  },
  // Hover state
  "&:hover .MuiOutlinedInput-notchedOutline": {
    borderColor: "#B084CC"
  },
  // Focus state (main customization)
  "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
    borderColor: "#884EA7 !important",
    boxShadow: "0 0 0 3px rgba(136, 78, 167, 0.2)"
  }
}));
function is({
  widgetId: e,
  options: t = [],
  defaultValue: n = ["all"],
  onFilterChange: r = () => {
  },
  onExport: i = () => {
  }
}) {
  const o = JSON.parse(sessionStorage.getItem("community_id")) || [], [a, s] = Ke(o), [l, c] = Ke(""), u = t.filter(
    (h) => h.community_name.toLowerCase().includes(l.toLowerCase())
  ), d = (h) => {
    let g = h.target.value;
    const m = t.map((v) => v.community_id);
    if (g.includes("all") && !a.includes("all"))
      s(["all", ...m]), Ti("community_id", JSON.stringify(m)), Ti("widget_id", e), r(m);
    else if (!g.includes("all") && a.includes("all"))
      s([]), Ti("community_id", JSON.stringify([])), Ti("widget_id", e), r([]);
    else {
      const v = g.filter((w) => w !== "all"), y = v.length > 0 && m.every((w) => v.includes(w));
      s(y ? ["all", ...m] : v);
      const S = v.length === 1 ? v[0] : v;
      Ti("community_id", JSON.stringify(S)), Ti("widget_id", e), r(S);
    }
  }, p = () => {
    Ti("widget_id", e), Ti("export", !0), i();
  };
  return /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-2", children: [
    /* @__PURE__ */ x.jsx(lg, { slotProps: { tooltip: { sx: { fontSize: "12px" } } }, children: /* @__PURE__ */ x.jsx(qy, { size: "small", children: /* @__PURE__ */ x.jsxs(
      fX,
      {
        multiple: !0,
        value: a,
        onChange: d,
        displayEmpty: !0,
        renderValue: (h) => h.length === 0 ? /* @__PURE__ */ x.jsx("span", { style: { color: "#9e9e9e" }, children: "Select Community" }) : h.includes("all") ? "All" : t.filter((g) => h.includes(g.community_id)).map((g) => g.community_name).join(", "),
        MenuProps: {
          PaperProps: { style: { maxHeight: 300 } },
          autoFocus: !1
        },
        children: [
          /* @__PURE__ */ x.jsx(
            $s,
            {
              onKeyDown: (h) => h.stopPropagation(),
              onClick: (h) => h.stopPropagation(),
              disableRipple: !0,
              sx: {
                "&:hover": { backgroundColor: "transparent" },
                cursor: "default"
              },
              children: /* @__PURE__ */ x.jsx(
                wk,
                {
                  placeholder: "Search...",
                  size: "small",
                  variant: "outlined",
                  value: l,
                  onChange: (h) => c(h.target.value),
                  onClick: (h) => h.stopPropagation(),
                  onKeyDown: (h) => h.stopPropagation(),
                  sx: { width: "100%" },
                  autoFocus: !0
                }
              )
            }
          ),
          /* @__PURE__ */ x.jsxs($s, { value: "all", children: [
            /* @__PURE__ */ x.jsx(ag, { checked: a.includes("all") }),
            /* @__PURE__ */ x.jsx(fu, { primary: "All", sx: { fontWeight: 600 } })
          ] }),
          u.length > 0 ? u.map((h) => /* @__PURE__ */ x.jsxs($s, { value: h.community_id, children: [
            /* @__PURE__ */ x.jsx(ag, { checked: a.includes(h.community_id) }),
            /* @__PURE__ */ x.jsx(fu, { primary: h.community_name })
          ] }, h.community_id)) : /* @__PURE__ */ x.jsx($s, { disabled: !0, children: /* @__PURE__ */ x.jsx(fu, { primary: "No results found" }) })
        ]
      }
    ) }) }),
    /* @__PURE__ */ x.jsx(lg, { title: "Export CSV for this widget", children: /* @__PURE__ */ x.jsx(
      "button",
      {
        onClick: p,
        className: "px-3 py-2 bg-[#FBF5FF] rounded cursor-pointer",
        children: /* @__PURE__ */ x.jsx(uX, { className: "stroke-[#884EA7] stroke-[1.4]" })
      }
    ) })
  ] });
}
function lne({ isStatic: e, data: t }) {
  const n = Number(t?.thisMonthMoveIns ?? t?.lastMonthMoveIns ?? 0), r = Number(
    t?.thisMonthMoveOuts ?? t?.lastMonthMoveOuts ?? 0
  ), i = Number(
    t?.moveInPercentChange ?? t?.moveInChange ?? 0
  ), o = Number(
    t?.moveOutPercentChange ?? t?.moveOutChange ?? 0
  ), a = ["#8B5CF6", "#EBE4F9"], s = [
    { name: "Move-ins", value: n, color: a[0] },
    { name: "Move-outs", value: r, color: a[1] }
  ];
  function l(c, u) {
    return ((Number(c) + Number(u)) / 2).toFixed(2) + "%";
  }
  return /* @__PURE__ */ x.jsx(
    qo,
    {
      title: "Community",
      period: "This Month",
      icon: /* @__PURE__ */ x.jsx(Lg, { className: "!text-[24px] text-[#329DFF]" }),
      className: `${e && "max-h-[184px]"} h-[184px] mb-4 break-inside-avoid`,
      actionButtons: /* @__PURE__ */ x.jsx(
        is,
        {
          widgetId: t?.widget_id,
          options: t?.communities,
          onFilterChange: (c, u) => console.log(c, u),
          onExport: (c) => console.log("Export triggered for", c)
        }
      ),
      children: /* @__PURE__ */ x.jsxs("div", { className: "flex", children: [
        /* @__PURE__ */ x.jsxs("div", { className: "w-[50%] flex flex-col gap-[28px]", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col gap-[8px]", children: [
            /* @__PURE__ */ x.jsx("div", { className: "!m-0 !text-[12px] !leading-[16px] !text-[#64748B]", children: "Move-in/Out Count" }),
            /* @__PURE__ */ x.jsx("div", { className: "!m-0 !text-[28px] !leading-[32px] !font-medium !text-[#8B5CF6]", children: n + r })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "!m-0 !text-[10px] !leading-[14px] !text-[#64748B] flex items-center gap-[4px]", children: [
            /* @__PURE__ */ x.jsx(
              I_,
              {
                value: l(i, o)
              }
            ),
            /* @__PURE__ */ x.jsx("div", { className: "whitespace-nowrap", children: "Compared to last month" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "w-[50%] h-[111px] flex justify-end", children: /* @__PURE__ */ x.jsx(Zo, { width: "75%", height: "100%", children: /* @__PURE__ */ x.jsxs(Sf, { children: [
          /* @__PURE__ */ x.jsxs(
            tc,
            {
              data: s,
              innerRadius: 36,
              outerRadius: 52,
              paddingAngle: 2,
              dataKey: "value",
              children: [
                /* @__PURE__ */ x.jsx(Hr, { fill: a[0] }),
                /* @__PURE__ */ x.jsx(Hr, { fill: a[1] })
              ]
            }
          ),
          /* @__PURE__ */ x.jsx(Xo, { content: /* @__PURE__ */ x.jsx(Rl, {}) })
        ] }) }) })
      ] })
    }
  );
}
function cne({ isStatic: e, data: t, communities: n }) {
  const r = ["#8B5CF6", "#22C55E", "#3B82F6", "#F59E0B"], i = [
    {
      name: "Notice",
      value: Number(t?.total_notices || 0),
      color: r[0]
    },
    { name: "Post", value: Number(t?.total_topics || 0), color: r[1] },
    { name: "Poll", value: Number(t?.total_polls || 0), color: r[2] },
    {
      name: "Survey",
      value: Number(t?.total_surveys || 0),
      color: r[3]
    }
  ];
  return /* @__PURE__ */ x.jsx(
    qo,
    {
      title: "Engagement",
      period: "This Month",
      icon: /* @__PURE__ */ x.jsx(M_, { className: "!text-[24px] text-[#DBB467]" }),
      className: `${e && "max-h-[303px]"} h-[303px]`,
      actionButtons: /* @__PURE__ */ x.jsx(
        is,
        {
          widgetId: t?.widget_id,
          options: t?.communities,
          onFilterChange: (o, a) => console.log(o, a),
          onExport: (o) => console.log("Export triggered for", o)
        }
      ),
      children: /* @__PURE__ */ x.jsx("div", { className: "w-full h-[235px]", children: /* @__PURE__ */ x.jsx(Zo, { width: "100%", height: "100%", children: /* @__PURE__ */ x.jsxs(
        eq,
        {
          data: i,
          layout: "vertical",
          margin: { top: 4, right: 8, left: 0, bottom: 0 },
          children: [
            /* @__PURE__ */ x.jsx(
              wf,
              {
                stroke: "#e5e7eb",
                strokeDasharray: "3 3",
                horizontal: !1
              }
            ),
            /* @__PURE__ */ x.jsx(
              hl,
              {
                type: "category",
                dataKey: "name",
                width: 40,
                axisLine: !1,
                tickLine: !1,
                tick: {
                  fontSize: 10,
                  lineHeight: 14,
                  fill: "#121212",
                  fontWeight: 400
                }
              }
            ),
            /* @__PURE__ */ x.jsx(
              Of,
              {
                type: "number",
                axisLine: !1,
                tickLine: !1,
                tick: {
                  fontSize: 10,
                  lineHeight: 14,
                  fill: "#64748B",
                  fontWeight: 400
                }
              }
            ),
            /* @__PURE__ */ x.jsx(
              Xo,
              {
                content: /* @__PURE__ */ x.jsx(Rl, {}),
                cursor: { fill: "transparent" }
              }
            ),
            /* @__PURE__ */ x.jsx(ZT, { dataKey: "value", barSize: 40, isAnimationActive: !1, children: i.map((o, a) => /* @__PURE__ */ x.jsx(Hr, { fill: r[a] }, o.name)) })
          ]
        }
      ) }) })
    }
  );
}
function une({ isStatic: e, data: t }) {
  const n = Number(t?.totalBookings || 0), r = Number(t?.averageUtilizationPercentage || 0), i = Un(() => {
    if (!t?.graph) return [];
    const { labels: s = [], bookings: l = [], utilization: c = [] } = t.graph;
    return s.map((u, d) => ({
      time: u,
      bookings: l[d] || 0,
      utilization: c[d] || 0
    }));
  }, [t]), o = (s) => ["12 AM", "6 AM", "12 PM", "6 PM", "11 PM"].includes(s) ? s : "", a = i.length ? i : Array.from({ length: 24 }, (s, l) => ({
    time: `${l % 12 || 12} ${l >= 12 ? "PM" : "AM"}`,
    bookings: 0,
    utilization: 0
  }));
  return /* @__PURE__ */ x.jsxs(
    qo,
    {
      title: "Facilities",
      period: "Today",
      icon: /* @__PURE__ */ x.jsx(k_, { className: "!text-[24px] text-[#8B5CF6]" }),
      className: `${e && "max-h-[305px]"} h-[305px] mb-4 break-inside-avoid`,
      actionButtons: /* @__PURE__ */ x.jsx(
        is,
        {
          widgetId: t?.widget_id,
          options: t?.communities,
          onFilterChange: (s, l) => console.log(s, l),
          onExport: (s) => console.log("Export triggered for", s)
        }
      ),
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-2 gap-[24px] mb-[16px]", children: [
          /* @__PURE__ */ x.jsxs("div", { children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] text-[#64748B]", children: "Bookings" }),
            /* @__PURE__ */ x.jsx("div", { className: "!text-[24px] font-medium text-[#8B5CF6]", children: n })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] text-[#64748B]", children: "Utilisation Rate" }),
            /* @__PURE__ */ x.jsxs("div", { className: "!text-[24px] font-medium text-[#329DFF]", children: [
              r.toFixed(2),
              "%"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "w-full h-[170px]", children: /* @__PURE__ */ x.jsx(Zo, { width: "100%", height: "100%", children: /* @__PURE__ */ x.jsxs(
          _A,
          {
            data: a,
            margin: { top: 5, right: -30, left: -35, bottom: 0 },
            children: [
              /* @__PURE__ */ x.jsx(wf, { strokeDasharray: "3 3", stroke: "#EBEBEB" }),
              /* @__PURE__ */ x.jsx(
                Of,
                {
                  dataKey: "time",
                  interval: 0,
                  tickFormatter: o,
                  tick: {
                    fontSize: 10,
                    fill: "#121212",
                    fontWeight: 400
                  },
                  axisLine: !1,
                  tickLine: !1,
                  minTickGap: 0
                }
              ),
              /* @__PURE__ */ x.jsx(
                hl,
                {
                  yAxisId: "left",
                  tick: { fontSize: 10, fill: "#64748B" },
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ x.jsx(
                hl,
                {
                  yAxisId: "right",
                  orientation: "right",
                  domain: [0, 100],
                  ticks: [0, 20, 40, 60, 80, 100],
                  tickFormatter: (s) => `${s}%`,
                  tick: { fontSize: 10, fill: "#64748B" },
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ x.jsx(Xo, { content: /* @__PURE__ */ x.jsx(Rl, {}) }),
              /* @__PURE__ */ x.jsx(
                Sa,
                {
                  yAxisId: "left",
                  type: "monotone",
                  dataKey: "bookings",
                  name: "Bookings",
                  stroke: "#8B5CF6",
                  strokeWidth: 2,
                  dot: !1,
                  isAnimationActive: !1
                }
              ),
              /* @__PURE__ */ x.jsx(
                Sa,
                {
                  yAxisId: "right",
                  type: "monotone",
                  dataKey: "utilization",
                  name: "Utilization Rate",
                  stroke: "#329DFF",
                  strokeWidth: 2,
                  dot: !1,
                  strokeDasharray: "2 4",
                  isAnimationActive: !1
                }
              )
            ]
          }
        ) }) })
      ]
    }
  );
}
function dne({ data: e }) {
  const t = e?.incomeSummary || {}, n = e?.expenditureSummary || {}, r = ["AED", "USD", "EUR"], i = ["Rs", "INR", ""];
  function o(s) {
    if (s == null || isNaN(s)) return "0";
    const l = Number(s), c = Math.abs(l), u = l < 0 ? "-" : "";
    return c >= 1e9 ? u + (c / 1e9).toFixed(c % 1e9 === 0 ? 0 : 2) + "B" : c >= 1e6 ? u + (c / 1e6).toFixed(c % 1e6 === 0 ? 0 : 2) + "M" : c >= 1e3 ? u + (c / 1e3).toFixed(c % 1e3 === 0 ? 0 : 2) + "K" : u + c.toFixed(c % 1 === 0 ? 0 : 2);
  }
  function a(s, l) {
    return l ? i.includes(l) ? `${l} ${o(s)}` : r.includes(l) ? `${o(s)} ${l}` : `${o(s)} ${l}` : o(s);
  }
  return console.log("Finance Summary Data:", e), /* @__PURE__ */ x.jsx(
    qo,
    {
      title: "Income",
      period: "This Month",
      icon: /* @__PURE__ */ x.jsx(E0, { className: "!text-[24px] text-green-600" }),
      className: "!gap-[16px] break-inside-avoid h-[232px] overflow-hidden",
      actionButtons: /* @__PURE__ */ x.jsx(
        is,
        {
          widgetId: e?.widget_id,
          options: e?.communities,
          onFilterChange: (s, l) => console.log(s, l),
          onExport: (s) => console.log("Export triggered for", s)
        }
      ),
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-4 !text-[12px] text-[#64748B] mb-2", children: [
          /* @__PURE__ */ x.jsx("div", { children: "Opening" }),
          /* @__PURE__ */ x.jsx("div", { children: "Income" }),
          /* @__PURE__ */ x.jsx("div", { children: "Collection" }),
          /* @__PURE__ */ x.jsx("div", { children: "Closing" })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-4 !text-[12px] font-medium text-[#121212] mb-2", children: [
          /* @__PURE__ */ x.jsx("div", { children: a(t.opening_balance, t?.currency_type) }),
          /* @__PURE__ */ x.jsx("div", { children: a(t.income, t?.currency_type) }),
          /* @__PURE__ */ x.jsx("div", { children: a(t.collection, t?.currency_type) }),
          /* @__PURE__ */ x.jsx("div", { children: a(t.closing_balance, t?.currency_type) })
        ] }),
        /* @__PURE__ */ x.jsx("hr", { className: "my-4 border-t border-dashed border-gray-300" }),
        /* @__PURE__ */ x.jsx("div", { className: "flex items-center justify-between", children: /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[12px]", children: [
          /* @__PURE__ */ x.jsx(E0, { className: "!text-[24px] text-red-600" }),
          /* @__PURE__ */ x.jsx("div", { className: "!my-0 !font-medium !text-[16px] !leading-[20px] !text-[#121212]", children: "Expenditure" })
        ] }) }),
        /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-4 !text-[12px] text-[#64748B] mt-4 mb-2", children: [
          /* @__PURE__ */ x.jsx("div", { children: "Opening" }),
          /* @__PURE__ */ x.jsx("div", { children: "Expenditure" }),
          /* @__PURE__ */ x.jsx("div", { children: "Payment" }),
          /* @__PURE__ */ x.jsx("div", { children: "Outstanding" })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-4 !text-[12px] font-medium text-[#121212]", children: [
          /* @__PURE__ */ x.jsx("div", { children: a(
            n.opening_balance,
            n?.currency_type
          ) }),
          /* @__PURE__ */ x.jsx("div", { children: a(n.expenditure, n?.currency_type) }),
          /* @__PURE__ */ x.jsx("div", { children: a(n.payment, n?.currency_type) }),
          /* @__PURE__ */ x.jsx("div", { children: a(n.outstanding, n?.currency_type) })
        ] })
      ] })
    }
  );
}
var pX = "tippy-box", Ok = "tippy-content", hX = "tippy-backdrop", Sk = "tippy-arrow", Ek = "tippy-svg-arrow", bo = {
  passive: !0,
  capture: !0
}, _k = function() {
  return document.body;
};
function mX(e, t) {
  return {}.hasOwnProperty.call(e, t);
}
function Rh(e, t, n) {
  if (Array.isArray(e)) {
    var r = e[t];
    return r ?? (Array.isArray(n) ? n[t] : n);
  }
  return e;
}
function Gy(e, t) {
  var n = {}.toString.call(e);
  return n.indexOf("[object") === 0 && n.indexOf(t + "]") > -1;
}
function Pk(e, t) {
  return typeof e == "function" ? e.apply(void 0, t) : e;
}
function oS(e, t) {
  if (t === 0)
    return e;
  var n;
  return function(r) {
    clearTimeout(n), n = setTimeout(function() {
      e(r);
    }, t);
  };
}
function gX(e, t) {
  var n = Object.assign({}, e);
  return t.forEach(function(r) {
    delete n[r];
  }), n;
}
function vX(e) {
  return e.split(/\s+/).filter(Boolean);
}
function ma(e) {
  return [].concat(e);
}
function aS(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function yX(e) {
  return e.filter(function(t, n) {
    return e.indexOf(t) === n;
  });
}
function bX(e) {
  return e.split("-")[0];
}
function gd(e) {
  return [].slice.call(e);
}
function sS(e) {
  return Object.keys(e).reduce(function(t, n) {
    return e[n] !== void 0 && (t[n] = e[n]), t;
  }, {});
}
function Ys() {
  return document.createElement("div");
}
function xl(e) {
  return ["Element", "Fragment"].some(function(t) {
    return Gy(e, t);
  });
}
function xX(e) {
  return Gy(e, "NodeList");
}
function wX(e) {
  return Gy(e, "MouseEvent");
}
function OX(e) {
  return !!(e && e._tippy && e._tippy.reference === e);
}
function SX(e) {
  return xl(e) ? [e] : xX(e) ? gd(e) : Array.isArray(e) ? e : gd(document.querySelectorAll(e));
}
function Ih(e, t) {
  e.forEach(function(n) {
    n && (n.style.transitionDuration = t + "ms");
  });
}
function lS(e, t) {
  e.forEach(function(n) {
    n && n.setAttribute("data-state", t);
  });
}
function EX(e) {
  var t, n = ma(e), r = n[0];
  return r != null && (t = r.ownerDocument) != null && t.body ? r.ownerDocument : document;
}
function _X(e, t) {
  var n = t.clientX, r = t.clientY;
  return e.every(function(i) {
    var o = i.popperRect, a = i.popperState, s = i.props, l = s.interactiveBorder, c = bX(a.placement), u = a.modifiersData.offset;
    if (!u)
      return !0;
    var d = c === "bottom" ? u.top.y : 0, p = c === "top" ? u.bottom.y : 0, h = c === "right" ? u.left.x : 0, g = c === "left" ? u.right.x : 0, m = o.top - r + d > l, v = r - o.bottom - p > l, y = o.left - n + h > l, S = n - o.right - g > l;
    return m || v || y || S;
  });
}
function $h(e, t, n) {
  var r = t + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    e[r](i, n);
  });
}
function cS(e, t) {
  for (var n = t; n; ) {
    var r;
    if (e.contains(n))
      return !0;
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var Dr = {
  isTouch: !1
}, uS = 0;
function PX() {
  Dr.isTouch || (Dr.isTouch = !0, window.performance && document.addEventListener("mousemove", Ck));
}
function Ck() {
  var e = performance.now();
  e - uS < 20 && (Dr.isTouch = !1, document.removeEventListener("mousemove", Ck)), uS = e;
}
function CX() {
  var e = document.activeElement;
  if (OX(e)) {
    var t = e._tippy;
    e.blur && !t.state.isVisible && e.blur();
  }
}
function TX() {
  document.addEventListener("touchstart", PX, bo), window.addEventListener("blur", CX);
}
var AX = typeof window < "u" && typeof document < "u", kX = AX ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function ua(e) {
  var t = e === "destroy" ? "n already-" : " ";
  return [e + "() was called on a" + t + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function dS(e) {
  var t = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return e.replace(t, " ").replace(n, "").trim();
}
function MX(e) {
  return dS(`
  %ctippy.js

  %c` + dS(e) + `

  %c This is a development-only message. It will be removed in production.
  `);
}
function Tk(e) {
  return [
    MX(e),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var wl;
process.env.NODE_ENV !== "production" && jX();
function jX() {
  wl = /* @__PURE__ */ new Set();
}
function ni(e, t) {
  if (e && !wl.has(t)) {
    var n;
    wl.add(t), (n = console).warn.apply(n, Tk(t));
  }
}
function cg(e, t) {
  if (e && !wl.has(t)) {
    var n;
    wl.add(t), (n = console).error.apply(n, Tk(t));
  }
}
function NX(e) {
  var t = !e, n = Object.prototype.toString.call(e) === "[object Object]" && !e.addEventListener;
  cg(t, ["tippy() was passed", "`" + String(e) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), cg(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var Ak = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, DX = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, Wn = Object.assign({
  appendTo: _k,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, Ak, DX), RX = Object.keys(Wn), IX = function(t) {
  process.env.NODE_ENV !== "production" && Mk(t, []);
  var n = Object.keys(t);
  n.forEach(function(r) {
    Wn[r] = t[r];
  });
};
function kk(e) {
  var t = e.plugins || [], n = t.reduce(function(r, i) {
    var o = i.name, a = i.defaultValue;
    if (o) {
      var s;
      r[o] = e[o] !== void 0 ? e[o] : (s = Wn[o]) != null ? s : a;
    }
    return r;
  }, {});
  return Object.assign({}, e, n);
}
function $X(e, t) {
  var n = t ? Object.keys(kk(Object.assign({}, Wn, {
    plugins: t
  }))) : RX, r = n.reduce(function(i, o) {
    var a = (e.getAttribute("data-tippy-" + o) || "").trim();
    if (!a)
      return i;
    if (o === "content")
      i[o] = a;
    else
      try {
        i[o] = JSON.parse(a);
      } catch {
        i[o] = a;
      }
    return i;
  }, {});
  return r;
}
function fS(e, t) {
  var n = Object.assign({}, t, {
    content: Pk(t.content, [e])
  }, t.ignoreAttributes ? {} : $X(e, t.plugins));
  return n.aria = Object.assign({}, Wn.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? t.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? t.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function Mk(e, t) {
  e === void 0 && (e = {}), t === void 0 && (t = []);
  var n = Object.keys(e);
  n.forEach(function(r) {
    var i = gX(Wn, Object.keys(Ak)), o = !mX(i, r);
    o && (o = t.filter(function(a) {
      return a.name === r;
    }).length === 0), ni(o, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var LX = function() {
  return "innerHTML";
};
function ug(e, t) {
  e[LX()] = t;
}
function pS(e) {
  var t = Ys();
  return e === !0 ? t.className = Sk : (t.className = Ek, xl(e) ? t.appendChild(e) : ug(t, e)), t;
}
function hS(e, t) {
  xl(t.content) ? (ug(e, ""), e.appendChild(t.content)) : typeof t.content != "function" && (t.allowHTML ? ug(e, t.content) : e.textContent = t.content);
}
function dg(e) {
  var t = e.firstElementChild, n = gd(t.children);
  return {
    box: t,
    content: n.find(function(r) {
      return r.classList.contains(Ok);
    }),
    arrow: n.find(function(r) {
      return r.classList.contains(Sk) || r.classList.contains(Ek);
    }),
    backdrop: n.find(function(r) {
      return r.classList.contains(hX);
    })
  };
}
function jk(e) {
  var t = Ys(), n = Ys();
  n.className = pX, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var r = Ys();
  r.className = Ok, r.setAttribute("data-state", "hidden"), hS(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props);
  function i(o, a) {
    var s = dg(t), l = s.box, c = s.content, u = s.arrow;
    a.theme ? l.setAttribute("data-theme", a.theme) : l.removeAttribute("data-theme"), typeof a.animation == "string" ? l.setAttribute("data-animation", a.animation) : l.removeAttribute("data-animation"), a.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof a.maxWidth == "number" ? a.maxWidth + "px" : a.maxWidth, a.role ? l.setAttribute("role", a.role) : l.removeAttribute("role"), (o.content !== a.content || o.allowHTML !== a.allowHTML) && hS(c, e.props), a.arrow ? u ? o.arrow !== a.arrow && (l.removeChild(u), l.appendChild(pS(a.arrow))) : l.appendChild(pS(a.arrow)) : u && l.removeChild(u);
  }
  return {
    popper: t,
    onUpdate: i
  };
}
jk.$$tippy = !0;
var FX = 1, Wc = [], Lh = [];
function BX(e, t) {
  var n = fS(e, Object.assign({}, Wn, kk(sS(t)))), r, i, o, a = !1, s = !1, l = !1, c = !1, u, d, p, h = [], g = oS(ne, n.interactiveDebounce), m, v = FX++, y = null, S = yX(n.plugins), w = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: v,
    reference: e,
    popper: Ys(),
    popperInstance: y,
    props: n,
    state: w,
    plugins: S,
    // methods
    clearDelayTimeouts: Jt,
    setProps: sn,
    setContent: wn,
    show: Ut,
    hide: On,
    hideWithInteractivity: ve,
    enable: tt,
    disable: an,
    unmount: ln,
    destroy: Ht
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && cg(!0, "render() function has not been supplied."), b;
  var O = n.render(b), E = O.popper, C = O.onUpdate;
  E.setAttribute("data-tippy-root", ""), E.id = "tippy-" + b.id, b.popper = E, e._tippy = b, E._tippy = b;
  var T = S.map(function(V) {
    return V.fn(b);
  }), j = e.hasAttribute("aria-expanded");
  return Z(), L(), F(), q("onCreate", [b]), n.showOnCreate && ue(), E.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), E.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && N().addEventListener("mousemove", g);
  }), b;
  function A() {
    var V = b.props.touch;
    return Array.isArray(V) ? V : [V, 0];
  }
  function M() {
    return A()[0] === "hold";
  }
  function P() {
    var V;
    return !!((V = b.props.render) != null && V.$$tippy);
  }
  function R() {
    return m || e;
  }
  function N() {
    var V = R().parentNode;
    return V ? EX(V) : document;
  }
  function D() {
    return dg(E);
  }
  function $(V) {
    return b.state.isMounted && !b.state.isVisible || Dr.isTouch || u && u.type === "focus" ? 0 : Rh(b.props.delay, V ? 0 : 1, Wn.delay);
  }
  function F(V) {
    V === void 0 && (V = !1), E.style.pointerEvents = b.props.interactive && !V ? "" : "none", E.style.zIndex = "" + b.props.zIndex;
  }
  function q(V, se, X) {
    if (X === void 0 && (X = !0), T.forEach(function(fe) {
      fe[V] && fe[V].apply(fe, se);
    }), X) {
      var le;
      (le = b.props)[V].apply(le, se);
    }
  }
  function B() {
    var V = b.props.aria;
    if (V.content) {
      var se = "aria-" + V.content, X = E.id, le = ma(b.props.triggerTarget || e);
      le.forEach(function(fe) {
        var nt = fe.getAttribute(se);
        if (b.state.isVisible)
          fe.setAttribute(se, nt ? nt + " " + X : X);
        else {
          var ht = nt && nt.replace(X, "").trim();
          ht ? fe.setAttribute(se, ht) : fe.removeAttribute(se);
        }
      });
    }
  }
  function L() {
    if (!(j || !b.props.aria.expanded)) {
      var V = ma(b.props.triggerTarget || e);
      V.forEach(function(se) {
        b.props.interactive ? se.setAttribute("aria-expanded", b.state.isVisible && se === R() ? "true" : "false") : se.removeAttribute("aria-expanded");
      });
    }
  }
  function Y() {
    N().removeEventListener("mousemove", g), Wc = Wc.filter(function(V) {
      return V !== g;
    });
  }
  function K(V) {
    if (!(Dr.isTouch && (l || V.type === "mousedown"))) {
      var se = V.composedPath && V.composedPath()[0] || V.target;
      if (!(b.props.interactive && cS(E, se))) {
        if (ma(b.props.triggerTarget || e).some(function(X) {
          return cS(X, se);
        })) {
          if (Dr.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          q("onClickOutside", [b, V]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), s = !0, setTimeout(function() {
          s = !1;
        }), b.state.isMounted || ee());
      }
    }
  }
  function te() {
    l = !0;
  }
  function J() {
    l = !1;
  }
  function G() {
    var V = N();
    V.addEventListener("mousedown", K, !0), V.addEventListener("touchend", K, bo), V.addEventListener("touchstart", J, bo), V.addEventListener("touchmove", te, bo);
  }
  function ee() {
    var V = N();
    V.removeEventListener("mousedown", K, !0), V.removeEventListener("touchend", K, bo), V.removeEventListener("touchstart", J, bo), V.removeEventListener("touchmove", te, bo);
  }
  function re(V, se) {
    W(V, function() {
      !b.state.isVisible && E.parentNode && E.parentNode.contains(E) && se();
    });
  }
  function oe(V, se) {
    W(V, se);
  }
  function W(V, se) {
    var X = D().box;
    function le(fe) {
      fe.target === X && ($h(X, "remove", le), se());
    }
    if (V === 0)
      return se();
    $h(X, "remove", d), $h(X, "add", le), d = le;
  }
  function U(V, se, X) {
    X === void 0 && (X = !1);
    var le = ma(b.props.triggerTarget || e);
    le.forEach(function(fe) {
      fe.addEventListener(V, se, X), h.push({
        node: fe,
        eventType: V,
        handler: se,
        options: X
      });
    });
  }
  function Z() {
    M() && (U("touchstart", de, {
      passive: !0
    }), U("touchend", he, {
      passive: !0
    })), vX(b.props.trigger).forEach(function(V) {
      if (V !== "manual")
        switch (U(V, de), V) {
          case "mouseenter":
            U("mouseleave", he);
            break;
          case "focus":
            U(kX ? "focusout" : "blur", xe);
            break;
          case "focusin":
            U("focusout", xe);
            break;
        }
    });
  }
  function k() {
    h.forEach(function(V) {
      var se = V.node, X = V.eventType, le = V.handler, fe = V.options;
      se.removeEventListener(X, le, fe);
    }), h = [];
  }
  function de(V) {
    var se, X = !1;
    if (!(!b.state.isEnabled || Oe(V) || s)) {
      var le = ((se = u) == null ? void 0 : se.type) === "focus";
      u = V, m = V.currentTarget, L(), !b.state.isVisible && wX(V) && Wc.forEach(function(fe) {
        return fe(V);
      }), V.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || a) && b.props.hideOnClick !== !1 && b.state.isVisible ? X = !0 : ue(V), V.type === "click" && (a = !X), X && !le && Tt(V);
    }
  }
  function ne(V) {
    var se = V.target, X = R().contains(se) || E.contains(se);
    if (!(V.type === "mousemove" && X)) {
      var le = Ce().concat(E).map(function(fe) {
        var nt, ht = fe._tippy, Jn = (nt = ht.popperInstance) == null ? void 0 : nt.state;
        return Jn ? {
          popperRect: fe.getBoundingClientRect(),
          popperState: Jn,
          props: n
        } : null;
      }).filter(Boolean);
      _X(le, V) && (Y(), Tt(V));
    }
  }
  function he(V) {
    var se = Oe(V) || b.props.trigger.indexOf("click") >= 0 && a;
    if (!se) {
      if (b.props.interactive) {
        b.hideWithInteractivity(V);
        return;
      }
      Tt(V);
    }
  }
  function xe(V) {
    b.props.trigger.indexOf("focusin") < 0 && V.target !== R() || b.props.interactive && V.relatedTarget && E.contains(V.relatedTarget) || Tt(V);
  }
  function Oe(V) {
    return Dr.isTouch ? M() !== V.type.indexOf("touch") >= 0 : !1;
  }
  function Ee() {
    et();
    var V = b.props, se = V.popperOptions, X = V.placement, le = V.offset, fe = V.getReferenceClientRect, nt = V.moveTransition, ht = P() ? dg(E).arrow : null, Jn = fe ? {
      getBoundingClientRect: fe,
      contextElement: fe.contextElement || R()
    } : e, Ci = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Xr) {
        var Pr = Xr.state;
        if (P()) {
          var ye = D(), mn = ye.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(ea) {
            ea === "placement" ? mn.setAttribute("data-placement", Pr.placement) : Pr.attributes.popper["data-popper-" + ea] ? mn.setAttribute("data-" + ea, "") : mn.removeAttribute("data-" + ea);
          }), Pr.attributes.popper = {};
        }
      }
    }, Qn = [{
      name: "offset",
      options: {
        offset: le
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !nt
      }
    }, Ci];
    P() && ht && Qn.push({
      name: "arrow",
      options: {
        element: ht,
        padding: 3
      }
    }), Qn.push.apply(Qn, se?.modifiers || []), b.popperInstance = XA(Jn, E, Object.assign({}, se, {
      placement: X,
      onFirstUpdate: p,
      modifiers: Qn
    }));
  }
  function et() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function Ie() {
    var V = b.props.appendTo, se, X = R();
    b.props.interactive && V === _k || V === "parent" ? se = X.parentNode : se = Pk(V, [X]), se.contains(E) || se.appendChild(E), b.state.isMounted = !0, Ee(), process.env.NODE_ENV !== "production" && ni(b.props.interactive && V === Wn.appendTo && X.nextElementSibling !== E, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function Ce() {
    return gd(E.querySelectorAll("[data-tippy-root]"));
  }
  function ue(V) {
    b.clearDelayTimeouts(), V && q("onTrigger", [b, V]), G();
    var se = $(!0), X = A(), le = X[0], fe = X[1];
    Dr.isTouch && le === "hold" && fe && (se = fe), se ? r = setTimeout(function() {
      b.show();
    }, se) : b.show();
  }
  function Tt(V) {
    if (b.clearDelayTimeouts(), q("onUntrigger", [b, V]), !b.state.isVisible) {
      ee();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(V.type) >= 0 && a)) {
      var se = $(!1);
      se ? i = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, se) : o = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function tt() {
    b.state.isEnabled = !0;
  }
  function an() {
    b.hide(), b.state.isEnabled = !1;
  }
  function Jt() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(o);
  }
  function sn(V) {
    if (process.env.NODE_ENV !== "production" && ni(b.state.isDestroyed, ua("setProps")), !b.state.isDestroyed) {
      q("onBeforeUpdate", [b, V]), k();
      var se = b.props, X = fS(e, Object.assign({}, se, sS(V), {
        ignoreAttributes: !0
      }));
      b.props = X, Z(), se.interactiveDebounce !== X.interactiveDebounce && (Y(), g = oS(ne, X.interactiveDebounce)), se.triggerTarget && !X.triggerTarget ? ma(se.triggerTarget).forEach(function(le) {
        le.removeAttribute("aria-expanded");
      }) : X.triggerTarget && e.removeAttribute("aria-expanded"), L(), F(), C && C(se, X), b.popperInstance && (Ee(), Ce().forEach(function(le) {
        requestAnimationFrame(le._tippy.popperInstance.forceUpdate);
      })), q("onAfterUpdate", [b, V]);
    }
  }
  function wn(V) {
    b.setProps({
      content: V
    });
  }
  function Ut() {
    process.env.NODE_ENV !== "production" && ni(b.state.isDestroyed, ua("show"));
    var V = b.state.isVisible, se = b.state.isDestroyed, X = !b.state.isEnabled, le = Dr.isTouch && !b.props.touch, fe = Rh(b.props.duration, 0, Wn.duration);
    if (!(V || se || X || le) && !R().hasAttribute("disabled") && (q("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, P() && (E.style.visibility = "visible"), F(), G(), b.state.isMounted || (E.style.transition = "none"), P()) {
        var nt = D(), ht = nt.box, Jn = nt.content;
        Ih([ht, Jn], 0);
      }
      p = function() {
        var Qn;
        if (!(!b.state.isVisible || c)) {
          if (c = !0, E.offsetHeight, E.style.transition = b.props.moveTransition, P() && b.props.animation) {
            var oo = D(), Xr = oo.box, Pr = oo.content;
            Ih([Xr, Pr], fe), lS([Xr, Pr], "visible");
          }
          B(), L(), aS(Lh, b), (Qn = b.popperInstance) == null || Qn.forceUpdate(), q("onMount", [b]), b.props.animation && P() && oe(fe, function() {
            b.state.isShown = !0, q("onShown", [b]);
          });
        }
      }, Ie();
    }
  }
  function On() {
    process.env.NODE_ENV !== "production" && ni(b.state.isDestroyed, ua("hide"));
    var V = !b.state.isVisible, se = b.state.isDestroyed, X = !b.state.isEnabled, le = Rh(b.props.duration, 1, Wn.duration);
    if (!(V || se || X) && (q("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, c = !1, a = !1, P() && (E.style.visibility = "hidden"), Y(), ee(), F(!0), P()) {
        var fe = D(), nt = fe.box, ht = fe.content;
        b.props.animation && (Ih([nt, ht], le), lS([nt, ht], "hidden"));
      }
      B(), L(), b.props.animation ? P() && re(le, b.unmount) : b.unmount();
    }
  }
  function ve(V) {
    process.env.NODE_ENV !== "production" && ni(b.state.isDestroyed, ua("hideWithInteractivity")), N().addEventListener("mousemove", g), aS(Wc, g), g(V);
  }
  function ln() {
    process.env.NODE_ENV !== "production" && ni(b.state.isDestroyed, ua("unmount")), b.state.isVisible && b.hide(), b.state.isMounted && (et(), Ce().forEach(function(V) {
      V._tippy.unmount();
    }), E.parentNode && E.parentNode.removeChild(E), Lh = Lh.filter(function(V) {
      return V !== b;
    }), b.state.isMounted = !1, q("onHidden", [b]));
  }
  function Ht() {
    process.env.NODE_ENV !== "production" && ni(b.state.isDestroyed, ua("destroy")), !b.state.isDestroyed && (b.clearDelayTimeouts(), b.unmount(), k(), delete e._tippy, b.state.isDestroyed = !0, q("onDestroy", [b]));
  }
}
function oc(e, t) {
  t === void 0 && (t = {});
  var n = Wn.plugins.concat(t.plugins || []);
  process.env.NODE_ENV !== "production" && (NX(e), Mk(t, n)), TX();
  var r = Object.assign({}, t, {
    plugins: n
  }), i = SX(e);
  if (process.env.NODE_ENV !== "production") {
    var o = xl(r.content), a = i.length > 1;
    ni(o && a, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var s = i.reduce(function(l, c) {
    var u = c && BX(c, r);
    return u && l.push(u), l;
  }, []);
  return xl(e) ? s[0] : s;
}
oc.defaultProps = Wn;
oc.setDefaultProps = IX;
oc.currentInput = Dr;
Object.assign({}, WA, {
  effect: function(t) {
    var n = t.state, r = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  }
});
oc.setDefaultProps({
  render: jk
});
function Nk(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Dk = typeof window < "u" && typeof document < "u";
function fg(e, t) {
  e && (typeof e == "function" && e(t), {}.hasOwnProperty.call(e, "current") && (e.current = t));
}
function mS() {
  return Dk && document.createElement("div");
}
function zX(e) {
  var t = {
    "data-placement": e.placement
  };
  return e.referenceHidden && (t["data-reference-hidden"] = ""), e.escaped && (t["data-escaped"] = ""), t;
}
function Rk(e, t) {
  if (e === t)
    return !0;
  if (typeof e == "object" && e != null && typeof t == "object" && t != null) {
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (var n in e)
      if (t.hasOwnProperty(n)) {
        if (!Rk(e[n], t[n]))
          return !1;
      } else
        return !1;
    return !0;
  } else
    return !1;
}
function WX(e) {
  var t = [];
  return e.forEach(function(n) {
    t.find(function(r) {
      return Rk(n, r);
    }) || t.push(n);
  }), t;
}
function VX(e, t) {
  var n, r;
  return Object.assign({}, t, {
    popperOptions: Object.assign({}, e.popperOptions, t.popperOptions, {
      modifiers: WX([].concat(((n = e.popperOptions) == null ? void 0 : n.modifiers) || [], ((r = t.popperOptions) == null ? void 0 : r.modifiers) || []))
    })
  });
}
var Fh = Dk ? WE : De;
function UX(e) {
  var t = Ne();
  return t.current || (t.current = typeof e == "function" ? e() : e), t.current;
}
function gS(e, t, n) {
  n.split(/\s+/).forEach(function(r) {
    r && e.classList[t](r);
  });
}
var HX = {
  name: "className",
  defaultValue: "",
  fn: function(t) {
    var n = t.popper.firstElementChild, r = function() {
      var s;
      return !!((s = t.props.render) != null && s.$$tippy);
    };
    function i() {
      if (t.props.className && !r()) {
        process.env.NODE_ENV !== "production" && console.warn(["@tippyjs/react: Cannot use `className` prop in conjunction with", "`render` prop. Place the className on the element you are", "rendering."].join(" "));
        return;
      }
      gS(n, "add", t.props.className);
    }
    function o() {
      r() && gS(n, "remove", t.props.className);
    }
    return {
      onCreate: i,
      onBeforeUpdate: o,
      onAfterUpdate: i
    };
  }
};
function qX(e) {
  function t(n) {
    var r = n.children, i = n.content, o = n.visible, a = n.singleton, s = n.render, l = n.reference, c = n.disabled, u = c === void 0 ? !1 : c, d = n.ignoreAttributes, p = d === void 0 ? !0 : d;
    n.__source, n.__self;
    var h = Nk(n, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]), g = o !== void 0, m = a !== void 0, v = Ke(!1), y = v[0], S = v[1], w = Ke({}), b = w[0], O = w[1], E = Ke(), C = E[0], T = E[1], j = UX(function() {
      return {
        container: mS(),
        renders: 1
      };
    }), A = Object.assign({
      ignoreAttributes: p
    }, h, {
      content: j.container
    });
    g && (process.env.NODE_ENV !== "production" && ["trigger", "hideOnClick", "showOnCreate"].forEach(function(N) {
      A[N] !== void 0 && console.warn(["@tippyjs/react: Cannot specify `" + N + "` prop in", "controlled mode (`visible` prop)"].join(" "));
    }), A.trigger = "manual", A.hideOnClick = !1), m && (u = !0);
    var M = A, P = A.plugins || [];
    s && (M = Object.assign({}, A, {
      plugins: m && a.data != null ? [].concat(P, [{
        fn: function() {
          return {
            onTrigger: function($, F) {
              var q = a.data.children.find(function(B) {
                var L = B.instance;
                return L.reference === F.currentTarget;
              });
              $.state.$$activeSingletonInstance = q.instance, T(q.content);
            }
          };
        }
      }]) : P,
      render: function() {
        return {
          popper: j.container
        };
      }
    }));
    var R = [l].concat(r ? [r.type] : []);
    return Fh(function() {
      var N = l;
      l && l.hasOwnProperty("current") && (N = l.current);
      var D = e(N || j.ref || mS(), Object.assign({}, M, {
        plugins: [HX].concat(A.plugins || [])
      }));
      return j.instance = D, u && D.disable(), o && D.show(), m && a.hook({
        instance: D,
        content: i,
        props: M,
        setSingletonContent: T
      }), S(!0), function() {
        D.destroy(), a?.cleanup(D);
      };
    }, R), Fh(function() {
      var N;
      if (j.renders === 1) {
        j.renders++;
        return;
      }
      var D = j.instance;
      D.setProps(VX(D.props, M)), (N = D.popperInstance) == null || N.forceUpdate(), u ? D.disable() : D.enable(), g && (o ? D.show() : D.hide()), m && a.hook({
        instance: D,
        content: i,
        props: M,
        setSingletonContent: T
      });
    }), Fh(function() {
      var N;
      if (s) {
        var D = j.instance;
        D.setProps({
          popperOptions: Object.assign({}, D.props.popperOptions, {
            modifiers: [].concat((((N = D.props.popperOptions) == null ? void 0 : N.modifiers) || []).filter(function($) {
              var F = $.name;
              return F !== "$$tippyReact";
            }), [{
              name: "$$tippyReact",
              enabled: !0,
              phase: "beforeWrite",
              requires: ["computeStyles"],
              fn: function(F) {
                var q, B = F.state, L = (q = B.modifiersData) == null ? void 0 : q.hide;
                (b.placement !== B.placement || b.referenceHidden !== L?.isReferenceHidden || b.escaped !== L?.hasPopperEscaped) && O({
                  placement: B.placement,
                  referenceHidden: L?.isReferenceHidden,
                  escaped: L?.hasPopperEscaped
                }), B.attributes.popper = {};
              }
            }])
          })
        });
      }
    }, [b.placement, b.referenceHidden, b.escaped].concat(R)), /* @__PURE__ */ Ye.createElement(Ye.Fragment, null, r ? /* @__PURE__ */ cr(r, {
      ref: function(D) {
        j.ref = D, fg(r.ref, D);
      }
    }) : null, y && /* @__PURE__ */ VE(s ? s(zX(b), C, j.instance) : i, j.container));
  }
  return t;
}
var KX = (function(e, t) {
  return /* @__PURE__ */ rn(function(r, i) {
    var o = r.children, a = Nk(r, ["children"]);
    return (
      // If I spread them separately here, Babel adds the _extends ponyfill for
      // some reason
      /* @__PURE__ */ Ye.createElement(e, Object.assign({}, t, a), o ? /* @__PURE__ */ cr(o, {
        ref: function(l) {
          fg(i, l), fg(o.ref, l);
        }
      }) : null)
    );
  });
}), YX = /* @__PURE__ */ KX(/* @__PURE__ */ qX(oc));
function GX(e) {
  const t = e >= 12 ? "PM" : "AM";
  let n = e % 12;
  return n === 0 && (n = 12), `${n} ${t}`;
}
function XX(e = []) {
  return Array.from({ length: 24 }, (t, n) => {
    const r = e.find((i) => i.hour === n) || {};
    return {
      hour: n,
      time: GX(n),
      walkins: r.walkins ?? 0,
      checkins: r.preApproved ?? 0,
      staffAttendance: r.staffAttendance ?? 0
    };
  });
}
const da = {
  walkins: "#1FA05B",
  preApproved: "#E7A015",
  staffAttendance: "#329DFF"
};
function ZX({ type: e, data: t, children: n }) {
  if (!e || !t) return n;
  const r = {
    activeWalkins: [
      ["Currently Inside", t.visitor_in],
      // ["Currently Out", data.visitor_out],
      ["Total Visited Today", t.total_pass]
    ],
    preApprovedCheckins: [
      ["Currently Inside", t.currently_inside],
      ["Total Visited Today", t.expected_pass_scanned],
      ["No show", t.expected_pass_not_scanned],
      ["Total Scheduled", t.total_expected_pass]
    ],
    staffAttendance: [
      ["Currently Inside", t.total_in_now],
      ["Absent Today", t.absent_staff],
      ["Total Visited Today", t.total_in_today],
      ["Total Staff", t.total_staff]
    ]
  }, i = {
    activeWalkins: "Active Walk-ins",
    preApprovedCheckins: "Pre-approved Check-ins",
    staffAttendance: "Staff Attendance"
  }, o = {
    activeWalkins: "text-[#1FA05B]",
    preApprovedCheckins: "text-[#E7A015]",
    staffAttendance: "text-[#329DFF]"
  }, a = /* @__PURE__ */ x.jsx(
    qo,
    {
      title: i[e],
      period: "Today",
      icon: /* @__PURE__ */ x.jsx(Fg, { className: `${o[e]} !text-[24px]` }),
      className: "!gap-0 min-w-[353px] bg-white shadow-xl rounded-lg border border-gray-200",
      children: /* @__PURE__ */ x.jsx("div", { className: "flex flex-col gap-[8px] mt-[12px] pt-[12px] border-t border-dashed border-[#EBEBEB]", children: r[e].map(([s, l]) => /* @__PURE__ */ x.jsxs(
        "div",
        {
          className: "flex justify-between text-[14px] text-[#64748B]",
          children: [
            /* @__PURE__ */ x.jsx("div", { children: s }),
            /* @__PURE__ */ x.jsx("div", { className: "font-semibold text-gray-800", children: l ?? 0 })
          ]
        },
        s
      )) })
    }
  );
  return /* @__PURE__ */ x.jsx(
    YX,
    {
      content: a,
      placement: "bottom-start",
      interactive: !0,
      delay: [100, 0],
      offset: [0, 8],
      appendTo: document.body,
      theme: "light-border",
      maxWidth: "none",
      children: n
    }
  );
}
function fne({ isStatic: e, data: t }) {
  const n = t?.summary?.activeWalkins || {}, r = t?.summary?.preApprovedCheckins || {}, i = t?.summary?.staffAttendance || {}, o = Un(
    () => XX(t?.chart || []),
    [t]
  ), { yAxisTicks: a, yAxisMax: s } = Un(() => {
    const l = Math.max(
      ...o.flatMap((u) => [u.walkins, u.checkins, u.staffAttendance])
    ), c = l > 0 ? l : 5;
    return {
      yAxisTicks: [0, Math.ceil(c / 2), c],
      yAxisMax: c
    };
  }, [o]);
  return /* @__PURE__ */ x.jsx(
    qo,
    {
      title: "Gate Updates",
      period: "Today",
      icon: /* @__PURE__ */ x.jsx(Fg, { className: "!text-[24px] text-[#37CC6D]" }),
      className: `${e ? "max-h-[303px]" : ""} h-[251px] mb-4 break-inside-avoid`,
      actionButtons: /* @__PURE__ */ x.jsx(
        is,
        {
          widgetId: t?.widget_id,
          options: t?.communities,
          onFilterChange: (l, c) => console.log(l, c),
          onExport: (l) => console.log("Export triggered for", l)
        }
      ),
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsx("div", { className: "grid grid-cols-3 gap-[24px] mb-[16px]", children: [
          {
            key: "activeWalkins",
            data: n,
            color: da.walkins,
            label: "Active Walk-ins"
          },
          {
            key: "staffAttendance",
            data: i,
            color: da.staffAttendance,
            label: "Staff Checked-in"
          },
          {
            key: "preApprovedCheckins",
            data: r,
            color: da.preApproved,
            label: "Pre-approved"
          }
        ].map((l) => /* @__PURE__ */ x.jsx(ZX, { type: l.key, data: l.data, children: /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col gap-[8px] cursor-pointer", children: [
          /* @__PURE__ */ x.jsx("div", { className: "text-[10px] text-[#64748B] whitespace-nowrap", children: l.label }),
          /* @__PURE__ */ x.jsxs(
            "div",
            {
              className: "text-[28px] font-medium flex items-center",
              style: { color: l.color },
              children: [
                l.key === "activeWalkins" ? l.data?.visitor_in ?? 0 : l.key === "preApprovedCheckins" ? l.data?.currently_inside ?? 0 : l.data?.total_in_now ?? 0,
                /* @__PURE__ */ x.jsxs("div", { className: "text-[20px] text-[#64748B] ml-1", children: [
                  "/",
                  l.key === "activeWalkins" ? l.data?.total_pass ?? 0 : l.key === "preApprovedCheckins" ? l.data?.total_expected_pass ?? 0 : l.data?.total_staff ?? 0
                ] })
              ]
            }
          )
        ] }) }, l.key)) }),
        /* @__PURE__ */ x.jsx("div", { className: "w-full h-[105px]", children: /* @__PURE__ */ x.jsx(Zo, { width: "100%", height: "100%", children: /* @__PURE__ */ x.jsxs(
          _A,
          {
            data: o,
            margin: { top: 5, right: 0, left: -40, bottom: 0 },
            children: [
              /* @__PURE__ */ x.jsx(wf, { strokeDasharray: "3 3", stroke: "#EBEBEB" }),
              /* @__PURE__ */ x.jsx(
                Of,
                {
                  dataKey: "time",
                  tickFormatter: (l, c) => c % 4 === 0 ? l : "",
                  tick: { fontSize: 10, fill: "#121212", fontWeight: 400 },
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ x.jsx(
                hl,
                {
                  tick: { fontSize: 10, fill: "#64748B", fontWeight: 400 },
                  ticks: a,
                  domain: [0, s],
                  allowDecimals: !1,
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ x.jsx(Xo, { content: /* @__PURE__ */ x.jsx(Rl, {}) }),
              /* @__PURE__ */ x.jsx(
                Sa,
                {
                  type: "monotone",
                  dataKey: "walkins",
                  stroke: da.walkins,
                  strokeWidth: 2,
                  dot: !1,
                  name: "Active Walk-ins",
                  isAnimationActive: !1
                }
              ),
              /* @__PURE__ */ x.jsx(
                Sa,
                {
                  type: "monotone",
                  dataKey: "checkins",
                  stroke: da.preApproved,
                  strokeWidth: 2,
                  strokeDasharray: "5 5",
                  dot: !1,
                  name: "Pre-approved",
                  isAnimationActive: !1
                }
              ),
              /* @__PURE__ */ x.jsx(
                Sa,
                {
                  type: "monotone",
                  dataKey: "staffAttendance",
                  stroke: da.staffAttendance,
                  strokeWidth: 2,
                  dot: !1,
                  name: "Staff Attendance",
                  isAnimationActive: !1
                }
              )
            ]
          }
        ) }) })
      ] })
    }
  );
}
function pne({ isStatic: e, data: t }) {
  const n = ["#1FA05B", "#E7A015", "#FA7E28", "#EF4444", "#CBD5E1"], r = [
    { name: "L1 Level", value: Number(t?.total_L1 || 0), color: n[0] },
    { name: "L2 Level", value: Number(t?.total_L2 || 0), color: n[1] },
    { name: "L3 Level", value: Number(t?.total_L3 || 0), color: n[2] },
    {
      name: "No Level",
      value: Number(t?.total_NoLevel || 0),
      color: n[3]
    }
  ];
  r.reduce((o, a) => o + a.value, 0);
  const i = r;
  return console.log("Helpdesk Data:", t), /* @__PURE__ */ x.jsx(
    qo,
    {
      title: "Helpdesk",
      period: "As of Today",
      icon: /* @__PURE__ */ x.jsx(AR, { className: "!text-[24px] text-[#FA7E28]" }),
      className: `${e && "max-h-[186px]"} h-[186px] mb-4 break-inside-avoid`,
      actionButtons: /* @__PURE__ */ x.jsx(
        is,
        {
          widgetId: t?.widget_id,
          options: t?.communities,
          onFilterChange: (o, a) => console.log(o, a),
          onExport: (o) => console.log("Export triggered for", o)
        }
      ),
      children: /* @__PURE__ */ x.jsxs("div", { className: "flex gap-[12px] h-fit", children: [
        /* @__PURE__ */ x.jsxs("div", { className: "w-[50%] flex flex-col gap-[28px]", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col gap-[8px]", children: [
            /* @__PURE__ */ x.jsx("div", { className: "!m-0 !text-[12px] !leading-[16px] !text-[#64748B]", children: "Un-resolved Complaints" }),
            /* @__PURE__ */ x.jsx("div", { className: "!m-0 !text-[28px] !leading-[32px] !font-medium text-[#FA7E28]", children: t?.total_open_complaints ?? 0 })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "!m-0 !text-[10px] !leading-[14px] !text-[#64748B] flex items-center gap-[4px]", children: [
            /* @__PURE__ */ x.jsx(I_, { value: t?.percent_change }),
            /* @__PURE__ */ x.jsx("div", { className: "whitespace-nowrap", children: "Compared to yesterday" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "w-[50%] h-[110px] flex justify-end", children: /* @__PURE__ */ x.jsx(Zo, { width: "75%", height: "100%", children: /* @__PURE__ */ x.jsxs(Sf, { children: [
          /* @__PURE__ */ x.jsx(
            tc,
            {
              data: i,
              innerRadius: 36,
              outerRadius: 52,
              paddingAngle: 2,
              dataKey: "value",
              children: i.map((o, a) => /* @__PURE__ */ x.jsx(Hr, { fill: n[a] || "#CBD5E1" }, o.name))
            }
          ),
          /* @__PURE__ */ x.jsx(Xo, { content: /* @__PURE__ */ x.jsx(Rl, {}) })
        ] }) }) })
      ] })
    }
  );
}
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function ac(e) {
  return e + 0.5 | 0;
}
const Ni = (e, t, n) => Math.max(Math.min(e, n), t);
function Ls(e) {
  return Ni(ac(e * 2.55), 0, 255);
}
function Fi(e) {
  return Ni(ac(e * 255), 0, 255);
}
function ri(e) {
  return Ni(ac(e / 2.55) / 100, 0, 1);
}
function vS(e) {
  return Ni(ac(e * 100), 0, 100);
}
const rr = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, pg = [..."0123456789ABCDEF"], JX = (e) => pg[e & 15], QX = (e) => pg[(e & 240) >> 4] + pg[e & 15], Vc = (e) => (e & 240) >> 4 === (e & 15), eZ = (e) => Vc(e.r) && Vc(e.g) && Vc(e.b) && Vc(e.a);
function tZ(e) {
  var t = e.length, n;
  return e[0] === "#" && (t === 4 || t === 5 ? n = {
    r: 255 & rr[e[1]] * 17,
    g: 255 & rr[e[2]] * 17,
    b: 255 & rr[e[3]] * 17,
    a: t === 5 ? rr[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (n = {
    r: rr[e[1]] << 4 | rr[e[2]],
    g: rr[e[3]] << 4 | rr[e[4]],
    b: rr[e[5]] << 4 | rr[e[6]],
    a: t === 9 ? rr[e[7]] << 4 | rr[e[8]] : 255
  })), n;
}
const nZ = (e, t) => e < 255 ? t(e) : "";
function rZ(e) {
  var t = eZ(e) ? JX : QX;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + nZ(e.a, t) : void 0;
}
const iZ = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Ik(e, t, n) {
  const r = t * Math.min(n, 1 - n), i = (o, a = (o + e / 30) % 12) => n - r * Math.max(Math.min(a - 3, 9 - a, 1), -1);
  return [i(0), i(8), i(4)];
}
function oZ(e, t, n) {
  const r = (i, o = (i + e / 60) % 6) => n - n * t * Math.max(Math.min(o, 4 - o, 1), 0);
  return [r(5), r(3), r(1)];
}
function aZ(e, t, n) {
  const r = Ik(e, 1, 0.5);
  let i;
  for (t + n > 1 && (i = 1 / (t + n), t *= i, n *= i), i = 0; i < 3; i++)
    r[i] *= 1 - t - n, r[i] += t;
  return r;
}
function sZ(e, t, n, r, i) {
  return e === i ? (t - n) / r + (t < n ? 6 : 0) : t === i ? (n - e) / r + 2 : (e - t) / r + 4;
}
function Xy(e) {
  const n = e.r / 255, r = e.g / 255, i = e.b / 255, o = Math.max(n, r, i), a = Math.min(n, r, i), s = (o + a) / 2;
  let l, c, u;
  return o !== a && (u = o - a, c = s > 0.5 ? u / (2 - o - a) : u / (o + a), l = sZ(n, r, i, u, o), l = l * 60 + 0.5), [l | 0, c || 0, s];
}
function Zy(e, t, n, r) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(Fi);
}
function Jy(e, t, n) {
  return Zy(Ik, e, t, n);
}
function lZ(e, t, n) {
  return Zy(aZ, e, t, n);
}
function cZ(e, t, n) {
  return Zy(oZ, e, t, n);
}
function $k(e) {
  return (e % 360 + 360) % 360;
}
function uZ(e) {
  const t = iZ.exec(e);
  let n = 255, r;
  if (!t)
    return;
  t[5] !== r && (n = t[6] ? Ls(+t[5]) : Fi(+t[5]));
  const i = $k(+t[2]), o = +t[3] / 100, a = +t[4] / 100;
  return t[1] === "hwb" ? r = lZ(i, o, a) : t[1] === "hsv" ? r = cZ(i, o, a) : r = Jy(i, o, a), {
    r: r[0],
    g: r[1],
    b: r[2],
    a: n
  };
}
function dZ(e, t) {
  var n = Xy(e);
  n[0] = $k(n[0] + t), n = Jy(n), e.r = n[0], e.g = n[1], e.b = n[2];
}
function fZ(e) {
  if (!e)
    return;
  const t = Xy(e), n = t[0], r = vS(t[1]), i = vS(t[2]);
  return e.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${ri(e.a)})` : `hsl(${n}, ${r}%, ${i}%)`;
}
const yS = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, bS = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function pZ() {
  const e = {}, t = Object.keys(bS), n = Object.keys(yS);
  let r, i, o, a, s;
  for (r = 0; r < t.length; r++) {
    for (a = s = t[r], i = 0; i < n.length; i++)
      o = n[i], s = s.replace(o, yS[o]);
    o = parseInt(bS[a], 16), e[s] = [o >> 16 & 255, o >> 8 & 255, o & 255];
  }
  return e;
}
let Uc;
function hZ(e) {
  Uc || (Uc = pZ(), Uc.transparent = [0, 0, 0, 0]);
  const t = Uc[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const mZ = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function gZ(e) {
  const t = mZ.exec(e);
  let n = 255, r, i, o;
  if (t) {
    if (t[7] !== r) {
      const a = +t[7];
      n = t[8] ? Ls(a) : Ni(a * 255, 0, 255);
    }
    return r = +t[1], i = +t[3], o = +t[5], r = 255 & (t[2] ? Ls(r) : Ni(r, 0, 255)), i = 255 & (t[4] ? Ls(i) : Ni(i, 0, 255)), o = 255 & (t[6] ? Ls(o) : Ni(o, 0, 255)), {
      r,
      g: i,
      b: o,
      a: n
    };
  }
}
function vZ(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${ri(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const Bh = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, fa = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function yZ(e, t, n) {
  const r = fa(ri(e.r)), i = fa(ri(e.g)), o = fa(ri(e.b));
  return {
    r: Fi(Bh(r + n * (fa(ri(t.r)) - r))),
    g: Fi(Bh(i + n * (fa(ri(t.g)) - i))),
    b: Fi(Bh(o + n * (fa(ri(t.b)) - o))),
    a: e.a + n * (t.a - e.a)
  };
}
function Hc(e, t, n) {
  if (e) {
    let r = Xy(e);
    r[t] = Math.max(0, Math.min(r[t] + r[t] * n, t === 0 ? 360 : 1)), r = Jy(r), e.r = r[0], e.g = r[1], e.b = r[2];
  }
}
function Lk(e, t) {
  return e && Object.assign(t || {}, e);
}
function xS(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Fi(e[3]))) : (t = Lk(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Fi(t.a)), t;
}
function bZ(e) {
  return e.charAt(0) === "r" ? gZ(e) : uZ(e);
}
class Ol {
  constructor(t) {
    if (t instanceof Ol)
      return t;
    const n = typeof t;
    let r;
    n === "object" ? r = xS(t) : n === "string" && (r = tZ(t) || hZ(t) || bZ(t)), this._rgb = r, this._valid = !!r;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = Lk(this._rgb);
    return t && (t.a = ri(t.a)), t;
  }
  set rgb(t) {
    this._rgb = xS(t);
  }
  rgbString() {
    return this._valid ? vZ(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? rZ(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? fZ(this._rgb) : void 0;
  }
  mix(t, n) {
    if (t) {
      const r = this.rgb, i = t.rgb;
      let o;
      const a = n === o ? 0.5 : n, s = 2 * a - 1, l = r.a - i.a, c = ((s * l === -1 ? s : (s + l) / (1 + s * l)) + 1) / 2;
      o = 1 - c, r.r = 255 & c * r.r + o * i.r + 0.5, r.g = 255 & c * r.g + o * i.g + 0.5, r.b = 255 & c * r.b + o * i.b + 0.5, r.a = a * r.a + (1 - a) * i.a, this.rgb = r;
    }
    return this;
  }
  interpolate(t, n) {
    return t && (this._rgb = yZ(this._rgb, t._rgb, n)), this;
  }
  clone() {
    return new Ol(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = Fi(t), this;
  }
  clearer(t) {
    const n = this._rgb;
    return n.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, n = ac(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = n, this;
  }
  opaquer(t) {
    const n = this._rgb;
    return n.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return Hc(this._rgb, 2, t), this;
  }
  darken(t) {
    return Hc(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return Hc(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return Hc(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return dZ(this._rgb, t), this;
  }
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function Qr() {
}
const xZ = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function We(e) {
  return e == null;
}
function Kt(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function Te(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function mr(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function Ar(e, t) {
  return mr(e) ? e : t;
}
function we(e, t) {
  return typeof e > "u" ? t : e;
}
const wZ = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, Fk = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function ut(e, t, n) {
  if (e && typeof e.call == "function")
    return e.apply(n, t);
}
function He(e, t, n, r) {
  let i, o, a;
  if (Kt(e))
    for (o = e.length, i = 0; i < o; i++)
      t.call(n, e[i], i);
  else if (Te(e))
    for (a = Object.keys(e), o = a.length, i = 0; i < o; i++)
      t.call(n, e[a[i]], a[i]);
}
function vd(e, t) {
  let n, r, i, o;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (n = 0, r = e.length; n < r; ++n)
    if (i = e[n], o = t[n], i.datasetIndex !== o.datasetIndex || i.index !== o.index)
      return !1;
  return !0;
}
function yd(e) {
  if (Kt(e))
    return e.map(yd);
  if (Te(e)) {
    const t = /* @__PURE__ */ Object.create(null), n = Object.keys(e), r = n.length;
    let i = 0;
    for (; i < r; ++i)
      t[n[i]] = yd(e[n[i]]);
    return t;
  }
  return e;
}
function Bk(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function OZ(e, t, n, r) {
  if (!Bk(e))
    return;
  const i = t[e], o = n[e];
  Te(i) && Te(o) ? Sl(i, o, r) : t[e] = yd(o);
}
function Sl(e, t, n) {
  const r = Kt(t) ? t : [
    t
  ], i = r.length;
  if (!Te(e))
    return e;
  n = n || {};
  const o = n.merger || OZ;
  let a;
  for (let s = 0; s < i; ++s) {
    if (a = r[s], !Te(a))
      continue;
    const l = Object.keys(a);
    for (let c = 0, u = l.length; c < u; ++c)
      o(l[c], e, a, n);
  }
  return e;
}
function Gs(e, t) {
  return Sl(e, t, {
    merger: SZ
  });
}
function SZ(e, t, n) {
  if (!Bk(e))
    return;
  const r = t[e], i = n[e];
  Te(r) && Te(i) ? Gs(r, i) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = yd(i));
}
const wS = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function EZ(e) {
  const t = e.split("."), n = [];
  let r = "";
  for (const i of t)
    r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = "");
  return n;
}
function _Z(e) {
  const t = EZ(e);
  return (n) => {
    for (const r of t) {
      if (r === "")
        break;
      n = n && n[r];
    }
    return n;
  };
}
function Uo(e, t) {
  return (wS[t] || (wS[t] = _Z(t)))(e);
}
function Qy(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const El = (e) => typeof e < "u", Ki = (e) => typeof e == "function", OS = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
};
function PZ(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const it = Math.PI, Pt = 2 * it, CZ = Pt + it, bd = Number.POSITIVE_INFINITY, TZ = it / 180, Bt = it / 2, uo = it / 4, SS = it * 2 / 3, zk = Math.log10, Br = Math.sign;
function Xs(e, t, n) {
  return Math.abs(e - t) < n;
}
function ES(e) {
  const t = Math.round(e);
  e = Xs(e, t, e / 1e3) ? t : e;
  const n = Math.pow(10, Math.floor(zk(e))), r = e / n;
  return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n;
}
function AZ(e) {
  const t = [], n = Math.sqrt(e);
  let r;
  for (r = 1; r < n; r++)
    e % r === 0 && (t.push(r), t.push(e / r));
  return n === (n | 0) && t.push(n), t.sort((i, o) => i - o).pop(), t;
}
function kZ(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function _l(e) {
  return !kZ(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function MZ(e, t) {
  const n = Math.round(e);
  return n - t <= e && n + t >= e;
}
function jZ(e, t, n) {
  let r, i, o;
  for (r = 0, i = e.length; r < i; r++)
    o = e[r][n], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));
}
function li(e) {
  return e * (it / 180);
}
function NZ(e) {
  return e * (180 / it);
}
function _S(e) {
  if (!mr(e))
    return;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n++;
  return n;
}
function Wk(e, t) {
  const n = t.x - e.x, r = t.y - e.y, i = Math.sqrt(n * n + r * r);
  let o = Math.atan2(r, n);
  return o < -0.5 * it && (o += Pt), {
    angle: o,
    distance: i
  };
}
function hg(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function DZ(e, t) {
  return (e - t + CZ) % Pt - it;
}
function xr(e) {
  return (e % Pt + Pt) % Pt;
}
function Pl(e, t, n, r) {
  const i = xr(e), o = xr(t), a = xr(n), s = xr(o - i), l = xr(a - i), c = xr(i - o), u = xr(i - a);
  return i === o || i === a || r && o === a || s > l && c < u;
}
function fn(e, t, n) {
  return Math.max(t, Math.min(n, e));
}
function RZ(e) {
  return fn(e, -32768, 32767);
}
function Di(e, t, n, r = 1e-6) {
  return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r;
}
function eb(e, t, n) {
  n = n || ((a) => e[a] < t);
  let r = e.length - 1, i = 0, o;
  for (; r - i > 1; )
    o = i + r >> 1, n(o) ? i = o : r = o;
  return {
    lo: i,
    hi: r
  };
}
const To = (e, t, n, r) => eb(e, n, r ? (i) => {
  const o = e[i][t];
  return o < n || o === n && e[i + 1][t] === n;
} : (i) => e[i][t] < n), IZ = (e, t, n) => eb(e, n, (r) => e[r][t] >= n);
function $Z(e, t, n) {
  let r = 0, i = e.length;
  for (; r < i && e[r] < t; )
    r++;
  for (; i > r && e[i - 1] > n; )
    i--;
  return r > 0 || i < e.length ? e.slice(r, i) : e;
}
const Vk = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function LZ(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), Vk.forEach((n) => {
    const r = "_onData" + Qy(n), i = e[n];
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      value(...o) {
        const a = i.apply(this, o);
        return e._chartjs.listeners.forEach((s) => {
          typeof s[r] == "function" && s[r](...o);
        }), a;
      }
    });
  });
}
function PS(e, t) {
  const n = e._chartjs;
  if (!n)
    return;
  const r = n.listeners, i = r.indexOf(t);
  i !== -1 && r.splice(i, 1), !(r.length > 0) && (Vk.forEach((o) => {
    delete e[o];
  }), delete e._chartjs);
}
function Uk(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const Hk = (function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
})();
function qk(e, t) {
  let n = [], r = !1;
  return function(...i) {
    n = i, r || (r = !0, Hk.call(window, () => {
      r = !1, e.apply(t, n);
    }));
  };
}
function FZ(e, t) {
  let n;
  return function(...r) {
    return t ? (clearTimeout(n), n = setTimeout(e, t, r)) : e.apply(this, r), t;
  };
}
const Kk = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", $n = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2, BZ = (e, t, n, r) => e === (r ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t;
function zZ(e, t, n) {
  const r = t.length;
  let i = 0, o = r;
  if (e._sorted) {
    const { iScale: a, vScale: s, _parsed: l } = e, c = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, u = a.axis, { min: d, max: p, minDefined: h, maxDefined: g } = a.getUserBounds();
    if (h) {
      if (i = Math.min(
        // @ts-expect-error Need to type _parsed
        To(l, u, d).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? r : To(t, u, a.getPixelForValue(d)).lo
      ), c) {
        const m = l.slice(0, i + 1).reverse().findIndex((v) => !We(v[s.axis]));
        i -= Math.max(0, m);
      }
      i = fn(i, 0, r - 1);
    }
    if (g) {
      let m = Math.max(
        // @ts-expect-error Need to type _parsed
        To(l, a.axis, p, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? 0 : To(t, u, a.getPixelForValue(p), !0).hi + 1
      );
      if (c) {
        const v = l.slice(m - 1).findIndex((y) => !We(y[s.axis]));
        m += Math.max(0, v);
      }
      o = fn(m, i, r) - i;
    } else
      o = r - i;
  }
  return {
    start: i,
    count: o
  };
}
function WZ(e) {
  const { xScale: t, yScale: n, _scaleRanges: r } = e, i = {
    xmin: t.min,
    xmax: t.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!r)
    return e._scaleRanges = i, !0;
  const o = r.xmin !== t.min || r.xmax !== t.max || r.ymin !== n.min || r.ymax !== n.max;
  return Object.assign(r, i), o;
}
const qc = (e) => e === 0 || e === 1, CS = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Pt / n)), TS = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * Pt / n) + 1, Zs = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * Bt) + 1,
  easeOutSine: (e) => Math.sin(e * Bt),
  easeInOutSine: (e) => -0.5 * (Math.cos(it * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => qc(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => qc(e) ? e : CS(e, 0.075, 0.3),
  easeOutElastic: (e) => qc(e) ? e : TS(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return qc(e) ? e : e < 0.5 ? 0.5 * CS(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * TS(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - Zs.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? Zs.easeInBounce(e * 2) * 0.5 : Zs.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function tb(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function AS(e) {
  return tb(e) ? e : new Ol(e);
}
function zh(e) {
  return tb(e) ? e : new Ol(e).saturate(0.5).darken(0.1).hexString();
}
const VZ = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], UZ = [
  "color",
  "borderColor",
  "backgroundColor"
];
function HZ(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: UZ
    },
    numbers: {
      type: "number",
      properties: VZ
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function qZ(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const kS = /* @__PURE__ */ new Map();
function KZ(e, t) {
  t = t || {};
  const n = e + JSON.stringify(t);
  let r = kS.get(n);
  return r || (r = new Intl.NumberFormat(e, t), kS.set(n, r)), r;
}
function nb(e, t, n) {
  return KZ(t, n).format(e);
}
const YZ = {
  values(e) {
    return Kt(e) ? e : "" + e;
  },
  numeric(e, t, n) {
    if (e === 0)
      return "0";
    const r = this.chart.options.locale;
    let i, o = e;
    if (n.length > 1) {
      const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (c < 1e-4 || c > 1e15) && (i = "scientific"), o = GZ(e, n);
    }
    const a = zk(Math.abs(o)), s = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = {
      notation: i,
      minimumFractionDigits: s,
      maximumFractionDigits: s
    };
    return Object.assign(l, this.options.ticks.format), nb(e, r, l);
  }
};
function GZ(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n;
}
var Yk = {
  formatters: YZ
};
function XZ(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Yk.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const Ho = /* @__PURE__ */ Object.create(null), mg = /* @__PURE__ */ Object.create(null);
function Js(e, t) {
  if (!t)
    return e;
  const n = t.split(".");
  for (let r = 0, i = n.length; r < i; ++r) {
    const o = n[r];
    e = e[o] || (e[o] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function Wh(e, t, n) {
  return typeof t == "string" ? Sl(Js(e, t), n) : Sl(Js(e, ""), t);
}
class ZZ {
  constructor(t, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (r) => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (r, i) => zh(i.backgroundColor), this.hoverBorderColor = (r, i) => zh(i.borderColor), this.hoverColor = (r, i) => zh(i.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(n);
  }
  set(t, n) {
    return Wh(this, t, n);
  }
  get(t) {
    return Js(this, t);
  }
  describe(t, n) {
    return Wh(mg, t, n);
  }
  override(t, n) {
    return Wh(Ho, t, n);
  }
  route(t, n, r, i) {
    const o = Js(this, t), a = Js(this, r), s = "_" + n;
    Object.defineProperties(o, {
      [s]: {
        value: o[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const l = this[s], c = a[i];
          return Te(l) ? Object.assign({}, c, l) : we(l, c);
        },
        set(l) {
          this[s] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((n) => n(this));
  }
}
var Mt = /* @__PURE__ */ new ZZ({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  HZ,
  qZ,
  XZ
]);
function JZ(e) {
  return !e || We(e.size) || We(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function MS(e, t, n, r, i) {
  let o = t[i];
  return o || (o = t[i] = e.measureText(i).width, n.push(i)), o > r && (r = o), r;
}
function fo(e, t, n) {
  const r = e.currentDevicePixelRatio, i = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((t - i) * r) / r + i;
}
function jS(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function gg(e, t, n, r) {
  Gk(e, t, n, r, null);
}
function Gk(e, t, n, r, i) {
  let o, a, s, l, c, u, d, p;
  const h = t.pointStyle, g = t.rotation, m = t.radius;
  let v = (g || 0) * TZ;
  if (h && typeof h == "object" && (o = h.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(n, r), e.rotate(v), e.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), e.restore();
    return;
  }
  if (!(isNaN(m) || m <= 0)) {
    switch (e.beginPath(), h) {
      // Default includes circle
      default:
        i ? e.ellipse(n, r, i / 2, m, 0, 0, Pt) : e.arc(n, r, m, 0, Pt), e.closePath();
        break;
      case "triangle":
        u = i ? i / 2 : m, e.moveTo(n + Math.sin(v) * u, r - Math.cos(v) * m), v += SS, e.lineTo(n + Math.sin(v) * u, r - Math.cos(v) * m), v += SS, e.lineTo(n + Math.sin(v) * u, r - Math.cos(v) * m), e.closePath();
        break;
      case "rectRounded":
        c = m * 0.516, l = m - c, a = Math.cos(v + uo) * l, d = Math.cos(v + uo) * (i ? i / 2 - c : l), s = Math.sin(v + uo) * l, p = Math.sin(v + uo) * (i ? i / 2 - c : l), e.arc(n - d, r - s, c, v - it, v - Bt), e.arc(n + p, r - a, c, v - Bt, v), e.arc(n + d, r + s, c, v, v + Bt), e.arc(n - p, r + a, c, v + Bt, v + it), e.closePath();
        break;
      case "rect":
        if (!g) {
          l = Math.SQRT1_2 * m, u = i ? i / 2 : l, e.rect(n - u, r - l, 2 * u, 2 * l);
          break;
        }
        v += uo;
      /* falls through */
      case "rectRot":
        d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, p = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + p, r - a), e.lineTo(n + d, r + s), e.lineTo(n - p, r + a), e.closePath();
        break;
      case "crossRot":
        v += uo;
      /* falls through */
      case "cross":
        d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, p = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + p, r - a), e.lineTo(n - p, r + a);
        break;
      case "star":
        d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, p = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + p, r - a), e.lineTo(n - p, r + a), v += uo, d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, p = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + p, r - a), e.lineTo(n - p, r + a);
        break;
      case "line":
        a = i ? i / 2 : Math.cos(v) * m, s = Math.sin(v) * m, e.moveTo(n - a, r - s), e.lineTo(n + a, r + s);
        break;
      case "dash":
        e.moveTo(n, r), e.lineTo(n + Math.cos(v) * (i ? i / 2 : m), r + Math.sin(v) * m);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function Cl(e, t, n) {
  return n = n || 0.5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n;
}
function rb(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function ib(e) {
  e.restore();
}
function QZ(e, t, n, r, i) {
  if (!t)
    return e.lineTo(n.x, n.y);
  if (i === "middle") {
    const o = (t.x + n.x) / 2;
    e.lineTo(o, t.y), e.lineTo(o, n.y);
  } else i === "after" != !!r ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
  e.lineTo(n.x, n.y);
}
function eJ(e, t, n, r) {
  if (!t)
    return e.lineTo(n.x, n.y);
  e.bezierCurveTo(r ? t.cp1x : t.cp2x, r ? t.cp1y : t.cp2y, r ? n.cp2x : n.cp1x, r ? n.cp2y : n.cp1y, n.x, n.y);
}
function tJ(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), We(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function nJ(e, t, n, r, i) {
  if (i.strikethrough || i.underline) {
    const o = e.measureText(r), a = t - o.actualBoundingBoxLeft, s = t + o.actualBoundingBoxRight, l = n - o.actualBoundingBoxAscent, c = n + o.actualBoundingBoxDescent, u = i.strikethrough ? (l + c) / 2 : c;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = i.decorationWidth || 2, e.moveTo(a, u), e.lineTo(s, u), e.stroke();
  }
}
function rJ(e, t) {
  const n = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n;
}
function xd(e, t, n, r, i, o = {}) {
  const a = Kt(t) ? t : [
    t
  ], s = o.strokeWidth > 0 && o.strokeColor !== "";
  let l, c;
  for (e.save(), e.font = i.string, tJ(e, o), l = 0; l < a.length; ++l)
    c = a[l], o.backdrop && rJ(e, o.backdrop), s && (o.strokeColor && (e.strokeStyle = o.strokeColor), We(o.strokeWidth) || (e.lineWidth = o.strokeWidth), e.strokeText(c, n, r, o.maxWidth)), e.fillText(c, n, r, o.maxWidth), nJ(e, n, r, c, o), r += Number(i.lineHeight);
  e.restore();
}
function wd(e, t) {
  const { x: n, y: r, w: i, h: o, radius: a } = t;
  e.arc(n + a.topLeft, r + a.topLeft, a.topLeft, 1.5 * it, it, !0), e.lineTo(n, r + o - a.bottomLeft), e.arc(n + a.bottomLeft, r + o - a.bottomLeft, a.bottomLeft, it, Bt, !0), e.lineTo(n + i - a.bottomRight, r + o), e.arc(n + i - a.bottomRight, r + o - a.bottomRight, a.bottomRight, Bt, 0, !0), e.lineTo(n + i, r + a.topRight), e.arc(n + i - a.topRight, r + a.topRight, a.topRight, 0, -Bt, !0), e.lineTo(n + a.topLeft, r);
}
const iJ = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, oJ = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function aJ(e, t) {
  const n = ("" + e).match(iJ);
  if (!n || n[1] === "normal")
    return t * 1.2;
  switch (e = +n[2], n[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const sJ = (e) => +e || 0;
function ob(e, t) {
  const n = {}, r = Te(t), i = r ? Object.keys(t) : t, o = Te(e) ? r ? (a) => we(e[a], e[t[a]]) : (a) => e[a] : () => e;
  for (const a of i)
    n[a] = sJ(o(a));
  return n;
}
function Xk(e) {
  return ob(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Ea(e) {
  return ob(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Or(e) {
  const t = Xk(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function An(e, t) {
  e = e || {}, t = t || Mt.font;
  let n = we(e.size, t.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let r = we(e.style, t.style);
  r && !("" + r).match(oJ) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0);
  const i = {
    family: we(e.family, t.family),
    lineHeight: aJ(we(e.lineHeight, t.lineHeight), n),
    size: n,
    style: r,
    weight: we(e.weight, t.weight),
    string: ""
  };
  return i.string = JZ(i), i;
}
function Kc(e, t, n, r) {
  let i, o, a;
  for (i = 0, o = e.length; i < o; ++i)
    if (a = e[i], a !== void 0 && a !== void 0)
      return a;
}
function lJ(e, t, n) {
  const { min: r, max: i } = e, o = Fk(t, (i - r) / 2), a = (s, l) => n && s === 0 ? 0 : s + l;
  return {
    min: a(r, -Math.abs(o)),
    max: a(i, o)
  };
}
function Qo(e, t) {
  return Object.assign(Object.create(e), t);
}
function ab(e, t = [
  ""
], n, r, i = () => e[0]) {
  const o = n || e;
  typeof r > "u" && (r = eM("_fallback", e));
  const a = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: o,
    _fallback: r,
    _getTarget: i,
    override: (s) => ab([
      s,
      ...e
    ], t, o, r)
  };
  return new Proxy(a, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(s, l) {
      return delete s[l], delete s._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(s, l) {
      return Jk(s, l, () => gJ(l, t, e, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(s, l) {
      return Reflect.getOwnPropertyDescriptor(s._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(s, l) {
      return DS(s).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(s) {
      return DS(s);
    },
    /**
    * A trap for setting property values.
    */
    set(s, l, c) {
      const u = s._storage || (s._storage = i());
      return s[l] = u[l] = c, delete s._keys, !0;
    }
  });
}
function za(e, t, n, r) {
  const i = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Zk(e, r),
    setContext: (o) => za(e, o, n, r),
    override: (o) => za(e.override(o), t, n, r)
  };
  return new Proxy(i, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(o, a) {
      return delete o[a], delete e[a], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(o, a, s) {
      return Jk(o, a, () => uJ(o, a, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(o, a) {
      return o._descriptors.allKeys ? Reflect.has(e, a) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, a);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(o, a) {
      return Reflect.has(e, a);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(o, a, s) {
      return e[a] = s, delete o[a], !0;
    }
  });
}
function Zk(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = t.scriptable, _indexable: r = t.indexable, _allKeys: i = t.allKeys } = e;
  return {
    allKeys: i,
    scriptable: n,
    indexable: r,
    isScriptable: Ki(n) ? n : () => n,
    isIndexable: Ki(r) ? r : () => r
  };
}
const cJ = (e, t) => e ? e + Qy(t) : t, sb = (e, t) => Te(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function Jk(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const r = n();
  return e[t] = r, r;
}
function uJ(e, t, n) {
  const { _proxy: r, _context: i, _subProxy: o, _descriptors: a } = e;
  let s = r[t];
  return Ki(s) && a.isScriptable(t) && (s = dJ(t, s, e, n)), Kt(s) && s.length && (s = fJ(t, s, e, a.isIndexable)), sb(t, s) && (s = za(s, i, o && o[t], a)), s;
}
function dJ(e, t, n, r) {
  const { _proxy: i, _context: o, _subProxy: a, _stack: s } = n;
  if (s.has(e))
    throw new Error("Recursion detected: " + Array.from(s).join("->") + "->" + e);
  s.add(e);
  let l = t(o, a || r);
  return s.delete(e), sb(e, l) && (l = lb(i._scopes, i, e, l)), l;
}
function fJ(e, t, n, r) {
  const { _proxy: i, _context: o, _subProxy: a, _descriptors: s } = n;
  if (typeof o.index < "u" && r(e))
    return t[o.index % t.length];
  if (Te(t[0])) {
    const l = t, c = i._scopes.filter((u) => u !== l);
    t = [];
    for (const u of l) {
      const d = lb(c, i, e, u);
      t.push(za(d, o, a && a[e], s));
    }
  }
  return t;
}
function Qk(e, t, n) {
  return Ki(e) ? e(t, n) : e;
}
const pJ = (e, t) => e === !0 ? t : typeof e == "string" ? Uo(t, e) : void 0;
function hJ(e, t, n, r, i) {
  for (const o of t) {
    const a = pJ(n, o);
    if (a) {
      e.add(a);
      const s = Qk(a._fallback, n, i);
      if (typeof s < "u" && s !== n && s !== r)
        return s;
    } else if (a === !1 && typeof r < "u" && n !== r)
      return null;
  }
  return !1;
}
function lb(e, t, n, r) {
  const i = t._rootScopes, o = Qk(t._fallback, n, r), a = [
    ...e,
    ...i
  ], s = /* @__PURE__ */ new Set();
  s.add(r);
  let l = NS(s, a, n, o || n, r);
  return l === null || typeof o < "u" && o !== n && (l = NS(s, a, o, l, r), l === null) ? !1 : ab(Array.from(s), [
    ""
  ], i, o, () => mJ(t, n, r));
}
function NS(e, t, n, r, i) {
  for (; n; )
    n = hJ(e, t, n, r, i);
  return n;
}
function mJ(e, t, n) {
  const r = e._getTarget();
  t in r || (r[t] = {});
  const i = r[t];
  return Kt(i) && Te(n) ? n : i || {};
}
function gJ(e, t, n, r) {
  let i;
  for (const o of t)
    if (i = eM(cJ(o, e), n), typeof i < "u")
      return sb(e, i) ? lb(n, r, e, i) : i;
}
function eM(e, t) {
  for (const n of t) {
    if (!n)
      continue;
    const r = n[e];
    if (typeof r < "u")
      return r;
  }
}
function DS(e) {
  let t = e._keys;
  return t || (t = e._keys = vJ(e._scopes)), t;
}
function vJ(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const r of Object.keys(n).filter((i) => !i.startsWith("_")))
      t.add(r);
  return Array.from(t);
}
const yJ = Number.EPSILON || 1e-14, Wa = (e, t) => t < e.length && !e[t].skip && e[t], tM = (e) => e === "x" ? "y" : "x";
function bJ(e, t, n, r) {
  const i = e.skip ? t : e, o = t, a = n.skip ? t : n, s = hg(o, i), l = hg(a, o);
  let c = s / (s + l), u = l / (s + l);
  c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
  const d = r * c, p = r * u;
  return {
    previous: {
      x: o.x - d * (a.x - i.x),
      y: o.y - d * (a.y - i.y)
    },
    next: {
      x: o.x + p * (a.x - i.x),
      y: o.y + p * (a.y - i.y)
    }
  };
}
function xJ(e, t, n) {
  const r = e.length;
  let i, o, a, s, l, c = Wa(e, 0);
  for (let u = 0; u < r - 1; ++u)
    if (l = c, c = Wa(e, u + 1), !(!l || !c)) {
      if (Xs(t[u], 0, yJ)) {
        n[u] = n[u + 1] = 0;
        continue;
      }
      i = n[u] / t[u], o = n[u + 1] / t[u], s = Math.pow(i, 2) + Math.pow(o, 2), !(s <= 9) && (a = 3 / Math.sqrt(s), n[u] = i * a * t[u], n[u + 1] = o * a * t[u]);
    }
}
function wJ(e, t, n = "x") {
  const r = tM(n), i = e.length;
  let o, a, s, l = Wa(e, 0);
  for (let c = 0; c < i; ++c) {
    if (a = s, s = l, l = Wa(e, c + 1), !s)
      continue;
    const u = s[n], d = s[r];
    a && (o = (u - a[n]) / 3, s[`cp1${n}`] = u - o, s[`cp1${r}`] = d - o * t[c]), l && (o = (l[n] - u) / 3, s[`cp2${n}`] = u + o, s[`cp2${r}`] = d + o * t[c]);
  }
}
function OJ(e, t = "x") {
  const n = tM(t), r = e.length, i = Array(r).fill(0), o = Array(r);
  let a, s, l, c = Wa(e, 0);
  for (a = 0; a < r; ++a)
    if (s = l, l = c, c = Wa(e, a + 1), !!l) {
      if (c) {
        const u = c[t] - l[t];
        i[a] = u !== 0 ? (c[n] - l[n]) / u : 0;
      }
      o[a] = s ? c ? Br(i[a - 1]) !== Br(i[a]) ? 0 : (i[a - 1] + i[a]) / 2 : i[a - 1] : i[a];
    }
  xJ(e, i, o), wJ(e, o, t);
}
function Yc(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
function SJ(e, t) {
  let n, r, i, o, a, s = Cl(e[0], t);
  for (n = 0, r = e.length; n < r; ++n)
    a = o, o = s, s = n < r - 1 && Cl(e[n + 1], t), o && (i = e[n], a && (i.cp1x = Yc(i.cp1x, t.left, t.right), i.cp1y = Yc(i.cp1y, t.top, t.bottom)), s && (i.cp2x = Yc(i.cp2x, t.left, t.right), i.cp2y = Yc(i.cp2y, t.top, t.bottom)));
}
function EJ(e, t, n, r, i) {
  let o, a, s, l;
  if (t.spanGaps && (e = e.filter((c) => !c.skip)), t.cubicInterpolationMode === "monotone")
    OJ(e, i);
  else {
    let c = r ? e[e.length - 1] : e[0];
    for (o = 0, a = e.length; o < a; ++o)
      s = e[o], l = bJ(c, s, e[Math.min(o + 1, a - (r ? 0 : 1)) % a], t.tension), s.cp1x = l.previous.x, s.cp1y = l.previous.y, s.cp2x = l.next.x, s.cp2y = l.next.y, c = s;
  }
  t.capBezierPoints && SJ(e, n);
}
function cb() {
  return typeof window < "u" && typeof document < "u";
}
function ub(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function Od(e, t, n) {
  let r;
  return typeof e == "string" ? (r = parseInt(e, 10), e.indexOf("%") !== -1 && (r = r / 100 * t.parentNode[n])) : r = e, r;
}
const $f = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function _J(e, t) {
  return $f(e).getPropertyValue(t);
}
const PJ = [
  "top",
  "right",
  "bottom",
  "left"
];
function Ro(e, t, n) {
  const r = {};
  n = n ? "-" + n : "";
  for (let i = 0; i < 4; i++) {
    const o = PJ[i];
    r[o] = parseFloat(e[t + "-" + o + n]) || 0;
  }
  return r.width = r.left + r.right, r.height = r.top + r.bottom, r;
}
const CJ = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function TJ(e, t) {
  const n = e.touches, r = n && n.length ? n[0] : e, { offsetX: i, offsetY: o } = r;
  let a = !1, s, l;
  if (CJ(i, o, e.target))
    s = i, l = o;
  else {
    const c = t.getBoundingClientRect();
    s = r.clientX - c.left, l = r.clientY - c.top, a = !0;
  }
  return {
    x: s,
    y: l,
    box: a
  };
}
function xo(e, t) {
  if ("native" in e)
    return e;
  const { canvas: n, currentDevicePixelRatio: r } = t, i = $f(n), o = i.boxSizing === "border-box", a = Ro(i, "padding"), s = Ro(i, "border", "width"), { x: l, y: c, box: u } = TJ(e, n), d = a.left + (u && s.left), p = a.top + (u && s.top);
  let { width: h, height: g } = t;
  return o && (h -= a.width + s.width, g -= a.height + s.height), {
    x: Math.round((l - d) / h * n.width / r),
    y: Math.round((c - p) / g * n.height / r)
  };
}
function AJ(e, t, n) {
  let r, i;
  if (t === void 0 || n === void 0) {
    const o = e && ub(e);
    if (!o)
      t = e.clientWidth, n = e.clientHeight;
    else {
      const a = o.getBoundingClientRect(), s = $f(o), l = Ro(s, "border", "width"), c = Ro(s, "padding");
      t = a.width - c.width - l.width, n = a.height - c.height - l.height, r = Od(s.maxWidth, o, "clientWidth"), i = Od(s.maxHeight, o, "clientHeight");
    }
  }
  return {
    width: t,
    height: n,
    maxWidth: r || bd,
    maxHeight: i || bd
  };
}
const Gc = (e) => Math.round(e * 10) / 10;
function kJ(e, t, n, r) {
  const i = $f(e), o = Ro(i, "margin"), a = Od(i.maxWidth, e, "clientWidth") || bd, s = Od(i.maxHeight, e, "clientHeight") || bd, l = AJ(e, t, n);
  let { width: c, height: u } = l;
  if (i.boxSizing === "content-box") {
    const p = Ro(i, "border", "width"), h = Ro(i, "padding");
    c -= h.width + p.width, u -= h.height + p.height;
  }
  return c = Math.max(0, c - o.width), u = Math.max(0, r ? c / r : u - o.height), c = Gc(Math.min(c, a, l.maxWidth)), u = Gc(Math.min(u, s, l.maxHeight)), c && !u && (u = Gc(c / 2)), (t !== void 0 || n !== void 0) && r && l.height && u > l.height && (u = l.height, c = Gc(Math.floor(u * r))), {
    width: c,
    height: u
  };
}
function RS(e, t, n) {
  const r = t || 1, i = Math.floor(e.height * r), o = Math.floor(e.width * r);
  e.height = Math.floor(e.height), e.width = Math.floor(e.width);
  const a = e.canvas;
  return a.style && (n || !a.style.height && !a.style.width) && (a.style.height = `${e.height}px`, a.style.width = `${e.width}px`), e.currentDevicePixelRatio !== r || a.height !== i || a.width !== o ? (e.currentDevicePixelRatio = r, a.height = i, a.width = o, e.ctx.setTransform(r, 0, 0, r, 0, 0), !0) : !1;
}
const MJ = (function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    cb() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
})();
function IS(e, t) {
  const n = _J(e, t), r = n && n.match(/^(\d+)(\.\d+)?px$/);
  return r ? +r[1] : void 0;
}
function wo(e, t, n, r) {
  return {
    x: e.x + n * (t.x - e.x),
    y: e.y + n * (t.y - e.y)
  };
}
function jJ(e, t, n, r) {
  return {
    x: e.x + n * (t.x - e.x),
    y: r === "middle" ? n < 0.5 ? e.y : t.y : r === "after" ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y
  };
}
function NJ(e, t, n, r) {
  const i = {
    x: e.cp2x,
    y: e.cp2y
  }, o = {
    x: t.cp1x,
    y: t.cp1y
  }, a = wo(e, i, n), s = wo(i, o, n), l = wo(o, t, n), c = wo(a, s, n), u = wo(s, l, n);
  return wo(c, u, n);
}
const DJ = function(e, t) {
  return {
    x(n) {
      return e + e + t - n;
    },
    setWidth(n) {
      t = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, r) {
      return n - r;
    },
    leftForLtr(n, r) {
      return n - r;
    }
  };
}, RJ = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function _a(e, t, n) {
  return e ? DJ(t, n) : RJ();
}
function nM(e, t) {
  let n, r;
  (t === "ltr" || t === "rtl") && (n = e.canvas.style, r = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", t, "important"), e.prevTextDirection = r);
}
function rM(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function iM(e) {
  return e === "angle" ? {
    between: Pl,
    compare: DZ,
    normalize: xr
  } : {
    between: Di,
    compare: (t, n) => t - n,
    normalize: (t) => t
  };
}
function $S({ start: e, end: t, count: n, loop: r, style: i }) {
  return {
    start: e % n,
    end: t % n,
    loop: r && (t - e + 1) % n === 0,
    style: i
  };
}
function IJ(e, t, n) {
  const { property: r, start: i, end: o } = n, { between: a, normalize: s } = iM(r), l = t.length;
  let { start: c, end: u, loop: d } = e, p, h;
  if (d) {
    for (c += l, u += l, p = 0, h = l; p < h && a(s(t[c % l][r]), i, o); ++p)
      c--, u--;
    c %= l, u %= l;
  }
  return u < c && (u += l), {
    start: c,
    end: u,
    loop: d,
    style: e.style
  };
}
function $J(e, t, n) {
  if (!n)
    return [
      e
    ];
  const { property: r, start: i, end: o } = n, a = t.length, { compare: s, between: l, normalize: c } = iM(r), { start: u, end: d, loop: p, style: h } = IJ(e, t, n), g = [];
  let m = !1, v = null, y, S, w;
  const b = () => l(i, w, y) && s(i, w) !== 0, O = () => s(o, y) === 0 || l(o, w, y), E = () => m || b(), C = () => !m || O();
  for (let T = u, j = u; T <= d; ++T)
    S = t[T % a], !S.skip && (y = c(S[r]), y !== w && (m = l(y, i, o), v === null && E() && (v = s(y, i) === 0 ? T : j), v !== null && C() && (g.push($S({
      start: v,
      end: T,
      loop: p,
      count: a,
      style: h
    })), v = null), j = T, w = y));
  return v !== null && g.push($S({
    start: v,
    end: d,
    loop: p,
    count: a,
    style: h
  })), g;
}
function LJ(e, t) {
  const n = [], r = e.segments;
  for (let i = 0; i < r.length; i++) {
    const o = $J(r[i], e.points, t);
    o.length && n.push(...o);
  }
  return n;
}
function FJ(e, t, n, r) {
  let i = 0, o = t - 1;
  if (n && !r)
    for (; i < t && !e[i].skip; )
      i++;
  for (; i < t && e[i].skip; )
    i++;
  for (i %= t, n && (o += i); o > i && e[o % t].skip; )
    o--;
  return o %= t, {
    start: i,
    end: o
  };
}
function BJ(e, t, n, r) {
  const i = e.length, o = [];
  let a = t, s = e[t], l;
  for (l = t + 1; l <= n; ++l) {
    const c = e[l % i];
    c.skip || c.stop ? s.skip || (r = !1, o.push({
      start: t % i,
      end: (l - 1) % i,
      loop: r
    }), t = a = c.stop ? l : null) : (a = l, s.skip && (t = l)), s = c;
  }
  return a !== null && o.push({
    start: t % i,
    end: a % i,
    loop: r
  }), o;
}
function zJ(e, t) {
  const n = e.points, r = e.options.spanGaps, i = n.length;
  if (!i)
    return [];
  const o = !!e._loop, { start: a, end: s } = FJ(n, i, o, r);
  if (r === !0)
    return LS(e, [
      {
        start: a,
        end: s,
        loop: o
      }
    ], n, t);
  const l = s < a ? s + i : s, c = !!e._fullLoop && a === 0 && s === i - 1;
  return LS(e, BJ(n, a, l, c), n, t);
}
function LS(e, t, n, r) {
  return !r || !r.setContext || !n ? t : WJ(e, t, n, r);
}
function WJ(e, t, n, r) {
  const i = e._chart.getContext(), o = FS(e.options), { _datasetIndex: a, options: { spanGaps: s } } = e, l = n.length, c = [];
  let u = o, d = t[0].start, p = d;
  function h(g, m, v, y) {
    const S = s ? -1 : 1;
    if (g !== m) {
      for (g += l; n[g % l].skip; )
        g -= S;
      for (; n[m % l].skip; )
        m += S;
      g % l !== m % l && (c.push({
        start: g % l,
        end: m % l,
        loop: v,
        style: y
      }), u = y, d = m % l);
    }
  }
  for (const g of t) {
    d = s ? d : g.start;
    let m = n[d % l], v;
    for (p = d + 1; p <= g.end; p++) {
      const y = n[p % l];
      v = FS(r.setContext(Qo(i, {
        type: "segment",
        p0: m,
        p1: y,
        p0DataIndex: (p - 1) % l,
        p1DataIndex: p % l,
        datasetIndex: a
      }))), VJ(v, u) && h(d, p - 1, g.loop, u), m = y, u = v;
    }
    d < p - 1 && h(d, p - 1, g.loop, u);
  }
  return c;
}
function FS(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function VJ(e, t) {
  if (!t)
    return !1;
  const n = [], r = function(i, o) {
    return tb(o) ? (n.includes(o) || n.push(o), n.indexOf(o)) : o;
  };
  return JSON.stringify(e, r) !== JSON.stringify(t, r);
}
function Xc(e, t, n) {
  return e.options.clip ? e[n] : t[n];
}
function UJ(e, t) {
  const { xScale: n, yScale: r } = e;
  return n && r ? {
    left: Xc(n, t, "left"),
    right: Xc(n, t, "right"),
    top: Xc(r, t, "top"),
    bottom: Xc(r, t, "bottom")
  } : t;
}
function HJ(e, t) {
  const n = t._clip;
  if (n.disabled)
    return !1;
  const r = UJ(t, e.chartArea);
  return {
    left: n.left === !1 ? 0 : r.left - (n.left === !0 ? 0 : n.left),
    right: n.right === !1 ? e.width : r.right + (n.right === !0 ? 0 : n.right),
    top: n.top === !1 ? 0 : r.top - (n.top === !0 ? 0 : n.top),
    bottom: n.bottom === !1 ? e.height : r.bottom + (n.bottom === !0 ? 0 : n.bottom)
  };
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class qJ {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, n, r, i) {
    const o = n.listeners[i], a = n.duration;
    o.forEach((s) => s({
      chart: t,
      initial: n.initial,
      numSteps: a,
      currentStep: Math.min(r - n.start, a)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Hk.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let n = 0;
    this._charts.forEach((r, i) => {
      if (!r.running || !r.items.length)
        return;
      const o = r.items;
      let a = o.length - 1, s = !1, l;
      for (; a >= 0; --a)
        l = o[a], l._active ? (l._total > r.duration && (r.duration = l._total), l.tick(t), s = !0) : (o[a] = o[o.length - 1], o.pop());
      s && (i.draw(), this._notify(i, r, t, "progress")), o.length || (r.running = !1, this._notify(i, r, t, "complete"), r.initial = !1), n += o.length;
    }), this._lastDate = t, n === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const n = this._charts;
    let r = n.get(t);
    return r || (r = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(t, r)), r;
  }
  listen(t, n, r) {
    this._getAnims(t).listeners[n].push(r);
  }
  add(t, n) {
    !n || !n.length || this._getAnims(t).items.push(...n);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const n = this._charts.get(t);
    n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const n = this._charts.get(t);
    return !(!n || !n.running || !n.items.length);
  }
  stop(t) {
    const n = this._charts.get(t);
    if (!n || !n.items.length)
      return;
    const r = n.items;
    let i = r.length - 1;
    for (; i >= 0; --i)
      r[i].cancel();
    n.items = [], this._notify(t, n, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var ei = /* @__PURE__ */ new qJ();
const BS = "transparent", KJ = {
  boolean(e, t, n) {
    return n > 0.5 ? t : e;
  },
  color(e, t, n) {
    const r = AS(e || BS), i = r.valid && AS(t || BS);
    return i && i.valid ? i.mix(r, n).hexString() : t;
  },
  number(e, t, n) {
    return e + (t - e) * n;
  }
};
class YJ {
  constructor(t, n, r, i) {
    const o = n[r];
    i = Kc([
      t.to,
      i,
      o,
      t.from
    ]);
    const a = Kc([
      t.from,
      o,
      i
    ]);
    this._active = !0, this._fn = t.fn || KJ[t.type || typeof a], this._easing = Zs[t.easing] || Zs.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = n, this._prop = r, this._from = a, this._to = i, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, n, r) {
    if (this._active) {
      this._notify(!1);
      const i = this._target[this._prop], o = r - this._start, a = this._duration - o;
      this._start = r, this._duration = Math.floor(Math.max(a, t.duration)), this._total += o, this._loop = !!t.loop, this._to = Kc([
        t.to,
        n,
        i,
        t.from
      ]), this._from = Kc([
        t.from,
        i,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const n = t - this._start, r = this._duration, i = this._prop, o = this._from, a = this._loop, s = this._to;
    let l;
    if (this._active = o !== s && (a || n < r), !this._active) {
      this._target[i] = s, this._notify(!0);
      return;
    }
    if (n < 0) {
      this._target[i] = o;
      return;
    }
    l = n / r % 2, l = a && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(o, s, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((n, r) => {
      t.push({
        res: n,
        rej: r
      });
    });
  }
  _notify(t) {
    const n = t ? "res" : "rej", r = this._promises || [];
    for (let i = 0; i < r.length; i++)
      r[i][n]();
  }
}
class oM {
  constructor(t, n) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(t) {
    if (!Te(t))
      return;
    const n = Object.keys(Mt.animation), r = this._properties;
    Object.getOwnPropertyNames(t).forEach((i) => {
      const o = t[i];
      if (!Te(o))
        return;
      const a = {};
      for (const s of n)
        a[s] = o[s];
      (Kt(o.properties) && o.properties || [
        i
      ]).forEach((s) => {
        (s === i || !r.has(s)) && r.set(s, a);
      });
    });
  }
  _animateOptions(t, n) {
    const r = n.options, i = XJ(t, r);
    if (!i)
      return [];
    const o = this._createAnimations(i, r);
    return r.$shared && GJ(t.options.$animations, r).then(() => {
      t.options = r;
    }, () => {
    }), o;
  }
  _createAnimations(t, n) {
    const r = this._properties, i = [], o = t.$animations || (t.$animations = {}), a = Object.keys(n), s = Date.now();
    let l;
    for (l = a.length - 1; l >= 0; --l) {
      const c = a[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        i.push(...this._animateOptions(t, n));
        continue;
      }
      const u = n[c];
      let d = o[c];
      const p = r.get(c);
      if (d)
        if (p && d.active()) {
          d.update(p, u, s);
          continue;
        } else
          d.cancel();
      if (!p || !p.duration) {
        t[c] = u;
        continue;
      }
      o[c] = d = new YJ(p, t, c, u), i.push(d);
    }
    return i;
  }
  update(t, n) {
    if (this._properties.size === 0) {
      Object.assign(t, n);
      return;
    }
    const r = this._createAnimations(t, n);
    if (r.length)
      return ei.add(this._chart, r), !0;
  }
}
function GJ(e, t) {
  const n = [], r = Object.keys(t);
  for (let i = 0; i < r.length; i++) {
    const o = e[r[i]];
    o && o.active() && n.push(o.wait());
  }
  return Promise.all(n);
}
function XJ(e, t) {
  if (!t)
    return;
  let n = e.options;
  if (!n) {
    e.options = t;
    return;
  }
  return n.$shared && (e.options = n = Object.assign({}, n, {
    $shared: !1,
    $animations: {}
  })), n;
}
function zS(e, t) {
  const n = e && e.options || {}, r = n.reverse, i = n.min === void 0 ? t : 0, o = n.max === void 0 ? t : 0;
  return {
    start: r ? o : i,
    end: r ? i : o
  };
}
function ZJ(e, t, n) {
  if (n === !1)
    return !1;
  const r = zS(e, n), i = zS(t, n);
  return {
    top: i.end,
    right: r.end,
    bottom: i.start,
    left: r.start
  };
}
function JJ(e) {
  let t, n, r, i;
  return Te(e) ? (t = e.top, n = e.right, r = e.bottom, i = e.left) : t = n = r = i = e, {
    top: t,
    right: n,
    bottom: r,
    left: i,
    disabled: e === !1
  };
}
function aM(e, t) {
  const n = [], r = e._getSortedDatasetMetas(t);
  let i, o;
  for (i = 0, o = r.length; i < o; ++i)
    n.push(r[i].index);
  return n;
}
function WS(e, t, n, r = {}) {
  const i = e.keys, o = r.mode === "single";
  let a, s, l, c;
  if (t === null)
    return;
  let u = !1;
  for (a = 0, s = i.length; a < s; ++a) {
    if (l = +i[a], l === n) {
      if (u = !0, r.all)
        continue;
      break;
    }
    c = e.values[l], mr(c) && (o || t === 0 || Br(t) === Br(c)) && (t += c);
  }
  return !u && !r.all ? 0 : t;
}
function QJ(e, t) {
  const { iScale: n, vScale: r } = t, i = n.axis === "x" ? "x" : "y", o = r.axis === "x" ? "x" : "y", a = Object.keys(e), s = new Array(a.length);
  let l, c, u;
  for (l = 0, c = a.length; l < c; ++l)
    u = a[l], s[l] = {
      [i]: u,
      [o]: e[u]
    };
  return s;
}
function Vh(e, t) {
  const n = e && e.options.stacked;
  return n || n === void 0 && t.stack !== void 0;
}
function eQ(e, t, n) {
  return `${e.id}.${t.id}.${n.stack || n.type}`;
}
function tQ(e) {
  const { min: t, max: n, minDefined: r, maxDefined: i } = e.getUserBounds();
  return {
    min: r ? t : Number.NEGATIVE_INFINITY,
    max: i ? n : Number.POSITIVE_INFINITY
  };
}
function nQ(e, t, n) {
  const r = e[t] || (e[t] = {});
  return r[n] || (r[n] = {});
}
function VS(e, t, n, r) {
  for (const i of t.getMatchingVisibleMetas(r).reverse()) {
    const o = e[i.index];
    if (n && o > 0 || !n && o < 0)
      return i.index;
  }
  return null;
}
function US(e, t) {
  const { chart: n, _cachedMeta: r } = e, i = n._stacks || (n._stacks = {}), { iScale: o, vScale: a, index: s } = r, l = o.axis, c = a.axis, u = eQ(o, a, r), d = t.length;
  let p;
  for (let h = 0; h < d; ++h) {
    const g = t[h], { [l]: m, [c]: v } = g, y = g._stacks || (g._stacks = {});
    p = y[c] = nQ(i, u, m), p[s] = v, p._top = VS(p, a, !0, r.type), p._bottom = VS(p, a, !1, r.type);
    const S = p._visualValues || (p._visualValues = {});
    S[s] = v;
  }
}
function Uh(e, t) {
  const n = e.scales;
  return Object.keys(n).filter((r) => n[r].axis === t).shift();
}
function rQ(e, t) {
  return Qo(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function iQ(e, t, n) {
  return Qo(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: t,
    mode: "default",
    type: "data"
  });
}
function Es(e, t) {
  const n = e.controller.index, r = e.vScale && e.vScale.axis;
  if (r) {
    t = t || e._parsed;
    for (const i of t) {
      const o = i._stacks;
      if (!o || o[r] === void 0 || o[r][n] === void 0)
        return;
      delete o[r][n], o[r]._visualValues !== void 0 && o[r]._visualValues[n] !== void 0 && delete o[r]._visualValues[n];
    }
  }
}
const Hh = (e) => e === "reset" || e === "none", HS = (e, t) => t ? e : Object.assign({}, e), oQ = (e, t, n) => e && !t.hidden && t._stacked && {
  keys: aM(n, !0),
  values: null
};
class Lf {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(t, n) {
    this.chart = t, this._ctx = t.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = Vh(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && Es(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, n = this._cachedMeta, r = this.getDataset(), i = (d, p, h, g) => d === "x" ? p : d === "r" ? g : h, o = n.xAxisID = we(r.xAxisID, Uh(t, "x")), a = n.yAxisID = we(r.yAxisID, Uh(t, "y")), s = n.rAxisID = we(r.rAxisID, Uh(t, "r")), l = n.indexAxis, c = n.iAxisID = i(l, o, a, s), u = n.vAxisID = i(l, a, o, s);
    n.xScale = this.getScaleForId(o), n.yScale = this.getScaleForId(a), n.rScale = this.getScaleForId(s), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const n = this._cachedMeta;
    return t === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && PS(this._data, this), t._stacked && Es(t);
  }
  _dataCheck() {
    const t = this.getDataset(), n = t.data || (t.data = []), r = this._data;
    if (Te(n)) {
      const i = this._cachedMeta;
      this._data = QJ(n, i);
    } else if (r !== n) {
      if (r) {
        PS(r, this);
        const i = this._cachedMeta;
        Es(i), i._parsed = [];
      }
      n && Object.isExtensible(n) && LZ(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const n = this._cachedMeta, r = this.getDataset();
    let i = !1;
    this._dataCheck();
    const o = n._stacked;
    n._stacked = Vh(n.vScale, n), n.stack !== r.stack && (i = !0, Es(n), n.stack = r.stack), this._resyncElements(t), (i || o !== n._stacked) && (US(this, n._parsed), n._stacked = Vh(n.vScale, n));
  }
  configure() {
    const t = this.chart.config, n = t.datasetScopeKeys(this._type), r = t.getOptionScopes(this.getDataset(), n, !0);
    this.options = t.createResolver(r, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, n) {
    const { _cachedMeta: r, _data: i } = this, { iScale: o, _stacked: a } = r, s = o.axis;
    let l = t === 0 && n === i.length ? !0 : r._sorted, c = t > 0 && r._parsed[t - 1], u, d, p;
    if (this._parsing === !1)
      r._parsed = i, r._sorted = !0, p = i;
    else {
      Kt(i[t]) ? p = this.parseArrayData(r, i, t, n) : Te(i[t]) ? p = this.parseObjectData(r, i, t, n) : p = this.parsePrimitiveData(r, i, t, n);
      const h = () => d[s] === null || c && d[s] < c[s];
      for (u = 0; u < n; ++u)
        r._parsed[u + t] = d = p[u], l && (h() && (l = !1), c = d);
      r._sorted = l;
    }
    a && US(this, p);
  }
  parsePrimitiveData(t, n, r, i) {
    const { iScale: o, vScale: a } = t, s = o.axis, l = a.axis, c = o.getLabels(), u = o === a, d = new Array(i);
    let p, h, g;
    for (p = 0, h = i; p < h; ++p)
      g = p + r, d[p] = {
        [s]: u || o.parse(c[g], g),
        [l]: a.parse(n[g], g)
      };
    return d;
  }
  parseArrayData(t, n, r, i) {
    const { xScale: o, yScale: a } = t, s = new Array(i);
    let l, c, u, d;
    for (l = 0, c = i; l < c; ++l)
      u = l + r, d = n[u], s[l] = {
        x: o.parse(d[0], u),
        y: a.parse(d[1], u)
      };
    return s;
  }
  parseObjectData(t, n, r, i) {
    const { xScale: o, yScale: a } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(i);
    let u, d, p, h;
    for (u = 0, d = i; u < d; ++u)
      p = u + r, h = n[p], c[u] = {
        x: o.parse(Uo(h, s), p),
        y: a.parse(Uo(h, l), p)
      };
    return c;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, n, r) {
    const i = this.chart, o = this._cachedMeta, a = n[t.axis], s = {
      keys: aM(i, !0),
      values: n._stacks[t.axis]._visualValues
    };
    return WS(s, a, o.index, {
      mode: r
    });
  }
  updateRangeFromParsed(t, n, r, i) {
    const o = r[n.axis];
    let a = o === null ? NaN : o;
    const s = i && r._stacks[n.axis];
    i && s && (i.values = s, a = WS(i, o, this._cachedMeta.index)), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a);
  }
  getMinMax(t, n) {
    const r = this._cachedMeta, i = r._parsed, o = r._sorted && t === r.iScale, a = i.length, s = this._getOtherScale(t), l = oQ(n, r, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: d } = tQ(s);
    let p, h;
    function g() {
      h = i[p];
      const m = h[s.axis];
      return !mr(h[t.axis]) || u > m || d < m;
    }
    for (p = 0; p < a && !(!g() && (this.updateRangeFromParsed(c, t, h, l), o)); ++p)
      ;
    if (o) {
      for (p = a - 1; p >= 0; --p)
        if (!g()) {
          this.updateRangeFromParsed(c, t, h, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(t) {
    const n = this._cachedMeta._parsed, r = [];
    let i, o, a;
    for (i = 0, o = n.length; i < o; ++i)
      a = n[i][t.axis], mr(a) && r.push(a);
    return r;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, r = n.iScale, i = n.vScale, o = this.getParsed(t);
    return {
      label: r ? "" + r.getLabelForValue(o[r.axis]) : "",
      value: i ? "" + i.getLabelForValue(o[i.axis]) : ""
    };
  }
  _update(t) {
    const n = this._cachedMeta;
    this.update(t || "default"), n._clip = JJ(we(this.options.clip, ZJ(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, n = this.chart, r = this._cachedMeta, i = r.data || [], o = n.chartArea, a = [], s = this._drawStart || 0, l = this._drawCount || i.length - s, c = this.options.drawActiveElementsOnTop;
    let u;
    for (r.dataset && r.dataset.draw(t, o, s, l), u = s; u < s + l; ++u) {
      const d = i[u];
      d.hidden || (d.active && c ? a.push(d) : d.draw(t, o));
    }
    for (u = 0; u < a.length; ++u)
      a[u].draw(t, o);
  }
  getStyle(t, n) {
    const r = n ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(t || 0, r);
  }
  getContext(t, n, r) {
    const i = this.getDataset();
    let o;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const a = this._cachedMeta.data[t];
      o = a.$context || (a.$context = iQ(this.getContext(), t, a)), o.parsed = this.getParsed(t), o.raw = i.data[t], o.index = o.dataIndex = t;
    } else
      o = this.$context || (this.$context = rQ(this.chart.getContext(), this.index)), o.dataset = i, o.index = o.datasetIndex = this.index;
    return o.active = !!n, o.mode = r, o;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, t);
  }
  _resolveElementOptions(t, n = "default", r) {
    const i = n === "active", o = this._cachedDataOpts, a = t + "-" + n, s = o[a], l = this.enableOptionSharing && El(r);
    if (s)
      return HS(s, l);
    const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, t), d = i ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], p = c.getOptionScopes(this.getDataset(), u), h = Object.keys(Mt.elements[t]), g = () => this.getContext(r, i, n), m = c.resolveNamedOptions(p, h, g, d);
    return m.$shared && (m.$shared = l, o[a] = Object.freeze(HS(m, l))), m;
  }
  _resolveAnimations(t, n, r) {
    const i = this.chart, o = this._cachedDataOpts, a = `animation-${n}`, s = o[a];
    if (s)
      return s;
    let l;
    if (i.options.animation !== !1) {
      const u = this.chart.config, d = u.datasetAnimationScopeKeys(this._type, n), p = u.getOptionScopes(this.getDataset(), d);
      l = u.createResolver(p, this.getContext(t, r, n));
    }
    const c = new oM(i, l && l.animations);
    return l && l._cacheable && (o[a] = Object.freeze(c)), c;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, n) {
    return !n || Hh(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, n) {
    const r = this.resolveDataElementOptions(t, n), i = this._sharedOptions, o = this.getSharedOptions(r), a = this.includeOptions(n, o) || o !== i;
    return this.updateSharedOptions(o, n, r), {
      sharedOptions: o,
      includeOptions: a
    };
  }
  updateElement(t, n, r, i) {
    Hh(i) ? Object.assign(t, r) : this._resolveAnimations(n, i).update(t, r);
  }
  updateSharedOptions(t, n, r) {
    t && !Hh(n) && this._resolveAnimations(void 0, n).update(t, r);
  }
  _setStyle(t, n, r, i) {
    t.active = i;
    const o = this.getStyle(n, i);
    this._resolveAnimations(n, r, i).update(t, {
      options: !i && this.getSharedOptions(o) || o
    });
  }
  removeHoverStyle(t, n, r) {
    this._setStyle(t, r, "active", !1);
  }
  setHoverStyle(t, n, r) {
    this._setStyle(t, r, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const n = this._data, r = this._cachedMeta.data;
    for (const [s, l, c] of this._syncList)
      this[s](l, c);
    this._syncList = [];
    const i = r.length, o = n.length, a = Math.min(o, i);
    a && this.parse(0, a), o > i ? this._insertElements(i, o - i, t) : o < i && this._removeElements(o, i - o);
  }
  _insertElements(t, n, r = !0) {
    const i = this._cachedMeta, o = i.data, a = t + n;
    let s;
    const l = (c) => {
      for (c.length += n, s = c.length - 1; s >= a; s--)
        c[s] = c[s - n];
    };
    for (l(o), s = t; s < a; ++s)
      o[s] = new this.dataElementType();
    this._parsing && l(i._parsed), this.parse(t, n), r && this.updateElements(o, t, n, "reset");
  }
  updateElements(t, n, r, i) {
  }
  _removeElements(t, n) {
    const r = this._cachedMeta;
    if (this._parsing) {
      const i = r._parsed.splice(t, n);
      r._stacked && Es(r, i);
    }
    r.data.splice(t, n);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [n, r, i] = t;
      this[n](r, i);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, n) {
    n && this._sync([
      "_removeElements",
      t,
      n
    ]);
    const r = arguments.length - 2;
    r && this._sync([
      "_insertElements",
      t,
      r
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
function aQ(e, t) {
  if (!e._cache.$bar) {
    const n = e.getMatchingVisibleMetas(t);
    let r = [];
    for (let i = 0, o = n.length; i < o; i++)
      r = r.concat(n[i].controller.getAllParsedValues(e));
    e._cache.$bar = Uk(r.sort((i, o) => i - o));
  }
  return e._cache.$bar;
}
function sQ(e) {
  const t = e.iScale, n = aQ(t, e.type);
  let r = t._length, i, o, a, s;
  const l = () => {
    a === 32767 || a === -32768 || (El(s) && (r = Math.min(r, Math.abs(a - s) || r)), s = a);
  };
  for (i = 0, o = n.length; i < o; ++i)
    a = t.getPixelForValue(n[i]), l();
  for (s = void 0, i = 0, o = t.ticks.length; i < o; ++i)
    a = t.getPixelForTick(i), l();
  return r;
}
function lQ(e, t, n, r) {
  const i = n.barThickness;
  let o, a;
  return We(i) ? (o = t.min * n.categoryPercentage, a = n.barPercentage) : (o = i * r, a = 1), {
    chunk: o / r,
    ratio: a,
    start: t.pixels[e] - o / 2
  };
}
function cQ(e, t, n, r) {
  const i = t.pixels, o = i[e];
  let a = e > 0 ? i[e - 1] : null, s = e < i.length - 1 ? i[e + 1] : null;
  const l = n.categoryPercentage;
  a === null && (a = o - (s === null ? t.end - t.start : s - o)), s === null && (s = o + o - a);
  const c = o - (o - Math.min(a, s)) / 2 * l;
  return {
    chunk: Math.abs(s - a) / 2 * l / r,
    ratio: n.barPercentage,
    start: c
  };
}
function uQ(e, t, n, r) {
  const i = n.parse(e[0], r), o = n.parse(e[1], r), a = Math.min(i, o), s = Math.max(i, o);
  let l = a, c = s;
  Math.abs(a) > Math.abs(s) && (l = s, c = a), t[n.axis] = c, t._custom = {
    barStart: l,
    barEnd: c,
    start: i,
    end: o,
    min: a,
    max: s
  };
}
function sM(e, t, n, r) {
  return Kt(e) ? uQ(e, t, n, r) : t[n.axis] = n.parse(e, r), t;
}
function qS(e, t, n, r) {
  const i = e.iScale, o = e.vScale, a = i.getLabels(), s = i === o, l = [];
  let c, u, d, p;
  for (c = n, u = n + r; c < u; ++c)
    p = t[c], d = {}, d[i.axis] = s || i.parse(a[c], c), l.push(sM(p, d, o, c));
  return l;
}
function qh(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function dQ(e, t, n) {
  return e !== 0 ? Br(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1);
}
function fQ(e) {
  let t, n, r, i, o;
  return e.horizontal ? (t = e.base > e.x, n = "left", r = "right") : (t = e.base < e.y, n = "bottom", r = "top"), t ? (i = "end", o = "start") : (i = "start", o = "end"), {
    start: n,
    end: r,
    reverse: t,
    top: i,
    bottom: o
  };
}
function pQ(e, t, n, r) {
  let i = t.borderSkipped;
  const o = {};
  if (!i) {
    e.borderSkipped = o;
    return;
  }
  if (i === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: a, end: s, reverse: l, top: c, bottom: u } = fQ(e);
  i === "middle" && n && (e.enableBorderRadius = !0, (n._top || 0) === r ? i = c : (n._bottom || 0) === r ? i = u : (o[KS(u, a, s, l)] = !0, i = c)), o[KS(i, a, s, l)] = !0, e.borderSkipped = o;
}
function KS(e, t, n, r) {
  return r ? (e = hQ(e, t, n), e = YS(e, n, t)) : e = YS(e, t, n), e;
}
function hQ(e, t, n) {
  return e === t ? n : e === n ? t : e;
}
function YS(e, t, n) {
  return e === "start" ? t : e === "end" ? n : e;
}
function mQ(e, { inflateAmount: t }, n) {
  e.inflateAmount = t === "auto" ? n === 1 ? 0.33 : 0 : t;
}
class gQ extends Lf {
  static id = "bar";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  parsePrimitiveData(t, n, r, i) {
    return qS(t, n, r, i);
  }
  parseArrayData(t, n, r, i) {
    return qS(t, n, r, i);
  }
  parseObjectData(t, n, r, i) {
    const { iScale: o, vScale: a } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, c = o.axis === "x" ? s : l, u = a.axis === "x" ? s : l, d = [];
    let p, h, g, m;
    for (p = r, h = r + i; p < h; ++p)
      m = n[p], g = {}, g[o.axis] = o.parse(Uo(m, c), p), d.push(sM(Uo(m, u), g, a, p));
    return d;
  }
  updateRangeFromParsed(t, n, r, i) {
    super.updateRangeFromParsed(t, n, r, i);
    const o = r._custom;
    o && n === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, { iScale: r, vScale: i } = n, o = this.getParsed(t), a = o._custom, s = qh(a) ? "[" + a.start + ", " + a.end + "]" : "" + i.getLabelForValue(o[i.axis]);
    return {
      label: "" + r.getLabelForValue(o[r.axis]),
      value: s
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const n = this._cachedMeta;
    this.updateElements(n.data, 0, n.data.length, t);
  }
  updateElements(t, n, r, i) {
    const o = i === "reset", { index: a, _cachedMeta: { vScale: s } } = this, l = s.getBasePixel(), c = s.isHorizontal(), u = this._getRuler(), { sharedOptions: d, includeOptions: p } = this._getSharedOptions(n, i);
    for (let h = n; h < n + r; h++) {
      const g = this.getParsed(h), m = o || We(g[s.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(h), v = this._calculateBarIndexPixels(h, u), y = (g._stacks || {})[s.axis], S = {
        horizontal: c,
        base: m.base,
        enableBorderRadius: !y || qh(g._custom) || a === y._top || a === y._bottom,
        x: c ? m.head : v.center,
        y: c ? v.center : m.head,
        height: c ? v.size : Math.abs(m.size),
        width: c ? Math.abs(m.size) : v.size
      };
      p && (S.options = d || this.resolveDataElementOptions(h, t[h].active ? "active" : i));
      const w = S.options || t[h].options;
      pQ(S, w, y, a), mQ(S, w, u.ratio), this.updateElement(t[h], h, S, i);
    }
  }
  _getStacks(t, n) {
    const { iScale: r } = this._cachedMeta, i = r.getMatchingVisibleMetas(this._type).filter((u) => u.controller.options.grouped), o = r.options.stacked, a = [], s = this._cachedMeta.controller.getParsed(n), l = s && s[r.axis], c = (u) => {
      const d = u._parsed.find((h) => h[r.axis] === l), p = d && d[u.vScale.axis];
      if (We(p) || isNaN(p))
        return !0;
    };
    for (const u of i)
      if (!(n !== void 0 && c(u)) && ((o === !1 || a.indexOf(u.stack) === -1 || o === void 0 && u.stack === void 0) && a.push(u.stack), u.index === t))
        break;
    return a.length || a.push(void 0), a;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales, n = this.chart.options.indexAxis;
    return Object.keys(t).filter((r) => t[r].axis === n).shift();
  }
  _getAxis() {
    const t = {}, n = this.getFirstScaleIdForIndexAxis();
    for (const r of this.chart.data.datasets)
      t[we(this.chart.options.indexAxis === "x" ? r.xAxisID : r.yAxisID, n)] = !0;
    return Object.keys(t);
  }
  _getStackIndex(t, n, r) {
    const i = this._getStacks(t, r), o = n !== void 0 ? i.indexOf(n) : -1;
    return o === -1 ? i.length - 1 : o;
  }
  _getRuler() {
    const t = this.options, n = this._cachedMeta, r = n.iScale, i = [];
    let o, a;
    for (o = 0, a = n.data.length; o < a; ++o)
      i.push(r.getPixelForValue(this.getParsed(o)[r.axis], o));
    const s = t.barThickness;
    return {
      min: s || sQ(n),
      pixels: i,
      start: r._startPixel,
      end: r._endPixel,
      stackCount: this._getStackCount(),
      scale: r,
      grouped: t.grouped,
      ratio: s ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: n, _stacked: r, index: i }, options: { base: o, minBarLength: a } } = this, s = o || 0, l = this.getParsed(t), c = l._custom, u = qh(c);
    let d = l[n.axis], p = 0, h = r ? this.applyStack(n, l, r) : d, g, m;
    h !== d && (p = h - d, h = d), u && (d = c.barStart, h = c.barEnd - c.barStart, d !== 0 && Br(d) !== Br(c.barEnd) && (p = 0), p += d);
    const v = !We(o) && !u ? o : p;
    let y = n.getPixelForValue(v);
    if (this.chart.getDataVisibility(t) ? g = n.getPixelForValue(p + h) : g = y, m = g - y, Math.abs(m) < a) {
      m = dQ(m, n, s) * a, d === s && (y -= m / 2);
      const S = n.getPixelForDecimal(0), w = n.getPixelForDecimal(1), b = Math.min(S, w), O = Math.max(S, w);
      y = Math.max(Math.min(y, O), b), g = y + m, r && !u && (l._stacks[n.axis]._visualValues[i] = n.getValueForPixel(g) - n.getValueForPixel(y));
    }
    if (y === n.getPixelForValue(s)) {
      const S = Br(m) * n.getLineWidthForValue(s) / 2;
      y += S, m -= S;
    }
    return {
      size: m,
      base: y,
      head: g,
      center: g + m / 2
    };
  }
  _calculateBarIndexPixels(t, n) {
    const r = n.scale, i = this.options, o = i.skipNull, a = we(i.maxBarThickness, 1 / 0);
    let s, l;
    const c = this._getAxisCount();
    if (n.grouped) {
      const u = o ? this._getStackCount(t) : n.stackCount, d = i.barThickness === "flex" ? cQ(t, n, i, u * c) : lQ(t, n, i, u * c), p = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, h = this._getAxis().indexOf(we(p, this.getFirstScaleIdForIndexAxis())), g = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0) + h;
      s = d.start + d.chunk * g + d.chunk / 2, l = Math.min(a, d.chunk * d.ratio);
    } else
      s = r.getPixelForValue(this.getParsed(t)[r.axis], t), l = Math.min(a, n.min * n.ratio);
    return {
      base: s - l / 2,
      head: s + l / 2,
      center: s,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, n = t.vScale, r = t.data, i = r.length;
    let o = 0;
    for (; o < i; ++o)
      this.getParsed(o)[n.axis] !== null && !r[o].hidden && r[o].draw(this._ctx);
  }
}
function vQ(e, t, n) {
  let r = 1, i = 1, o = 0, a = 0;
  if (t < Pt) {
    const s = e, l = s + t, c = Math.cos(s), u = Math.sin(s), d = Math.cos(l), p = Math.sin(l), h = (w, b, O) => Pl(w, s, l, !0) ? 1 : Math.max(b, b * n, O, O * n), g = (w, b, O) => Pl(w, s, l, !0) ? -1 : Math.min(b, b * n, O, O * n), m = h(0, c, d), v = h(Bt, u, p), y = g(it, c, d), S = g(it + Bt, u, p);
    r = (m - y) / 2, i = (v - S) / 2, o = -(m + y) / 2, a = -(v + S) / 2;
  }
  return {
    ratioX: r,
    ratioY: i,
    offsetX: o,
    offsetY: a
  };
}
class yQ extends Lf {
  static id = "doughnut";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (t) => t !== "spacing",
    _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const n = t.data;
            if (n.labels.length && n.datasets.length) {
              const { labels: { pointStyle: r, color: i } } = t.legend.options;
              return n.labels.map((o, a) => {
                const l = t.getDatasetMeta(0).controller.getStyle(a);
                return {
                  text: o,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: i,
                  lineWidth: l.borderWidth,
                  pointStyle: r,
                  hidden: !t.getDataVisibility(a),
                  index: a
                };
              });
            }
            return [];
          }
        },
        onClick(t, n, r) {
          r.chart.toggleDataVisibility(n.index), r.chart.update();
        }
      }
    }
  };
  constructor(t, n) {
    super(t, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, n) {
    const r = this.getDataset().data, i = this._cachedMeta;
    if (this._parsing === !1)
      i._parsed = r;
    else {
      let o = (l) => +r[l];
      if (Te(r[t])) {
        const { key: l = "value" } = this._parsing;
        o = (c) => +Uo(r[c], l);
      }
      let a, s;
      for (a = t, s = t + n; a < s; ++a)
        i._parsed[a] = o(a);
    }
  }
  _getRotation() {
    return li(this.options.rotation - 90);
  }
  _getCircumference() {
    return li(this.options.circumference);
  }
  _getRotationExtents() {
    let t = Pt, n = -Pt;
    for (let r = 0; r < this.chart.data.datasets.length; ++r)
      if (this.chart.isDatasetVisible(r) && this.chart.getDatasetMeta(r).type === this._type) {
        const i = this.chart.getDatasetMeta(r).controller, o = i._getRotation(), a = i._getCircumference();
        t = Math.min(t, o), n = Math.max(n, o + a);
      }
    return {
      rotation: t,
      circumference: n - t
    };
  }
  update(t) {
    const n = this.chart, { chartArea: r } = n, i = this._cachedMeta, o = i.data, a = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, s = Math.max((Math.min(r.width, r.height) - a) / 2, 0), l = Math.min(wZ(this.options.cutout, s), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: p, ratioY: h, offsetX: g, offsetY: m } = vQ(d, u, l), v = (r.width - a) / p, y = (r.height - a) / h, S = Math.max(Math.min(v, y) / 2, 0), w = Fk(this.options.radius, S), b = Math.max(w * l, 0), O = (w - b) / this._getVisibleDatasetWeightTotal();
    this.offsetX = g * w, this.offsetY = m * w, i.total = this.calculateTotal(), this.outerRadius = w - O * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - O * c, 0), this.updateElements(o, 0, o.length, t);
  }
  _circumference(t, n) {
    const r = this.options, i = this._cachedMeta, o = this._getCircumference();
    return n && r.animation.animateRotate || !this.chart.getDataVisibility(t) || i._parsed[t] === null || i.data[t].hidden ? 0 : this.calculateCircumference(i._parsed[t] * o / Pt);
  }
  updateElements(t, n, r, i) {
    const o = i === "reset", a = this.chart, s = a.chartArea, c = a.options.animation, u = (s.left + s.right) / 2, d = (s.top + s.bottom) / 2, p = o && c.animateScale, h = p ? 0 : this.innerRadius, g = p ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: v } = this._getSharedOptions(n, i);
    let y = this._getRotation(), S;
    for (S = 0; S < n; ++S)
      y += this._circumference(S, o);
    for (S = n; S < n + r; ++S) {
      const w = this._circumference(S, o), b = t[S], O = {
        x: u + this.offsetX,
        y: d + this.offsetY,
        startAngle: y,
        endAngle: y + w,
        circumference: w,
        outerRadius: g,
        innerRadius: h
      };
      v && (O.options = m || this.resolveDataElementOptions(S, b.active ? "active" : i)), y += w, this.updateElement(b, S, O, i);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, n = t.data;
    let r = 0, i;
    for (i = 0; i < n.length; i++) {
      const o = t._parsed[i];
      o !== null && !isNaN(o) && this.chart.getDataVisibility(i) && !n[i].hidden && (r += Math.abs(o));
    }
    return r;
  }
  calculateCircumference(t) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(t) ? Pt * (Math.abs(t) / n) : 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, r = this.chart, i = r.data.labels || [], o = nb(n._parsed[t], r.options.locale);
    return {
      label: i[t] || "",
      value: o
    };
  }
  getMaxBorderWidth(t) {
    let n = 0;
    const r = this.chart;
    let i, o, a, s, l;
    if (!t) {
      for (i = 0, o = r.data.datasets.length; i < o; ++i)
        if (r.isDatasetVisible(i)) {
          a = r.getDatasetMeta(i), t = a.data, s = a.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (i = 0, o = t.length; i < o; ++i)
      l = s.resolveDataElementOptions(i), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(t) {
    let n = 0;
    for (let r = 0, i = t.length; r < i; ++r) {
      const o = this.resolveDataElementOptions(r);
      n = Math.max(n, o.offset || 0, o.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(t) {
    let n = 0;
    for (let r = 0; r < t; ++r)
      this.chart.isDatasetVisible(r) && (n += this._getRingWeight(r));
    return n;
  }
  _getRingWeight(t) {
    return Math.max(we(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
class bQ extends Lf {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const n = this._cachedMeta, { dataset: r, data: i = [], _dataset: o } = n, a = this.chart._animationsDisabled;
    let { start: s, count: l } = zZ(n, i, a);
    this._drawStart = s, this._drawCount = l, WZ(n) && (s = 0, l = i.length), r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!o._decimated, r.points = i;
    const c = this.resolveDatasetElementOptions(t);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(r, void 0, {
      animated: !a,
      options: c
    }, t), this.updateElements(i, s, l, t);
  }
  updateElements(t, n, r, i) {
    const o = i === "reset", { iScale: a, vScale: s, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, i), p = a.axis, h = s.axis, { spanGaps: g, segment: m } = this.options, v = _l(g) ? g : Number.POSITIVE_INFINITY, y = this.chart._animationsDisabled || o || i === "none", S = n + r, w = t.length;
    let b = n > 0 && this.getParsed(n - 1);
    for (let O = 0; O < w; ++O) {
      const E = t[O], C = y ? E : {};
      if (O < n || O >= S) {
        C.skip = !0;
        continue;
      }
      const T = this.getParsed(O), j = We(T[h]), A = C[p] = a.getPixelForValue(T[p], O), M = C[h] = o || j ? s.getBasePixel() : s.getPixelForValue(l ? this.applyStack(s, T, l) : T[h], O);
      C.skip = isNaN(A) || isNaN(M) || j, C.stop = O > 0 && Math.abs(T[p] - b[p]) > v, m && (C.parsed = T, C.raw = c.data[O]), d && (C.options = u || this.resolveDataElementOptions(O, E.active ? "active" : i)), y || this.updateElement(E, O, C, i), b = T;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, n = t.dataset, r = n.options && n.options.borderWidth || 0, i = t.data || [];
    if (!i.length)
      return r;
    const o = i[0].size(this.resolveDataElementOptions(0)), a = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
    return Math.max(r, o, a) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
function po() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class db {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(db.prototype, t);
  }
  options;
  constructor(t) {
    this.options = t || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return po();
  }
  parse() {
    return po();
  }
  format() {
    return po();
  }
  add() {
    return po();
  }
  diff() {
    return po();
  }
  startOf() {
    return po();
  }
  endOf() {
    return po();
  }
}
var xQ = {
  _date: db
};
function wQ(e, t, n, r) {
  const { controller: i, data: o, _sorted: a } = e, s = i._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (s && t === s.axis && t !== "r" && a && o.length) {
    const c = s._reversePixels ? IZ : To;
    if (r) {
      if (i._sharedOptions) {
        const u = o[0], d = typeof u.getRange == "function" && u.getRange(t);
        if (d) {
          const p = c(o, t, n - d), h = c(o, t, n + d);
          return {
            lo: p.lo,
            hi: h.hi
          };
        }
      }
    } else {
      const u = c(o, t, n);
      if (l) {
        const { vScale: d } = i._cachedMeta, { _parsed: p } = e, h = p.slice(0, u.lo + 1).reverse().findIndex((m) => !We(m[d.axis]));
        u.lo -= Math.max(0, h);
        const g = p.slice(u.hi).findIndex((m) => !We(m[d.axis]));
        u.hi += Math.max(0, g);
      }
      return u;
    }
  }
  return {
    lo: 0,
    hi: o.length - 1
  };
}
function Ff(e, t, n, r, i) {
  const o = e.getSortedVisibleDatasetMetas(), a = n[t];
  for (let s = 0, l = o.length; s < l; ++s) {
    const { index: c, data: u } = o[s], { lo: d, hi: p } = wQ(o[s], t, a, i);
    for (let h = d; h <= p; ++h) {
      const g = u[h];
      g.skip || r(g, c, h);
    }
  }
}
function OQ(e) {
  const t = e.indexOf("x") !== -1, n = e.indexOf("y") !== -1;
  return function(r, i) {
    const o = t ? Math.abs(r.x - i.x) : 0, a = n ? Math.abs(r.y - i.y) : 0;
    return Math.sqrt(Math.pow(o, 2) + Math.pow(a, 2));
  };
}
function Kh(e, t, n, r, i) {
  const o = [];
  return !i && !e.isPointInArea(t) || Ff(e, n, t, function(s, l, c) {
    !i && !Cl(s, e.chartArea, 0) || s.inRange(t.x, t.y, r) && o.push({
      element: s,
      datasetIndex: l,
      index: c
    });
  }, !0), o;
}
function SQ(e, t, n, r) {
  let i = [];
  function o(a, s, l) {
    const { startAngle: c, endAngle: u } = a.getProps([
      "startAngle",
      "endAngle"
    ], r), { angle: d } = Wk(a, {
      x: t.x,
      y: t.y
    });
    Pl(d, c, u) && i.push({
      element: a,
      datasetIndex: s,
      index: l
    });
  }
  return Ff(e, n, t, o), i;
}
function EQ(e, t, n, r, i, o) {
  let a = [];
  const s = OQ(n);
  let l = Number.POSITIVE_INFINITY;
  function c(u, d, p) {
    const h = u.inRange(t.x, t.y, i);
    if (r && !h)
      return;
    const g = u.getCenterPoint(i);
    if (!(!!o || e.isPointInArea(g)) && !h)
      return;
    const v = s(t, g);
    v < l ? (a = [
      {
        element: u,
        datasetIndex: d,
        index: p
      }
    ], l = v) : v === l && a.push({
      element: u,
      datasetIndex: d,
      index: p
    });
  }
  return Ff(e, n, t, c), a;
}
function Yh(e, t, n, r, i, o) {
  return !o && !e.isPointInArea(t) ? [] : n === "r" && !r ? SQ(e, t, n, i) : EQ(e, t, n, r, i, o);
}
function GS(e, t, n, r, i) {
  const o = [], a = n === "x" ? "inXRange" : "inYRange";
  let s = !1;
  return Ff(e, n, t, (l, c, u) => {
    l[a] && l[a](t[n], i) && (o.push({
      element: l,
      datasetIndex: c,
      index: u
    }), s = s || l.inRange(t.x, t.y, i));
  }), r && !s ? [] : o;
}
var _Q = {
  modes: {
    index(e, t, n, r) {
      const i = xo(t, e), o = n.axis || "x", a = n.includeInvisible || !1, s = n.intersect ? Kh(e, i, o, r, a) : Yh(e, i, o, !1, r, a), l = [];
      return s.length ? (e.getSortedVisibleDatasetMetas().forEach((c) => {
        const u = s[0].index, d = c.data[u];
        d && !d.skip && l.push({
          element: d,
          datasetIndex: c.index,
          index: u
        });
      }), l) : [];
    },
    dataset(e, t, n, r) {
      const i = xo(t, e), o = n.axis || "xy", a = n.includeInvisible || !1;
      let s = n.intersect ? Kh(e, i, o, r, a) : Yh(e, i, o, !1, r, a);
      if (s.length > 0) {
        const l = s[0].datasetIndex, c = e.getDatasetMeta(l).data;
        s = [];
        for (let u = 0; u < c.length; ++u)
          s.push({
            element: c[u],
            datasetIndex: l,
            index: u
          });
      }
      return s;
    },
    point(e, t, n, r) {
      const i = xo(t, e), o = n.axis || "xy", a = n.includeInvisible || !1;
      return Kh(e, i, o, r, a);
    },
    nearest(e, t, n, r) {
      const i = xo(t, e), o = n.axis || "xy", a = n.includeInvisible || !1;
      return Yh(e, i, o, n.intersect, r, a);
    },
    x(e, t, n, r) {
      const i = xo(t, e);
      return GS(e, i, "x", n.intersect, r);
    },
    y(e, t, n, r) {
      const i = xo(t, e);
      return GS(e, i, "y", n.intersect, r);
    }
  }
};
const lM = [
  "left",
  "top",
  "right",
  "bottom"
];
function _s(e, t) {
  return e.filter((n) => n.pos === t);
}
function XS(e, t) {
  return e.filter((n) => lM.indexOf(n.pos) === -1 && n.box.axis === t);
}
function Ps(e, t) {
  return e.sort((n, r) => {
    const i = t ? r : n, o = t ? n : r;
    return i.weight === o.weight ? i.index - o.index : i.weight - o.weight;
  });
}
function PQ(e) {
  const t = [];
  let n, r, i, o, a, s;
  for (n = 0, r = (e || []).length; n < r; ++n)
    i = e[n], { position: o, options: { stack: a, stackWeight: s = 1 } } = i, t.push({
      index: n,
      box: i,
      pos: o,
      horizontal: i.isHorizontal(),
      weight: i.weight,
      stack: a && o + a,
      stackWeight: s
    });
  return t;
}
function CQ(e) {
  const t = {};
  for (const n of e) {
    const { stack: r, pos: i, stackWeight: o } = n;
    if (!r || !lM.includes(i))
      continue;
    const a = t[r] || (t[r] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    a.count++, a.weight += o;
  }
  return t;
}
function TQ(e, t) {
  const n = CQ(e), { vBoxMaxWidth: r, hBoxMaxHeight: i } = t;
  let o, a, s;
  for (o = 0, a = e.length; o < a; ++o) {
    s = e[o];
    const { fullSize: l } = s.box, c = n[s.stack], u = c && s.stackWeight / c.weight;
    s.horizontal ? (s.width = u ? u * r : l && t.availableWidth, s.height = i) : (s.width = r, s.height = u ? u * i : l && t.availableHeight);
  }
  return n;
}
function AQ(e) {
  const t = PQ(e), n = Ps(t.filter((c) => c.box.fullSize), !0), r = Ps(_s(t, "left"), !0), i = Ps(_s(t, "right")), o = Ps(_s(t, "top"), !0), a = Ps(_s(t, "bottom")), s = XS(t, "x"), l = XS(t, "y");
  return {
    fullSize: n,
    leftAndTop: r.concat(o),
    rightAndBottom: i.concat(l).concat(a).concat(s),
    chartArea: _s(t, "chartArea"),
    vertical: r.concat(i).concat(l),
    horizontal: o.concat(a).concat(s)
  };
}
function ZS(e, t, n, r) {
  return Math.max(e[n], t[n]) + Math.max(e[r], t[r]);
}
function cM(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function kQ(e, t, n, r) {
  const { pos: i, box: o } = n, a = e.maxPadding;
  if (!Te(i)) {
    n.size && (e[i] -= n.size);
    const d = r[n.stack] || {
      size: 0,
      count: 1
    };
    d.size = Math.max(d.size, n.horizontal ? o.height : o.width), n.size = d.size / d.count, e[i] += n.size;
  }
  o.getPadding && cM(a, o.getPadding());
  const s = Math.max(0, t.outerWidth - ZS(a, e, "left", "right")), l = Math.max(0, t.outerHeight - ZS(a, e, "top", "bottom")), c = s !== e.w, u = l !== e.h;
  return e.w = s, e.h = l, n.horizontal ? {
    same: c,
    other: u
  } : {
    same: u,
    other: c
  };
}
function MQ(e) {
  const t = e.maxPadding;
  function n(r) {
    const i = Math.max(t[r] - e[r], 0);
    return e[r] += i, i;
  }
  e.y += n("top"), e.x += n("left"), n("right"), n("bottom");
}
function jQ(e, t) {
  const n = t.maxPadding;
  function r(i) {
    const o = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return i.forEach((a) => {
      o[a] = Math.max(t[a], n[a]);
    }), o;
  }
  return r(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Fs(e, t, n, r) {
  const i = [];
  let o, a, s, l, c, u;
  for (o = 0, a = e.length, c = 0; o < a; ++o) {
    s = e[o], l = s.box, l.update(s.width || t.w, s.height || t.h, jQ(s.horizontal, t));
    const { same: d, other: p } = kQ(t, n, s, r);
    c |= d && i.length, u = u || p, l.fullSize || i.push(s);
  }
  return c && Fs(i, t, n, r) || u;
}
function Zc(e, t, n, r, i) {
  e.top = n, e.left = t, e.right = t + r, e.bottom = n + i, e.width = r, e.height = i;
}
function JS(e, t, n, r) {
  const i = n.padding;
  let { x: o, y: a } = t;
  for (const s of e) {
    const l = s.box, c = r[s.stack] || {
      placed: 0,
      weight: 1
    }, u = s.stackWeight / c.weight || 1;
    if (s.horizontal) {
      const d = t.w * u, p = c.size || l.height;
      El(c.start) && (a = c.start), l.fullSize ? Zc(l, i.left, a, n.outerWidth - i.right - i.left, p) : Zc(l, t.left + c.placed, a, d, p), c.start = a, c.placed += d, a = l.bottom;
    } else {
      const d = t.h * u, p = c.size || l.width;
      El(c.start) && (o = c.start), l.fullSize ? Zc(l, o, i.top, p, n.outerHeight - i.bottom - i.top) : Zc(l, o, t.top + c.placed, p, d), c.start = o, c.placed += d, o = l.right;
    }
  }
  t.x = o, t.y = a;
}
var Ri = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            t.draw(n);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const n = e.boxes ? e.boxes.indexOf(t) : -1;
    n !== -1 && e.boxes.splice(n, 1);
  },
  configure(e, t, n) {
    t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight;
  },
  update(e, t, n, r) {
    if (!e)
      return;
    const i = Or(e.options.layout.padding), o = Math.max(t - i.width, 0), a = Math.max(n - i.height, 0), s = AQ(e.boxes), l = s.vertical, c = s.horizontal;
    He(e.boxes, (m) => {
      typeof m.beforeLayout == "function" && m.beforeLayout();
    });
    const u = l.reduce((m, v) => v.box.options && v.box.options.display === !1 ? m : m + 1, 0) || 1, d = Object.freeze({
      outerWidth: t,
      outerHeight: n,
      padding: i,
      availableWidth: o,
      availableHeight: a,
      vBoxMaxWidth: o / 2 / u,
      hBoxMaxHeight: a / 2
    }), p = Object.assign({}, i);
    cM(p, Or(r));
    const h = Object.assign({
      maxPadding: p,
      w: o,
      h: a,
      x: i.left,
      y: i.top
    }, i), g = TQ(l.concat(c), d);
    Fs(s.fullSize, h, d, g), Fs(l, h, d, g), Fs(c, h, d, g) && Fs(l, h, d, g), MQ(h), JS(s.leftAndTop, h, d, g), h.x += h.w, h.y += h.h, JS(s.rightAndBottom, h, d, g), e.chartArea = {
      left: h.left,
      top: h.top,
      right: h.left + h.w,
      bottom: h.top + h.h,
      height: h.h,
      width: h.w
    }, He(s.chartArea, (m) => {
      const v = m.box;
      Object.assign(v, e.chartArea), v.update(h.w, h.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class uM {
  acquireContext(t, n) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, n, r) {
  }
  removeEventListener(t, n, r) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, n, r, i) {
    return n = Math.max(0, n || t.width), r = r || t.height, {
      width: n,
      height: Math.max(0, i ? Math.floor(n / i) : r)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class NQ extends uM {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const pu = "$chartjs", DQ = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, QS = (e) => e === null || e === "";
function RQ(e, t) {
  const n = e.style, r = e.getAttribute("height"), i = e.getAttribute("width");
  if (e[pu] = {
    initial: {
      height: r,
      width: i,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", QS(i)) {
    const o = IS(e, "width");
    o !== void 0 && (e.width = o);
  }
  if (QS(r))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const o = IS(e, "height");
      o !== void 0 && (e.height = o);
    }
  return e;
}
const dM = MJ ? {
  passive: !0
} : !1;
function IQ(e, t, n) {
  e && e.addEventListener(t, n, dM);
}
function $Q(e, t, n) {
  e && e.canvas && e.canvas.removeEventListener(t, n, dM);
}
function LQ(e, t) {
  const n = DQ[e.type] || e.type, { x: r, y: i } = xo(e, t);
  return {
    type: n,
    chart: t,
    native: e,
    x: r !== void 0 ? r : null,
    y: i !== void 0 ? i : null
  };
}
function Sd(e, t) {
  for (const n of e)
    if (n === t || n.contains(t))
      return !0;
}
function FQ(e, t, n) {
  const r = e.canvas, i = new MutationObserver((o) => {
    let a = !1;
    for (const s of o)
      a = a || Sd(s.addedNodes, r), a = a && !Sd(s.removedNodes, r);
    a && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
function BQ(e, t, n) {
  const r = e.canvas, i = new MutationObserver((o) => {
    let a = !1;
    for (const s of o)
      a = a || Sd(s.removedNodes, r), a = a && !Sd(s.addedNodes, r);
    a && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
const Tl = /* @__PURE__ */ new Map();
let eE = 0;
function fM() {
  const e = window.devicePixelRatio;
  e !== eE && (eE = e, Tl.forEach((t, n) => {
    n.currentDevicePixelRatio !== e && t();
  }));
}
function zQ(e, t) {
  Tl.size || window.addEventListener("resize", fM), Tl.set(e, t);
}
function WQ(e) {
  Tl.delete(e), Tl.size || window.removeEventListener("resize", fM);
}
function VQ(e, t, n) {
  const r = e.canvas, i = r && ub(r);
  if (!i)
    return;
  const o = qk((s, l) => {
    const c = i.clientWidth;
    n(s, l), c < i.clientWidth && n();
  }, window), a = new ResizeObserver((s) => {
    const l = s[0], c = l.contentRect.width, u = l.contentRect.height;
    c === 0 && u === 0 || o(c, u);
  });
  return a.observe(i), zQ(e, o), a;
}
function Gh(e, t, n) {
  n && n.disconnect(), t === "resize" && WQ(e);
}
function UQ(e, t, n) {
  const r = e.canvas, i = qk((o) => {
    e.ctx !== null && n(LQ(o, e));
  }, e);
  return IQ(r, t, i), i;
}
class HQ extends uM {
  acquireContext(t, n) {
    const r = t && t.getContext && t.getContext("2d");
    return r && r.canvas === t ? (RQ(t, n), r) : null;
  }
  releaseContext(t) {
    const n = t.canvas;
    if (!n[pu])
      return !1;
    const r = n[pu].initial;
    [
      "height",
      "width"
    ].forEach((o) => {
      const a = r[o];
      We(a) ? n.removeAttribute(o) : n.setAttribute(o, a);
    });
    const i = r.style || {};
    return Object.keys(i).forEach((o) => {
      n.style[o] = i[o];
    }), n.width = n.width, delete n[pu], !0;
  }
  addEventListener(t, n, r) {
    this.removeEventListener(t, n);
    const i = t.$proxies || (t.$proxies = {}), a = {
      attach: FQ,
      detach: BQ,
      resize: VQ
    }[n] || UQ;
    i[n] = a(t, n, r);
  }
  removeEventListener(t, n) {
    const r = t.$proxies || (t.$proxies = {}), i = r[n];
    if (!i)
      return;
    ({
      attach: Gh,
      detach: Gh,
      resize: Gh
    }[n] || $Q)(t, n, i), r[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, n, r, i) {
    return kJ(t, n, r, i);
  }
  isAttached(t) {
    const n = t && ub(t);
    return !!(n && n.isConnected);
  }
}
function qQ(e) {
  return !cb() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? NQ : HQ;
}
let no = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(t) {
    const { x: n, y: r } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: r
    };
  }
  hasValue() {
    return _l(this.x) && _l(this.y);
  }
  getProps(t, n) {
    const r = this.$animations;
    if (!n || !r)
      return this;
    const i = {};
    return t.forEach((o) => {
      i[o] = r[o] && r[o].active() ? r[o]._to : this[o];
    }), i;
  }
};
function KQ(e, t) {
  const n = e.options.ticks, r = YQ(e), i = Math.min(n.maxTicksLimit || r, r), o = n.major.enabled ? XQ(t) : [], a = o.length, s = o[0], l = o[a - 1], c = [];
  if (a > i)
    return ZQ(t, c, o, a / i), c;
  const u = GQ(o, t, i);
  if (a > 0) {
    let d, p;
    const h = a > 1 ? Math.round((l - s) / (a - 1)) : null;
    for (Jc(t, c, u, We(h) ? 0 : s - h, s), d = 0, p = a - 1; d < p; d++)
      Jc(t, c, u, o[d], o[d + 1]);
    return Jc(t, c, u, l, We(h) ? t.length : l + h), c;
  }
  return Jc(t, c, u), c;
}
function YQ(e) {
  const t = e.options.offset, n = e._tickSize(), r = e._length / n + (t ? 0 : 1), i = e._maxLength / n;
  return Math.floor(Math.min(r, i));
}
function GQ(e, t, n) {
  const r = JQ(e), i = t.length / n;
  if (!r)
    return Math.max(i, 1);
  const o = AZ(r);
  for (let a = 0, s = o.length - 1; a < s; a++) {
    const l = o[a];
    if (l > i)
      return l;
  }
  return Math.max(i, 1);
}
function XQ(e) {
  const t = [];
  let n, r;
  for (n = 0, r = e.length; n < r; n++)
    e[n].major && t.push(n);
  return t;
}
function ZQ(e, t, n, r) {
  let i = 0, o = n[0], a;
  for (r = Math.ceil(r), a = 0; a < e.length; a++)
    a === o && (t.push(e[a]), i++, o = n[i * r]);
}
function Jc(e, t, n, r, i) {
  const o = we(r, 0), a = Math.min(we(i, e.length), e.length);
  let s = 0, l, c, u;
  for (n = Math.ceil(n), i && (l = i - r, n = l / Math.floor(l / n)), u = o; u < 0; )
    s++, u = Math.round(o + s * n);
  for (c = Math.max(o, 0); c < a; c++)
    c === u && (t.push(e[c]), s++, u = Math.round(o + s * n));
}
function JQ(e) {
  const t = e.length;
  let n, r;
  if (t < 2)
    return !1;
  for (r = e[0], n = 1; n < t; ++n)
    if (e[n] - e[n - 1] !== r)
      return !1;
  return r;
}
const QQ = (e) => e === "left" ? "right" : e === "right" ? "left" : e, tE = (e, t, n) => t === "top" || t === "left" ? e[t] + n : e[t] - n, nE = (e, t) => Math.min(t || e, e);
function rE(e, t) {
  const n = [], r = e.length / t, i = e.length;
  let o = 0;
  for (; o < i; o += r)
    n.push(e[Math.floor(o)]);
  return n;
}
function eee(e, t, n) {
  const r = e.ticks.length, i = Math.min(t, r - 1), o = e._startPixel, a = e._endPixel, s = 1e-6;
  let l = e.getPixelForTick(i), c;
  if (!(n && (r === 1 ? c = Math.max(l - o, a - l) : t === 0 ? c = (e.getPixelForTick(1) - l) / 2 : c = (l - e.getPixelForTick(i - 1)) / 2, l += i < t ? c : -c, l < o - s || l > a + s)))
    return l;
}
function tee(e, t) {
  He(e, (n) => {
    const r = n.gc, i = r.length / 2;
    let o;
    if (i > t) {
      for (o = 0; o < i; ++o)
        delete n.data[r[o]];
      r.splice(0, i);
    }
  });
}
function Cs(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function iE(e, t) {
  if (!e.display)
    return 0;
  const n = An(e.font, t), r = Or(e.padding);
  return (Kt(e.text) ? e.text.length : 1) * n.lineHeight + r.height;
}
function nee(e, t) {
  return Qo(e, {
    scale: t,
    type: "scale"
  });
}
function ree(e, t, n) {
  return Qo(e, {
    tick: n,
    index: t,
    type: "tick"
  });
}
function iee(e, t, n) {
  let r = Kk(e);
  return (n && t !== "right" || !n && t === "right") && (r = QQ(r)), r;
}
function oee(e, t, n, r) {
  const { top: i, left: o, bottom: a, right: s, chart: l } = e, { chartArea: c, scales: u } = l;
  let d = 0, p, h, g;
  const m = a - i, v = s - o;
  if (e.isHorizontal()) {
    if (h = $n(r, o, s), Te(n)) {
      const y = Object.keys(n)[0], S = n[y];
      g = u[y].getPixelForValue(S) + m - t;
    } else n === "center" ? g = (c.bottom + c.top) / 2 + m - t : g = tE(e, n, t);
    p = s - o;
  } else {
    if (Te(n)) {
      const y = Object.keys(n)[0], S = n[y];
      h = u[y].getPixelForValue(S) - v + t;
    } else n === "center" ? h = (c.left + c.right) / 2 - v + t : h = tE(e, n, t);
    g = $n(r, a, i), d = n === "left" ? -Bt : Bt;
  }
  return {
    titleX: h,
    titleY: g,
    maxWidth: p,
    rotation: d
  };
}
class os extends no {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, n) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this;
    return t = Ar(t, Number.POSITIVE_INFINITY), n = Ar(n, Number.NEGATIVE_INFINITY), r = Ar(r, Number.POSITIVE_INFINITY), i = Ar(i, Number.NEGATIVE_INFINITY), {
      min: Ar(t, r),
      max: Ar(n, i),
      minDefined: mr(t),
      maxDefined: mr(n)
    };
  }
  getMinMax(t) {
    let { min: n, max: r, minDefined: i, maxDefined: o } = this.getUserBounds(), a;
    if (i && o)
      return {
        min: n,
        max: r
      };
    const s = this.getMatchingVisibleMetas();
    for (let l = 0, c = s.length; l < c; ++l)
      a = s[l].controller.getMinMax(this, t), i || (n = Math.min(n, a.min)), o || (r = Math.max(r, a.max));
    return n = o && n > r ? r : n, r = i && n > r ? n : r, {
      min: Ar(n, Ar(r, n)),
      max: Ar(r, Ar(n, r))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    ut(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, n, r) {
    const { beginAtZero: i, grace: o, ticks: a } = this.options, s = a.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = n, this._margins = r = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = lJ(this, o, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = s < this.ticks.length;
    this._convertTicksToLabels(l ? rE(this.ticks, s) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a.display && (a.autoSkip || a.source === "auto") && (this.ticks = KQ(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, n, r;
    this.isHorizontal() ? (n = this.left, r = this.right) : (n = this.top, r = this.bottom, t = !t), this._startPixel = n, this._endPixel = r, this._reversePixels = t, this._length = r - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    ut(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    ut(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    ut(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), ut(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    ut(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const n = this.options.ticks;
    let r, i, o;
    for (r = 0, i = t.length; r < i; r++)
      o = t[r], o.label = ut(n.callback, [
        o.value,
        r,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    ut(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    ut(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, n = t.ticks, r = nE(this.ticks.length, t.ticks.maxTicksLimit), i = n.minRotation || 0, o = n.maxRotation;
    let a = i, s, l, c;
    if (!this._isVisible() || !n.display || i >= o || r <= 1 || !this.isHorizontal()) {
      this.labelRotation = i;
      return;
    }
    const u = this._getLabelSizes(), d = u.widest.width, p = u.highest.height, h = fn(this.chart.width - d, 0, this.maxWidth);
    s = t.offset ? this.maxWidth / r : h / (r - 1), d + 6 > s && (s = h / (r - (t.offset ? 0.5 : 1)), l = this.maxHeight - Cs(t.grid) - n.padding - iE(t.title, this.chart.options.font), c = Math.sqrt(d * d + p * p), a = NZ(Math.min(Math.asin(fn((u.highest.height + 6) / s, -1, 1)), Math.asin(fn(l / c, -1, 1)) - Math.asin(fn(p / c, -1, 1)))), a = Math.max(i, Math.min(o, a))), this.labelRotation = a;
  }
  afterCalculateLabelRotation() {
    ut(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    ut(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: r, title: i, grid: o } } = this, a = this._isVisible(), s = this.isHorizontal();
    if (a) {
      const l = iE(i, n.options.font);
      if (s ? (t.width = this.maxWidth, t.height = Cs(o) + l) : (t.height = this.maxHeight, t.width = Cs(o) + l), r.display && this.ticks.length) {
        const { first: c, last: u, widest: d, highest: p } = this._getLabelSizes(), h = r.padding * 2, g = li(this.labelRotation), m = Math.cos(g), v = Math.sin(g);
        if (s) {
          const y = r.mirror ? 0 : v * d.width + m * p.height;
          t.height = Math.min(this.maxHeight, t.height + y + h);
        } else {
          const y = r.mirror ? 0 : m * d.width + v * p.height;
          t.width = Math.min(this.maxWidth, t.width + y + h);
        }
        this._calculatePadding(c, u, v, m);
      }
    }
    this._handleMargins(), s ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, n, r, i) {
    const { ticks: { align: o, padding: a }, position: s } = this.options, l = this.labelRotation !== 0, c = s !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let p = 0, h = 0;
      l ? c ? (p = i * t.width, h = r * n.height) : (p = r * t.height, h = i * n.width) : o === "start" ? h = n.width : o === "end" ? p = t.width : o !== "inner" && (p = t.width / 2, h = n.width / 2), this.paddingLeft = Math.max((p - u + a) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h - d + a) * this.width / (this.width - d), 0);
    } else {
      let u = n.height / 2, d = t.height / 2;
      o === "start" ? (u = 0, d = t.height) : o === "end" && (u = n.height, d = 0), this.paddingTop = u + a, this.paddingBottom = d + a;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    ut(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: n } = this.options;
    return n === "top" || n === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let n, r;
    for (n = 0, r = t.length; n < r; n++)
      We(t[n].label) && (t.splice(n, 1), r--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const n = this.options.ticks.sampleSize;
      let r = this.ticks;
      n < r.length && (r = rE(r, n)), this._labelSizes = t = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, n, r) {
    const { ctx: i, _longestTextCache: o } = this, a = [], s = [], l = Math.floor(n / nE(n, r));
    let c = 0, u = 0, d, p, h, g, m, v, y, S, w, b, O;
    for (d = 0; d < n; d += l) {
      if (g = t[d].label, m = this._resolveTickFontOptions(d), i.font = v = m.string, y = o[v] = o[v] || {
        data: {},
        gc: []
      }, S = m.lineHeight, w = b = 0, !We(g) && !Kt(g))
        w = MS(i, y.data, y.gc, w, g), b = S;
      else if (Kt(g))
        for (p = 0, h = g.length; p < h; ++p)
          O = g[p], !We(O) && !Kt(O) && (w = MS(i, y.data, y.gc, w, O), b += S);
      a.push(w), s.push(b), c = Math.max(w, c), u = Math.max(b, u);
    }
    tee(o, n);
    const E = a.indexOf(c), C = s.indexOf(u), T = (j) => ({
      width: a[j] || 0,
      height: s[j] || 0
    });
    return {
      first: T(0),
      last: T(n - 1),
      widest: T(E),
      highest: T(C),
      widths: a,
      heights: s
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, n) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const n = this._startPixel + t * this._length;
    return RZ(this._alignToPixels ? fo(this.chart, n, 0) : n);
  }
  getDecimalForPixel(t) {
    const n = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: n } = this;
    return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0;
  }
  getContext(t) {
    const n = this.ticks || [];
    if (t >= 0 && t < n.length) {
      const r = n[t];
      return r.$context || (r.$context = ree(this.getContext(), t, r));
    }
    return this.$context || (this.$context = nee(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, n = li(this.labelRotation), r = Math.abs(Math.cos(n)), i = Math.abs(Math.sin(n)), o = this._getLabelSizes(), a = t.autoSkipPadding || 0, s = o ? o.widest.width + a : 0, l = o ? o.highest.height + a : 0;
    return this.isHorizontal() ? l * r > s * i ? s / r : l / i : l * i < s * r ? l / r : s / i;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const n = this.axis, r = this.chart, i = this.options, { grid: o, position: a, border: s } = i, l = o.offset, c = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), p = Cs(o), h = [], g = s.setContext(this.getContext()), m = g.display ? g.width : 0, v = m / 2, y = function($) {
      return fo(r, $, m);
    };
    let S, w, b, O, E, C, T, j, A, M, P, R;
    if (a === "top")
      S = y(this.bottom), C = this.bottom - p, j = S - v, M = y(t.top) + v, R = t.bottom;
    else if (a === "bottom")
      S = y(this.top), M = t.top, R = y(t.bottom) - v, C = S + v, j = this.top + p;
    else if (a === "left")
      S = y(this.right), E = this.right - p, T = S - v, A = y(t.left) + v, P = t.right;
    else if (a === "right")
      S = y(this.left), A = t.left, P = y(t.right) - v, E = S + v, T = this.left + p;
    else if (n === "x") {
      if (a === "center")
        S = y((t.top + t.bottom) / 2 + 0.5);
      else if (Te(a)) {
        const $ = Object.keys(a)[0], F = a[$];
        S = y(this.chart.scales[$].getPixelForValue(F));
      }
      M = t.top, R = t.bottom, C = S + v, j = C + p;
    } else if (n === "y") {
      if (a === "center")
        S = y((t.left + t.right) / 2);
      else if (Te(a)) {
        const $ = Object.keys(a)[0], F = a[$];
        S = y(this.chart.scales[$].getPixelForValue(F));
      }
      E = S - v, T = E - p, A = t.left, P = t.right;
    }
    const N = we(i.ticks.maxTicksLimit, d), D = Math.max(1, Math.ceil(d / N));
    for (w = 0; w < d; w += D) {
      const $ = this.getContext(w), F = o.setContext($), q = s.setContext($), B = F.lineWidth, L = F.color, Y = q.dash || [], K = q.dashOffset, te = F.tickWidth, J = F.tickColor, G = F.tickBorderDash || [], ee = F.tickBorderDashOffset;
      b = eee(this, w, l), b !== void 0 && (O = fo(r, b, B), c ? E = T = A = P = O : C = j = M = R = O, h.push({
        tx1: E,
        ty1: C,
        tx2: T,
        ty2: j,
        x1: A,
        y1: M,
        x2: P,
        y2: R,
        width: B,
        color: L,
        borderDash: Y,
        borderDashOffset: K,
        tickWidth: te,
        tickColor: J,
        tickBorderDash: G,
        tickBorderDashOffset: ee
      }));
    }
    return this._ticksLength = d, this._borderValue = S, h;
  }
  _computeLabelItems(t) {
    const n = this.axis, r = this.options, { position: i, ticks: o } = r, a = this.isHorizontal(), s = this.ticks, { align: l, crossAlign: c, padding: u, mirror: d } = o, p = Cs(r.grid), h = p + u, g = d ? -u : h, m = -li(this.labelRotation), v = [];
    let y, S, w, b, O, E, C, T, j, A, M, P, R = "middle";
    if (i === "top")
      E = this.bottom - g, C = this._getXAxisLabelAlignment();
    else if (i === "bottom")
      E = this.top + g, C = this._getXAxisLabelAlignment();
    else if (i === "left") {
      const D = this._getYAxisLabelAlignment(p);
      C = D.textAlign, O = D.x;
    } else if (i === "right") {
      const D = this._getYAxisLabelAlignment(p);
      C = D.textAlign, O = D.x;
    } else if (n === "x") {
      if (i === "center")
        E = (t.top + t.bottom) / 2 + h;
      else if (Te(i)) {
        const D = Object.keys(i)[0], $ = i[D];
        E = this.chart.scales[D].getPixelForValue($) + h;
      }
      C = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (i === "center")
        O = (t.left + t.right) / 2 - h;
      else if (Te(i)) {
        const D = Object.keys(i)[0], $ = i[D];
        O = this.chart.scales[D].getPixelForValue($);
      }
      C = this._getYAxisLabelAlignment(p).textAlign;
    }
    n === "y" && (l === "start" ? R = "top" : l === "end" && (R = "bottom"));
    const N = this._getLabelSizes();
    for (y = 0, S = s.length; y < S; ++y) {
      w = s[y], b = w.label;
      const D = o.setContext(this.getContext(y));
      T = this.getPixelForTick(y) + o.labelOffset, j = this._resolveTickFontOptions(y), A = j.lineHeight, M = Kt(b) ? b.length : 1;
      const $ = M / 2, F = D.color, q = D.textStrokeColor, B = D.textStrokeWidth;
      let L = C;
      a ? (O = T, C === "inner" && (y === S - 1 ? L = this.options.reverse ? "left" : "right" : y === 0 ? L = this.options.reverse ? "right" : "left" : L = "center"), i === "top" ? c === "near" || m !== 0 ? P = -M * A + A / 2 : c === "center" ? P = -N.highest.height / 2 - $ * A + A : P = -N.highest.height + A / 2 : c === "near" || m !== 0 ? P = A / 2 : c === "center" ? P = N.highest.height / 2 - $ * A : P = N.highest.height - M * A, d && (P *= -1), m !== 0 && !D.showLabelBackdrop && (O += A / 2 * Math.sin(m))) : (E = T, P = (1 - M) * A / 2);
      let Y;
      if (D.showLabelBackdrop) {
        const K = Or(D.backdropPadding), te = N.heights[y], J = N.widths[y];
        let G = P - K.top, ee = 0 - K.left;
        switch (R) {
          case "middle":
            G -= te / 2;
            break;
          case "bottom":
            G -= te;
            break;
        }
        switch (C) {
          case "center":
            ee -= J / 2;
            break;
          case "right":
            ee -= J;
            break;
          case "inner":
            y === S - 1 ? ee -= J : y > 0 && (ee -= J / 2);
            break;
        }
        Y = {
          left: ee,
          top: G,
          width: J + K.width,
          height: te + K.height,
          color: D.backdropColor
        };
      }
      v.push({
        label: b,
        font: j,
        textOffset: P,
        options: {
          rotation: m,
          color: F,
          strokeColor: q,
          strokeWidth: B,
          textAlign: L,
          textBaseline: R,
          translation: [
            O,
            E
          ],
          backdrop: Y
        }
      });
    }
    return v;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: n } = this.options;
    if (-li(this.labelRotation))
      return t === "top" ? "left" : "right";
    let i = "center";
    return n.align === "start" ? i = "left" : n.align === "end" ? i = "right" : n.align === "inner" && (i = "inner"), i;
  }
  _getYAxisLabelAlignment(t) {
    const { position: n, ticks: { crossAlign: r, mirror: i, padding: o } } = this.options, a = this._getLabelSizes(), s = t + o, l = a.widest.width;
    let c, u;
    return n === "left" ? i ? (u = this.right + o, r === "near" ? c = "left" : r === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - s, r === "near" ? c = "right" : r === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : n === "right" ? i ? (u = this.left + o, r === "near" ? c = "right" : r === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + s, r === "near" ? c = "left" : r === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
      textAlign: c,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: n }, left: r, top: i, width: o, height: a } = this;
    n && (t.save(), t.fillStyle = n, t.fillRect(r, i, o, a), t.restore());
  }
  getLineWidthForValue(t) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const i = this.ticks.findIndex((o) => o.value === t);
    return i >= 0 ? n.setContext(this.getContext(i)).lineWidth : 0;
  }
  drawGrid(t) {
    const n = this.options.grid, r = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let o, a;
    const s = (l, c, u) => {
      !u.width || !u.color || (r.save(), r.lineWidth = u.width, r.strokeStyle = u.color, r.setLineDash(u.borderDash || []), r.lineDashOffset = u.borderDashOffset, r.beginPath(), r.moveTo(l.x, l.y), r.lineTo(c.x, c.y), r.stroke(), r.restore());
    };
    if (n.display)
      for (o = 0, a = i.length; o < a; ++o) {
        const l = i[o];
        n.drawOnChartArea && s({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), n.drawTicks && s({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: n, options: { border: r, grid: i } } = this, o = r.setContext(this.getContext()), a = r.display ? o.width : 0;
    if (!a)
      return;
    const s = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, u, d, p;
    this.isHorizontal() ? (c = fo(t, this.left, a) - a / 2, u = fo(t, this.right, s) + s / 2, d = p = l) : (d = fo(t, this.top, a) - a / 2, p = fo(t, this.bottom, s) + s / 2, c = u = l), n.save(), n.lineWidth = o.width, n.strokeStyle = o.color, n.beginPath(), n.moveTo(c, d), n.lineTo(u, p), n.stroke(), n.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const r = this.ctx, i = this._computeLabelArea();
    i && rb(r, i);
    const o = this.getLabelItems(t);
    for (const a of o) {
      const s = a.options, l = a.font, c = a.label, u = a.textOffset;
      xd(r, c, 0, u, l, s);
    }
    i && ib(r);
  }
  drawTitle() {
    const { ctx: t, options: { position: n, title: r, reverse: i } } = this;
    if (!r.display)
      return;
    const o = An(r.font), a = Or(r.padding), s = r.align;
    let l = o.lineHeight / 2;
    n === "bottom" || n === "center" || Te(n) ? (l += a.bottom, Kt(r.text) && (l += o.lineHeight * (r.text.length - 1))) : l += a.top;
    const { titleX: c, titleY: u, maxWidth: d, rotation: p } = oee(this, l, n, s);
    xd(t, r.text, 0, 0, o, {
      color: r.color,
      maxWidth: d,
      rotation: p,
      textAlign: iee(s, n, i),
      textBaseline: "middle",
      translation: [
        c,
        u
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, n = t.ticks && t.ticks.z || 0, r = we(t.grid && t.grid.z, -1), i = we(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== os.prototype.draw ? [
      {
        z: n,
        draw: (o) => {
          this.draw(o);
        }
      }
    ] : [
      {
        z: r,
        draw: (o) => {
          this.drawBackground(), this.drawGrid(o), this.drawTitle();
        }
      },
      {
        z: i,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (o) => {
          this.drawLabels(o);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const n = this.chart.getSortedVisibleDatasetMetas(), r = this.axis + "AxisID", i = [];
    let o, a;
    for (o = 0, a = n.length; o < a; ++o) {
      const s = n[o];
      s[r] === this.id && (!t || s.type === t) && i.push(s);
    }
    return i;
  }
  _resolveTickFontOptions(t) {
    const n = this.options.ticks.setContext(this.getContext(t));
    return An(n.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class Qc {
  constructor(t, n, r) {
    this.type = t, this.scope = n, this.override = r, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const n = Object.getPrototypeOf(t);
    let r;
    lee(n) && (r = this.register(n));
    const i = this.items, o = t.id, a = this.scope + "." + o;
    if (!o)
      throw new Error("class does not have id: " + t);
    return o in i || (i[o] = t, aee(t, a, r), this.override && Mt.override(t.id, t.overrides)), a;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const n = this.items, r = t.id, i = this.scope;
    r in n && delete n[r], i && r in Mt[i] && (delete Mt[i][r], this.override && delete Ho[r]);
  }
}
function aee(e, t, n) {
  const r = Sl(/* @__PURE__ */ Object.create(null), [
    n ? Mt.get(n) : {},
    Mt.get(t),
    e.defaults
  ]);
  Mt.set(t, r), e.defaultRoutes && see(t, e.defaultRoutes), e.descriptors && Mt.describe(t, e.descriptors);
}
function see(e, t) {
  Object.keys(t).forEach((n) => {
    const r = n.split("."), i = r.pop(), o = [
      e
    ].concat(r).join("."), a = t[n].split("."), s = a.pop(), l = a.join(".");
    Mt.route(o, i, l, s);
  });
}
function lee(e) {
  return "id" in e && "defaults" in e;
}
class cee {
  constructor() {
    this.controllers = new Qc(Lf, "datasets", !0), this.elements = new Qc(no, "elements"), this.plugins = new Qc(Object, "plugins"), this.scales = new Qc(os, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, n, r) {
    [
      ...n
    ].forEach((i) => {
      const o = r || this._getRegistryForType(i);
      r || o.isForType(i) || o === this.plugins && i.id ? this._exec(t, o, i) : He(i, (a) => {
        const s = r || this._getRegistryForType(a);
        this._exec(t, s, a);
      });
    });
  }
  _exec(t, n, r) {
    const i = Qy(t);
    ut(r["before" + i], [], r), n[t](r), ut(r["after" + i], [], r);
  }
  _getRegistryForType(t) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const r = this._typedRegistries[n];
      if (r.isForType(t))
        return r;
    }
    return this.plugins;
  }
  _get(t, n, r) {
    const i = n.get(t);
    if (i === void 0)
      throw new Error('"' + t + '" is not a registered ' + r + ".");
    return i;
  }
}
var Mr = /* @__PURE__ */ new cee();
class uee {
  constructor() {
    this._init = [];
  }
  notify(t, n, r, i) {
    n === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const o = i ? this._descriptors(t).filter(i) : this._descriptors(t), a = this._notify(o, t, n, r);
    return n === "afterDestroy" && (this._notify(o, t, "stop"), this._notify(this._init, t, "uninstall")), a;
  }
  _notify(t, n, r, i) {
    i = i || {};
    for (const o of t) {
      const a = o.plugin, s = a[r], l = [
        n,
        i,
        o.options
      ];
      if (ut(s, l, a) === !1 && i.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    We(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), n;
  }
  _createDescriptors(t, n) {
    const r = t && t.config, i = we(r.options && r.options.plugins, {}), o = dee(r);
    return i === !1 && !n ? [] : pee(t, o, i, n);
  }
  _notifyStateChanges(t) {
    const n = this._oldCache || [], r = this._cache, i = (o, a) => o.filter((s) => !a.some((l) => s.plugin.id === l.plugin.id));
    this._notify(i(n, r), t, "stop"), this._notify(i(r, n), t, "start");
  }
}
function dee(e) {
  const t = {}, n = [], r = Object.keys(Mr.plugins.items);
  for (let o = 0; o < r.length; o++)
    n.push(Mr.getPlugin(r[o]));
  const i = e.plugins || [];
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    n.indexOf(a) === -1 && (n.push(a), t[a.id] = !0);
  }
  return {
    plugins: n,
    localIds: t
  };
}
function fee(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function pee(e, { plugins: t, localIds: n }, r, i) {
  const o = [], a = e.getContext();
  for (const s of t) {
    const l = s.id, c = fee(r[l], i);
    c !== null && o.push({
      plugin: s,
      options: hee(e.config, {
        plugin: s,
        local: n[l]
      }, c, a)
    });
  }
  return o;
}
function hee(e, { plugin: t, local: n }, r, i) {
  const o = e.pluginScopeKeys(t), a = e.getOptionScopes(r, o);
  return n && t.defaults && a.push(t.defaults), e.createResolver(a, i, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function vg(e, t) {
  const n = Mt.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x";
}
function mee(e, t) {
  let n = e;
  return e === "_index_" ? n = t : e === "_value_" && (n = t === "x" ? "y" : "x"), n;
}
function gee(e, t) {
  return e === t ? "_index_" : "_value_";
}
function oE(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function vee(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function yg(e, ...t) {
  if (oE(e))
    return e;
  for (const n of t) {
    const r = n.axis || vee(n.position) || e.length > 1 && oE(e[0].toLowerCase());
    if (r)
      return r;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function aE(e, t, n) {
  if (n[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function yee(e, t) {
  if (t.data && t.data.datasets) {
    const n = t.data.datasets.filter((r) => r.xAxisID === e || r.yAxisID === e);
    if (n.length)
      return aE(e, "x", n[0]) || aE(e, "y", n[0]);
  }
  return {};
}
function bee(e, t) {
  const n = Ho[e.type] || {
    scales: {}
  }, r = t.scales || {}, i = vg(e.type, t), o = /* @__PURE__ */ Object.create(null);
  return Object.keys(r).forEach((a) => {
    const s = r[a];
    if (!Te(s))
      return console.error(`Invalid scale configuration for scale: ${a}`);
    if (s._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${a}`);
    const l = yg(a, s, yee(a, e), Mt.scales[s.type]), c = gee(l, i), u = n.scales || {};
    o[a] = Gs(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      s,
      u[l],
      u[c]
    ]);
  }), e.data.datasets.forEach((a) => {
    const s = a.type || e.type, l = a.indexAxis || vg(s, t), u = (Ho[s] || {}).scales || {};
    Object.keys(u).forEach((d) => {
      const p = mee(d, l), h = a[p + "AxisID"] || p;
      o[h] = o[h] || /* @__PURE__ */ Object.create(null), Gs(o[h], [
        {
          axis: p
        },
        r[h],
        u[d]
      ]);
    });
  }), Object.keys(o).forEach((a) => {
    const s = o[a];
    Gs(s, [
      Mt.scales[s.type],
      Mt.scale
    ]);
  }), o;
}
function pM(e) {
  const t = e.options || (e.options = {});
  t.plugins = we(t.plugins, {}), t.scales = bee(e, t);
}
function hM(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function xee(e) {
  return e = e || {}, e.data = hM(e.data), pM(e), e;
}
const sE = /* @__PURE__ */ new Map(), mM = /* @__PURE__ */ new Set();
function eu(e, t) {
  let n = sE.get(e);
  return n || (n = t(), sE.set(e, n), mM.add(n)), n;
}
const Ts = (e, t, n) => {
  const r = Uo(t, n);
  r !== void 0 && e.add(r);
};
class wee {
  constructor(t) {
    this._config = xee(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = hM(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), pM(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return eu(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, n) {
    return eu(`${t}.transition.${n}`, () => [
      [
        `datasets.${t}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, n) {
    return eu(`${t}-${n}`, () => [
      [
        `datasets.${t}.elements.${n}`,
        `datasets.${t}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const n = t.id, r = this.type;
    return eu(`${r}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, n) {
    const r = this._scopeCache;
    let i = r.get(t);
    return (!i || n) && (i = /* @__PURE__ */ new Map(), r.set(t, i)), i;
  }
  getOptionScopes(t, n, r) {
    const { options: i, type: o } = this, a = this._cachedScopes(t, r), s = a.get(n);
    if (s)
      return s;
    const l = /* @__PURE__ */ new Set();
    n.forEach((u) => {
      t && (l.add(t), u.forEach((d) => Ts(l, t, d))), u.forEach((d) => Ts(l, i, d)), u.forEach((d) => Ts(l, Ho[o] || {}, d)), u.forEach((d) => Ts(l, Mt, d)), u.forEach((d) => Ts(l, mg, d));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), mM.has(n) && a.set(n, c), c;
  }
  chartOptionScopes() {
    const { options: t, type: n } = this;
    return [
      t,
      Ho[n] || {},
      Mt.datasets[n] || {},
      {
        type: n
      },
      Mt,
      mg
    ];
  }
  resolveNamedOptions(t, n, r, i = [
    ""
  ]) {
    const o = {
      $shared: !0
    }, { resolver: a, subPrefixes: s } = lE(this._resolverCache, t, i);
    let l = a;
    if (See(a, n)) {
      o.$shared = !1, r = Ki(r) ? r() : r;
      const c = this.createResolver(t, r, s);
      l = za(a, r, c);
    }
    for (const c of n)
      o[c] = l[c];
    return o;
  }
  createResolver(t, n, r = [
    ""
  ], i) {
    const { resolver: o } = lE(this._resolverCache, t, r);
    return Te(n) ? za(o, n, void 0, i) : o;
  }
}
function lE(e, t, n) {
  let r = e.get(t);
  r || (r = /* @__PURE__ */ new Map(), e.set(t, r));
  const i = n.join();
  let o = r.get(i);
  return o || (o = {
    resolver: ab(t, n),
    subPrefixes: n.filter((s) => !s.toLowerCase().includes("hover"))
  }, r.set(i, o)), o;
}
const Oee = (e) => Te(e) && Object.getOwnPropertyNames(e).some((t) => Ki(e[t]));
function See(e, t) {
  const { isScriptable: n, isIndexable: r } = Zk(e);
  for (const i of t) {
    const o = n(i), a = r(i), s = (a || o) && e[i];
    if (o && (Ki(s) || Oee(s)) || a && Kt(s))
      return !0;
  }
  return !1;
}
var Eee = "4.5.0";
const _ee = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function cE(e, t) {
  return e === "top" || e === "bottom" || _ee.indexOf(e) === -1 && t === "x";
}
function uE(e, t) {
  return function(n, r) {
    return n[e] === r[e] ? n[t] - r[t] : n[e] - r[e];
  };
}
function dE(e) {
  const t = e.chart, n = t.options.animation;
  t.notifyPlugins("afterRender"), ut(n && n.onComplete, [
    e
  ], t);
}
function Pee(e) {
  const t = e.chart, n = t.options.animation;
  ut(n && n.onProgress, [
    e
  ], t);
}
function gM(e) {
  return cb() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const hu = {}, fE = (e) => {
  const t = gM(e);
  return Object.values(hu).filter((n) => n.canvas === t).pop();
};
function Cee(e, t, n) {
  const r = Object.keys(e);
  for (const i of r) {
    const o = +i;
    if (o >= t) {
      const a = e[i];
      delete e[i], (n > 0 || o > t) && (e[o + n] = a);
    }
  }
}
function Tee(e, t, n, r) {
  return !n || e.type === "mouseout" ? null : r ? t : e;
}
let Dn = class {
  static defaults = Mt;
  static instances = hu;
  static overrides = Ho;
  static registry = Mr;
  static version = Eee;
  static getChart = fE;
  static register(...t) {
    Mr.add(...t), pE();
  }
  static unregister(...t) {
    Mr.remove(...t), pE();
  }
  constructor(t, n) {
    const r = this.config = new wee(n), i = gM(t), o = fE(i);
    if (o)
      throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused.");
    const a = r.createResolver(r.chartOptionScopes(), this.getContext());
    this.platform = new (r.platform || qQ(i))(), this.platform.updateConfig(r);
    const s = this.platform.acquireContext(i, a.aspectRatio), l = s && s.canvas, c = l && l.height, u = l && l.width;
    if (this.id = xZ(), this.ctx = s, this.canvas = l, this.width = u, this.height = c, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new uee(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = FZ((d) => this.update(d), a.resizeDelay || 0), this._dataChanges = [], hu[this.id] = this, !s || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    ei.listen(this, "complete", dE), ei.listen(this, "progress", Pee), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: n }, width: r, height: i, _aspectRatio: o } = this;
    return We(t) ? n && o ? o : i ? r / i : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return Mr;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : RS(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return jS(this.canvas, this.ctx), this;
  }
  stop() {
    return ei.stop(this), this;
  }
  resize(t, n) {
    ei.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: n
    } : this._resize(t, n);
  }
  _resize(t, n) {
    const r = this.options, i = this.canvas, o = r.maintainAspectRatio && this.aspectRatio, a = this.platform.getMaximumSize(i, t, n, o), s = r.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = a.width, this.height = a.height, this._aspectRatio = this.aspectRatio, RS(this, s, !0) && (this.notifyPlugins("resize", {
      size: a
    }), ut(r.onResize, [
      this,
      a
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    He(n, (r, i) => {
      r.id = i;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, n = t.scales, r = this.scales, i = Object.keys(r).reduce((a, s) => (a[s] = !1, a), {});
    let o = [];
    n && (o = o.concat(Object.keys(n).map((a) => {
      const s = n[a], l = yg(a, s), c = l === "r", u = l === "x";
      return {
        options: s,
        dposition: c ? "chartArea" : u ? "bottom" : "left",
        dtype: c ? "radialLinear" : u ? "category" : "linear"
      };
    }))), He(o, (a) => {
      const s = a.options, l = s.id, c = yg(l, s), u = we(s.type, a.dtype);
      (s.position === void 0 || cE(s.position, c) !== cE(a.dposition)) && (s.position = a.dposition), i[l] = !0;
      let d = null;
      if (l in r && r[l].type === u)
        d = r[l];
      else {
        const p = Mr.getScale(u);
        d = new p({
          id: l,
          type: u,
          ctx: this.ctx,
          chart: this
        }), r[d.id] = d;
      }
      d.init(s, t);
    }), He(i, (a, s) => {
      a || delete r[s];
    }), He(r, (a) => {
      Ri.configure(this, a, a.options), Ri.addBox(this, a);
    });
  }
  _updateMetasets() {
    const t = this._metasets, n = this.data.datasets.length, r = t.length;
    if (t.sort((i, o) => i.index - o.index), r > n) {
      for (let i = n; i < r; ++i)
        this._destroyDatasetMeta(i);
      t.splice(n, r - n);
    }
    this._sortedMetasets = t.slice(0).sort(uE("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: n } } = this;
    t.length > n.length && delete this._stacks, t.forEach((r, i) => {
      n.filter((o) => o === r._dataset).length === 0 && this._destroyDatasetMeta(i);
    });
  }
  buildOrUpdateControllers() {
    const t = [], n = this.data.datasets;
    let r, i;
    for (this._removeUnreferencedMetasets(), r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      let a = this.getDatasetMeta(r);
      const s = o.type || this.config.type;
      if (a.type && a.type !== s && (this._destroyDatasetMeta(r), a = this.getDatasetMeta(r)), a.type = s, a.indexAxis = o.indexAxis || vg(s, this.options), a.order = o.order || 0, a.index = r, a.label = "" + o.label, a.visible = this.isDatasetVisible(r), a.controller)
        a.controller.updateIndex(r), a.controller.linkScales();
      else {
        const l = Mr.getController(s), { datasetElementType: c, dataElementType: u } = Mt.datasets[s];
        Object.assign(l, {
          dataElementType: Mr.getElement(u),
          datasetElementType: c && Mr.getElement(c)
        }), a.controller = new l(this, r), t.push(a.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    He(this.data.datasets, (t, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const n = this.config;
    n.update();
    const r = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !r.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const o = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let a = 0;
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: d } = this.getDatasetMeta(c), p = !i && o.indexOf(d) === -1;
      d.buildOrUpdateElements(p), a = Math.max(+d.getMaxOverflow(), a);
    }
    a = this._minPadding = r.layout.autoPadding ? a : 0, this._updateLayout(a), i || He(o, (c) => {
      c.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(uE("z", "_idx"));
    const { _active: s, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : s.length && this._updateHoverStyles(s, s, !0), this.render();
  }
  _updateScales() {
    He(this.scales, (t) => {
      Ri.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, n = new Set(Object.keys(this._listeners)), r = new Set(t.events);
    (!OS(n, r) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, n = this._getUniformDataChanges() || [];
    for (const { method: r, start: i, count: o } of n) {
      const a = r === "_removeElements" ? -o : o;
      Cee(t, i, a);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, r = (o) => new Set(t.filter((a) => a[0] === o).map((a, s) => s + "," + a.splice(1).join(","))), i = r(0);
    for (let o = 1; o < n; o++)
      if (!OS(i, r(o)))
        return;
    return Array.from(i).map((o) => o.split(",")).map((o) => ({
      method: o[1],
      start: +o[2],
      count: +o[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Ri.update(this, this.width, this.height, t);
    const n = this.chartArea, r = n.width <= 0 || n.height <= 0;
    this._layers = [], He(this.boxes, (i) => {
      r && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers()));
    }, this), this._layers.forEach((i, o) => {
      i._idx = o;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this._updateDataset(n, Ki(t) ? t({
          datasetIndex: n
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, n) {
    const r = this.getDatasetMeta(t), i = {
      meta: r,
      index: t,
      mode: n,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", i) !== !1 && (r.controller._update(n), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (ei.has(this) ? this.attached && !ei.running(this) && ei.start(this) : (this.draw(), dE({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: r, height: i } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(r, i);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const n = this._layers;
    for (t = 0; t < n.length && n[t].z <= 0; ++t)
      n[t].draw(this.chartArea);
    for (this._drawDatasets(); t < n.length; ++t)
      n[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const n = this._sortedMetasets, r = [];
    let i, o;
    for (i = 0, o = n.length; i < o; ++i) {
      const a = n[i];
      (!t || a.visible) && r.push(a);
    }
    return r;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let n = t.length - 1; n >= 0; --n)
      this._drawDataset(t[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const n = this.ctx, r = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, i = HJ(this, t);
    this.notifyPlugins("beforeDatasetDraw", r) !== !1 && (i && rb(n, i), t.controller.draw(), i && ib(n), r.cancelable = !1, this.notifyPlugins("afterDatasetDraw", r));
  }
  isPointInArea(t) {
    return Cl(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, n, r, i) {
    const o = _Q.modes[n];
    return typeof o == "function" ? o(this, t, r, i) : [];
  }
  getDatasetMeta(t) {
    const n = this.data.datasets[t], r = this._metasets;
    let i = r.filter((o) => o && o._dataset === n).pop();
    return i || (i = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: t,
      _dataset: n,
      _parsed: [],
      _sorted: !1
    }, r.push(i)), i;
  }
  getContext() {
    return this.$context || (this.$context = Qo(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const n = this.data.datasets[t];
    if (!n)
      return !1;
    const r = this.getDatasetMeta(t);
    return typeof r.hidden == "boolean" ? !r.hidden : !n.hidden;
  }
  setDatasetVisibility(t, n) {
    const r = this.getDatasetMeta(t);
    r.hidden = !n;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, n, r) {
    const i = r ? "show" : "hide", o = this.getDatasetMeta(t), a = o.controller._resolveAnimations(void 0, i);
    El(n) ? (o.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(t, r), a.update(o, {
      visible: r
    }), this.update((s) => s.datasetIndex === t ? i : void 0));
  }
  hide(t, n) {
    this._updateVisibility(t, n, !1);
  }
  show(t, n) {
    this._updateVisibility(t, n, !0);
  }
  _destroyDatasetMeta(t) {
    const n = this._metasets[t];
    n && n.controller && n.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, n;
    for (this.stop(), ei.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: n } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), jS(t, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete hu[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, n = this.platform, r = (o, a) => {
      n.addEventListener(this, o, a), t[o] = a;
    }, i = (o, a, s) => {
      o.offsetX = a, o.offsetY = s, this._eventHandler(o);
    };
    He(this.options.events, (o) => r(o, i));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, n = this.platform, r = (l, c) => {
      n.addEventListener(this, l, c), t[l] = c;
    }, i = (l, c) => {
      t[l] && (n.removeEventListener(this, l, c), delete t[l]);
    }, o = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let a;
    const s = () => {
      i("attach", s), this.attached = !0, this.resize(), r("resize", o), r("detach", a);
    };
    a = () => {
      this.attached = !1, i("resize", o), this._stop(), this._resize(0, 0), r("attach", s);
    }, n.isAttached(this.canvas) ? s() : a();
  }
  unbindEvents() {
    He(this._listeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._listeners = {}, He(this._responsiveListeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, n, r) {
    const i = r ? "set" : "remove";
    let o, a, s, l;
    for (n === "dataset" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller["_" + i + "DatasetHoverStyle"]()), s = 0, l = t.length; s < l; ++s) {
      a = t[s];
      const c = a && this.getDatasetMeta(a.datasetIndex).controller;
      c && c[i + "HoverStyle"](a.element, a.datasetIndex, a.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const n = this._active || [], r = t.map(({ datasetIndex: o, index: a }) => {
      const s = this.getDatasetMeta(o);
      if (!s)
        throw new Error("No dataset found at index " + o);
      return {
        datasetIndex: o,
        element: s.data[a],
        index: a
      };
    });
    !vd(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n));
  }
  notifyPlugins(t, n, r) {
    return this._plugins.notify(this, t, n, r);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((n) => n.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, n, r) {
    const i = this.options.hover, o = (l, c) => l.filter((u) => !c.some((d) => u.datasetIndex === d.datasetIndex && u.index === d.index)), a = o(n, t), s = r ? t : o(t, n);
    a.length && this.updateHoverStyle(a, i.mode, !1), s.length && i.mode && this.updateHoverStyle(s, i.mode, !0);
  }
  _eventHandler(t, n) {
    const r = {
      event: t,
      replay: n,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, i = (a) => (a.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", r, i) === !1)
      return;
    const o = this._handleEvent(t, n, r.inChartArea);
    return r.cancelable = !1, this.notifyPlugins("afterEvent", r, i), (o || r.changed) && this.render(), this;
  }
  _handleEvent(t, n, r) {
    const { _active: i = [], options: o } = this, a = n, s = this._getActiveElements(t, i, r, a), l = PZ(t), c = Tee(t, this._lastEvent, r, l);
    r && (this._lastEvent = null, ut(o.onHover, [
      t,
      s,
      this
    ], this), l && ut(o.onClick, [
      t,
      s,
      this
    ], this));
    const u = !vd(s, i);
    return (u || n) && (this._active = s, this._updateHoverStyles(s, i, n)), this._lastEvent = c, u;
  }
  _getActiveElements(t, n, r, i) {
    if (t.type === "mouseout")
      return [];
    if (!r)
      return n;
    const o = this.options.hover;
    return this.getElementsAtEventForMode(t, o.mode, o, i);
  }
};
function pE() {
  return He(Dn.instances, (e) => e._plugins.invalidate());
}
function Aee(e, t, n) {
  const { startAngle: r, x: i, y: o, outerRadius: a, innerRadius: s, options: l } = t, { borderWidth: c, borderJoinStyle: u } = l, d = Math.min(c / a, xr(r - n));
  if (e.beginPath(), e.arc(i, o, a - c / 2, r + d / 2, n - d / 2), s > 0) {
    const p = Math.min(c / s, xr(r - n));
    e.arc(i, o, s + c / 2, n - p / 2, r + p / 2, !0);
  } else {
    const p = Math.min(c / 2, a * xr(r - n));
    if (u === "round")
      e.arc(i, o, p, n - it / 2, r + it / 2, !0);
    else if (u === "bevel") {
      const h = 2 * p * p, g = -h * Math.cos(n + it / 2) + i, m = -h * Math.sin(n + it / 2) + o, v = h * Math.cos(r + it / 2) + i, y = h * Math.sin(r + it / 2) + o;
      e.lineTo(g, m), e.lineTo(v, y);
    }
  }
  e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd");
}
function kee(e, t, n) {
  const { startAngle: r, pixelMargin: i, x: o, y: a, outerRadius: s, innerRadius: l } = t;
  let c = i / s;
  e.beginPath(), e.arc(o, a, s, r - c, n + c), l > i ? (c = i / l, e.arc(o, a, l, n + c, r - c, !0)) : e.arc(o, a, i, n + Bt, r - Bt), e.closePath(), e.clip();
}
function Mee(e) {
  return ob(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function jee(e, t, n, r) {
  const i = Mee(e.options.borderRadius), o = (n - t) / 2, a = Math.min(o, r * t / 2), s = (l) => {
    const c = (n - Math.min(o, l)) * r / 2;
    return fn(l, 0, Math.min(o, c));
  };
  return {
    outerStart: s(i.outerStart),
    outerEnd: s(i.outerEnd),
    innerStart: fn(i.innerStart, 0, a),
    innerEnd: fn(i.innerEnd, 0, a)
  };
}
function pa(e, t, n, r) {
  return {
    x: n + e * Math.cos(t),
    y: r + e * Math.sin(t)
  };
}
function Ed(e, t, n, r, i, o) {
  const { x: a, y: s, startAngle: l, pixelMargin: c, innerRadius: u } = t, d = Math.max(t.outerRadius + r + n - c, 0), p = u > 0 ? u + r + n + c : 0;
  let h = 0;
  const g = i - l;
  if (r) {
    const D = u > 0 ? u - r : 0, $ = d > 0 ? d - r : 0, F = (D + $) / 2, q = F !== 0 ? g * F / (F + r) : g;
    h = (g - q) / 2;
  }
  const m = Math.max(1e-3, g * d - n / it) / d, v = (g - m) / 2, y = l + v + h, S = i - v - h, { outerStart: w, outerEnd: b, innerStart: O, innerEnd: E } = jee(t, p, d, S - y), C = d - w, T = d - b, j = y + w / C, A = S - b / T, M = p + O, P = p + E, R = y + O / M, N = S - E / P;
  if (e.beginPath(), o) {
    const D = (j + A) / 2;
    if (e.arc(a, s, d, j, D), e.arc(a, s, d, D, A), b > 0) {
      const B = pa(T, A, a, s);
      e.arc(B.x, B.y, b, A, S + Bt);
    }
    const $ = pa(P, S, a, s);
    if (e.lineTo($.x, $.y), E > 0) {
      const B = pa(P, N, a, s);
      e.arc(B.x, B.y, E, S + Bt, N + Math.PI);
    }
    const F = (S - E / p + (y + O / p)) / 2;
    if (e.arc(a, s, p, S - E / p, F, !0), e.arc(a, s, p, F, y + O / p, !0), O > 0) {
      const B = pa(M, R, a, s);
      e.arc(B.x, B.y, O, R + Math.PI, y - Bt);
    }
    const q = pa(C, y, a, s);
    if (e.lineTo(q.x, q.y), w > 0) {
      const B = pa(C, j, a, s);
      e.arc(B.x, B.y, w, y - Bt, j);
    }
  } else {
    e.moveTo(a, s);
    const D = Math.cos(j) * d + a, $ = Math.sin(j) * d + s;
    e.lineTo(D, $);
    const F = Math.cos(A) * d + a, q = Math.sin(A) * d + s;
    e.lineTo(F, q);
  }
  e.closePath();
}
function Nee(e, t, n, r, i) {
  const { fullCircles: o, startAngle: a, circumference: s } = t;
  let l = t.endAngle;
  if (o) {
    Ed(e, t, n, r, l, i);
    for (let c = 0; c < o; ++c)
      e.fill();
    isNaN(s) || (l = a + (s % Pt || Pt));
  }
  return Ed(e, t, n, r, l, i), e.fill(), l;
}
function Dee(e, t, n, r, i) {
  const { fullCircles: o, startAngle: a, circumference: s, options: l } = t, { borderWidth: c, borderJoinStyle: u, borderDash: d, borderDashOffset: p, borderRadius: h } = l, g = l.borderAlign === "inner";
  if (!c)
    return;
  e.setLineDash(d || []), e.lineDashOffset = p, g ? (e.lineWidth = c * 2, e.lineJoin = u || "round") : (e.lineWidth = c, e.lineJoin = u || "bevel");
  let m = t.endAngle;
  if (o) {
    Ed(e, t, n, r, m, i);
    for (let v = 0; v < o; ++v)
      e.stroke();
    isNaN(s) || (m = a + (s % Pt || Pt));
  }
  g && kee(e, t, m), l.selfJoin && m - a >= it && h === 0 && u !== "miter" && Aee(e, t, m), o || (Ed(e, t, n, r, m, i), e.stroke());
}
class fb extends no {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, n, r) {
    const i = this.getProps([
      "x",
      "y"
    ], r), { angle: o, distance: a } = Wk(i, {
      x: t,
      y: n
    }), { startAngle: s, endAngle: l, innerRadius: c, outerRadius: u, circumference: d } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], r), p = (this.options.spacing + this.options.borderWidth) / 2, h = we(d, l - s), g = Pl(o, s, l) && s !== l, m = h >= Pt || g, v = Di(a, c + p, u + p);
    return m && v;
  }
  getCenterPoint(t) {
    const { x: n, y: r, startAngle: i, endAngle: o, innerRadius: a, outerRadius: s } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: l, spacing: c } = this.options, u = (i + o) / 2, d = (a + s + c + l) / 2;
    return {
      x: n + Math.cos(u) * d,
      y: r + Math.sin(u) * d
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: n, circumference: r } = this, i = (n.offset || 0) / 4, o = (n.spacing || 0) / 2, a = n.circular;
    if (this.pixelMargin = n.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = r > Pt ? Math.floor(r / Pt) : 0, r === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const s = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(s) * i, Math.sin(s) * i);
    const l = 1 - Math.sin(Math.min(it, r || 0)), c = i * l;
    t.fillStyle = n.backgroundColor, t.strokeStyle = n.borderColor, Nee(t, this, c, o, a), Dee(t, this, c, o, a), t.restore();
  }
}
function vM(e, t, n = t) {
  e.lineCap = we(n.borderCapStyle, t.borderCapStyle), e.setLineDash(we(n.borderDash, t.borderDash)), e.lineDashOffset = we(n.borderDashOffset, t.borderDashOffset), e.lineJoin = we(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = we(n.borderWidth, t.borderWidth), e.strokeStyle = we(n.borderColor, t.borderColor);
}
function Ree(e, t, n) {
  e.lineTo(n.x, n.y);
}
function Iee(e) {
  return e.stepped ? QZ : e.tension || e.cubicInterpolationMode === "monotone" ? eJ : Ree;
}
function yM(e, t, n = {}) {
  const r = e.length, { start: i = 0, end: o = r - 1 } = n, { start: a, end: s } = t, l = Math.max(i, a), c = Math.min(o, s), u = i < a && o < a || i > s && o > s;
  return {
    count: r,
    start: l,
    loop: t.loop,
    ilen: c < l && !u ? r + c - l : c - l
  };
}
function $ee(e, t, n, r) {
  const { points: i, options: o } = t, { count: a, start: s, loop: l, ilen: c } = yM(i, n, r), u = Iee(o);
  let { move: d = !0, reverse: p } = r || {}, h, g, m;
  for (h = 0; h <= c; ++h)
    g = i[(s + (p ? c - h : h)) % a], !g.skip && (d ? (e.moveTo(g.x, g.y), d = !1) : u(e, m, g, p, o.stepped), m = g);
  return l && (g = i[(s + (p ? c : 0)) % a], u(e, m, g, p, o.stepped)), !!l;
}
function Lee(e, t, n, r) {
  const i = t.points, { count: o, start: a, ilen: s } = yM(i, n, r), { move: l = !0, reverse: c } = r || {};
  let u = 0, d = 0, p, h, g, m, v, y;
  const S = (b) => (a + (c ? s - b : b)) % o, w = () => {
    m !== v && (e.lineTo(u, v), e.lineTo(u, m), e.lineTo(u, y));
  };
  for (l && (h = i[S(0)], e.moveTo(h.x, h.y)), p = 0; p <= s; ++p) {
    if (h = i[S(p)], h.skip)
      continue;
    const b = h.x, O = h.y, E = b | 0;
    E === g ? (O < m ? m = O : O > v && (v = O), u = (d * u + b) / ++d) : (w(), e.lineTo(b, O), g = E, d = 0, m = v = O), y = O;
  }
  w();
}
function bg(e) {
  const t = e.options, n = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? Lee : $ee;
}
function Fee(e) {
  return e.stepped ? jJ : e.tension || e.cubicInterpolationMode === "monotone" ? NJ : wo;
}
function Bee(e, t, n, r) {
  let i = t._path;
  i || (i = t._path = new Path2D(), t.path(i, n, r) && i.closePath()), vM(e, t.options), e.stroke(i);
}
function zee(e, t, n, r) {
  const { segments: i, options: o } = t, a = bg(t);
  for (const s of i)
    vM(e, o, s.style), e.beginPath(), a(e, t, s, {
      start: n,
      end: n + r - 1
    }) && e.closePath(), e.stroke();
}
const Wee = typeof Path2D == "function";
function Vee(e, t, n, r) {
  Wee && !t.options.segment ? Bee(e, t, n, r) : zee(e, t, n, r);
}
class pb extends no {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash" && t !== "fill"
  };
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, n) {
    const r = this.options;
    if ((r.tension || r.cubicInterpolationMode === "monotone") && !r.stepped && !this._pointsUpdated) {
      const i = r.spanGaps ? this._loop : this._fullLoop;
      EJ(this._points, r, t, i, n), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = zJ(this, this.options.segment));
  }
  first() {
    const t = this.segments, n = this.points;
    return t.length && n[t[0].start];
  }
  last() {
    const t = this.segments, n = this.points, r = t.length;
    return r && n[t[r - 1].end];
  }
  interpolate(t, n) {
    const r = this.options, i = t[n], o = this.points, a = LJ(this, {
      property: n,
      start: i,
      end: i
    });
    if (!a.length)
      return;
    const s = [], l = Fee(r);
    let c, u;
    for (c = 0, u = a.length; c < u; ++c) {
      const { start: d, end: p } = a[c], h = o[d], g = o[p];
      if (h === g) {
        s.push(h);
        continue;
      }
      const m = Math.abs((i - h[n]) / (g[n] - h[n])), v = l(h, g, m, r.stepped);
      v[n] = t[n], s.push(v);
    }
    return s.length === 1 ? s[0] : s;
  }
  pathSegment(t, n, r) {
    return bg(this)(t, this, n, r);
  }
  path(t, n, r) {
    const i = this.segments, o = bg(this);
    let a = this._loop;
    n = n || 0, r = r || this.points.length - n;
    for (const s of i)
      a &= o(t, this, s, {
        start: n,
        end: n + r - 1
      });
    return !!a;
  }
  draw(t, n, r, i) {
    const o = this.options || {};
    (this.points || []).length && o.borderWidth && (t.save(), Vee(t, this, r, i), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function hE(e, t, n, r) {
  const i = e.options, { [n]: o } = e.getProps([
    n
  ], r);
  return Math.abs(t - o) < i.radius + i.hitRadius;
}
class hb extends no {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, n, r) {
    const i = this.options, { x: o, y: a } = this.getProps([
      "x",
      "y"
    ], r);
    return Math.pow(t - o, 2) + Math.pow(n - a, 2) < Math.pow(i.hitRadius + i.radius, 2);
  }
  inXRange(t, n) {
    return hE(this, t, "x", n);
  }
  inYRange(t, n) {
    return hE(this, t, "y", n);
  }
  getCenterPoint(t) {
    const { x: n, y: r } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: r
    };
  }
  size(t) {
    t = t || this.options || {};
    let n = t.radius || 0;
    n = Math.max(n, n && t.hoverRadius || 0);
    const r = n && t.borderWidth || 0;
    return (n + r) * 2;
  }
  draw(t, n) {
    const r = this.options;
    this.skip || r.radius < 0.1 || !Cl(this, n, this.size(r) / 2) || (t.strokeStyle = r.borderColor, t.lineWidth = r.borderWidth, t.fillStyle = r.backgroundColor, gg(t, r, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
function bM(e, t) {
  const { x: n, y: r, base: i, width: o, height: a } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let s, l, c, u, d;
  return e.horizontal ? (d = a / 2, s = Math.min(n, i), l = Math.max(n, i), c = r - d, u = r + d) : (d = o / 2, s = n - d, l = n + d, c = Math.min(r, i), u = Math.max(r, i)), {
    left: s,
    top: c,
    right: l,
    bottom: u
  };
}
function Ii(e, t, n, r) {
  return e ? 0 : fn(t, n, r);
}
function Uee(e, t, n) {
  const r = e.options.borderWidth, i = e.borderSkipped, o = Xk(r);
  return {
    t: Ii(i.top, o.top, 0, n),
    r: Ii(i.right, o.right, 0, t),
    b: Ii(i.bottom, o.bottom, 0, n),
    l: Ii(i.left, o.left, 0, t)
  };
}
function Hee(e, t, n) {
  const { enableBorderRadius: r } = e.getProps([
    "enableBorderRadius"
  ]), i = e.options.borderRadius, o = Ea(i), a = Math.min(t, n), s = e.borderSkipped, l = r || Te(i);
  return {
    topLeft: Ii(!l || s.top || s.left, o.topLeft, 0, a),
    topRight: Ii(!l || s.top || s.right, o.topRight, 0, a),
    bottomLeft: Ii(!l || s.bottom || s.left, o.bottomLeft, 0, a),
    bottomRight: Ii(!l || s.bottom || s.right, o.bottomRight, 0, a)
  };
}
function qee(e) {
  const t = bM(e), n = t.right - t.left, r = t.bottom - t.top, i = Uee(e, n / 2, r / 2), o = Hee(e, n / 2, r / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: n,
      h: r,
      radius: o
    },
    inner: {
      x: t.left + i.l,
      y: t.top + i.t,
      w: n - i.l - i.r,
      h: r - i.t - i.b,
      radius: {
        topLeft: Math.max(0, o.topLeft - Math.max(i.t, i.l)),
        topRight: Math.max(0, o.topRight - Math.max(i.t, i.r)),
        bottomLeft: Math.max(0, o.bottomLeft - Math.max(i.b, i.l)),
        bottomRight: Math.max(0, o.bottomRight - Math.max(i.b, i.r))
      }
    }
  };
}
function Xh(e, t, n, r) {
  const i = t === null, o = n === null, s = e && !(i && o) && bM(e, r);
  return s && (i || Di(t, s.left, s.right)) && (o || Di(n, s.top, s.bottom));
}
function Kee(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function Yee(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function Zh(e, t, n = {}) {
  const r = e.x !== n.x ? -t : 0, i = e.y !== n.y ? -t : 0, o = (e.x + e.w !== n.x + n.w ? t : 0) - r, a = (e.y + e.h !== n.y + n.h ? t : 0) - i;
  return {
    x: e.x + r,
    y: e.y + i,
    w: e.w + o,
    h: e.h + a,
    radius: e.radius
  };
}
class sc extends no {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: n, options: { borderColor: r, backgroundColor: i } } = this, { inner: o, outer: a } = qee(this), s = Kee(a.radius) ? wd : Yee;
    t.save(), (a.w !== o.w || a.h !== o.h) && (t.beginPath(), s(t, Zh(a, n, o)), t.clip(), s(t, Zh(o, -n, a)), t.fillStyle = r, t.fill("evenodd")), t.beginPath(), s(t, Zh(o, n)), t.fillStyle = i, t.fill(), t.restore();
  }
  inRange(t, n, r) {
    return Xh(this, t, n, r);
  }
  inXRange(t, n) {
    return Xh(this, t, null, n);
  }
  inYRange(t, n) {
    return Xh(this, null, t, n);
  }
  getCenterPoint(t) {
    const { x: n, y: r, base: i, horizontal: o } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: o ? (n + i) / 2 : n,
      y: o ? r : (r + i) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
const mE = (e, t) => {
  let { boxHeight: n = t, boxWidth: r = t } = e;
  return e.usePointStyle && (n = Math.min(n, t), r = e.pointStyleWidth || Math.min(r, t)), {
    boxWidth: r,
    boxHeight: n,
    itemHeight: Math.max(t, n)
  };
}, Gee = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class gE extends no {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, n, r) {
    this.maxWidth = t, this.maxHeight = n, this._margins = r, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let n = ut(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (n = n.filter((r) => t.filter(r, this.chart.data))), t.sort && (n = n.sort((r, i) => t.sort(r, i, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n;
  }
  fit() {
    const { options: t, ctx: n } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const r = t.labels, i = An(r.font), o = i.size, a = this._computeTitleHeight(), { boxWidth: s, itemHeight: l } = mE(r, o);
    let c, u;
    n.font = i.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(a, o, s, l) + 10) : (u = this.maxHeight, c = this._fitCols(a, i, s, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(u, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, n, r, i) {
    const { ctx: o, maxWidth: a, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
      0
    ], u = i + s;
    let d = t;
    o.textAlign = "left", o.textBaseline = "middle";
    let p = -1, h = -u;
    return this.legendItems.forEach((g, m) => {
      const v = r + n / 2 + o.measureText(g.text).width;
      (m === 0 || c[c.length - 1] + v + 2 * s > a) && (d += u, c[c.length - (m > 0 ? 0 : 1)] = 0, h += u, p++), l[m] = {
        left: 0,
        top: h,
        row: p,
        width: v,
        height: i
      }, c[c.length - 1] += v + s;
    }), d;
  }
  _fitCols(t, n, r, i) {
    const { ctx: o, maxHeight: a, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = a - t;
    let d = s, p = 0, h = 0, g = 0, m = 0;
    return this.legendItems.forEach((v, y) => {
      const { itemWidth: S, itemHeight: w } = Xee(r, n, o, v, i);
      y > 0 && h + w + 2 * s > u && (d += p + s, c.push({
        width: p,
        height: h
      }), g += p + s, m++, p = h = 0), l[y] = {
        left: g,
        top: h,
        col: m,
        width: S,
        height: w
      }, p = Math.max(p, S), h += w + s;
    }), d += p, c.push({
      width: p,
      height: h
    }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: r, labels: { padding: i }, rtl: o } } = this, a = _a(o, this.left, this.width);
    if (this.isHorizontal()) {
      let s = 0, l = $n(r, this.left + i, this.right - this.lineWidths[s]);
      for (const c of n)
        s !== c.row && (s = c.row, l = $n(r, this.left + i, this.right - this.lineWidths[s])), c.top += this.top + t + i, c.left = a.leftForLtr(a.x(l), c.width), l += c.width + i;
    } else {
      let s = 0, l = $n(r, this.top + t + i, this.bottom - this.columnSizes[s].height);
      for (const c of n)
        c.col !== s && (s = c.col, l = $n(r, this.top + t + i, this.bottom - this.columnSizes[s].height)), c.top = l, c.left += this.left + i, c.left = a.leftForLtr(a.x(c.left), c.width), l += c.height + i;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      rb(t, this), this._draw(), ib(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: n, lineWidths: r, ctx: i } = this, { align: o, labels: a } = t, s = Mt.color, l = _a(t.rtl, this.left, this.width), c = An(a.font), { padding: u } = a, d = c.size, p = d / 2;
    let h;
    this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = 0.5, i.font = c.string;
    const { boxWidth: g, boxHeight: m, itemHeight: v } = mE(a, d), y = function(E, C, T) {
      if (isNaN(g) || g <= 0 || isNaN(m) || m < 0)
        return;
      i.save();
      const j = we(T.lineWidth, 1);
      if (i.fillStyle = we(T.fillStyle, s), i.lineCap = we(T.lineCap, "butt"), i.lineDashOffset = we(T.lineDashOffset, 0), i.lineJoin = we(T.lineJoin, "miter"), i.lineWidth = j, i.strokeStyle = we(T.strokeStyle, s), i.setLineDash(we(T.lineDash, [])), a.usePointStyle) {
        const A = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: T.pointStyle,
          rotation: T.rotation,
          borderWidth: j
        }, M = l.xPlus(E, g / 2), P = C + p;
        Gk(i, A, M, P, a.pointStyleWidth && g);
      } else {
        const A = C + Math.max((d - m) / 2, 0), M = l.leftForLtr(E, g), P = Ea(T.borderRadius);
        i.beginPath(), Object.values(P).some((R) => R !== 0) ? wd(i, {
          x: M,
          y: A,
          w: g,
          h: m,
          radius: P
        }) : i.rect(M, A, g, m), i.fill(), j !== 0 && i.stroke();
      }
      i.restore();
    }, S = function(E, C, T) {
      xd(i, T.text, E, C + v / 2, c, {
        strikethrough: T.hidden,
        textAlign: l.textAlign(T.textAlign)
      });
    }, w = this.isHorizontal(), b = this._computeTitleHeight();
    w ? h = {
      x: $n(o, this.left + u, this.right - r[0]),
      y: this.top + u + b,
      line: 0
    } : h = {
      x: this.left + u,
      y: $n(o, this.top + b + u, this.bottom - n[0].height),
      line: 0
    }, nM(this.ctx, t.textDirection);
    const O = v + u;
    this.legendItems.forEach((E, C) => {
      i.strokeStyle = E.fontColor, i.fillStyle = E.fontColor;
      const T = i.measureText(E.text).width, j = l.textAlign(E.textAlign || (E.textAlign = a.textAlign)), A = g + p + T;
      let M = h.x, P = h.y;
      l.setWidth(this.width), w ? C > 0 && M + A + u > this.right && (P = h.y += O, h.line++, M = h.x = $n(o, this.left + u, this.right - r[h.line])) : C > 0 && P + O > this.bottom && (M = h.x = M + n[h.line].width + u, h.line++, P = h.y = $n(o, this.top + b + u, this.bottom - n[h.line].height));
      const R = l.x(M);
      if (y(R, P, E), M = BZ(j, M + g + p, w ? M + A : this.right, t.rtl), S(l.x(M), P, E), w)
        h.x += A + u;
      else if (typeof E.text != "string") {
        const N = c.lineHeight;
        h.y += xM(E, N) + u;
      } else
        h.y += O;
    }), rM(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, n = t.title, r = An(n.font), i = Or(n.padding);
    if (!n.display)
      return;
    const o = _a(t.rtl, this.left, this.width), a = this.ctx, s = n.position, l = r.size / 2, c = i.top + l;
    let u, d = this.left, p = this.width;
    if (this.isHorizontal())
      p = Math.max(...this.lineWidths), u = this.top + c, d = $n(t.align, d, this.right - p);
    else {
      const g = this.columnSizes.reduce((m, v) => Math.max(m, v.height), 0);
      u = c + $n(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());
    }
    const h = $n(s, d, d + p);
    a.textAlign = o.textAlign(Kk(s)), a.textBaseline = "middle", a.strokeStyle = n.color, a.fillStyle = n.color, a.font = r.string, xd(a, n.text, h, u, r);
  }
  _computeTitleHeight() {
    const t = this.options.title, n = An(t.font), r = Or(t.padding);
    return t.display ? n.lineHeight + r.height : 0;
  }
  _getLegendItemAt(t, n) {
    let r, i, o;
    if (Di(t, this.left, this.right) && Di(n, this.top, this.bottom)) {
      for (o = this.legendHitBoxes, r = 0; r < o.length; ++r)
        if (i = o[r], Di(t, i.left, i.left + i.width) && Di(n, i.top, i.top + i.height))
          return this.legendItems[r];
    }
    return null;
  }
  handleEvent(t) {
    const n = this.options;
    if (!Qee(t.type, n))
      return;
    const r = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const i = this._hoveredItem, o = Gee(i, r);
      i && !o && ut(n.onLeave, [
        t,
        i,
        this
      ], this), this._hoveredItem = r, r && !o && ut(n.onHover, [
        t,
        r,
        this
      ], this);
    } else r && ut(n.onClick, [
      t,
      r,
      this
    ], this);
  }
}
function Xee(e, t, n, r, i) {
  const o = Zee(r, e, t, n), a = Jee(i, r, t.lineHeight);
  return {
    itemWidth: o,
    itemHeight: a
  };
}
function Zee(e, t, n, r) {
  let i = e.text;
  return i && typeof i != "string" && (i = i.reduce((o, a) => o.length > a.length ? o : a)), t + n.size / 2 + r.measureText(i).width;
}
function Jee(e, t, n) {
  let r = e;
  return typeof t.text != "string" && (r = xM(t, n)), r;
}
function xM(e, t) {
  const n = e.text ? e.text.length : 0;
  return t * n;
}
function Qee(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var Er = {
  id: "legend",
  _element: gE,
  start(e, t, n) {
    const r = e.legend = new gE({
      ctx: e.ctx,
      options: n,
      chart: e
    });
    Ri.configure(e, r, n), Ri.addBox(e, r);
  },
  stop(e) {
    Ri.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, n) {
    const r = e.legend;
    Ri.configure(e, r, n), r.options = n;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, n) {
      const r = t.datasetIndex, i = n.chart;
      i.isDatasetVisible(r) ? (i.hide(r), t.hidden = !0) : (i.show(r), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: n, pointStyle: r, textAlign: i, color: o, useBorderRadius: a, borderRadius: s } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(n ? 0 : void 0), u = Or(c.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: o,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: r || c.pointStyle,
            rotation: c.rotation,
            textAlign: i || c.textAlign,
            borderRadius: a && (s || c.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
const Bs = {
  average(e) {
    if (!e.length)
      return !1;
    let t, n, r = /* @__PURE__ */ new Set(), i = 0, o = 0;
    for (t = 0, n = e.length; t < n; ++t) {
      const s = e[t].element;
      if (s && s.hasValue()) {
        const l = s.tooltipPosition();
        r.add(l.x), i += l.y, ++o;
      }
    }
    return o === 0 || r.size === 0 ? !1 : {
      x: [
        ...r
      ].reduce((s, l) => s + l) / r.size,
      y: i / o
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let n = t.x, r = t.y, i = Number.POSITIVE_INFINITY, o, a, s;
    for (o = 0, a = e.length; o < a; ++o) {
      const l = e[o].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), u = hg(t, c);
        u < i && (i = u, s = l);
      }
    }
    if (s) {
      const l = s.tooltipPosition();
      n = l.x, r = l.y;
    }
    return {
      x: n,
      y: r
    };
  }
};
function kr(e, t) {
  return t && (Kt(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function ti(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function ete(e, t) {
  const { element: n, datasetIndex: r, index: i } = t, o = e.getDatasetMeta(r).controller, { label: a, value: s } = o.getLabelAndValue(i);
  return {
    chart: e,
    label: a,
    parsed: o.getParsed(i),
    raw: e.data.datasets[r].data[i],
    formattedValue: s,
    dataset: o.getDataset(),
    dataIndex: i,
    datasetIndex: r,
    element: n
  };
}
function vE(e, t) {
  const n = e.chart.ctx, { body: r, footer: i, title: o } = e, { boxWidth: a, boxHeight: s } = t, l = An(t.bodyFont), c = An(t.titleFont), u = An(t.footerFont), d = o.length, p = i.length, h = r.length, g = Or(t.padding);
  let m = g.height, v = 0, y = r.reduce((b, O) => b + O.before.length + O.lines.length + O.after.length, 0);
  if (y += e.beforeBody.length + e.afterBody.length, d && (m += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), y) {
    const b = t.displayColors ? Math.max(s, l.lineHeight) : l.lineHeight;
    m += h * b + (y - h) * l.lineHeight + (y - 1) * t.bodySpacing;
  }
  p && (m += t.footerMarginTop + p * u.lineHeight + (p - 1) * t.footerSpacing);
  let S = 0;
  const w = function(b) {
    v = Math.max(v, n.measureText(b).width + S);
  };
  return n.save(), n.font = c.string, He(e.title, w), n.font = l.string, He(e.beforeBody.concat(e.afterBody), w), S = t.displayColors ? a + 2 + t.boxPadding : 0, He(r, (b) => {
    He(b.before, w), He(b.lines, w), He(b.after, w);
  }), S = 0, n.font = u.string, He(e.footer, w), n.restore(), v += g.width, {
    width: v,
    height: m
  };
}
function tte(e, t) {
  const { y: n, height: r } = t;
  return n < r / 2 ? "top" : n > e.height - r / 2 ? "bottom" : "center";
}
function nte(e, t, n, r) {
  const { x: i, width: o } = r, a = n.caretSize + n.caretPadding;
  if (e === "left" && i + o + a > t.width || e === "right" && i - o - a < 0)
    return !0;
}
function rte(e, t, n, r) {
  const { x: i, width: o } = n, { width: a, chartArea: { left: s, right: l } } = e;
  let c = "center";
  return r === "center" ? c = i <= (s + l) / 2 ? "left" : "right" : i <= o / 2 ? c = "left" : i >= a - o / 2 && (c = "right"), nte(c, e, t, n) && (c = "center"), c;
}
function yE(e, t, n) {
  const r = n.yAlign || t.yAlign || tte(e, n);
  return {
    xAlign: n.xAlign || t.xAlign || rte(e, t, n, r),
    yAlign: r
  };
}
function ite(e, t) {
  let { x: n, width: r } = e;
  return t === "right" ? n -= r : t === "center" && (n -= r / 2), n;
}
function ote(e, t, n) {
  let { y: r, height: i } = e;
  return t === "top" ? r += n : t === "bottom" ? r -= i + n : r -= i / 2, r;
}
function bE(e, t, n, r) {
  const { caretSize: i, caretPadding: o, cornerRadius: a } = e, { xAlign: s, yAlign: l } = n, c = i + o, { topLeft: u, topRight: d, bottomLeft: p, bottomRight: h } = Ea(a);
  let g = ite(t, s);
  const m = ote(t, l, c);
  return l === "center" ? s === "left" ? g += c : s === "right" && (g -= c) : s === "left" ? g -= Math.max(u, p) + i : s === "right" && (g += Math.max(d, h) + i), {
    x: fn(g, 0, r.width - t.width),
    y: fn(m, 0, r.height - t.height)
  };
}
function tu(e, t, n) {
  const r = Or(n.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - r.right : e.x + r.left;
}
function xE(e) {
  return kr([], ti(e));
}
function ate(e, t, n) {
  return Qo(e, {
    tooltip: t,
    tooltipItems: n,
    type: "tooltip"
  });
}
function wE(e, t) {
  const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return n ? e.override(n) : e;
}
const wM = {
  beforeTitle: Qr,
  title(e) {
    if (e.length > 0) {
      const t = e[0], n = t.chart.data.labels, r = n ? n.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (r > 0 && t.dataIndex < r)
        return n[t.dataIndex];
    }
    return "";
  },
  afterTitle: Qr,
  beforeBody: Qr,
  beforeLabel: Qr,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const n = e.formattedValue;
    return We(n) || (t += n), t;
  },
  labelColor(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: n.pointStyle,
      rotation: n.rotation
    };
  },
  afterLabel: Qr,
  afterBody: Qr,
  beforeFooter: Qr,
  footer: Qr,
  afterFooter: Qr
};
function En(e, t, n, r) {
  const i = e[t].call(n, r);
  return typeof i > "u" ? wM[t].call(n, r) : i;
}
class OE extends no {
  static positioners = Bs;
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const n = this.chart, r = this.options.setContext(this.getContext()), i = r.enabled && n.options.animation && r.animations, o = new oM(this.chart, i);
    return i._cacheable && (this._cachedAnimations = Object.freeze(o)), o;
  }
  getContext() {
    return this.$context || (this.$context = ate(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, n) {
    const { callbacks: r } = n, i = En(r, "beforeTitle", this, t), o = En(r, "title", this, t), a = En(r, "afterTitle", this, t);
    let s = [];
    return s = kr(s, ti(i)), s = kr(s, ti(o)), s = kr(s, ti(a)), s;
  }
  getBeforeBody(t, n) {
    return xE(En(n.callbacks, "beforeBody", this, t));
  }
  getBody(t, n) {
    const { callbacks: r } = n, i = [];
    return He(t, (o) => {
      const a = {
        before: [],
        lines: [],
        after: []
      }, s = wE(r, o);
      kr(a.before, ti(En(s, "beforeLabel", this, o))), kr(a.lines, En(s, "label", this, o)), kr(a.after, ti(En(s, "afterLabel", this, o))), i.push(a);
    }), i;
  }
  getAfterBody(t, n) {
    return xE(En(n.callbacks, "afterBody", this, t));
  }
  getFooter(t, n) {
    const { callbacks: r } = n, i = En(r, "beforeFooter", this, t), o = En(r, "footer", this, t), a = En(r, "afterFooter", this, t);
    let s = [];
    return s = kr(s, ti(i)), s = kr(s, ti(o)), s = kr(s, ti(a)), s;
  }
  _createItems(t) {
    const n = this._active, r = this.chart.data, i = [], o = [], a = [];
    let s = [], l, c;
    for (l = 0, c = n.length; l < c; ++l)
      s.push(ete(this.chart, n[l]));
    return t.filter && (s = s.filter((u, d, p) => t.filter(u, d, p, r))), t.itemSort && (s = s.sort((u, d) => t.itemSort(u, d, r))), He(s, (u) => {
      const d = wE(t.callbacks, u);
      i.push(En(d, "labelColor", this, u)), o.push(En(d, "labelPointStyle", this, u)), a.push(En(d, "labelTextColor", this, u));
    }), this.labelColors = i, this.labelPointStyles = o, this.labelTextColors = a, this.dataPoints = s, s;
  }
  update(t, n) {
    const r = this.options.setContext(this.getContext()), i = this._active;
    let o, a = [];
    if (!i.length)
      this.opacity !== 0 && (o = {
        opacity: 0
      });
    else {
      const s = Bs[r.position].call(this, i, this._eventPosition);
      a = this._createItems(r), this.title = this.getTitle(a, r), this.beforeBody = this.getBeforeBody(a, r), this.body = this.getBody(a, r), this.afterBody = this.getAfterBody(a, r), this.footer = this.getFooter(a, r);
      const l = this._size = vE(this, r), c = Object.assign({}, s, l), u = yE(this.chart, r, c), d = bE(r, c, u, this.chart);
      this.xAlign = u.xAlign, this.yAlign = u.yAlign, o = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: s.x,
        caretY: s.y
      };
    }
    this._tooltipItems = a, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && r.external && r.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: n
    });
  }
  drawCaret(t, n, r, i) {
    const o = this.getCaretPosition(t, r, i);
    n.lineTo(o.x1, o.y1), n.lineTo(o.x2, o.y2), n.lineTo(o.x3, o.y3);
  }
  getCaretPosition(t, n, r) {
    const { xAlign: i, yAlign: o } = this, { caretSize: a, cornerRadius: s } = r, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: d } = Ea(s), { x: p, y: h } = t, { width: g, height: m } = n;
    let v, y, S, w, b, O;
    return o === "center" ? (b = h + m / 2, i === "left" ? (v = p, y = v - a, w = b + a, O = b - a) : (v = p + g, y = v + a, w = b - a, O = b + a), S = v) : (i === "left" ? y = p + Math.max(l, u) + a : i === "right" ? y = p + g - Math.max(c, d) - a : y = this.caretX, o === "top" ? (w = h, b = w - a, v = y - a, S = y + a) : (w = h + m, b = w + a, v = y + a, S = y - a), O = w), {
      x1: v,
      x2: y,
      x3: S,
      y1: w,
      y2: b,
      y3: O
    };
  }
  drawTitle(t, n, r) {
    const i = this.title, o = i.length;
    let a, s, l;
    if (o) {
      const c = _a(r.rtl, this.x, this.width);
      for (t.x = tu(this, r.titleAlign, r), n.textAlign = c.textAlign(r.titleAlign), n.textBaseline = "middle", a = An(r.titleFont), s = r.titleSpacing, n.fillStyle = r.titleColor, n.font = a.string, l = 0; l < o; ++l)
        n.fillText(i[l], c.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + s, l + 1 === o && (t.y += r.titleMarginBottom - s);
    }
  }
  _drawColorBox(t, n, r, i, o) {
    const a = this.labelColors[r], s = this.labelPointStyles[r], { boxHeight: l, boxWidth: c } = o, u = An(o.bodyFont), d = tu(this, "left", o), p = i.x(d), h = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, g = n.y + h;
    if (o.usePointStyle) {
      const m = {
        radius: Math.min(c, l) / 2,
        pointStyle: s.pointStyle,
        rotation: s.rotation,
        borderWidth: 1
      }, v = i.leftForLtr(p, c) + c / 2, y = g + l / 2;
      t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, gg(t, m, v, y), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, gg(t, m, v, y);
    } else {
      t.lineWidth = Te(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;
      const m = i.leftForLtr(p, c), v = i.leftForLtr(i.xPlus(p, 1), c - 2), y = Ea(a.borderRadius);
      Object.values(y).some((S) => S !== 0) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, wd(t, {
        x: m,
        y: g,
        w: c,
        h: l,
        radius: y
      }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), wd(t, {
        x: v,
        y: g + 1,
        w: c - 2,
        h: l - 2,
        radius: y
      }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(m, g, c, l), t.strokeRect(m, g, c, l), t.fillStyle = a.backgroundColor, t.fillRect(v, g + 1, c - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[r];
  }
  drawBody(t, n, r) {
    const { body: i } = this, { bodySpacing: o, bodyAlign: a, displayColors: s, boxHeight: l, boxWidth: c, boxPadding: u } = r, d = An(r.bodyFont);
    let p = d.lineHeight, h = 0;
    const g = _a(r.rtl, this.x, this.width), m = function(T) {
      n.fillText(T, g.x(t.x + h), t.y + p / 2), t.y += p + o;
    }, v = g.textAlign(a);
    let y, S, w, b, O, E, C;
    for (n.textAlign = a, n.textBaseline = "middle", n.font = d.string, t.x = tu(this, v, r), n.fillStyle = r.bodyColor, He(this.beforeBody, m), h = s && v !== "right" ? a === "center" ? c / 2 + u : c + 2 + u : 0, b = 0, E = i.length; b < E; ++b) {
      for (y = i[b], S = this.labelTextColors[b], n.fillStyle = S, He(y.before, m), w = y.lines, s && w.length && (this._drawColorBox(n, t, b, g, r), p = Math.max(d.lineHeight, l)), O = 0, C = w.length; O < C; ++O)
        m(w[O]), p = d.lineHeight;
      He(y.after, m);
    }
    h = 0, p = d.lineHeight, He(this.afterBody, m), t.y -= o;
  }
  drawFooter(t, n, r) {
    const i = this.footer, o = i.length;
    let a, s;
    if (o) {
      const l = _a(r.rtl, this.x, this.width);
      for (t.x = tu(this, r.footerAlign, r), t.y += r.footerMarginTop, n.textAlign = l.textAlign(r.footerAlign), n.textBaseline = "middle", a = An(r.footerFont), n.fillStyle = r.footerColor, n.font = a.string, s = 0; s < o; ++s)
        n.fillText(i[s], l.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + r.footerSpacing;
    }
  }
  drawBackground(t, n, r, i) {
    const { xAlign: o, yAlign: a } = this, { x: s, y: l } = t, { width: c, height: u } = r, { topLeft: d, topRight: p, bottomLeft: h, bottomRight: g } = Ea(i.cornerRadius);
    n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.beginPath(), n.moveTo(s + d, l), a === "top" && this.drawCaret(t, n, r, i), n.lineTo(s + c - p, l), n.quadraticCurveTo(s + c, l, s + c, l + p), a === "center" && o === "right" && this.drawCaret(t, n, r, i), n.lineTo(s + c, l + u - g), n.quadraticCurveTo(s + c, l + u, s + c - g, l + u), a === "bottom" && this.drawCaret(t, n, r, i), n.lineTo(s + h, l + u), n.quadraticCurveTo(s, l + u, s, l + u - h), a === "center" && o === "left" && this.drawCaret(t, n, r, i), n.lineTo(s, l + d), n.quadraticCurveTo(s, l, s + d, l), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke();
  }
  _updateAnimationTarget(t) {
    const n = this.chart, r = this.$animations, i = r && r.x, o = r && r.y;
    if (i || o) {
      const a = Bs[t.position].call(this, this._active, this._eventPosition);
      if (!a)
        return;
      const s = this._size = vE(this, t), l = Object.assign({}, a, this._size), c = yE(n, t, l), u = bE(t, l, c, n);
      (i._to !== u.x || o._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = s.width, this.height = s.height, this.caretX = a.x, this.caretY = a.y, this._resolveAnimations().update(this, u));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const n = this.options.setContext(this.getContext());
    let r = this.opacity;
    if (!r)
      return;
    this._updateAnimationTarget(n);
    const i = {
      width: this.width,
      height: this.height
    }, o = {
      x: this.x,
      y: this.y
    };
    r = Math.abs(r) < 1e-3 ? 0 : r;
    const a = Or(n.padding), s = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && s && (t.save(), t.globalAlpha = r, this.drawBackground(o, t, i, n), nM(t, n.textDirection), o.y += a.top, this.drawTitle(o, t, n), this.drawBody(o, t, n), this.drawFooter(o, t, n), rM(t, n.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, n) {
    const r = this._active, i = t.map(({ datasetIndex: s, index: l }) => {
      const c = this.chart.getDatasetMeta(s);
      if (!c)
        throw new Error("Cannot find a dataset at index " + s);
      return {
        datasetIndex: s,
        element: c.data[l],
        index: l
      };
    }), o = !vd(r, i), a = this._positionChanged(i, n);
    (o || a) && (this._active = i, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, n, r = !0) {
    if (n && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const i = this.options, o = this._active || [], a = this._getActiveElements(t, o, n, r), s = this._positionChanged(a, t), l = n || !vd(a, o) || s;
    return l && (this._active = a, (i.enabled || i.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, n))), l;
  }
  _getActiveElements(t, n, r, i) {
    const o = this.options;
    if (t.type === "mouseout")
      return [];
    if (!i)
      return n.filter((s) => this.chart.data.datasets[s.datasetIndex] && this.chart.getDatasetMeta(s.datasetIndex).controller.getParsed(s.index) !== void 0);
    const a = this.chart.getElementsAtEventForMode(t, o.mode, o, r);
    return o.reverse && a.reverse(), a;
  }
  _positionChanged(t, n) {
    const { caretX: r, caretY: i, options: o } = this, a = Bs[o.position].call(this, t, n);
    return a !== !1 && (r !== a.x || i !== a.y);
  }
}
var _r = {
  id: "tooltip",
  _element: OE,
  positioners: Bs,
  afterInit(e, t, n) {
    n && (e.tooltip = new OE({
      chart: e,
      options: n
    }));
  },
  beforeUpdate(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  reset(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const n = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...n,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", n);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const n = t.replay;
      e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: wM
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const ste = (e, t, n, r) => (typeof t == "string" ? (n = e.push(t) - 1, r.unshift({
  index: n,
  label: t
})) : isNaN(t) && (n = null), n);
function lte(e, t, n, r) {
  const i = e.indexOf(t);
  if (i === -1)
    return ste(e, t, n, r);
  const o = e.lastIndexOf(t);
  return i !== o ? n : i;
}
const cte = (e, t) => e === null ? null : fn(Math.round(e), 0, t);
function SE(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class ro extends os {
  static id = "category";
  static defaults = {
    ticks: {
      callback: SE
    }
  };
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const n = this._addedLabels;
    if (n.length) {
      const r = this.getLabels();
      for (const { index: i, label: o } of n)
        r[i] === o && r.splice(i, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, n) {
    if (We(t))
      return null;
    const r = this.getLabels();
    return n = isFinite(n) && r[n] === t ? n : lte(r, t, we(n, t), this._addedLabels), cte(n, r.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds();
    let { min: r, max: i } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (r = 0), n || (i = this.getLabels().length - 1)), this.min = r, this.max = i;
  }
  buildTicks() {
    const t = this.min, n = this.max, r = this.options.offset, i = [];
    let o = this.getLabels();
    o = t === 0 && n === o.length - 1 ? o : o.slice(t, n + 1), this._valueRange = Math.max(o.length - (r ? 0 : 1), 1), this._startValue = this.min - (r ? 0.5 : 0);
    for (let a = t; a <= n; a++)
      i.push({
        value: a
      });
    return i;
  }
  getLabelForValue(t) {
    return SE.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function ute(e, t) {
  const n = [], { bounds: i, step: o, min: a, max: s, precision: l, count: c, maxTicks: u, maxDigits: d, includeBounds: p } = e, h = o || 1, g = u - 1, { min: m, max: v } = t, y = !We(a), S = !We(s), w = !We(c), b = (v - m) / (d + 1);
  let O = ES((v - m) / g / h) * h, E, C, T, j;
  if (O < 1e-14 && !y && !S)
    return [
      {
        value: m
      },
      {
        value: v
      }
    ];
  j = Math.ceil(v / O) - Math.floor(m / O), j > g && (O = ES(j * O / g / h) * h), We(l) || (E = Math.pow(10, l), O = Math.ceil(O * E) / E), i === "ticks" ? (C = Math.floor(m / O) * O, T = Math.ceil(v / O) * O) : (C = m, T = v), y && S && o && MZ((s - a) / o, O / 1e3) ? (j = Math.round(Math.min((s - a) / O, u)), O = (s - a) / j, C = a, T = s) : w ? (C = y ? a : C, T = S ? s : T, j = c - 1, O = (T - C) / j) : (j = (T - C) / O, Xs(j, Math.round(j), O / 1e3) ? j = Math.round(j) : j = Math.ceil(j));
  const A = Math.max(_S(O), _S(C));
  E = Math.pow(10, We(l) ? A : l), C = Math.round(C * E) / E, T = Math.round(T * E) / E;
  let M = 0;
  for (y && (p && C !== a ? (n.push({
    value: a
  }), C < a && M++, Xs(Math.round((C + M * O) * E) / E, a, EE(a, b, e)) && M++) : C < a && M++); M < j; ++M) {
    const P = Math.round((C + M * O) * E) / E;
    if (S && P > s)
      break;
    n.push({
      value: P
    });
  }
  return S && p && T !== s ? n.length && Xs(n[n.length - 1].value, s, EE(s, b, e)) ? n[n.length - 1].value = s : n.push({
    value: s
  }) : (!S || T === s) && n.push({
    value: T
  }), n;
}
function EE(e, t, { horizontal: n, minRotation: r }) {
  const i = li(r), o = (n ? Math.sin(i) : Math.cos(i)) || 1e-3, a = 0.75 * t * ("" + e).length;
  return Math.min(t / o, a);
}
class dte extends os {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, n) {
    return We(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: n, maxDefined: r } = this.getUserBounds();
    let { min: i, max: o } = this;
    const a = (l) => i = n ? i : l, s = (l) => o = r ? o : l;
    if (t) {
      const l = Br(i), c = Br(o);
      l < 0 && c < 0 ? s(0) : l > 0 && c > 0 && a(0);
    }
    if (i === o) {
      let l = o === 0 ? 1 : Math.abs(o * 0.05);
      s(o + l), t || a(i - l);
    }
    this.min = i, this.max = o;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: n, stepSize: r } = t, i;
    return r ? (i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, n = t.ticks;
    let r = this.getTickLimit();
    r = Math.max(2, r);
    const i = {
      maxTicks: r,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== !1
    }, o = this._range || this, a = ute(i, o);
    return t.bounds === "ticks" && jZ(a, this, "value"), t.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a;
  }
  configure() {
    const t = this.ticks;
    let n = this.min, r = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const i = (r - n) / Math.max(t.length - 1, 1) / 2;
      n -= i, r += i;
    }
    this._startValue = n, this._endValue = r, this._valueRange = r - n;
  }
  getLabelForValue(t) {
    return nb(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class io extends dte {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: Yk.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0);
    this.min = mr(t) ? t : 0, this.max = mr(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), n = t ? this.width : this.height, r = li(this.options.ticks.minRotation), i = (t ? Math.sin(r) : Math.cos(r)) || 1e-3, o = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, o.lineHeight / i));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
const Bf = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Cn = /* @__PURE__ */ Object.keys(Bf);
function _E(e, t) {
  return e - t;
}
function PE(e, t) {
  if (We(t))
    return null;
  const n = e._adapter, { parser: r, round: i, isoWeekday: o } = e._parseOpts;
  let a = t;
  return typeof r == "function" && (a = r(a)), mr(a) || (a = typeof r == "string" ? n.parse(a, r) : n.parse(a)), a === null ? null : (i && (a = i === "week" && (_l(o) || o === !0) ? n.startOf(a, "isoWeek", o) : n.startOf(a, i)), +a);
}
function CE(e, t, n, r) {
  const i = Cn.length;
  for (let o = Cn.indexOf(e); o < i - 1; ++o) {
    const a = Bf[Cn[o]], s = a.steps ? a.steps : Number.MAX_SAFE_INTEGER;
    if (a.common && Math.ceil((n - t) / (s * a.size)) <= r)
      return Cn[o];
  }
  return Cn[i - 1];
}
function fte(e, t, n, r, i) {
  for (let o = Cn.length - 1; o >= Cn.indexOf(n); o--) {
    const a = Cn[o];
    if (Bf[a].common && e._adapter.diff(i, r, a) >= t - 1)
      return a;
  }
  return Cn[n ? Cn.indexOf(n) : 0];
}
function pte(e) {
  for (let t = Cn.indexOf(e) + 1, n = Cn.length; t < n; ++t)
    if (Bf[Cn[t]].common)
      return Cn[t];
}
function TE(e, t, n) {
  if (!n)
    e[t] = !0;
  else if (n.length) {
    const { lo: r, hi: i } = eb(n, t), o = n[r] >= t ? n[r] : n[i];
    e[o] = !0;
  }
}
function hte(e, t, n, r) {
  const i = e._adapter, o = +i.startOf(t[0].value, r), a = t[t.length - 1].value;
  let s, l;
  for (s = o; s <= a; s = +i.add(s, 1, r))
    l = n[s], l >= 0 && (t[l].major = !0);
  return t;
}
function AE(e, t, n) {
  const r = [], i = {}, o = t.length;
  let a, s;
  for (a = 0; a < o; ++a)
    s = t[a], i[s] = a, r.push({
      value: s,
      major: !1
    });
  return o === 0 || !n ? r : hte(e, r, i, n);
}
class kE extends os {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, n = {}) {
    const r = t.time || (t.time = {}), i = this._adapter = new xQ._date(t.adapters.date);
    i.init(n), Gs(r.displayFormats, i.formats()), this._parseOpts = {
      parser: r.parser,
      round: r.round,
      isoWeekday: r.isoWeekday
    }, super.init(t), this._normalized = n.normalized;
  }
  parse(t, n) {
    return t === void 0 ? null : PE(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, n = this._adapter, r = t.time.unit || "day";
    let { min: i, max: o, minDefined: a, maxDefined: s } = this.getUserBounds();
    function l(c) {
      !a && !isNaN(c.min) && (i = Math.min(i, c.min)), !s && !isNaN(c.max) && (o = Math.max(o, c.max));
    }
    (!a || !s) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), i = mr(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r), o = mr(o) && !isNaN(o) ? o : +n.endOf(Date.now(), r) + 1, this.min = Math.min(i, o - 1), this.max = Math.max(i + 1, o);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY;
    return t.length && (n = t[0], r = t[t.length - 1]), {
      min: n,
      max: r
    };
  }
  buildTicks() {
    const t = this.options, n = t.time, r = t.ticks, i = r.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]);
    const o = this.min, a = this.max, s = $Z(i, o, a);
    return this._unit = n.unit || (r.autoSkip ? CE(n.minUnit, this.min, this.max, this._getLabelCapacity(o)) : fte(this, s.length, n.minUnit, this.min, this.max)), this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : pte(this._unit), this.initOffsets(i), t.reverse && s.reverse(), AE(this, s, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let n = 0, r = 0, i, o;
    this.options.offset && t.length && (i = this.getDecimalForValue(t[0]), t.length === 1 ? n = 1 - i : n = (this.getDecimalForValue(t[1]) - i) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? r = o : r = (o - this.getDecimalForValue(t[t.length - 2])) / 2);
    const a = t.length < 3 ? 0.5 : 0.25;
    n = fn(n, 0, a), r = fn(r, 0, a), this._offsets = {
      start: n,
      end: r,
      factor: 1 / (n + 1 + r)
    };
  }
  _generate() {
    const t = this._adapter, n = this.min, r = this.max, i = this.options, o = i.time, a = o.unit || CE(o.minUnit, n, r, this._getLabelCapacity(n)), s = we(i.ticks.stepSize, 1), l = a === "week" ? o.isoWeekday : !1, c = _l(l) || l === !0, u = {};
    let d = n, p, h;
    if (c && (d = +t.startOf(d, "isoWeek", l)), d = +t.startOf(d, c ? "day" : a), t.diff(r, n, a) > 1e5 * s)
      throw new Error(n + " and " + r + " are too far apart with stepSize of " + s + " " + a);
    const g = i.ticks.source === "data" && this.getDataTimestamps();
    for (p = d, h = 0; p < r; p = +t.add(p, s, a), h++)
      TE(u, p, g);
    return (p === r || i.bounds === "ticks" || h === 1) && TE(u, p, g), Object.keys(u).sort(_E).map((m) => +m);
  }
  getLabelForValue(t) {
    const n = this._adapter, r = this.options.time;
    return r.tooltipFormat ? n.format(t, r.tooltipFormat) : n.format(t, r.displayFormats.datetime);
  }
  format(t, n) {
    const i = this.options.time.displayFormats, o = this._unit, a = n || i[o];
    return this._adapter.format(t, a);
  }
  _tickFormatFunction(t, n, r, i) {
    const o = this.options, a = o.ticks.callback;
    if (a)
      return ut(a, [
        t,
        n,
        r
      ], this);
    const s = o.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && s[l], d = c && s[c], p = r[n], h = c && d && p && p.major;
    return this._adapter.format(t, i || (h ? d : u));
  }
  generateTickLabels(t) {
    let n, r, i;
    for (n = 0, r = t.length; n < r; ++n)
      i = t[n], i.label = this._tickFormatFunction(i.value, n, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const n = this._offsets, r = this.getDecimalForValue(t);
    return this.getPixelForDecimal((n.start + r) * n.factor);
  }
  getValueForPixel(t) {
    const n = this._offsets, r = this.getDecimalForPixel(t) / n.factor - n.end;
    return this.min + r * (this.max - this.min);
  }
  _getLabelSize(t) {
    const n = this.options.ticks, r = this.ctx.measureText(t).width, i = li(this.isHorizontal() ? n.maxRotation : n.minRotation), o = Math.cos(i), a = Math.sin(i), s = this._resolveTickFontOptions(0).size;
    return {
      w: r * o + s * a,
      h: r * a + s * o
    };
  }
  _getLabelCapacity(t) {
    const n = this.options.time, r = n.displayFormats, i = r[n.unit] || r.millisecond, o = this._tickFormatFunction(t, 0, AE(this, [
      t
    ], this._majorUnit), i), a = this._getLabelSize(o), s = Math.floor(this.isHorizontal() ? this.width / a.w : this.height / a.h) - 1;
    return s > 0 ? s : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], n, r;
    if (t.length)
      return t;
    const i = this.getMatchingVisibleMetas();
    if (this._normalized && i.length)
      return this._cache.data = i[0].controller.getAllParsedValues(this);
    for (n = 0, r = i.length; n < r; ++n)
      t = t.concat(i[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let n, r;
    if (t.length)
      return t;
    const i = this.getLabels();
    for (n = 0, r = i.length; n < r; ++n)
      t.push(PE(this, i[n]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return Uk(t.sort(_E));
  }
}
function nu(e, t, n) {
  let r = 0, i = e.length - 1, o, a, s, l;
  n ? (t >= e[r].pos && t <= e[i].pos && ({ lo: r, hi: i } = To(e, "pos", t)), { pos: o, time: s } = e[r], { pos: a, time: l } = e[i]) : (t >= e[r].time && t <= e[i].time && ({ lo: r, hi: i } = To(e, "time", t)), { time: o, pos: s } = e[r], { time: a, pos: l } = e[i]);
  const c = a - o;
  return c ? s + (l - s) * (t - o) / c : s;
}
class gne extends kE {
  static id = "timeseries";
  static defaults = kE.defaults;
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(t);
    this._minPos = nu(n, this.min), this._tableRange = nu(n, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: n, max: r } = this, i = [], o = [];
    let a, s, l, c, u;
    for (a = 0, s = t.length; a < s; ++a)
      c = t[a], c >= n && c <= r && i.push(c);
    if (i.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: r,
          pos: 1
        }
      ];
    for (a = 0, s = i.length; a < s; ++a)
      u = i[a + 1], l = i[a - 1], c = i[a], Math.round((u + l) / 2) !== c && o.push({
        time: c,
        pos: a / (s - 1)
      });
    return o;
  }
  _generate() {
    const t = this.min, n = this.max;
    let r = super.getDataTimestamps();
    return (!r.includes(t) || !r.length) && r.splice(0, 0, t), (!r.includes(n) || r.length === 1) && r.push(n), r.sort((i, o) => i - o);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const n = this.getDataTimestamps(), r = this.getLabelTimestamps();
    return n.length && r.length ? t = this.normalize(n.concat(r)) : t = n.length ? n : r, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (nu(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const n = this._offsets, r = this.getDecimalForPixel(t) / n.factor - n.end;
    return nu(this._table, r * this._tableRange + this._minPos, !0);
  }
}
const OM = "label";
function ME(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
function mte(e, t) {
  const n = e.options;
  n && t && Object.assign(n, t);
}
function SM(e, t) {
  e.labels = t;
}
function EM(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OM;
  const r = [];
  e.datasets = t.map((i) => {
    const o = e.datasets.find((a) => a[n] === i[n]);
    return !o || !i.data || r.includes(o) ? {
      ...i
    } : (r.push(o), Object.assign(o, i), o);
  });
}
function gte(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : OM;
  const n = {
    labels: [],
    datasets: []
  };
  return SM(n, e.labels), EM(n, e.datasets, t), n;
}
function vte(e, t) {
  const { height: n = 150, width: r = 300, redraw: i = !1, datasetIdKey: o, type: a, data: s, options: l, plugins: c = [], fallbackContent: u, updateMode: d, ...p } = e, h = Ne(null), g = Ne(null), m = () => {
    h.current && (g.current = new Dn(h.current, {
      type: a,
      data: gte(s, o),
      options: l && {
        ...l
      },
      plugins: c
    }), ME(t, g.current));
  }, v = () => {
    ME(t, null), g.current && (g.current.destroy(), g.current = null);
  };
  return De(() => {
    !i && g.current && l && mte(g.current, l);
  }, [
    i,
    l
  ]), De(() => {
    !i && g.current && SM(g.current.config.data, s.labels);
  }, [
    i,
    s.labels
  ]), De(() => {
    !i && g.current && s.datasets && EM(g.current.config.data, s.datasets, o);
  }, [
    i,
    s.datasets
  ]), De(() => {
    g.current && (i ? (v(), setTimeout(m)) : g.current.update(d));
  }, [
    i,
    l,
    s.labels,
    s.datasets,
    d
  ]), De(() => {
    g.current && (v(), setTimeout(m));
  }, [
    a
  ]), De(() => (m(), () => v()), []), /* @__PURE__ */ Ye.createElement("canvas", {
    ref: h,
    role: "img",
    height: n,
    width: r,
    ...p
  }, u);
}
const yte = /* @__PURE__ */ rn(vte);
function mb(e, t) {
  return Dn.register(t), /* @__PURE__ */ rn((n, r) => /* @__PURE__ */ Ye.createElement(yte, {
    ...n,
    ref: r,
    type: e
  }));
}
const gb = /* @__PURE__ */ mb("line", bQ), lc = /* @__PURE__ */ mb("bar", gQ), vb = /* @__PURE__ */ mb("doughnut", yQ);
Dn.register(fb, _r, Er);
const bte = {
  id: "centerText",
  afterDraw(e, t, n) {
    const { ctx: r } = e, i = e.getDatasetMeta(0);
    if (!i?.data?.[0]) return;
    const { x: o, y: a } = i.data[0], {
      top: s = "",
      bottom: l = "",
      topSize: c = 20,
      bottomSize: u = 10,
      topColor: d = "#0F172A",
      bottomColor: p = "#64748B"
    } = n || {};
    r.save(), r.textAlign = "center", r.textBaseline = "middle", r.fillStyle = d, r.font = `600 ${c}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(s, o, a - 5), r.fillStyle = p, r.font = `500 ${u}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(l, o, a + 12), r.restore();
  }
}, vne = ({ sold: e = 847, unsold: t = 73, growthPct: n = "+9.1%" }) => {
  const r = e + t, i = {
    labels: ["Sold", "Unsold"],
    datasets: [
      {
        data: [e, t],
        backgroundColor: ["#12B981", "#EF4444"],
        borderWidth: 2,
        hoverOffset: 4
      }
    ]
  }, o = {
    responsive: !0,
    maintainAspectRatio: !1,
    cutout: "68%",
    plugins: {
      legend: { display: !1 },
      tooltip: {
        callbacks: { label: (a) => `${a.label}: ${a.parsed}` },
        displayColors: !1
      },
      centerText: {
        top: `${r}`,
        bottom: "Total Units",
        topSize: 20,
        bottomSize: 10
      }
    }
  };
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Unit Status",
      period: "This Month",
      icon: /* @__PURE__ */ x.jsx(Lg, { className: "h-6 w-6 text-green-600" }),
      className: "h-[238px]",
      children: /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-12 gap-[16px] items-center", children: [
        /* @__PURE__ */ x.jsxs("div", { className: "col-span-5 space-y-3", children: [
          /* @__PURE__ */ x.jsxs("div", { children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] lending-[16px] text-[#64748B]", children: "Sold" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px] text-[#1FA05B]", children: e })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] lending-[16px] text-[#64748B]", children: "Unsold" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px] text-[#EF4444]", children: t })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "text-[10px] text-[#1FA05B] flex gap-[8px] items-center ", children: [
            n,
            " ",
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] text-[10px]", children: "Compared to last month" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "col-span-7", children: /* @__PURE__ */ x.jsx("div", { className: "h-[158px] w-[158px] ml-auto mr-2", children: /* @__PURE__ */ x.jsx(
          vb,
          {
            data: i,
            options: o,
            plugins: [bte]
          }
        ) }) })
      ] })
    }
  );
}, jE = ({ value: e = 0, total: t = 1, colorClass: n = "", label: r = "" }) => {
  const i = Math.max(0, Math.min(100, e / (t || 1) * 100)), o = n === "bg-[#8B5CF6]" ? "text-[#8B5CF6]" : n === "bg-[#12B981]" ? "text-[#12B981]" : "text-slate-600";
  return /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col items-start", children: [
    /* @__PURE__ */ x.jsx("div", { className: "w-2/3 min-w-[80px] h-3 rounded-full overflow-hidden", children: /* @__PURE__ */ x.jsx(
      "div",
      {
        className: `h-3 rounded-full ${n}`,
        style: { width: `${i}%` }
      }
    ) }),
    /* @__PURE__ */ x.jsx("div", { className: `${o} !text-[12px] font-bold mt-1`, children: e }),
    /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] text-[#64748B] mt-1", children: r })
  ] });
}, NE = ({ title: e, value: t, suffix: n, valueClass: r = "" }) => /* @__PURE__ */ x.jsxs("div", { className: "bg-white border border-[#EBEBEB] rounded-xl shadow-[0_0_12px_0_#EAF2FF] h-[98px] p-4 flex flex-col justify-center", children: [
  /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] leading-[16px] text-[#121212] mb-1", children: e }),
  /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: `text-[28px] leading-[32px] flex item gap-[4px] font-medium ${r}`,
      children: [
        t,
        " ",
        n && /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px] font-medium", children: n })
      ]
    }
  )
] }), yne = ({
  totalUnits: e = 847,
  occupiedUnits: t = 756,
  ownerCount: n = 700,
  tenantCount: r = 56,
  avgResidents: i = 4.4,
  avgLeaseMonths: o = 18
}) => {
  const a = n + r;
  return /* @__PURE__ */ x.jsxs("div", { children: [
    /* @__PURE__ */ x.jsxs("div", { className: "bg-white border border-[#EBEBEB] rounded-xl shadow-[0_0_12px_0_#EAF2FF] p-4 h-[128px]", children: [
      /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[12px] mb-4", children: [
        /* @__PURE__ */ x.jsx(D_, { className: "h-6 w-6 text-[#329DFF]" }),
        /* @__PURE__ */ x.jsx("div", { className: "font-medium text-[#121212]", children: "Occupancy Overview" })
      ] }),
      /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between gap-", children: [
        /* @__PURE__ */ x.jsxs("div", { children: [
          /* @__PURE__ */ x.jsx("div", { className: "text-xs leading-[16px] text-[#64748B]", children: "Occupied Units" }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px] font-medium text-[#121212]", children: t }),
            /* @__PURE__ */ x.jsxs("div", { className: "text-[#64748B] text-[20px] leading-[32px]", children: [
              "/",
              e
            ] })
          ] })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-end", children: [
          /* @__PURE__ */ x.jsx(
            jE,
            {
              value: n,
              total: a,
              colorClass: "bg-[#8B5CF6]",
              label: "Owner"
            }
          ),
          /* @__PURE__ */ x.jsx(
            jE,
            {
              value: r,
              total: a,
              colorClass: "bg-[#12B981]",
              label: "Tenant"
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "mt-2.5 grid grid-cols-2 gap-[12px]", children: [
      /* @__PURE__ */ x.jsx(
        NE,
        {
          title: "Avg Residents Per Unit",
          value: i,
          valueClass: "text-[#8B5CF6]"
        }
      ),
      /* @__PURE__ */ x.jsx(
        NE,
        {
          title: "Avg Lease Period",
          value: o,
          suffix: "months",
          valueClass: "text-[#E7A015]"
        }
      )
    ] })
  ] });
};
Dn.register(fb, _r, Er);
const xte = {
  id: "centerText",
  afterDraw(e, t, n) {
    const { ctx: r } = e, i = e.getDatasetMeta(0);
    if (!i?.data?.[0]) return;
    const { x: o, y: a } = i.data[0], {
      top: s = "",
      bottom: l = "",
      topSize: c = 20,
      bottomSize: u = 10,
      topColor: d = "#0F172A",
      bottomColor: p = "#64748B"
    } = n || {};
    r.save(), r.textAlign = "center", r.textBaseline = "middle", r.fillStyle = d, r.font = `600 ${c}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(s, o, a - 5), r.fillStyle = p, r.font = `500 ${u}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(l, o, a + 12), r.restore();
  }
}, bne = ({
  ownerCount: e = 1e3,
  tenantCount: t = 200,
  nonResidingOwners: n = 26,
  growthPct: r = "+9.1%"
}) => {
  const i = Math.max(e - n, 0), o = e + t, a = {
    labels: ["Owners", "Tenants", "Non-residing Owner"],
    datasets: [
      {
        data: [i, t, n],
        backgroundColor: ["#3C81F6", "#08B6D4", "#8B5CF6"],
        borderWidth: 2,
        hoverOffset: 4
      }
    ]
  }, s = {
    responsive: !0,
    maintainAspectRatio: !1,
    cutout: "68%",
    plugins: {
      legend: { display: !1 },
      tooltip: {
        callbacks: { label: (l) => `${l.label}: ${l.parsed}` },
        displayColors: !1
      },
      centerText: {
        top: `${o}`,
        bottom: "Total Members",
        topSize: 20,
        bottomSize: 10
      }
    }
  };
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Resident Overview",
      icon: /* @__PURE__ */ x.jsx(N_, { className: "h-6 w-6 text-[#8B5CF6]" }),
      className: "h-[238px]",
      children: /* @__PURE__ */ x.jsxs("div", { className: " flex-1 min-h-0 grid grid-cols-12 gap-[16px] items-center", children: [
        /* @__PURE__ */ x.jsxs("div", { className: "col-span-5", children: [
          /* @__PURE__ */ x.jsxs("div", { children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] text-[#64748B] leading-[16px]", children: "Total Owners" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px ]  text-[#3C81F6]", children: e })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] text-[#64748B]  leading-[16px]", children: "Total Tenants" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px ] text-[#08B6D4]", children: t })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "text-[10px] text-[#1FA05B] flex gap-2 items-center", children: [
            r,
            " ",
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] ", children: "Compared to last month" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "col-span-7", children: /* @__PURE__ */ x.jsx("div", { className: "h-[162px] w-[162px] ml-auto mr-2", children: /* @__PURE__ */ x.jsx(
          vb,
          {
            data: a,
            options: s,
            plugins: [xte]
          }
        ) }) })
      ] })
    }
  );
};
Dn.register(ro, io, sc, _r, Er);
const xne = ({
  blocks: e = [
    { name: "Block A", owner: 110, rented: 24, vacant: 8 },
    { name: "Block B", owner: 95, rented: 18, vacant: 6 },
    { name: "Block C", owner: 65, rented: 12, vacant: 18 },
    { name: "Block D", owner: 78, rented: 16, vacant: 30 }
  ]
}) => {
  const t = e.map((s) => s.name), n = e.map((s) => s.owner), r = e.map((s) => s.rented), i = e.map((s) => s.vacant), o = {
    labels: t,
    datasets: [
      {
        label: "Owner",
        data: n,
        backgroundColor: "#3C81F6",
        barThickness: 40
      },
      {
        label: "",
        data: n.map(() => 2),
        backgroundColor: "transparent",
        barThickness: 40
      },
      {
        label: "Rented",
        data: r,
        backgroundColor: "#8B5CF6",
        barThickness: 40
      },
      {
        label: "",
        data: r.map(() => 2),
        backgroundColor: "transparent",
        barThickness: 40
      },
      {
        label: "Vacant",
        data: i,
        backgroundColor: "#08B6D4",
        barThickness: 40
      }
    ]
  }, a = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          pointStyle: "rectRot",
          padding: 20
        }
      },
      tooltip: {
        callbacks: {
          label: (s) => `${s.dataset.label}: ${s.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        stacked: !0,
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        stacked: !0,
        beginAtZero: !0,
        suggestedMax: 180,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 20 }
      }
    }
  };
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Block-wise Occupancy",
      period: /* @__PURE__ */ x.jsx(xn, { className: "text-xl text-[#884EA7]" }),
      className: "w-full h-[360px]",
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ x.jsx(lc, { data: o, options: a })
    }
  );
};
Dn.register(
  ro,
  io,
  hb,
  pb,
  _r,
  Er
);
const wte = (e) => {
  const [t, n] = String(e).split(" ");
  return `${{
    Jan: "January",
    Feb: "February",
    Mar: "March",
    Apr: "April",
    May: "May",
    Jun: "June",
    Jul: "July",
    Aug: "August",
    Sep: "September",
    Oct: "October",
    Nov: "November",
    Dec: "December"
  }[t] || t} 20${n}`;
}, wne = ({
  labels: e = ["Jan 25", "Feb 25", "Mar 25", "Apr 25", "May 25"],
  moveIn: t = [24, 27, 20, 26, 23],
  moveOut: n = [12, 17, 8, 5, 16]
}) => {
  const r = {
    labels: e,
    datasets: [
      {
        label: "Move-in",
        data: t,
        borderColor: "#12B981",
        backgroundColor: "rgba(16,185,129,0.15)",
        pointBackgroundColor: "#12B981",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Move-out",
        data: n,
        borderColor: "#8B5CF6",
        backgroundColor: "rgba(124,58,237,0.15)",
        pointBackgroundColor: "#8B5CF6",
        pointStyle: "rectRot",
        fill: !1
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    interaction: { mode: "index", intersect: !1 },
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 0,
        callbacks: {
          title: (o) => wte(o[0].label),
          label: (o) => `${o.dataset.label}: ${o.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        suggestedMax: 28,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 4, precision: 0 }
      }
    },
    elements: {
      line: { borderWidth: 2, tension: 0 },
      point: { radius: 0, hoverRadius: 3, hitRadius: 10 }
    }
  };
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Move-in/Out Trends",
      className: "w-full h-[360px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "text-[20px] text-[#884EA7]" }),
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ x.jsx(gb, { data: r, options: i })
    }
  );
};
Dn.register(ro, io, hb, pb, _r, Er);
const Ote = (e) => {
  const [t, n] = String(e).split(" ");
  return `${{
    Jan: "January",
    Feb: "February",
    Mar: "March",
    Apr: "April",
    May: "May",
    Jun: "June",
    Jul: "July",
    Aug: "August",
    Sep: "September",
    Oct: "October",
    Nov: "November",
    Dec: "December"
  }[t] || t} 20${n}`;
}, Ste = ({
  labels: e = ["Jan 25", "Feb 25", "Mar 25", "Apr 25", "May 25"],
  moveIn: t = [24, 27, 20, 26, 23],
  moveOut: n = [4, 17, 8, 5, 16, 4, 7]
}) => {
  const r = {
    labels: e,
    datasets: [
      {
        label: "Income",
        data: t,
        borderColor: "#10B981",
        backgroundColor: "rgba(16,185,129,0.15)",
        pointBackgroundColor: "#10B981",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Expenditure",
        data: n,
        borderColor: "#AB0000",
        backgroundColor: "rgba(124,58,237,0.15)",
        pointBackgroundColor: "#AB0000",
        pointStyle: "rectRot",
        fill: !1
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    interaction: { mode: "index", intersect: !1 },
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 0,
        callbacks: {
          title: (o) => Ote(o[0].label),
          label: (o) => `${o.dataset.label}: ${o.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        suggestedMax: 28,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 4, precision: 0 }
      }
    },
    elements: {
      line: { borderWidth: 2, tension: 0 },
      point: { radius: 0, hoverRadius: 3, hitRadius: 10 }
    }
  };
  return /* @__PURE__ */ x.jsx(gb, { data: r, options: i });
};
function DE({
  label: e,
  value: t,
  positive: n,
  bgColor: r,
  delta: i,
  deltaLabel: o,
  textColor: a
}) {
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: `rounded-lg p-4 ${r} border border-[#EBEBEB] h-[126px]`,
      children: [
        /* @__PURE__ */ x.jsx("div", { className: `text-[16px] leading-[20px] ${a}`, children: e }),
        /* @__PURE__ */ x.jsx("div", { className: "mt-[16px] leading-[28px]  !text-[24px] font-medium text-[#121212]", children: t }),
        /* @__PURE__ */ x.jsxs("div", { className: "mt-[8px] flex items-center gap-[8px] leading-[14px] text-[10px]", children: [
          /* @__PURE__ */ x.jsx(
            "div",
            {
              className: n ? "text-[#1FA05B] font-medium" : "text-[#EF4444] font-medium",
              children: i
            }
          ),
          /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] ", children: o })
        ] })
      ]
    }
  );
}
function One() {
  return /* @__PURE__ */ x.jsxs(
    ft,
    {
      title: "Accounting",
      className: "w-full h-[523px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-2 gap-[16px]", children: [
          /* @__PURE__ */ x.jsx(
            DE,
            {
              label: "Total Income",
              value: "AED 5.68M",
              delta: "+4.4%",
              positive: !0,
              bgColor: "bg-slate-50",
              deltaLabel: "Compared to last month",
              textColor: "text-[#1FA05B]"
            }
          ),
          /* @__PURE__ */ x.jsx(
            DE,
            {
              label: "Total Expenditure",
              value: "AED 1.83M",
              delta: "-1.1%",
              positive: !1,
              bgColor: "bg-slate-50",
              deltaLabel: "Compared to last month",
              textColor: "text-[#AB0000]"
            }
          )
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "h-[254px] mt-[35.5px]", children: /* @__PURE__ */ x.jsx(Ste, {}) })
      ]
    }
  );
}
Dn.register(ro, io, sc, _r, Er);
const Sne = () => {
  const e = [
    "Maintenance",
    "Security",
    "Utilities",
    "Housekeeping",
    "Administration",
    "Others"
  ], r = {
    labels: e,
    datasets: [
      {
        label: "Budget",
        data: [55e3, 56e3, 64e3, 38e3, 54e3, 65e3],
        backgroundColor: "#93C5FD",
        barThickness: 60
      },
      {
        label: "Actual",
        data: [63e3, 48e3, 51300, 28e3, 42e3, 35e3],
        backgroundColor: "#3B82F6",
        barThickness: 60
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          pointStyle: "rectRot",
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 6,
        callbacks: {
          title: (o) => e[o[0].dataIndex],
          label: (o) => {
            const a = o.parsed.y;
            return `${o.dataset.label}: AED ${(a / 1e3).toFixed(1)}K`;
          }
        }
      }
    },
    scales: {
      x: {
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        grid: { color: "#F1F5F9" },
        ticks: {
          color: "#64748B",
          callback: (o) => `${o / 1e3}K`
        }
      }
    }
  };
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Budget vs Actuals",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ x.jsx(lc, { data: r, options: i })
    }
  );
}, Ene = () => {
  const e = [
    { title: "Primary Account", amount: 285e4, subtitle: "Savings" },
    { title: "Emergency Fund", amount: 12e5, subtitle: "Fixed deposit" },
    { title: "Maintenance Fund", amount: 68e4, subtitle: "Current" }
  ], t = e.reduce((r, i) => r + i.amount, 0), n = (r) => r >= 1e6 ? `AED ${(r / 1e6).toFixed(2)}M` : r >= 1e3 ? `AED ${(r / 1e3).toFixed(1)}K` : `AED ${r}`;
  return /* @__PURE__ */ x.jsxs(
    ft,
    {
      title: "Cash & Bank Balance",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      children: [
        /* @__PURE__ */ x.jsx("div", { className: "flex flex-col gap-[12px]", children: e.map((r, i) => /* @__PURE__ */ x.jsxs(
          "div",
          {
            className: "flex items-center justify-between bg-[#F9FAFB] rounded-lg p-3",
            children: [
              /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col", children: [
                /* @__PURE__ */ x.jsx("div", { className: "text-[14px] font-medium text-[#121212]", children: r.title }),
                /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] text-[#64748B]", children: r?.subtitle })
              ] }),
              /* @__PURE__ */ x.jsx("div", { className: "flex flex-col items-end", children: /* @__PURE__ */ x.jsx("div", { className: "text-[14px] text-[#1FA05B] font-semibold", children: n(r.amount) }) })
            ]
          },
          i
        )) }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between border-t border-[#EBEBEB] h-[68px] px-3", children: [
          /* @__PURE__ */ x.jsx("div", { className: "text-[14px] font-medium text-[#121212]", children: "Total" }),
          /* @__PURE__ */ x.jsx("div", { className: "text-[16px] text-[#1FA05B] font-bold", children: n(t) })
        ] })
      ]
    }
  );
};
Dn.register(ro, io, sc, _r, Er);
const _ne = () => {
  const e = ["Current Month", "1-3 Months", "3-6 Months", "6+ Months"], t = [13e3, 9400, 8800, 7200], n = [18, 12, 18, 6], r = {
    labels: e,
    datasets: [
      {
        label: "Due",
        data: t,
        backgroundColor: "#EF4444",
        barThickness: 60
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: { display: !1 },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 6,
        callbacks: {
          title: (o) => e[o[0].dataIndex],
          label: (o) => `Due: AED ${(o.parsed.y / 1e3).toFixed(1)}K`,
          afterLabel: (o) => `Units Count: ${n[o.dataIndex]}`
        }
      }
    },
    scales: {
      x: {
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        grid: { color: "#F1F5F9" },
        ticks: {
          color: "#64748B",
          callback: (o) => `${o / 1e3}K`
        }
      }
    }
  };
  return /* @__PURE__ */ x.jsxs(
    ft,
    {
      title: "Dues Ageing",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: [
        /* @__PURE__ */ x.jsx("div", { className: "grid grid-cols-4 md:grid-cols-4 gap-[12px] h-[48px]", children: e.map((o, a) => /* @__PURE__ */ x.jsx("div", { className: "p-2 rounded-lg bg-slate-50", children: /* @__PURE__ */ x.jsxs("div", { className: "flex justify-between items-start", children: [
          /* @__PURE__ */ x.jsx("div", { className: "font-medium leading-[16px] !text-[12px] rounded", children: o }),
          /* @__PURE__ */ x.jsxs("div", { className: "text-right", children: [
            /* @__PURE__ */ x.jsxs("div", { className: "text-red-600 font-medium leading-[16px] !text-[12px]", children: [
              "AED ",
              (t[a] / 1e3).toFixed(1),
              "K"
            ] }),
            /* @__PURE__ */ x.jsxs("div", { className: " text-gray-500 leading-[14px] text-[10px]", children: [
              n[a],
              " Units"
            ] })
          ] })
        ] }) }, o)) }),
        /* @__PURE__ */ x.jsx("div", { className: "h-[192px]", children: /* @__PURE__ */ x.jsx(lc, { data: r, options: i }) })
      ]
    }
  );
};
Dn.register(fb, _r, Er);
const Pne = () => {
  const e = [
    "Maintenance",
    "Utilities",
    "Security",
    "Administration",
    "Others"
  ], t = [45e4, 32e4, 28e4, 18e4, 12e4], n = {
    labels: e,
    datasets: [
      {
        label: "Expenses",
        data: t,
        backgroundColor: [
          "#08B6D4",
          "#8B5CF6",
          "#EF4444",
          "#F69E0A",
          "#12B981"
        ],
        borderColor: "#FFFFFF",
        borderWidth: 2,
        cutout: "70%"
      }
    ]
  }, r = t.reduce((o, a) => o + a, 0), i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: { display: !1 },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 10,
        callbacks: {
          label: (o) => `${o.label}: AED ${o.formattedValue}`
        }
      }
    }
  };
  return /* @__PURE__ */ x.jsxs(
    ft,
    {
      title: "Expense Categories",
      className: "w-full h-[523px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: "relative h-[259px] flex justify-center items-center", children: [
          /* @__PURE__ */ x.jsx(vb, { data: n, options: i }),
          /* @__PURE__ */ x.jsxs("div", { className: "absolute text-center", children: [
            /* @__PURE__ */ x.jsxs("div", { className: "!text-[24px] font-medium leading-[28px] text-[#121212]", children: [
              "AED ",
              (r / 1e6).toFixed(2),
              "M"
            ] }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[#121212] leading-[18px] text-[14px]", children: "Total Expenses" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "space-y-2", children: e.map((o, a) => /* @__PURE__ */ x.jsxs(
          "div",
          {
            className: "flex justify-between items-center text-[14px] pb-2",
            children: [
              /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px] !text-[12px] leading-[16px] text-[#64748B]", children: [
                /* @__PURE__ */ x.jsx(
                  "div",
                  {
                    className: "w-[7px] h-[7px] rotate-45",
                    style: { backgroundColor: n.datasets[0].backgroundColor[a] }
                  }
                ),
                o
              ] }),
              /* @__PURE__ */ x.jsxs("div", { className: "leading-[16px] !text-[12px] text-[#64748B]", children: [
                "AED ",
                (t[a] / 1e3).toFixed(0),
                "K"
              ] })
            ]
          },
          o
        )) })
      ]
    }
  );
}, As = [
  { name: "Gym Equipment", value: 1e6, color: "#08B6D4" },
  { name: "Security", value: 8e5, color: "#EF4444" },
  { name: "Others", value: 6e5, color: "#F59E0B" },
  { name: "Pool Maintenance", value: 7e5, color: "#8B5CF6" },
  { name: "Administration", value: 52e4, color: "#10B981" }
];
function Cne() {
  const e = As.reduce((t, n) => t + n.value, 0);
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Asset Value Breakdown",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
        /* @__PURE__ */ x.jsxs("div", { className: "w-[214px] h-[181px] relative", children: [
          /* @__PURE__ */ x.jsx(Zo, { width: "100%", height: "100%", children: /* @__PURE__ */ x.jsxs(Sf, { children: [
            /* @__PURE__ */ x.jsx(
              tc,
              {
                data: As,
                innerRadius: 60,
                outerRadius: 90,
                paddingAngle: 2,
                dataKey: "value",
                nameKey: "name",
                children: As.map((t, n) => /* @__PURE__ */ x.jsx(Hr, { fill: t.color }, `cell-${n}`))
              }
            ),
            /* @__PURE__ */ x.jsx(Xo, { formatter: (t) => `AED ${t.toLocaleString()}` })
          ] }) }),
          /* @__PURE__ */ x.jsxs("div", { className: "absolute inset-0 flex flex-col items-center justify-center pointer-events-none", children: [
            /* @__PURE__ */ x.jsxs("div", { className: "font-medium text-lg leading-[12px] ", children: [
              "AED ",
              (e / 1e6).toFixed(2),
              "M"
            ] }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[10px] leading-[12.59px] text-[#121212] mt-[6px]", children: "Total Assets" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex justify-between w-full px-4 sm:px-8 mt-4 text-[14px]", children: [
          /* @__PURE__ */ x.jsx("div", { className: "flex flex-col gap-[8px]", children: As.slice(0, 3).map((t) => /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px]", children: [
            /* @__PURE__ */ x.jsx(
              "div",
              {
                className: "inline-block h-[7px] w-[7px] rotate-45",
                style: { backgroundColor: t.color }
              }
            ),
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] leading-[16px] !text-[12px]", children: t.name })
          ] }, t.name)) }),
          /* @__PURE__ */ x.jsx("div", { className: "flex flex-col gap-[8px] items-start", children: As.slice(3).map((t) => /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px]", children: [
            /* @__PURE__ */ x.jsx(
              "div",
              {
                className: "inline-block h-[7px] w-[7px] rotate-45",
                style: { backgroundColor: t.color }
              }
            ),
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] leading-[16px] !text-[12px]", children: t.name })
          ] }, t.name)) })
        ] })
      ] })
    }
  );
}
Dn.register(ro, io, sc, _r, Er);
const Tne = () => {
  const e = [
    "Gym",
    "Parking",
    "Swimming Pool",
    "Community Hall",
    "Tennis Court"
  ], t = [13e3, 9400, 8800, 7200, 6e3], n = [18, 12, 18, 6], r = {
    labels: e,
    datasets: [
      {
        label: "Due",
        data: t,
        backgroundColor: "#8B5CF6",
        barThickness: 60
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: { display: !1 },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 6,
        callbacks: {
          title: (o) => e[o[0].dataIndex],
          label: (o) => `Due: AED ${(o.parsed.y / 1e3).toFixed(1)}K`,
          afterLabel: (o) => `Units Count: ${n[o.dataIndex]}`
        }
      }
    },
    scales: {
      x: {
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        grid: { color: "#F1F5F9" },
        ticks: {
          color: "#64748B",
          callback: (o) => `${o / 1e3}K`
        }
      }
    }
  };
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Revenue by Category",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ x.jsx(lc, { data: r, options: i })
    }
  );
};
function Ete(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M15 5l0 2" }, child: [] }, { tag: "path", attr: { d: "M15 11l0 2" }, child: [] }, { tag: "path", attr: { d: "M15 17l0 2" }, child: [] }, { tag: "path", attr: { d: "M5 5h14a2 2 0 0 1 2 2v3a2 2 0 0 0 0 4v3a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-3a2 2 0 0 0 0 -4v-3a2 2 0 0 1 2 -2" }, child: [] }] })(e);
}
function _te(e) {
  return Qe({ attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M855.7 210.8l-42.4-42.4a8.03 8.03 0 0 0-11.3 0L168.3 801.9a8.03 8.03 0 0 0 0 11.3l42.4 42.4c3.1 3.1 8.2 3.1 11.3 0L855.6 222c3.2-3 3.2-8.1.1-11.2zM304 448c79.4 0 144-64.6 144-144s-64.6-144-144-144-144 64.6-144 144 64.6 144 144 144zm0-216c39.7 0 72 32.3 72 72s-32.3 72-72 72-72-32.3-72-72 32.3-72 72-72zm416 344c-79.4 0-144 64.6-144 144s64.6 144 144 144 144-64.6 144-144-64.6-144-144-144zm0 216c-39.7 0-72-32.3-72-72s32.3-72 72-72 72 32.3 72 72-32.3 72-72 72z" }, child: [] }] })(e);
}
function Pte({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Dl,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ x.jsxs(
    ft,
    {
      title: e,
      icon: /* @__PURE__ */ x.jsx("div", { className: "h-6 w-6 grid place-items-center", children: /* @__PURE__ */ x.jsx(o, { className: `h-6 w-6 ${a}` }) }),
      children: [
        /* @__PURE__ */ x.jsx("div", { className: "text-4xl font-semibold tracking-tight text-[#121212]", children: t }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px] text-[14px]", children: [
          /* @__PURE__ */ x.jsx(
            "div",
            {
              className: i ? "text-emerald-600 font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ x.jsx("div", { className: "text-slate-500", children: r })
        ] })
      ]
    }
  );
}
function Ane() {
  const e = [
    {
      title: "Total Bookings",
      value: 160,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: j_,
      iconColor: "text-emerald-600"
    },
    {
      title: "Utilisation Rate",
      value: 73,
      delta: "+2.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: _te,
      iconColor: "text-[#329DFF]"
    },
    {
      title: "Revenue",
      value: 3,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: Ete,
      iconColor: "text-[#FA7E28]"
    },
    {
      title: "Pending Dues",
      value: 5,
      delta: "-8.0%",
      deltaLabel: "Compared to last month",
      positive: !1,
      Icon: R_,
      iconColor: "text-[#DBB467]"
    }
  ];
  return /* @__PURE__ */ x.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-[24px]", children: e.map((t, n) => /* @__PURE__ */ x.jsx(Pte, { ...t }, n)) });
}
const ru = [
  { name: "Completed", value: 46, color: "#12B981" },
  { name: "Delayed", value: 2, color: "#EF4444" },
  { name: "Missed", value: 2, color: "#F69E0A" }
];
function kne() {
  const t = ru.find((n) => n.name === "Completed")?.value || 0;
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Guard Patrols",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
        /* @__PURE__ */ x.jsxs("div", { className: "w-[215px] h-[182px] relative", children: [
          /* @__PURE__ */ x.jsx(Zo, { width: "100%", height: "100%", children: /* @__PURE__ */ x.jsxs(Sf, { children: [
            /* @__PURE__ */ x.jsx(
              tc,
              {
                data: ru,
                innerRadius: 60,
                outerRadius: 90,
                paddingAngle: 2,
                dataKey: "value",
                nameKey: "name",
                children: ru.map((n, r) => /* @__PURE__ */ x.jsx(Hr, { fill: n.color }, `cell-${r}`))
              }
            ),
            /* @__PURE__ */ x.jsx(Xo, { formatter: (n) => n.toLocaleString() })
          ] }) }),
          /* @__PURE__ */ x.jsxs("div", { className: "absolute inset-0 flex flex-col items-center justify-center pointer-events-none", children: [
            /* @__PURE__ */ x.jsxs("div", { className: "font-medium text-[19.35px] leading-[23.65px] ", children: [
              t,
              "/",
              50
            ] }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[10.75px] leading-[15.05px] text-[#64748B]", children: "Completed" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { className: "flex flex-col gap-[8px] mt-3 w-full px-6 text-[14px]", children: ru.map((n) => /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px]", children: [
            /* @__PURE__ */ x.jsx(
              "div",
              {
                className: "inline-block w-[7px] h-[7px] rotate-45",
                style: { backgroundColor: n.color }
              }
            ),
            /* @__PURE__ */ x.jsx("div", { className: "leading-[16.09px] text-[12.07px] text-[#64748B]", children: n.name })
          ] }),
          /* @__PURE__ */ x.jsx("div", { className: "leading-[16.09px] text-[12.07px] text-[#64748B]", children: n.value })
        ] }, n.name)) })
      ] })
    }
  );
}
Dn.register(
  ro,
  io,
  hb,
  pb,
  _r,
  Er
);
const Mne = () => {
  const t = {
    labels: ["10 AM", "12 PM", "2 PM", "4 PM", "6 PM", "8 PM", "10 PM"],
    datasets: [
      {
        label: "Guest",
        data: [9, 5, 12, 7, 3, 6, 4],
        borderColor: "#EF4444",
        backgroundColor: "rgba(239,68,68,0.15)",
        pointBackgroundColor: "#EF4444",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Cab",
        data: [15, 12, 10, 14, 7, 12, 8],
        borderColor: "#7C3AED",
        backgroundColor: "rgba(124,58,237,0.15)",
        pointBackgroundColor: "#7C3AED",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Delivery",
        data: [22, 18, 16, 20, 22, 14, 17],
        borderColor: "#10B981",
        backgroundColor: "rgba(16,185,129,0.15)",
        pointBackgroundColor: "#10B981",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Service",
        data: [13, 12, 8, 9, 5, 10, 7],
        borderColor: "#F59E0B",
        backgroundColor: "rgba(245,158,11,0.15)",
        pointBackgroundColor: "#F59E0B",
        pointStyle: "rectRot",
        fill: !1
      }
    ]
  }, n = {
    responsive: !0,
    maintainAspectRatio: !1,
    interaction: { mode: "index", intersect: !1 },
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 0,
        callbacks: {
          title: (r) => r[0].label,
          label: (r) => `${r.dataset.label}  ${r.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        suggestedMax: 28,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 4, precision: 0 }
      }
    },
    elements: {
      line: { borderWidth: 2, tension: 0 },
      point: { radius: 0, hoverRadius: 3, hitRadius: 10 }
    }
  };
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Hourly Traffic Flow",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ x.jsx(xn, { className: "text-[20px] text-[#884EA7]" }),
      children: /* @__PURE__ */ x.jsx(gb, { data: t, options: n })
    }
  );
};
function jne() {
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Incident Reports",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsxs("div", { className: "flex w-full text-center gap-[24px]", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex-1 py-3 bg-[#FBF4F4] h-[76px] rounded", children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[24px] leading-[28px] font-medium text-[#AB0000]", children: "3" }),
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] leading-[16px] text-[#AB0000]", children: "Open" })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex-1 py-3 bg-[#FFFBF2] h-[76px] rounded", children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[24px] leading-[28px] font-medium text-[#E7A015]", children: "5" }),
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] leading-[16px] text-[#E7A015]", children: "In-progress" })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex-1 py-3 bg-[#F7FEFA] h-[76px] rounded", children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[24px] leading-[28px] font-medium text-[#1FA05B]", children: "12" }),
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] leading-[16px] text-[#1FA05B]", children: "Closed" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "mt-4 ", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between p-3 bg-[#FAFBFD] rounded-md border border-[#FAFBFD]", children: [
            /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px]", children: [
              /* @__PURE__ */ x.jsx("div", { className: "w-4 h-4 rounded-full flex items-center justify-center bg-[#AB0000]", children: /* @__PURE__ */ x.jsx("div", { className: "text-white !text-[12px] font-bold", children: "!" }) }),
              /* @__PURE__ */ x.jsx("div", { className: "text-gray-700 font-medium", children: "INC 001" })
            ] }),
            /* @__PURE__ */ x.jsxs("div", { className: "px-3 py-1 rounded-full !text-[12px] font-semibold flex items-center gap-[4px] text-[#AB0000] bg-red-50", children: [
              /* @__PURE__ */ x.jsx("div", { children: "4 - Danger" }),
              /* @__PURE__ */ x.jsx("div", { className: "w-2 h-2 rounded-full bg-[#AB0000]" })
            ] })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between p-3 bg-[#FAFBFD] rounded-md border border-[#FAFBFD]", children: [
            /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px]", children: [
              /* @__PURE__ */ x.jsx("div", { className: "w-4 h-4 rounded-full flex items-center justify-center bg-[#E7A015]", children: /* @__PURE__ */ x.jsx(S0, { className: "text-white text-[10px]" }) }),
              /* @__PURE__ */ x.jsx("div", { className: "text-gray-700 font-medium", children: "INC 002" })
            ] }),
            /* @__PURE__ */ x.jsxs("div", { className: "px-3 py-1 rounded-full !text-[12px] font-semibold flex items-center gap-[4px] text-[#E7A015] bg-yellow-50", children: [
              /* @__PURE__ */ x.jsx("div", { children: "3 - High" }),
              /* @__PURE__ */ x.jsx("div", { className: "w-2 h-2 rounded-full bg-[#E7A015]" })
            ] })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between p-3 bg-[#FAFBFD] rounded-md border border-[#FAFBFD]", children: [
            /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px]", children: [
              /* @__PURE__ */ x.jsx("div", { className: "w-4 h-4 rounded-full flex items-center justify-center bg-[#1FA05B]", children: /* @__PURE__ */ x.jsx(S0, { className: "text-white text-[10px]" }) }),
              /* @__PURE__ */ x.jsx("div", { className: "text-gray-700 font-medium", children: "INC 003" })
            ] }),
            /* @__PURE__ */ x.jsxs("div", { className: "px-3 py-1 rounded-full !text-[12px] font-semibold flex items-center gap-[4px] text-[#1FA05B] bg-green-50", children: [
              /* @__PURE__ */ x.jsx("div", { children: "1 - Low" }),
              /* @__PURE__ */ x.jsx("div", { className: "w-2 h-2 rounded-full bg-[#1FA05B]" })
            ] })
          ] })
        ] })
      ] })
    }
  );
}
function Nne() {
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Staff Attendance",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsxs("div", { className: "flex w-full text-center h-[76px] gap-[16px] mb-2", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex-1 py-4 bg-green-50 rounded-md", children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[24px] leading-[18px] font-medium text-[#1FA05B] pb-[8px]", children: "25" }),
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] leading-[16px] text-[#1FA05B]", children: "Present" })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex-1 py-4 bg-red-50 rounded-md", children: [
            /* @__PURE__ */ x.jsx("div", { className: "!text-[24px] leading-[18px] font-medium text-[#AB0000] pb-[8px]", children: "1" }),
            /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] leading-[16px] text-[#AB0000]", children: "Absent" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "mt-[24px] ", children: [
          /* @__PURE__ */ x.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ x.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Security guards" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "12/12 Present" })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ x.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Housekeeping" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "7/8 Present" })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ x.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Maintenance" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "4/4 Present" })
          ] }),
          /* @__PURE__ */ x.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ x.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Gardening" }),
            /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "2/2 Present" })
          ] })
        ] })
      ] })
    }
  );
}
function Cte(e) {
  return Qe({ attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M116,132V96a12,12,0,0,1,24,0v36a12,12,0,0,1-24,0Zm12,56a16,16,0,1,0-16-16A16,16,0,0,0,128,188ZM228,56v56c0,54.29-26.32,87.22-48.4,105.29-23.71,19.39-47.44,26-48.44,26.29a12.1,12.1,0,0,1-6.32,0c-1-.28-24.73-6.9-48.44-26.29C54.32,199.22,28,166.29,28,112V56A20,20,0,0,1,48,36H208A20,20,0,0,1,228,56Zm-24,4H52v52c0,35.71,13.09,64.69,38.91,86.15A126.14,126.14,0,0,0,128,219.38a126.28,126.28,0,0,0,37.09-21.23C190.91,176.69,204,147.71,204,112Z" }, child: [] }] })(e);
}
function Tte({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Dl,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ x.jsxs(
    ft,
    {
      title: e,
      icon: /* @__PURE__ */ x.jsx("div", { className: "h-6 w-6 grid place-items-center", children: /* @__PURE__ */ x.jsx(o, { className: `h-6 w-6 ${a}` }) }),
      children: [
        /* @__PURE__ */ x.jsx("div", { className: "text-4xl font-semibold tracking-tight text-[#121212]", children: t }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px] text-[14px]", children: [
          /* @__PURE__ */ x.jsx(
            "div",
            {
              className: i ? "text-emerald-600 font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ x.jsx("div", { className: "text-slate-500", children: r })
        ] })
      ]
    }
  );
}
function Dne() {
  const e = [
    {
      title: "Total Visitors",
      value: 160,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: D_,
      iconColor: "text-[#329DFF]"
    },
    {
      title: "Active Incidents",
      value: 73,
      delta: "+2.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: dX,
      iconColor: "text-[#F69E0A]"
    },
    {
      title: "Missed Patrols",
      value: 3,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: Cte,
      iconColor: "text-[#AB0000]"
    },
    {
      title: "Parking Usage",
      value: 5,
      delta: "-8.0%",
      deltaLabel: "Compared to last month",
      positive: !1,
      Icon: CR,
      iconColor: "text-[#36AB6C]"
    }
  ];
  return /* @__PURE__ */ x.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-[24px]", children: e.map((t, n) => /* @__PURE__ */ x.jsx(Tte, { ...t }, n)) });
}
const Ate = [
  { title: "Maintenance", total: 12, pending: 3 },
  { title: "Security", total: 8, pending: 1 },
  { title: "Housekeeping", total: 6, pending: 2 },
  { title: "Utilities", total: 10, pending: 4 }
];
function Rne({ data: e }) {
  console.log(e, "complaints data");
  const t = Array.isArray(e?.complaints_by_category) && e.complaints_by_category.length > 0 ? e.complaints_by_category.map((n) => ({
    title: n.category_name || "",
    total: n.total || 0,
    pending: n.pending || 0
  })) : Ate;
  return /* @__PURE__ */ x.jsx(ft, { title: "Complaints", className: "h-[362px]", children: /* @__PURE__ */ x.jsx("div", { className: "flex flex-col gap-[12px]", children: t.map((n, r) => /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: "flex items-center justify-between bg-[#F9FAFB] rounded-lg p-3 h-[62px]",
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ x.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-[#121212]", children: n.title }),
          /* @__PURE__ */ x.jsxs("div", { className: "text-[12px] leading-[16px] text-[#64748B]", children: [
            "Total: ",
            n.total
          ] })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col items-end", children: [
          /* @__PURE__ */ x.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-red-700", children: String(n.pending).padStart(2, "0") }),
          /* @__PURE__ */ x.jsx("div", { className: "text-[12px] leading-[16px] text-[#64748B]", children: "Pending" })
        ] })
      ]
    },
    r
  )) }) });
}
Dn.register(ro, io, sc, _r, Er);
const RE = [
  { key: "closed_count", label: "Closed", color: "#12B981" },
  { key: "in_progress_count", label: "In Progress", color: "#F59D0D" },
  { key: "open_count", label: "Open", color: "#EF4444" }
], kte = [
  {
    level: "L1",
    open_count: 4,
    in_progress_count: 3,
    closed_count: 8,
    total: 15
  },
  {
    level: "L2",
    open_count: 3,
    in_progress_count: 2,
    closed_count: 6,
    total: 11
  },
  {
    level: "L3",
    open_count: 2,
    in_progress_count: 1,
    closed_count: 4,
    total: 7
  }
], Ine = ({ data: e }) => {
  console.log(e, "data for complaint");
  const t = Array.isArray(e?.complaints_by_level) && e.complaints_by_level.length > 0 ? e.complaints_by_level : kte, n = Un(() => {
    const i = t.map((l) => l.level || ""), o = Math.max(
      ...t.map((l) => Number(l.total) || 0),
      0
    ), a = t.map(() => 1), s = RE.flatMap((l, c) => [
      {
        label: l.label,
        data: t.map((u) => Number(u[l.key]) || 0),
        backgroundColor: l.color,
        barThickness: 44
      },
      ...c < RE.length - 1 ? [
        {
          label: "",
          data: a,
          backgroundColor: "transparent",
          barThickness: 44
        }
      ] : []
    ]);
    return { labels: i, datasets: s, maxTotal: o };
  }, [t]), r = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10
        }
      },
      tooltip: {
        callbacks: {
          label: (i) => i.dataset.label ? `${i.dataset.label}: ${i.parsed.y}` : null
        }
      }
    },
    scales: {
      x: {
        stacked: !0,
        grid: { display: !1 }
      },
      y: {
        stacked: !0,
        beginAtZero: !0,
        suggestedMax: Math.ceil(n.maxTotal * 1.2) || 5,
        ticks: {
          stepSize: Math.max(Math.ceil(n.maxTotal / 6), 1)
        }
      }
    }
  };
  return /* @__PURE__ */ x.jsx(ft, { title: "Complaints by Level", className: "w-full h-[362px]", children: /* @__PURE__ */ x.jsx(lc, { data: n, options: r }) });
}, Mte = [
  { title: "Maintenance", total: 18, pending: 4 },
  { title: "Security", total: 11, pending: 2 },
  { title: "Housekeeping", total: 9, pending: 3 },
  { title: "Utilities", total: 14, pending: 5 }
];
function $ne({ data: e }) {
  console.log(e, "request box data");
  const t = Array.isArray(e?.request_box_by_type) && e.request_box_by_type.length > 0 ? e.request_box_by_type.map((n) => ({
    title: n.category_name || "",
    total: Number(n.total) || 0,
    pending: Number(n.pending) || 0
  })) : Mte;
  return console.log(t, "requests"), /* @__PURE__ */ x.jsx(ft, { title: "Request Box", className: "h-[362px]", children: /* @__PURE__ */ x.jsx("div", { className: "flex flex-col gap-[12px]", children: t.map((n, r) => /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: "flex items-center justify-between bg-[#F9FAFB] rounded-lg p-3 h-[62px]",
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ x.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-[#121212]", children: n.title }),
          /* @__PURE__ */ x.jsxs("div", { className: "text-[12px] leading-[16px] text-[#64748B]", children: [
            "Total: ",
            n.total
          ] })
        ] }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex flex-col items-end", children: [
          /* @__PURE__ */ x.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-red-700", children: String(n.pending).padStart(2, "0") }),
          /* @__PURE__ */ x.jsx("div", { className: "text-[12px] leading-[16px] text-[#64748B]", children: "Pending" })
        ] })
      ]
    },
    `${n.title}-${r}`
  )) }) });
}
function jte(e) {
  return Qe({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinejoin: "round", strokeWidth: "32", d: "M416 221.25V416a48 48 0 0 1-48 48H144a48 48 0 0 1-48-48V96a48 48 0 0 1 48-48h98.75a32 32 0 0 1 22.62 9.37l141.26 141.26a32 32 0 0 1 9.37 22.62z" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M256 56v120a32 32 0 0 0 32 32h120m-232 80h160m-160 80h160" }, child: [] }] })(e);
}
const Nte = [
  "open_complaints",
  "pending_requests",
  "avg_response_time",
  "resolution_rate"
], Dte = {
  open_complaints: {
    title: "Open Complaints",
    Icon: j_,
    iconColor: "text-[#AB0000]",
    deltaLabel: "Compared to last month"
  },
  pending_requests: {
    title: "Pending Requests",
    Icon: jte,
    iconColor: "text-[#E7A015]",
    deltaLabel: "Compared to last month"
  },
  avg_response_time: {
    title: "Avg Response Time",
    Icon: ER,
    iconColor: "text-[#1FA05B]",
    deltaLabel: "Compared to last month"
  },
  resolution_rate: {
    title: "Resolution Rate",
    Icon: wR,
    iconColor: "text-[#329DFF]",
    deltaLabel: "Compared to last month"
  }
}, Rte = {
  open_complaints: {
    current: 24,
    trend_percent: "-8%",
    direction: "bad"
  },
  pending_requests: {
    current: 17,
    trend_percent: "-5%",
    direction: "bad"
  },
  avg_response_time: {
    current: "2.4 hrs",
    trend_percent: "+6%",
    direction: "good"
  },
  resolution_rate: {
    current: "89%",
    trend_percent: "+4%",
    direction: "good"
  }
};
function Lne({ id: e, data: t }) {
  return e && t && !t[e] && t.current !== void 0 ? /* @__PURE__ */ x.jsx(IE, { id: e, data: t }) : /* @__PURE__ */ x.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4", children: Nte.map((n) => /* @__PURE__ */ x.jsx(IE, { id: n }, n)) });
}
function IE({ id: e, data: t }) {
  const n = Dte[e];
  if (!n) return null;
  const {
    title: r,
    Icon: i = Dl,
    iconColor: o,
    deltaLabel: a
  } = n, s = t && Object.keys(t).length > 0 ? t : Rte[e], l = s?.current ?? "", c = s?.trend_percent ?? "", u = s?.direction === "good" || s?.direction === "neutral";
  return /* @__PURE__ */ x.jsxs(
    ft,
    {
      title: r,
      icon: /* @__PURE__ */ x.jsx("div", { className: "h-6 w-6 flex items-center justify-center", children: /* @__PURE__ */ x.jsx(i, { className: `h-6 w-6 ${o}` }) }),
      children: [
        /* @__PURE__ */ x.jsx("div", { className: "text-4xl font-semibold tracking-tight text-[#121212]", children: l }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px] text-[14px] mt-2", children: [
          /* @__PURE__ */ x.jsx(
            "div",
            {
              className: u ? "text-emerald-600 font-medium" : "text-rose-600 font-medium",
              children: c
            }
          ),
          /* @__PURE__ */ x.jsx("div", { className: "text-slate-500", children: a })
        ] })
      ]
    }
  );
}
function $E({ title: e, date: t, rsvp: n, utilisation: r, status: i }) {
  return /* @__PURE__ */ x.jsxs("div", { className: " bg-[#F8FAFC] h-[106px] px-3 mt-3", children: [
    /* @__PURE__ */ x.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ x.jsx("div", { className: "text-[16px] leading-[20px] font-semibold text-[#121212]", children: e }),
      /* @__PURE__ */ x.jsx(
        "div",
        {
          className: `!text-[12px] font-medium leading-[16px] px-2 py-1  ${i === "Completed" ? "text-[#36AB6C] bg-[#E6F7EE]" : i === "Upcoming" ? "text-[#329DFF] bg-[#E6F2FF]" : "text-slate-500 bg-slate-100"}`,
          children: i
        }
      )
    ] }),
    /* @__PURE__ */ x.jsx("div", { className: "text-[14px] leading-[18px] text-[#64748B]", children: t }),
    /* @__PURE__ */ x.jsxs("div", { className: "flex justify-between items-center mt-2", children: [
      /* @__PURE__ */ x.jsxs("div", { className: "text-[14px] leading-[18px] text-[#64748B]", children: [
        n,
        " RSVP"
      ] }),
      /* @__PURE__ */ x.jsxs("div", { className: "text-[#3C82F6] text-[14px] leading-[18px] font-medium", children: [
        r,
        "% utilisation"
      ] })
    ] }),
    /* @__PURE__ */ x.jsx("div", { className: "w-full bg-[#F8FAFC] h-[6px] rounded mt-2 mb-3", children: /* @__PURE__ */ x.jsx(
      "div",
      {
        className: "h-[6px] rounded bg-[#3C82F6]",
        style: { width: `${r}%` }
      }
    ) })
  ] });
}
function Fne() {
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Events Utilisation",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "w-full h-[360px]",
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsx(
          $E,
          {
            title: "Holi Celebration",
            date: "25 Jun 2025",
            rsvp: "78/100",
            utilisation: 71,
            status: "Upcoming"
          }
        ),
        /* @__PURE__ */ x.jsx(
          $E,
          {
            title: "Maintenance Meeting",
            date: "25 Jun 2025",
            rsvp: "45/60",
            utilisation: 75,
            status: "Completed"
          }
        )
      ] })
    }
  );
}
function iu({ label: e, value: t, subLabel: n, bgColor: r, textColor: i }) {
  return /* @__PURE__ */ x.jsxs("div", { className: `rounded-lg p-4 ${r} h-[124px]`, children: [
    /* @__PURE__ */ x.jsx("div", { className: `text-[16px] font-medium ${i} leading-[20px]`, children: e }),
    /* @__PURE__ */ x.jsx("div", { className: "mt-4 text-[28px] leading-[32px] font-semibold text-[#121212]", children: t }),
    /* @__PURE__ */ x.jsx("div", { className: "!text-[12px] leading-[16px] text-[#64748B] mt-2", children: n })
  ] });
}
function Bne() {
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: "Notice Board Status",
      period: /* @__PURE__ */ x.jsx(xn, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "w-full h-[360px]",
      children: /* @__PURE__ */ x.jsxs("div", { className: "grid grid-cols-2 gap-[16px]", children: [
        /* @__PURE__ */ x.jsx(
          iu,
          {
            label: "Active",
            value: 138,
            subLabel: "3 expiring soon",
            bgColor: "bg-[#F0FFF7]",
            textColor: "text-[#1FA05B]"
          }
        ),
        /* @__PURE__ */ x.jsx(
          iu,
          {
            label: "Scheduled",
            value: 13,
            subLabel: "4 this week",
            bgColor: "bg-[#FFFBF2]",
            textColor: "text-[#E7A015]"
          }
        ),
        /* @__PURE__ */ x.jsx(
          iu,
          {
            label: "Recurring",
            value: 3,
            subLabel: "All active",
            bgColor: "bg-[#EDF6FF]",
            textColor: "text-[#329DFF]"
          }
        ),
        /* @__PURE__ */ x.jsx(
          iu,
          {
            label: "Expired",
            value: 7,
            subLabel: "4 recent",
            bgColor: "bg-[#F6F6F6]",
            textColor: "text-[#64748B]"
          }
        )
      ] })
    }
  );
}
function _M(e) {
  return Qe({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M20 22H4C3.44772 22 3 21.5523 3 21V3C3 2.44772 3.44772 2 4 2H20C20.5523 2 21 2.44772 21 3V21C21 21.5523 20.5523 22 20 22ZM19 20V4H5V20H19ZM8 9H16V11H8V9ZM8 13H16V15H8V13Z" }, child: [] }] })(e);
}
function Ite({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Dl,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: e,
      icon: /* @__PURE__ */ x.jsx("div", { className: `h-6 w-6 grid place-items-center rounded-md ${s}`, children: /* @__PURE__ */ x.jsx(o, { className: `h-4 w-4 ${a}` }) }),
      className: "h-[132px]",
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px] font-medium text-[#121212]", children: t }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px] pt-[8px] !text-[12px] leading-[16px]", children: [
          /* @__PURE__ */ x.jsx(
            "div",
            {
              className: i ? "text-[#1FA05B] font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B]", children: r })
        ] })
      ] })
    }
  );
}
function zne({ data: e }) {
  const t = [
    {
      title: e?.title || "Total Bookings",
      value: 145,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: _M,
      iconColor: "text-emerald-600",
      iconBg: "bg-emerald-50"
    }
  ];
  return /* @__PURE__ */ x.jsx("div", { className: "h-full", children: t.map((n, r) => /* @__PURE__ */ x.jsx(Ite, { ...n }, r)) });
}
function $te(e) {
  return Qe({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" }, child: [] }] })(e);
}
function Lte({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Dl,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ x.jsx(
    ft,
    {
      title: e,
      icon: /* @__PURE__ */ x.jsx("div", { className: `h-6 w-6 grid place-items-center rounded-md ${s}`, children: /* @__PURE__ */ x.jsx(o, { className: `h-4 w-4 ${a}` }) }),
      className: "h-[132px]",
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsx("div", { className: "text-[28px] leading-[32px] font-medium text-[#121212]", children: t }),
        /* @__PURE__ */ x.jsxs("div", { className: "flex items-center gap-[8px] pt-[8px] !text-[12px] leading-[16px]", children: [
          /* @__PURE__ */ x.jsx(
            "div",
            {
              className: i ? "text-[#1FA05B] font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ x.jsx("div", { className: "text-[#64748B]", children: r })
        ] })
      ] })
    }
  );
}
function Wne() {
  const e = [
    {
      title: "Notice",
      value: 160,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: _M,
      iconColor: "text-emerald-600",
      iconBg: "bg-emerald-50"
    },
    {
      title: "Post",
      value: 83,
      delta: "+2.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: TR,
      iconColor: "text-[#329DFF]",
      iconBg: "bg-emerald-50"
    },
    {
      title: "Poll",
      value: 3,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: cX,
      iconColor: "text-[#FA7E28]",
      iconBg: "bg-orange-100"
    },
    {
      title: "Poll",
      value: 5,
      delta: "-8.0%",
      deltaLabel: "Compared to last month",
      positive: !1,
      Icon: $te,
      iconColor: "text-[#DBB467]",
      iconBg: "bg-yellow-100"
    }
  ];
  return /* @__PURE__ */ x.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-[24px]", children: e.map((t, n) => /* @__PURE__ */ x.jsx(Lte, { ...t }, n)) });
}
export {
  One as Accounting,
  Cne as AssetValueBreakdown,
  xne as BlockWiseOccupancy,
  Sne as Budgets,
  ft as Card,
  Ene as CashBankBalance,
  lne as Community,
  Rne as Complaints,
  Ine as ComplaintsByLevel,
  _ne as DuesAgeing,
  cne as Engagement,
  Wne as EngagementStatsGrid,
  Fne as EventsUtilisation,
  Pne as ExpenseCategories,
  une as Facilities,
  dne as FinanceSummary,
  Dne as GateAndSecurityStatsGrid,
  fne as GateUpdates,
  kne as GuardPatrols,
  zte as Header,
  pne as Helpdesk,
  Lne as HelpdeskStatsGrid,
  Mne as HourlyTrafficFlow,
  jne as IncidentReports,
  Ste as IncomeExpenditure,
  Wte as MainHeader,
  wne as MoveInOutTrends,
  Bne as NoticeBoardStatus,
  yne as OccupancyOverview,
  $ne as RequestBox,
  bne as ResidentOverview,
  Tne as RevenuebyCategory,
  zne as SingleStats,
  Nne as StaffAttendance,
  Ane as StatsGrid,
  vne as UnitStatus
};

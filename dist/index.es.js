import * as _ from "react";
import He, { forwardRef as nn, useContext as Vr, useState as Rt, isValidElement as bn, Children as mE, createContext as hr, useCallback as pt, PureComponent as gE, useMemo as Ur, useRef as Ue, useEffect as Le, cloneElement as sr, createElement as vE, useImperativeHandle as yE, Component as lM, useLayoutEffect as bE } from "react";
import * as cM from "react-dom";
import Zl, { createPortal as xE } from "react-dom";
function xi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Jl = { exports: {} }, Ja = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ab;
function uM() {
  if (ab) return Ja;
  ab = 1;
  var e = He, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, c) {
    var u, d = {}, f = null, p = null;
    c !== void 0 && (f = "" + c), l.key !== void 0 && (f = "" + l.key), l.ref !== void 0 && (p = l.ref);
    for (u in l) r.call(l, u) && !o.hasOwnProperty(u) && (d[u] = l[u]);
    if (s && s.defaultProps) for (u in l = s.defaultProps, l) d[u] === void 0 && (d[u] = l[u]);
    return { $$typeof: t, type: s, key: f, ref: p, props: d, _owner: i.current };
  }
  return Ja.Fragment = n, Ja.jsx = a, Ja.jsxs = a, Ja;
}
var Qa = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sb;
function dM() {
  return sb || (sb = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = He, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), g = Symbol.iterator, m = "@@iterator";
    function v(I) {
      if (I === null || typeof I != "object")
        return null;
      var X = g && I[g] || I[m];
      return typeof X == "function" ? X : null;
    }
    var y = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(I) {
      {
        for (var X = arguments.length, oe = new Array(X > 1 ? X - 1 : 0), ye = 1; ye < X; ye++)
          oe[ye - 1] = arguments[ye];
        x("error", I, oe);
      }
    }
    function x(I, X, oe) {
      {
        var ye = y.ReactDebugCurrentFrame, Ne = ye.getStackAddendum();
        Ne !== "" && (X += "%s", oe = oe.concat([Ne]));
        var Ze = oe.map(function(Ee) {
          return String(Ee);
        });
        Ze.unshift("Warning: " + X), Function.prototype.apply.call(console[I], console, Ze);
      }
    }
    var b = !1, w = !1, E = !1, C = !1, A = !1, k;
    k = Symbol.for("react.module.reference");
    function R(I) {
      return !!(typeof I == "string" || typeof I == "function" || I === r || I === o || A || I === i || I === c || I === u || C || I === p || b || w || E || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === d || I.$$typeof === a || I.$$typeof === s || I.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      I.$$typeof === k || I.getModuleId !== void 0));
    }
    function M(I, X, oe) {
      var ye = I.displayName;
      if (ye)
        return ye;
      var Ne = X.displayName || X.name || "";
      return Ne !== "" ? oe + "(" + Ne + ")" : oe;
    }
    function P(I) {
      return I.displayName || "Context";
    }
    function D(I) {
      if (I == null)
        return null;
      if (typeof I.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof I == "function")
        return I.displayName || I.name || null;
      if (typeof I == "string")
        return I;
      switch (I) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof I == "object")
        switch (I.$$typeof) {
          case s:
            var X = I;
            return P(X) + ".Consumer";
          case a:
            var oe = I;
            return P(oe._context) + ".Provider";
          case l:
            return M(I, I.render, "ForwardRef");
          case d:
            var ye = I.displayName || null;
            return ye !== null ? ye : D(I.type) || "Memo";
          case f: {
            var Ne = I, Ze = Ne._payload, Ee = Ne._init;
            try {
              return D(Ee(Ze));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var j = Object.assign, N = 0, $, F, q, B, L, Y, K;
    function te() {
    }
    te.__reactDisabledLog = !0;
    function J() {
      {
        if (N === 0) {
          $ = console.log, F = console.info, q = console.warn, B = console.error, L = console.group, Y = console.groupCollapsed, K = console.groupEnd;
          var I = {
            configurable: !0,
            enumerable: !0,
            value: te,
            writable: !0
          };
          Object.defineProperties(console, {
            info: I,
            log: I,
            warn: I,
            error: I,
            group: I,
            groupCollapsed: I,
            groupEnd: I
          });
        }
        N++;
      }
    }
    function Q() {
      {
        if (N--, N === 0) {
          var I = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: j({}, I, {
              value: $
            }),
            info: j({}, I, {
              value: F
            }),
            warn: j({}, I, {
              value: q
            }),
            error: j({}, I, {
              value: B
            }),
            group: j({}, I, {
              value: L
            }),
            groupCollapsed: j({}, I, {
              value: Y
            }),
            groupEnd: j({}, I, {
              value: K
            })
          });
        }
        N < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ne = y.ReactCurrentDispatcher, re;
    function ie(I, X, oe) {
      {
        if (re === void 0)
          try {
            throw Error();
          } catch (Ne) {
            var ye = Ne.stack.trim().match(/\n( *(at )?)/);
            re = ye && ye[1] || "";
          }
        return `
` + re + I;
      }
    }
    var U = !1, H;
    {
      var Z = typeof WeakMap == "function" ? WeakMap : Map;
      H = new Z();
    }
    function T(I, X) {
      if (!I || U)
        return "";
      {
        var oe = H.get(I);
        if (oe !== void 0)
          return oe;
      }
      var ye;
      U = !0;
      var Ne = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ze;
      Ze = ne.current, ne.current = null, J();
      try {
        if (X) {
          var Ee = function() {
            throw Error();
          };
          if (Object.defineProperty(Ee.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ee, []);
            } catch (On) {
              ye = On;
            }
            Reflect.construct(I, [], Ee);
          } else {
            try {
              Ee.call();
            } catch (On) {
              ye = On;
            }
            I.call(Ee.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (On) {
            ye = On;
          }
          I();
        }
      } catch (On) {
        if (On && ye && typeof On.stack == "string") {
          for (var Oe = On.stack.split(`
`), gn = ye.stack.split(`
`), wt = Oe.length - 1, Ct = gn.length - 1; wt >= 1 && Ct >= 0 && Oe[wt] !== gn[Ct]; )
            Ct--;
          for (; wt >= 1 && Ct >= 0; wt--, Ct--)
            if (Oe[wt] !== gn[Ct]) {
              if (wt !== 1 || Ct !== 1)
                do
                  if (wt--, Ct--, Ct < 0 || Oe[wt] !== gn[Ct]) {
                    var Jn = `
` + Oe[wt].replace(" at new ", " at ");
                    return I.displayName && Jn.includes("<anonymous>") && (Jn = Jn.replace("<anonymous>", I.displayName)), typeof I == "function" && H.set(I, Jn), Jn;
                  }
                while (wt >= 1 && Ct >= 0);
              break;
            }
        }
      } finally {
        U = !1, ne.current = Ze, Q(), Error.prepareStackTrace = Ne;
      }
      var Zo = I ? I.displayName || I.name : "", io = Zo ? ie(Zo) : "";
      return typeof I == "function" && H.set(I, io), io;
    }
    function de(I, X, oe) {
      return T(I, !1);
    }
    function ee(I) {
      var X = I.prototype;
      return !!(X && X.isReactComponent);
    }
    function he(I, X, oe) {
      if (I == null)
        return "";
      if (typeof I == "function")
        return T(I, ee(I));
      if (typeof I == "string")
        return ie(I);
      switch (I) {
        case c:
          return ie("Suspense");
        case u:
          return ie("SuspenseList");
      }
      if (typeof I == "object")
        switch (I.$$typeof) {
          case l:
            return de(I.render);
          case d:
            return he(I.type, X, oe);
          case f: {
            var ye = I, Ne = ye._payload, Ze = ye._init;
            try {
              return he(Ze(Ne), X, oe);
            } catch {
            }
          }
        }
      return "";
    }
    var be = Object.prototype.hasOwnProperty, Se = {}, Ce = y.ReactDebugCurrentFrame;
    function nt(I) {
      if (I) {
        var X = I._owner, oe = he(I.type, I._source, X ? X.type : null);
        Ce.setExtraStackFrame(oe);
      } else
        Ce.setExtraStackFrame(null);
    }
    function Ke(I, X, oe, ye, Ne) {
      {
        var Ze = Function.call.bind(be);
        for (var Ee in I)
          if (Ze(I, Ee)) {
            var Oe = void 0;
            try {
              if (typeof I[Ee] != "function") {
                var gn = Error((ye || "React class") + ": " + oe + " type `" + Ee + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof I[Ee] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw gn.name = "Invariant Violation", gn;
              }
              Oe = I[Ee](X, Ee, ye, oe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (wt) {
              Oe = wt;
            }
            Oe && !(Oe instanceof Error) && (nt(Ne), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ye || "React class", oe, Ee, typeof Oe), nt(null)), Oe instanceof Error && !(Oe.message in Se) && (Se[Oe.message] = !0, nt(Ne), S("Failed %s type: %s", oe, Oe.message), nt(null));
          }
      }
    }
    var Te = Array.isArray;
    function ue(I) {
      return Te(I);
    }
    function jt(I) {
      {
        var X = typeof Symbol == "function" && Symbol.toStringTag, oe = X && I[Symbol.toStringTag] || I.constructor.name || "Object";
        return oe;
      }
    }
    function at(I) {
      try {
        return on(I), !1;
      } catch {
        return !0;
      }
    }
    function on(I) {
      return "" + I;
    }
    function Zt(I) {
      if (at(I))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", jt(I)), on(I);
    }
    var an = y.ReactCurrentOwner, xn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, zt, wn;
    function ge(I) {
      if (be.call(I, "ref")) {
        var X = Object.getOwnPropertyDescriptor(I, "ref").get;
        if (X && X.isReactWarning)
          return !1;
      }
      return I.ref !== void 0;
    }
    function sn(I) {
      if (be.call(I, "key")) {
        var X = Object.getOwnPropertyDescriptor(I, "key").get;
        if (X && X.isReactWarning)
          return !1;
      }
      return I.key !== void 0;
    }
    function Wt(I, X) {
      typeof I.ref == "string" && an.current;
    }
    function W(I, X) {
      {
        var oe = function() {
          zt || (zt = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", X));
        };
        oe.isReactWarning = !0, Object.defineProperty(I, "key", {
          get: oe,
          configurable: !0
        });
      }
    }
    function ae(I, X) {
      {
        var oe = function() {
          wn || (wn = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", X));
        };
        oe.isReactWarning = !0, Object.defineProperty(I, "ref", {
          get: oe,
          configurable: !0
        });
      }
    }
    var G = function(I, X, oe, ye, Ne, Ze, Ee) {
      var Oe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: I,
        key: X,
        ref: oe,
        props: Ee,
        // Record the component responsible for creating this element.
        _owner: Ze
      };
      return Oe._store = {}, Object.defineProperty(Oe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Oe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ye
      }), Object.defineProperty(Oe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ne
      }), Object.freeze && (Object.freeze(Oe.props), Object.freeze(Oe)), Oe;
    };
    function se(I, X, oe, ye, Ne) {
      {
        var Ze, Ee = {}, Oe = null, gn = null;
        oe !== void 0 && (Zt(oe), Oe = "" + oe), sn(X) && (Zt(X.key), Oe = "" + X.key), ge(X) && (gn = X.ref, Wt(X, Ne));
        for (Ze in X)
          be.call(X, Ze) && !xn.hasOwnProperty(Ze) && (Ee[Ze] = X[Ze]);
        if (I && I.defaultProps) {
          var wt = I.defaultProps;
          for (Ze in wt)
            Ee[Ze] === void 0 && (Ee[Ze] = wt[Ze]);
        }
        if (Oe || gn) {
          var Ct = typeof I == "function" ? I.displayName || I.name || "Unknown" : I;
          Oe && W(Ee, Ct), gn && ae(Ee, Ct);
        }
        return G(I, Oe, gn, Ne, ye, an.current, Ee);
      }
    }
    var fe = y.ReactCurrentOwner, Xe = y.ReactDebugCurrentFrame;
    function st(I) {
      if (I) {
        var X = I._owner, oe = he(I.type, I._source, X ? X.type : null);
        Xe.setExtraStackFrame(oe);
      } else
        Xe.setExtraStackFrame(null);
    }
    var Xn;
    Xn = !1;
    function Ci(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function Zn() {
      {
        if (fe.current) {
          var I = D(fe.current.type);
          if (I)
            return `

Check the render method of \`` + I + "`.";
        }
        return "";
      }
    }
    function ro(I) {
      return "";
    }
    var Gr = {};
    function Sr(I) {
      {
        var X = Zn();
        if (!X) {
          var oe = typeof I == "string" ? I : I.displayName || I.name;
          oe && (X = `

Check the top-level render call using <` + oe + ">.");
        }
        return X;
      }
    }
    function ve(I, X) {
      {
        if (!I._store || I._store.validated || I.key != null)
          return;
        I._store.validated = !0;
        var oe = Sr(X);
        if (Gr[oe])
          return;
        Gr[oe] = !0;
        var ye = "";
        I && I._owner && I._owner !== fe.current && (ye = " It was passed a child from " + D(I._owner.type) + "."), st(I), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', oe, ye), st(null);
      }
    }
    function mn(I, X) {
      {
        if (typeof I != "object")
          return;
        if (ue(I))
          for (var oe = 0; oe < I.length; oe++) {
            var ye = I[oe];
            Ci(ye) && ve(ye, X);
          }
        else if (Ci(I))
          I._store && (I._store.validated = !0);
        else if (I) {
          var Ne = v(I);
          if (typeof Ne == "function" && Ne !== I.entries)
            for (var Ze = Ne.call(I), Ee; !(Ee = Ze.next()).done; )
              Ci(Ee.value) && ve(Ee.value, X);
        }
      }
    }
    function Xo(I) {
      {
        var X = I.type;
        if (X == null || typeof X == "string")
          return;
        var oe;
        if (typeof X == "function")
          oe = X.propTypes;
        else if (typeof X == "object" && (X.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        X.$$typeof === d))
          oe = X.propTypes;
        else
          return;
        if (oe) {
          var ye = D(X);
          Ke(oe, I.props, "prop", ye, I);
        } else if (X.PropTypes !== void 0 && !Xn) {
          Xn = !0;
          var Ne = D(X);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ne || "Unknown");
        }
        typeof X.getDefaultProps == "function" && !X.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function tM(I) {
      {
        for (var X = Object.keys(I.props), oe = 0; oe < X.length; oe++) {
          var ye = X[oe];
          if (ye !== "children" && ye !== "key") {
            st(I), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ye), st(null);
            break;
          }
        }
        I.ref !== null && (st(I), S("Invalid attribute `ref` supplied to `React.Fragment`."), st(null));
      }
    }
    var ib = {};
    function ob(I, X, oe, ye, Ne, Ze) {
      {
        var Ee = R(I);
        if (!Ee) {
          var Oe = "";
          (I === void 0 || typeof I == "object" && I !== null && Object.keys(I).length === 0) && (Oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var gn = ro();
          gn ? Oe += gn : Oe += Zn();
          var wt;
          I === null ? wt = "null" : ue(I) ? wt = "array" : I !== void 0 && I.$$typeof === t ? (wt = "<" + (D(I.type) || "Unknown") + " />", Oe = " Did you accidentally export a JSX literal instead of a component?") : wt = typeof I, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", wt, Oe);
        }
        var Ct = se(I, X, oe, Ne, Ze);
        if (Ct == null)
          return Ct;
        if (Ee) {
          var Jn = X.children;
          if (Jn !== void 0)
            if (ye)
              if (ue(Jn)) {
                for (var Zo = 0; Zo < Jn.length; Zo++)
                  mn(Jn[Zo], I);
                Object.freeze && Object.freeze(Jn);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              mn(Jn, I);
        }
        if (be.call(X, "key")) {
          var io = D(I), On = Object.keys(X).filter(function(sM) {
            return sM !== "key";
          }), _f = On.length > 0 ? "{key: someKey, " + On.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!ib[io + _f]) {
            var aM = On.length > 0 ? "{" + On.join(": ..., ") + ": ...}" : "{}";
            S(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, _f, io, aM, io), ib[io + _f] = !0;
          }
        }
        return I === r ? tM(Ct) : Xo(Ct), Ct;
      }
    }
    function nM(I, X, oe) {
      return ob(I, X, oe, !0);
    }
    function rM(I, X, oe) {
      return ob(I, X, oe, !1);
    }
    var iM = rM, oM = nM;
    Qa.Fragment = r, Qa.jsx = iM, Qa.jsxs = oM;
  })()), Qa;
}
var lb;
function fM() {
  return lb || (lb = 1, process.env.NODE_ENV === "production" ? Jl.exports = uM() : Jl.exports = dM()), Jl.exports;
}
var O = fM();
const ot = ({
  title: e,
  icon: t,
  period: n,
  children: r,
  footer: i,
  className: o = "",
  childrenClassName: a,
  titleWeight: s
}) => {
  const l = s === "semi-bold" ? 600 : 500;
  return /* @__PURE__ */ O.jsxs(
    "div",
    {
      className: `relative bg-white !border-[0.5px] !border-[#EBEBEB] !rounded-[12px] !shadow-[0_0_12px_0_#EAF2FF] p-[16px] flex flex-col gap-[24px] ${o}`,
      children: [
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[12px]", children: [
            t,
            /* @__PURE__ */ O.jsx(
              "div",
              {
                style: {
                  fontWeight: l,
                  fontSize: "16px",
                  lineHeight: "20px"
                },
                className: "!my-0 !text-[16px] !leading-[20px] !text-[#121212]",
                children: e
              }
            )
          ] }),
          n && /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] !leading-[16px] !text-[#64748B]", children: n })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: `flex-1 min-h-0 space-y-[24px] ${a}`, children: r }),
        i && /* @__PURE__ */ O.jsx("div", { className: "mt-3 pt-3 border-t border-gray-100 !text-[12px] text-[#64748B]", children: i })
      ]
    }
  );
}, cb = (e) => e, pM = () => {
  let e = cb;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = cb;
    }
  };
}, hM = pM();
function $r(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function It(e) {
  if (typeof e != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : $r(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function ub(...e) {
  return e.reduce((t, n) => n == null ? t : function(...i) {
    t.apply(this, i), n.apply(this, i);
  }, () => {
  });
}
var Ql = { exports: {} }, ec = { exports: {} }, De = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var db;
function mM() {
  if (db) return De;
  db = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var E = w.$$typeof;
      switch (E) {
        case t:
          switch (w = w.type, w) {
            case l:
            case c:
            case r:
            case o:
            case i:
            case d:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case s:
                case u:
                case g:
                case p:
                case a:
                  return w;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function b(w) {
    return x(w) === c;
  }
  return De.AsyncMode = l, De.ConcurrentMode = c, De.ContextConsumer = s, De.ContextProvider = a, De.Element = t, De.ForwardRef = u, De.Fragment = r, De.Lazy = g, De.Memo = p, De.Portal = n, De.Profiler = o, De.StrictMode = i, De.Suspense = d, De.isAsyncMode = function(w) {
    return b(w) || x(w) === l;
  }, De.isConcurrentMode = b, De.isContextConsumer = function(w) {
    return x(w) === s;
  }, De.isContextProvider = function(w) {
    return x(w) === a;
  }, De.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, De.isForwardRef = function(w) {
    return x(w) === u;
  }, De.isFragment = function(w) {
    return x(w) === r;
  }, De.isLazy = function(w) {
    return x(w) === g;
  }, De.isMemo = function(w) {
    return x(w) === p;
  }, De.isPortal = function(w) {
    return x(w) === n;
  }, De.isProfiler = function(w) {
    return x(w) === o;
  }, De.isStrictMode = function(w) {
    return x(w) === i;
  }, De.isSuspense = function(w) {
    return x(w) === d;
  }, De.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === c || w === o || w === i || w === d || w === f || typeof w == "object" && w !== null && (w.$$typeof === g || w.$$typeof === p || w.$$typeof === a || w.$$typeof === s || w.$$typeof === u || w.$$typeof === v || w.$$typeof === y || w.$$typeof === S || w.$$typeof === m);
  }, De.typeOf = x, De;
}
var Re = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fb;
function gM() {
  return fb || (fb = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
    function x(T) {
      return typeof T == "string" || typeof T == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      T === r || T === c || T === o || T === i || T === d || T === f || typeof T == "object" && T !== null && (T.$$typeof === g || T.$$typeof === p || T.$$typeof === a || T.$$typeof === s || T.$$typeof === u || T.$$typeof === v || T.$$typeof === y || T.$$typeof === S || T.$$typeof === m);
    }
    function b(T) {
      if (typeof T == "object" && T !== null) {
        var de = T.$$typeof;
        switch (de) {
          case t:
            var ee = T.type;
            switch (ee) {
              case l:
              case c:
              case r:
              case o:
              case i:
              case d:
                return ee;
              default:
                var he = ee && ee.$$typeof;
                switch (he) {
                  case s:
                  case u:
                  case g:
                  case p:
                  case a:
                    return he;
                  default:
                    return de;
                }
            }
          case n:
            return de;
        }
      }
    }
    var w = l, E = c, C = s, A = a, k = t, R = u, M = r, P = g, D = p, j = n, N = o, $ = i, F = d, q = !1;
    function B(T) {
      return q || (q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(T) || b(T) === l;
    }
    function L(T) {
      return b(T) === c;
    }
    function Y(T) {
      return b(T) === s;
    }
    function K(T) {
      return b(T) === a;
    }
    function te(T) {
      return typeof T == "object" && T !== null && T.$$typeof === t;
    }
    function J(T) {
      return b(T) === u;
    }
    function Q(T) {
      return b(T) === r;
    }
    function ne(T) {
      return b(T) === g;
    }
    function re(T) {
      return b(T) === p;
    }
    function ie(T) {
      return b(T) === n;
    }
    function U(T) {
      return b(T) === o;
    }
    function H(T) {
      return b(T) === i;
    }
    function Z(T) {
      return b(T) === d;
    }
    Re.AsyncMode = w, Re.ConcurrentMode = E, Re.ContextConsumer = C, Re.ContextProvider = A, Re.Element = k, Re.ForwardRef = R, Re.Fragment = M, Re.Lazy = P, Re.Memo = D, Re.Portal = j, Re.Profiler = N, Re.StrictMode = $, Re.Suspense = F, Re.isAsyncMode = B, Re.isConcurrentMode = L, Re.isContextConsumer = Y, Re.isContextProvider = K, Re.isElement = te, Re.isForwardRef = J, Re.isFragment = Q, Re.isLazy = ne, Re.isMemo = re, Re.isPortal = ie, Re.isProfiler = U, Re.isStrictMode = H, Re.isSuspense = Z, Re.isValidElementType = x, Re.typeOf = b;
  })()), Re;
}
var pb;
function wE() {
  return pb || (pb = 1, process.env.NODE_ENV === "production" ? ec.exports = mM() : ec.exports = gM()), ec.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Pf, hb;
function vM() {
  if (hb) return Pf;
  hb = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(u) {
        return a[u];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        c[u] = u;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Pf = i() ? Object.assign : function(o, a) {
    for (var s, l = r(o), c, u = 1; u < arguments.length; u++) {
      s = Object(arguments[u]);
      for (var d in s)
        t.call(s, d) && (l[d] = s[d]);
      if (e) {
        c = e(s);
        for (var f = 0; f < c.length; f++)
          n.call(s, c[f]) && (l[c[f]] = s[c[f]]);
      }
    }
    return l;
  }, Pf;
}
var Cf, mb;
function ng() {
  if (mb) return Cf;
  mb = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Cf = e, Cf;
}
var Af, gb;
function OE() {
  return gb || (gb = 1, Af = Function.call.bind(Object.prototype.hasOwnProperty)), Af;
}
var Tf, vb;
function yM() {
  if (vb) return Tf;
  vb = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = /* @__PURE__ */ ng(), n = {}, r = /* @__PURE__ */ OE();
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in o)
        if (r(o, u)) {
          var d;
          try {
            if (typeof o[u] != "function") {
              var f = Error(
                (l || "React class") + ": " + s + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw f.name = "Invariant Violation", f;
            }
            d = o[u](a, u, l, s, null, t);
          } catch (g) {
            d = g;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var p = c ? c() : "";
            e(
              "Failed " + s + " type: " + d.message + (p ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Tf = i, Tf;
}
var kf, yb;
function bM() {
  if (yb) return kf;
  yb = 1;
  var e = wE(), t = vM(), n = /* @__PURE__ */ ng(), r = /* @__PURE__ */ OE(), i = /* @__PURE__ */ yM(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return kf = function(s, l) {
    var c = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function d(L) {
      var Y = L && (c && L[c] || L[u]);
      if (typeof Y == "function")
        return Y;
    }
    var f = "<<anonymous>>", p = {
      array: y("array"),
      bigint: y("bigint"),
      bool: y("boolean"),
      func: y("function"),
      number: y("number"),
      object: y("object"),
      string: y("string"),
      symbol: y("symbol"),
      any: S(),
      arrayOf: x,
      element: b(),
      elementType: w(),
      instanceOf: E,
      node: R(),
      objectOf: A,
      oneOf: C,
      oneOfType: k,
      shape: P,
      exact: D
    };
    function g(L, Y) {
      return L === Y ? L !== 0 || 1 / L === 1 / Y : L !== L && Y !== Y;
    }
    function m(L, Y) {
      this.message = L, this.data = Y && typeof Y == "object" ? Y : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(L) {
      if (process.env.NODE_ENV !== "production")
        var Y = {}, K = 0;
      function te(Q, ne, re, ie, U, H, Z) {
        if (ie = ie || f, H = H || re, Z !== n) {
          if (l) {
            var T = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw T.name = "Invariant Violation", T;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var de = ie + ":" + re;
            !Y[de] && // Avoid spamming the console because they are often not actionable except for lib authors
            K < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + H + "` prop on `" + ie + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), Y[de] = !0, K++);
          }
        }
        return ne[re] == null ? Q ? ne[re] === null ? new m("The " + U + " `" + H + "` is marked as required " + ("in `" + ie + "`, but its value is `null`.")) : new m("The " + U + " `" + H + "` is marked as required in " + ("`" + ie + "`, but its value is `undefined`.")) : null : L(ne, re, ie, U, H);
      }
      var J = te.bind(null, !1);
      return J.isRequired = te.bind(null, !0), J;
    }
    function y(L) {
      function Y(K, te, J, Q, ne, re) {
        var ie = K[te], U = $(ie);
        if (U !== L) {
          var H = F(ie);
          return new m(
            "Invalid " + Q + " `" + ne + "` of type " + ("`" + H + "` supplied to `" + J + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return v(Y);
    }
    function S() {
      return v(a);
    }
    function x(L) {
      function Y(K, te, J, Q, ne) {
        if (typeof L != "function")
          return new m("Property `" + ne + "` of component `" + J + "` has invalid PropType notation inside arrayOf.");
        var re = K[te];
        if (!Array.isArray(re)) {
          var ie = $(re);
          return new m("Invalid " + Q + " `" + ne + "` of type " + ("`" + ie + "` supplied to `" + J + "`, expected an array."));
        }
        for (var U = 0; U < re.length; U++) {
          var H = L(re, U, J, Q, ne + "[" + U + "]", n);
          if (H instanceof Error)
            return H;
        }
        return null;
      }
      return v(Y);
    }
    function b() {
      function L(Y, K, te, J, Q) {
        var ne = Y[K];
        if (!s(ne)) {
          var re = $(ne);
          return new m("Invalid " + J + " `" + Q + "` of type " + ("`" + re + "` supplied to `" + te + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(L);
    }
    function w() {
      function L(Y, K, te, J, Q) {
        var ne = Y[K];
        if (!e.isValidElementType(ne)) {
          var re = $(ne);
          return new m("Invalid " + J + " `" + Q + "` of type " + ("`" + re + "` supplied to `" + te + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(L);
    }
    function E(L) {
      function Y(K, te, J, Q, ne) {
        if (!(K[te] instanceof L)) {
          var re = L.name || f, ie = B(K[te]);
          return new m("Invalid " + Q + " `" + ne + "` of type " + ("`" + ie + "` supplied to `" + J + "`, expected ") + ("instance of `" + re + "`."));
        }
        return null;
      }
      return v(Y);
    }
    function C(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function Y(K, te, J, Q, ne) {
        for (var re = K[te], ie = 0; ie < L.length; ie++)
          if (g(re, L[ie]))
            return null;
        var U = JSON.stringify(L, function(Z, T) {
          var de = F(T);
          return de === "symbol" ? String(T) : T;
        });
        return new m("Invalid " + Q + " `" + ne + "` of value `" + String(re) + "` " + ("supplied to `" + J + "`, expected one of " + U + "."));
      }
      return v(Y);
    }
    function A(L) {
      function Y(K, te, J, Q, ne) {
        if (typeof L != "function")
          return new m("Property `" + ne + "` of component `" + J + "` has invalid PropType notation inside objectOf.");
        var re = K[te], ie = $(re);
        if (ie !== "object")
          return new m("Invalid " + Q + " `" + ne + "` of type " + ("`" + ie + "` supplied to `" + J + "`, expected an object."));
        for (var U in re)
          if (r(re, U)) {
            var H = L(re, U, J, Q, ne + "." + U, n);
            if (H instanceof Error)
              return H;
          }
        return null;
      }
      return v(Y);
    }
    function k(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var Y = 0; Y < L.length; Y++) {
        var K = L[Y];
        if (typeof K != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + q(K) + " at index " + Y + "."
          ), a;
      }
      function te(J, Q, ne, re, ie) {
        for (var U = [], H = 0; H < L.length; H++) {
          var Z = L[H], T = Z(J, Q, ne, re, ie, n);
          if (T == null)
            return null;
          T.data && r(T.data, "expectedType") && U.push(T.data.expectedType);
        }
        var de = U.length > 0 ? ", expected one of type [" + U.join(", ") + "]" : "";
        return new m("Invalid " + re + " `" + ie + "` supplied to " + ("`" + ne + "`" + de + "."));
      }
      return v(te);
    }
    function R() {
      function L(Y, K, te, J, Q) {
        return j(Y[K]) ? null : new m("Invalid " + J + " `" + Q + "` supplied to " + ("`" + te + "`, expected a ReactNode."));
      }
      return v(L);
    }
    function M(L, Y, K, te, J) {
      return new m(
        (L || "React class") + ": " + Y + " type `" + K + "." + te + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + J + "`."
      );
    }
    function P(L) {
      function Y(K, te, J, Q, ne) {
        var re = K[te], ie = $(re);
        if (ie !== "object")
          return new m("Invalid " + Q + " `" + ne + "` of type `" + ie + "` " + ("supplied to `" + J + "`, expected `object`."));
        for (var U in L) {
          var H = L[U];
          if (typeof H != "function")
            return M(J, Q, ne, U, F(H));
          var Z = H(re, U, J, Q, ne + "." + U, n);
          if (Z)
            return Z;
        }
        return null;
      }
      return v(Y);
    }
    function D(L) {
      function Y(K, te, J, Q, ne) {
        var re = K[te], ie = $(re);
        if (ie !== "object")
          return new m("Invalid " + Q + " `" + ne + "` of type `" + ie + "` " + ("supplied to `" + J + "`, expected `object`."));
        var U = t({}, K[te], L);
        for (var H in U) {
          var Z = L[H];
          if (r(L, H) && typeof Z != "function")
            return M(J, Q, ne, H, F(Z));
          if (!Z)
            return new m(
              "Invalid " + Q + " `" + ne + "` key `" + H + "` supplied to `" + J + "`.\nBad object: " + JSON.stringify(K[te], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var T = Z(re, H, J, Q, ne + "." + H, n);
          if (T)
            return T;
        }
        return null;
      }
      return v(Y);
    }
    function j(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(j);
          if (L === null || s(L))
            return !0;
          var Y = d(L);
          if (Y) {
            var K = Y.call(L), te;
            if (Y !== L.entries) {
              for (; !(te = K.next()).done; )
                if (!j(te.value))
                  return !1;
            } else
              for (; !(te = K.next()).done; ) {
                var J = te.value;
                if (J && !j(J[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function N(L, Y) {
      return L === "symbol" ? !0 : Y ? Y["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && Y instanceof Symbol : !1;
    }
    function $(L) {
      var Y = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : N(Y, L) ? "symbol" : Y;
    }
    function F(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var Y = $(L);
      if (Y === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return Y;
    }
    function q(L) {
      var Y = F(L);
      switch (Y) {
        case "array":
        case "object":
          return "an " + Y;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + Y;
        default:
          return Y;
      }
    }
    function B(L) {
      return !L.constructor || !L.constructor.name ? f : L.constructor.name;
    }
    return p.checkPropTypes = i, p.resetWarningCache = i.resetWarningCache, p.PropTypes = p, p;
  }, kf;
}
var Mf, bb;
function xM() {
  if (bb) return Mf;
  bb = 1;
  var e = /* @__PURE__ */ ng();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Mf = function() {
    function r(a, s, l, c, u, d) {
      if (d !== e) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, Mf;
}
var xb;
function wM() {
  if (xb) return Ql.exports;
  if (xb = 1, process.env.NODE_ENV !== "production") {
    var e = wE(), t = !0;
    Ql.exports = /* @__PURE__ */ bM()(e.isElement, t);
  } else
    Ql.exports = /* @__PURE__ */ xM()();
  return Ql.exports;
}
var OM = /* @__PURE__ */ wM();
const h = /* @__PURE__ */ xi(OM);
function SE(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = SE(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function ce() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = SE(e)) && (r && (r += " "), r += t);
  return r;
}
function $t(e, t, n = void 0) {
  const r = {};
  for (const i in e) {
    const o = e[i];
    let a = "", s = !0;
    for (let l = 0; l < o.length; l += 1) {
      const c = o[l];
      c && (a += (s === !0 ? "" : " ") + t(c), s = !1, n && n[c] && (a += " " + n[c]));
    }
    r[i] = a;
  }
  return r;
}
var tc = { exports: {} }, qe = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wb;
function SM() {
  if (wb) return qe;
  wb = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), a = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.for("react.view_transition"), p = Symbol.for("react.client.reference");
  function g(m) {
    if (typeof m == "object" && m !== null) {
      var v = m.$$typeof;
      switch (v) {
        case e:
          switch (m = m.type, m) {
            case n:
            case i:
            case r:
            case l:
            case c:
            case f:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case a:
                case s:
                case d:
                case u:
                  return m;
                case o:
                  return m;
                default:
                  return v;
              }
          }
        case t:
          return v;
      }
    }
  }
  return qe.ContextConsumer = o, qe.ContextProvider = a, qe.Element = e, qe.ForwardRef = s, qe.Fragment = n, qe.Lazy = d, qe.Memo = u, qe.Portal = t, qe.Profiler = i, qe.StrictMode = r, qe.Suspense = l, qe.SuspenseList = c, qe.isContextConsumer = function(m) {
    return g(m) === o;
  }, qe.isContextProvider = function(m) {
    return g(m) === a;
  }, qe.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === e;
  }, qe.isForwardRef = function(m) {
    return g(m) === s;
  }, qe.isFragment = function(m) {
    return g(m) === n;
  }, qe.isLazy = function(m) {
    return g(m) === d;
  }, qe.isMemo = function(m) {
    return g(m) === u;
  }, qe.isPortal = function(m) {
    return g(m) === t;
  }, qe.isProfiler = function(m) {
    return g(m) === i;
  }, qe.isStrictMode = function(m) {
    return g(m) === r;
  }, qe.isSuspense = function(m) {
    return g(m) === l;
  }, qe.isSuspenseList = function(m) {
    return g(m) === c;
  }, qe.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === n || m === i || m === r || m === l || m === c || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === u || m.$$typeof === a || m.$$typeof === o || m.$$typeof === s || m.$$typeof === p || m.getModuleId !== void 0);
  }, qe.typeOf = g, qe;
}
var Ye = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ob;
function EM() {
  return Ob || (Ob = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(m) {
      if (typeof m == "object" && m !== null) {
        var v = m.$$typeof;
        switch (v) {
          case t:
            switch (m = m.type, m) {
              case r:
              case o:
              case i:
              case c:
              case u:
              case p:
                return m;
              default:
                switch (m = m && m.$$typeof, m) {
                  case s:
                  case l:
                  case f:
                  case d:
                    return m;
                  case a:
                    return m;
                  default:
                    return v;
                }
            }
          case n:
            return v;
        }
      }
    }
    var t = Symbol.for("react.transitional.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.view_transition"), g = Symbol.for("react.client.reference");
    Ye.ContextConsumer = a, Ye.ContextProvider = s, Ye.Element = t, Ye.ForwardRef = l, Ye.Fragment = r, Ye.Lazy = f, Ye.Memo = d, Ye.Portal = n, Ye.Profiler = o, Ye.StrictMode = i, Ye.Suspense = c, Ye.SuspenseList = u, Ye.isContextConsumer = function(m) {
      return e(m) === a;
    }, Ye.isContextProvider = function(m) {
      return e(m) === s;
    }, Ye.isElement = function(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }, Ye.isForwardRef = function(m) {
      return e(m) === l;
    }, Ye.isFragment = function(m) {
      return e(m) === r;
    }, Ye.isLazy = function(m) {
      return e(m) === f;
    }, Ye.isMemo = function(m) {
      return e(m) === d;
    }, Ye.isPortal = function(m) {
      return e(m) === n;
    }, Ye.isProfiler = function(m) {
      return e(m) === o;
    }, Ye.isStrictMode = function(m) {
      return e(m) === i;
    }, Ye.isSuspense = function(m) {
      return e(m) === c;
    }, Ye.isSuspenseList = function(m) {
      return e(m) === u;
    }, Ye.isValidElementType = function(m) {
      return typeof m == "string" || typeof m == "function" || m === r || m === o || m === i || m === c || m === u || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === d || m.$$typeof === s || m.$$typeof === a || m.$$typeof === l || m.$$typeof === g || m.getModuleId !== void 0);
    }, Ye.typeOf = e;
  })()), Ye;
}
var Sb;
function _M() {
  return Sb || (Sb = 1, process.env.NODE_ENV === "production" ? tc.exports = /* @__PURE__ */ SM() : tc.exports = /* @__PURE__ */ EM()), tc.exports;
}
var Fi = /* @__PURE__ */ _M();
function ri(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function EE(e) {
  if (/* @__PURE__ */ _.isValidElement(e) || Fi.isValidElementType(e) || !ri(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = EE(e[n]);
  }), t;
}
function fn(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return ri(e) && ri(t) && Object.keys(t).forEach((i) => {
    /* @__PURE__ */ _.isValidElement(t[i]) || Fi.isValidElementType(t[i]) ? r[i] = t[i] : ri(t[i]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, i) && ri(e[i]) ? r[i] = fn(e[i], t[i], n) : n.clone ? r[i] = ri(t[i]) ? EE(t[i]) : t[i] : r[i] = t[i];
  }), r;
}
function Ms(e, t) {
  return t ? fn(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const qi = process.env.NODE_ENV !== "production" ? h.oneOfType([h.number, h.string, h.object, h.array]) : {};
function Eb(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, i) => {
    const o = /min-width:\s*([0-9.]+)/;
    return +(r.match(o)?.[1] || 0) - +(i.match(o)?.[1] || 0);
  });
  return n.length ? n.reduce((r, i) => {
    const o = t[i];
    return delete r[i], r[i] = o, r;
  }, {
    ...t
  }) : t;
}
function PM(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function CM(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n) {
    if (process.env.NODE_ENV !== "production")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The provided shorthand ${`(${t})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : $r(18, `(${t})`));
    return null;
  }
  const [, r, i] = n, o = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(i).up(o);
}
function AM(e) {
  const t = (o, a) => o.replace("@media", a ? `@container ${a}` : "@container");
  function n(o, a) {
    o.up = (...s) => t(e.breakpoints.up(...s), a), o.down = (...s) => t(e.breakpoints.down(...s), a), o.between = (...s) => t(e.breakpoints.between(...s), a), o.only = (...s) => t(e.breakpoints.only(...s), a), o.not = (...s) => {
      const l = t(e.breakpoints.not(...s), a);
      return l.includes("not all and") ? l.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : l;
    };
  }
  const r = {}, i = (o) => (n(r, o), r);
  return n(i), {
    ...e,
    containerQueries: i
  };
}
const fd = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, _b = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${fd[e]}px)`
}, TM = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : fd[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function fi(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const o = r.breakpoints || _b;
    return t.reduce((a, s, l) => (a[o.up(o.keys[l])] = n(t[l]), a), {});
  }
  if (typeof t == "object") {
    const o = r.breakpoints || _b;
    return Object.keys(t).reduce((a, s) => {
      if (PM(o.keys, s)) {
        const l = CM(r.containerQueries ? r : TM, s);
        l && (a[l] = n(t[s], s));
      } else if (Object.keys(o.values || fd).includes(s)) {
        const l = o.up(s);
        a[l] = n(t[s], s);
      } else {
        const l = s;
        a[l] = t[l];
      }
      return a;
    }, {});
  }
  return n(t);
}
function kM(e = {}) {
  return e.keys?.reduce((n, r) => {
    const i = e.up(r);
    return n[i] = {}, n;
  }, {}) || {};
}
function Pb(e, t) {
  return e.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n;
  }, t);
}
function pd(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((i, o) => i && i[o] ? i[o] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, e);
}
function nu(e, t, n, r = n) {
  let i;
  return typeof e == "function" ? i = e(n) : Array.isArray(e) ? i = e[n] || r : i = pd(e, n) || r, t && (i = t(i, r, e)), i;
}
function Et(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: i
  } = e, o = (a) => {
    if (a[t] == null)
      return null;
    const s = a[t], l = a.theme, c = pd(l, r) || {};
    return fi(a, s, (d) => {
      let f = nu(c, i, d);
      return d === f && typeof d == "string" && (f = nu(c, i, `${t}${d === "default" ? "" : It(d)}`, d)), n === !1 ? f : {
        [n]: f
      };
    });
  };
  return o.propTypes = process.env.NODE_ENV !== "production" ? {
    [t]: qi
  } : {}, o.filterProps = [t], o;
}
function MM(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const jM = {
  m: "margin",
  p: "padding"
}, NM = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, Cb = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, DM = MM((e) => {
  if (e.length > 2)
    if (Cb[e])
      e = Cb[e];
    else
      return [e];
  const [t, n] = e.split(""), r = jM[t], i = NM[n] || "";
  return Array.isArray(i) ? i.map((o) => r + o) : [r + i];
}), hd = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], md = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], RM = [...hd, ...md];
function vl(e, t, n, r) {
  const i = pd(e, t, !0) ?? n;
  return typeof i == "number" || typeof i == "string" ? (o) => typeof o == "string" ? o : (process.env.NODE_ENV !== "production" && typeof o != "number" && console.error(`MUI: Expected ${r} argument to be a number or a string, got ${o}.`), typeof i == "string" ? i.startsWith("var(") && o === 0 ? 0 : i.startsWith("var(") && o === 1 ? i : `calc(${o} * ${i})` : i * o) : Array.isArray(i) ? (o) => {
    if (typeof o == "string")
      return o;
    const a = Math.abs(o);
    process.env.NODE_ENV !== "production" && (Number.isInteger(a) ? a > i.length - 1 && console.error([`MUI: The value provided (${a}) overflows.`, `The supported values are: ${JSON.stringify(i)}.`, `${a} > ${i.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${t}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${t}\` as a number.`].join(`
`)));
    const s = i[a];
    return o >= 0 ? s : typeof s == "number" ? -s : typeof s == "string" && s.startsWith("var(") ? `calc(-1 * ${s})` : `-${s}`;
  } : typeof i == "function" ? i : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${t}\` value (${i}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function rg(e) {
  return vl(e, "spacing", 8, "spacing");
}
function yl(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function IM(e, t) {
  return (n) => e.reduce((r, i) => (r[i] = yl(t, n), r), {});
}
function $M(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const i = DM(n), o = IM(i, r), a = e[n];
  return fi(e, a, o);
}
function _E(e, t) {
  const n = rg(e.theme);
  return Object.keys(e).map((r) => $M(e, t, r, n)).reduce(Ms, {});
}
function mt(e) {
  return _E(e, hd);
}
mt.propTypes = process.env.NODE_ENV !== "production" ? hd.reduce((e, t) => (e[t] = qi, e), {}) : {};
mt.filterProps = hd;
function gt(e) {
  return _E(e, md);
}
gt.propTypes = process.env.NODE_ENV !== "production" ? md.reduce((e, t) => (e[t] = qi, e), {}) : {};
gt.filterProps = md;
process.env.NODE_ENV !== "production" && RM.reduce((e, t) => (e[t] = qi, e), {});
function gd(...e) {
  const t = e.reduce((r, i) => (i.filterProps.forEach((o) => {
    r[o] = i;
  }), r), {}), n = (r) => Object.keys(r).reduce((i, o) => t[o] ? Ms(i, t[o](r)) : i, {});
  return n.propTypes = process.env.NODE_ENV !== "production" ? e.reduce((r, i) => Object.assign(r, i.propTypes), {}) : {}, n.filterProps = e.reduce((r, i) => r.concat(i.filterProps), []), n;
}
function ir(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function mr(e, t) {
  return Et({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const LM = mr("border", ir), FM = mr("borderTop", ir), BM = mr("borderRight", ir), zM = mr("borderBottom", ir), WM = mr("borderLeft", ir), VM = mr("borderColor"), UM = mr("borderTopColor"), HM = mr("borderRightColor"), KM = mr("borderBottomColor"), qM = mr("borderLeftColor"), YM = mr("outline", ir), GM = mr("outlineColor"), vd = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = vl(e.theme, "shape.borderRadius", 4, "borderRadius"), n = (r) => ({
      borderRadius: yl(t, r)
    });
    return fi(e, e.borderRadius, n);
  }
  return null;
};
vd.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: qi
} : {};
vd.filterProps = ["borderRadius"];
gd(LM, FM, BM, zM, WM, VM, UM, HM, KM, qM, vd, YM, GM);
const yd = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = vl(e.theme, "spacing", 8, "gap"), n = (r) => ({
      gap: yl(t, r)
    });
    return fi(e, e.gap, n);
  }
  return null;
};
yd.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: qi
} : {};
yd.filterProps = ["gap"];
const bd = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = vl(e.theme, "spacing", 8, "columnGap"), n = (r) => ({
      columnGap: yl(t, r)
    });
    return fi(e, e.columnGap, n);
  }
  return null;
};
bd.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: qi
} : {};
bd.filterProps = ["columnGap"];
const xd = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = vl(e.theme, "spacing", 8, "rowGap"), n = (r) => ({
      rowGap: yl(t, r)
    });
    return fi(e, e.rowGap, n);
  }
  return null;
};
xd.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: qi
} : {};
xd.filterProps = ["rowGap"];
const XM = Et({
  prop: "gridColumn"
}), ZM = Et({
  prop: "gridRow"
}), JM = Et({
  prop: "gridAutoFlow"
}), QM = Et({
  prop: "gridAutoColumns"
}), ej = Et({
  prop: "gridAutoRows"
}), tj = Et({
  prop: "gridTemplateColumns"
}), nj = Et({
  prop: "gridTemplateRows"
}), rj = Et({
  prop: "gridTemplateAreas"
}), ij = Et({
  prop: "gridArea"
});
gd(yd, bd, xd, XM, ZM, JM, QM, ej, tj, nj, rj, ij);
function pa(e, t) {
  return t === "grey" ? t : e;
}
const oj = Et({
  prop: "color",
  themeKey: "palette",
  transform: pa
}), aj = Et({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: pa
}), sj = Et({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: pa
});
gd(oj, aj, sj);
function Bn(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const lj = Et({
  prop: "width",
  transform: Bn
}), ig = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      const r = e.theme?.breakpoints?.values?.[n] || fd[n];
      return r ? e.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: Bn(n)
      };
    };
    return fi(e, e.maxWidth, t);
  }
  return null;
};
ig.filterProps = ["maxWidth"];
const cj = Et({
  prop: "minWidth",
  transform: Bn
}), uj = Et({
  prop: "height",
  transform: Bn
}), dj = Et({
  prop: "maxHeight",
  transform: Bn
}), fj = Et({
  prop: "minHeight",
  transform: Bn
});
Et({
  prop: "size",
  cssProperty: "width",
  transform: Bn
});
Et({
  prop: "size",
  cssProperty: "height",
  transform: Bn
});
const pj = Et({
  prop: "boxSizing"
});
gd(lj, ig, cj, uj, dj, fj, pj);
const wd = {
  // borders
  border: {
    themeKey: "borders",
    transform: ir
  },
  borderTop: {
    themeKey: "borders",
    transform: ir
  },
  borderRight: {
    themeKey: "borders",
    transform: ir
  },
  borderBottom: {
    themeKey: "borders",
    transform: ir
  },
  borderLeft: {
    themeKey: "borders",
    transform: ir
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: ir
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: vd
  },
  // palette
  color: {
    themeKey: "palette",
    transform: pa
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: pa
  },
  backgroundColor: {
    themeKey: "palette",
    transform: pa
  },
  // spacing
  p: {
    style: gt
  },
  pt: {
    style: gt
  },
  pr: {
    style: gt
  },
  pb: {
    style: gt
  },
  pl: {
    style: gt
  },
  px: {
    style: gt
  },
  py: {
    style: gt
  },
  padding: {
    style: gt
  },
  paddingTop: {
    style: gt
  },
  paddingRight: {
    style: gt
  },
  paddingBottom: {
    style: gt
  },
  paddingLeft: {
    style: gt
  },
  paddingX: {
    style: gt
  },
  paddingY: {
    style: gt
  },
  paddingInline: {
    style: gt
  },
  paddingInlineStart: {
    style: gt
  },
  paddingInlineEnd: {
    style: gt
  },
  paddingBlock: {
    style: gt
  },
  paddingBlockStart: {
    style: gt
  },
  paddingBlockEnd: {
    style: gt
  },
  m: {
    style: mt
  },
  mt: {
    style: mt
  },
  mr: {
    style: mt
  },
  mb: {
    style: mt
  },
  ml: {
    style: mt
  },
  mx: {
    style: mt
  },
  my: {
    style: mt
  },
  margin: {
    style: mt
  },
  marginTop: {
    style: mt
  },
  marginRight: {
    style: mt
  },
  marginBottom: {
    style: mt
  },
  marginLeft: {
    style: mt
  },
  marginX: {
    style: mt
  },
  marginY: {
    style: mt
  },
  marginInline: {
    style: mt
  },
  marginInlineStart: {
    style: mt
  },
  marginInlineEnd: {
    style: mt
  },
  marginBlock: {
    style: mt
  },
  marginBlockStart: {
    style: mt
  },
  marginBlockEnd: {
    style: mt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: yd
  },
  rowGap: {
    style: xd
  },
  columnGap: {
    style: bd
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Bn
  },
  maxWidth: {
    style: ig
  },
  minWidth: {
    transform: Bn
  },
  height: {
    transform: Bn
  },
  maxHeight: {
    transform: Bn
  },
  minHeight: {
    transform: Bn
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function hj(...e) {
  const t = e.reduce((r, i) => r.concat(Object.keys(i)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function mj(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function gj() {
  function e(n, r, i, o) {
    const a = {
      [n]: r,
      theme: i
    }, s = o[n];
    if (!s)
      return {
        [n]: r
      };
    const {
      cssProperty: l = n,
      themeKey: c,
      transform: u,
      style: d
    } = s;
    if (r == null)
      return null;
    if (c === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const f = pd(i, c) || {};
    return d ? d(a) : fi(a, r, (g) => {
      let m = nu(f, u, g);
      return g === m && typeof g == "string" && (m = nu(f, u, `${n}${g === "default" ? "" : It(g)}`, g)), l === !1 ? m : {
        [l]: m
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: i = {},
      nested: o
    } = n || {};
    if (!r)
      return null;
    const a = i.unstable_sxConfig ?? wd;
    function s(l) {
      let c = l;
      if (typeof l == "function")
        c = l(i);
      else if (typeof l != "object")
        return l;
      if (!c)
        return null;
      const u = kM(i.breakpoints), d = Object.keys(u);
      let f = u;
      return Object.keys(c).forEach((p) => {
        const g = mj(c[p], i);
        if (g != null)
          if (typeof g == "object")
            if (a[p])
              f = Ms(f, e(p, g, i, a));
            else {
              const m = fi({
                theme: i
              }, g, (v) => ({
                [p]: v
              }));
              hj(m, g) ? f[p] = t({
                sx: g,
                theme: i,
                nested: !0
              }) : f = Ms(f, m);
            }
          else
            f = Ms(f, e(p, g, i, a));
      }), !o && i.modularCssLayers ? {
        "@layer sx": Eb(i, Pb(d, f))
      } : Eb(i, Pb(d, f));
    }
    return Array.isArray(r) ? r.map(s) : s(r);
  }
  return t;
}
const xa = gj();
xa.filterProps = ["sx"];
function ru() {
  return ru = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ru.apply(null, arguments);
}
function vj(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function yj(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var bj = /* @__PURE__ */ (function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(yj(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = vj(i);
      try {
        o.insertRule(r, o.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), ln = "-ms-", iu = "-moz-", ke = "-webkit-", PE = "comm", og = "rule", ag = "decl", xj = "@import", CE = "@keyframes", wj = "@layer", Oj = Math.abs, Od = String.fromCharCode, Sj = Object.assign;
function Ej(e, t) {
  return en(e, 0) ^ 45 ? (((t << 2 ^ en(e, 0)) << 2 ^ en(e, 1)) << 2 ^ en(e, 2)) << 2 ^ en(e, 3) : 0;
}
function AE(e) {
  return e.trim();
}
function _j(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function Me(e, t, n) {
  return e.replace(t, n);
}
function Rh(e, t) {
  return e.indexOf(t);
}
function en(e, t) {
  return e.charCodeAt(t) | 0;
}
function Ws(e, t, n) {
  return e.slice(t, n);
}
function Tr(e) {
  return e.length;
}
function sg(e) {
  return e.length;
}
function nc(e, t) {
  return t.push(e), e;
}
function Pj(e, t) {
  return e.map(t).join("");
}
var Sd = 1, wa = 1, TE = 0, jn = 0, At = 0, $a = "";
function Ed(e, t, n, r, i, o, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: o, line: Sd, column: wa, length: a, return: "" };
}
function es(e, t) {
  return Sj(Ed("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function Cj() {
  return At;
}
function Aj() {
  return At = jn > 0 ? en($a, --jn) : 0, wa--, At === 10 && (wa = 1, Sd--), At;
}
function Vn() {
  return At = jn < TE ? en($a, jn++) : 0, wa++, At === 10 && (wa = 1, Sd++), At;
}
function Nr() {
  return en($a, jn);
}
function qc() {
  return jn;
}
function bl(e, t) {
  return Ws($a, e, t);
}
function Vs(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function kE(e) {
  return Sd = wa = 1, TE = Tr($a = e), jn = 0, [];
}
function ME(e) {
  return $a = "", e;
}
function Yc(e) {
  return AE(bl(jn - 1, Ih(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function Tj(e) {
  for (; (At = Nr()) && At < 33; )
    Vn();
  return Vs(e) > 2 || Vs(At) > 3 ? "" : " ";
}
function kj(e, t) {
  for (; --t && Vn() && !(At < 48 || At > 102 || At > 57 && At < 65 || At > 70 && At < 97); )
    ;
  return bl(e, qc() + (t < 6 && Nr() == 32 && Vn() == 32));
}
function Ih(e) {
  for (; Vn(); )
    switch (At) {
      // ] ) " '
      case e:
        return jn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Ih(At);
        break;
      // (
      case 40:
        e === 41 && Ih(e);
        break;
      // \
      case 92:
        Vn();
        break;
    }
  return jn;
}
function Mj(e, t) {
  for (; Vn() && e + At !== 57; )
    if (e + At === 84 && Nr() === 47)
      break;
  return "/*" + bl(t, jn - 1) + "*" + Od(e === 47 ? e : Vn());
}
function jj(e) {
  for (; !Vs(Nr()); )
    Vn();
  return bl(e, jn);
}
function Nj(e) {
  return ME(Gc("", null, null, null, [""], e = kE(e), 0, [0], e));
}
function Gc(e, t, n, r, i, o, a, s, l) {
  for (var c = 0, u = 0, d = a, f = 0, p = 0, g = 0, m = 1, v = 1, y = 1, S = 0, x = "", b = i, w = o, E = r, C = x; v; )
    switch (g = S, S = Vn()) {
      // (
      case 40:
        if (g != 108 && en(C, d - 1) == 58) {
          Rh(C += Me(Yc(S), "&", "&\f"), "&\f") != -1 && (y = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        C += Yc(S);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        C += Tj(g);
        break;
      // \
      case 92:
        C += kj(qc() - 1, 7);
        continue;
      // /
      case 47:
        switch (Nr()) {
          case 42:
          case 47:
            nc(Dj(Mj(Vn(), qc()), t, n), l);
            break;
          default:
            C += "/";
        }
        break;
      // {
      case 123 * m:
        s[c++] = Tr(C) * y;
      // } ; \0
      case 125 * m:
      case 59:
      case 0:
        switch (S) {
          // \0 }
          case 0:
          case 125:
            v = 0;
          // ;
          case 59 + u:
            y == -1 && (C = Me(C, /\f/g, "")), p > 0 && Tr(C) - d && nc(p > 32 ? Tb(C + ";", r, n, d - 1) : Tb(Me(C, " ", "") + ";", r, n, d - 2), l);
            break;
          // @ ;
          case 59:
            C += ";";
          // { rule/at-rule
          default:
            if (nc(E = Ab(C, t, n, c, u, i, s, x, b = [], w = [], d), o), S === 123)
              if (u === 0)
                Gc(C, t, E, E, b, o, d, s, w);
              else
                switch (f === 99 && en(C, 3) === 110 ? 100 : f) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Gc(e, E, E, r && nc(Ab(e, E, E, 0, 0, i, s, x, i, b = [], d), w), i, w, d, s, r ? b : w);
                    break;
                  default:
                    Gc(C, E, E, E, [""], w, 0, s, w);
                }
        }
        c = u = p = 0, m = y = 1, x = C = "", d = a;
        break;
      // :
      case 58:
        d = 1 + Tr(C), p = g;
      default:
        if (m < 1) {
          if (S == 123)
            --m;
          else if (S == 125 && m++ == 0 && Aj() == 125)
            continue;
        }
        switch (C += Od(S), S * m) {
          // &
          case 38:
            y = u > 0 ? 1 : (C += "\f", -1);
            break;
          // ,
          case 44:
            s[c++] = (Tr(C) - 1) * y, y = 1;
            break;
          // @
          case 64:
            Nr() === 45 && (C += Yc(Vn())), f = Nr(), u = d = Tr(x = C += jj(qc())), S++;
            break;
          // -
          case 45:
            g === 45 && Tr(C) == 2 && (m = 0);
        }
    }
  return o;
}
function Ab(e, t, n, r, i, o, a, s, l, c, u) {
  for (var d = i - 1, f = i === 0 ? o : [""], p = sg(f), g = 0, m = 0, v = 0; g < r; ++g)
    for (var y = 0, S = Ws(e, d + 1, d = Oj(m = a[g])), x = e; y < p; ++y)
      (x = AE(m > 0 ? f[y] + " " + S : Me(S, /&\f/g, f[y]))) && (l[v++] = x);
  return Ed(e, t, n, i === 0 ? og : s, l, c, u);
}
function Dj(e, t, n) {
  return Ed(e, t, n, PE, Od(Cj()), Ws(e, 2, -2), 0);
}
function Tb(e, t, n, r) {
  return Ed(e, t, n, ag, Ws(e, 0, r), Ws(e, r + 1, -1), r);
}
function ha(e, t) {
  for (var n = "", r = sg(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function Rj(e, t, n, r) {
  switch (e.type) {
    case wj:
      if (e.children.length) break;
    case xj:
    case ag:
      return e.return = e.return || e.value;
    case PE:
      return "";
    case CE:
      return e.return = e.value + "{" + ha(e.children, r) + "}";
    case og:
      e.value = e.props.join(",");
  }
  return Tr(n = ha(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function Ij(e) {
  var t = sg(e);
  return function(n, r, i, o) {
    for (var a = "", s = 0; s < t; s++)
      a += e[s](n, r, i, o) || "";
    return a;
  };
}
function $j(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function jE(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Lj = function(t, n, r) {
  for (var i = 0, o = 0; i = o, o = Nr(), i === 38 && o === 12 && (n[r] = 1), !Vs(o); )
    Vn();
  return bl(t, jn);
}, Fj = function(t, n) {
  var r = -1, i = 44;
  do
    switch (Vs(i)) {
      case 0:
        i === 38 && Nr() === 12 && (n[r] = 1), t[r] += Lj(jn - 1, n, r);
        break;
      case 2:
        t[r] += Yc(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = Nr() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Od(i);
    }
  while (i = Vn());
  return t;
}, Bj = function(t, n) {
  return ME(Fj(kE(t), n));
}, kb = /* @__PURE__ */ new WeakMap(), zj = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !kb.get(r)) && !i) {
      kb.set(t, !0);
      for (var o = [], a = Bj(n, o), s = r.props, l = 0, c = 0; l < a.length; l++)
        for (var u = 0; u < s.length; u++, c++)
          t.props[c] = o[l] ? a[l].replace(/&\f/g, s[u]) : s[u] + " " + a[l];
    }
  }
}, Wj = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function NE(e, t) {
  switch (Ej(e, t)) {
    // color-adjust
    case 5103:
      return ke + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return ke + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return ke + e + iu + e + ln + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return ke + e + ln + e + e;
    // order
    case 6165:
      return ke + e + ln + "flex-" + e + e;
    // align-items
    case 5187:
      return ke + e + Me(e, /(\w+).+(:[^]+)/, ke + "box-$1$2" + ln + "flex-$1$2") + e;
    // align-self
    case 5443:
      return ke + e + ln + "flex-item-" + Me(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return ke + e + ln + "flex-line-pack" + Me(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return ke + e + ln + Me(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return ke + e + ln + Me(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return ke + "box-" + Me(e, "-grow", "") + ke + e + ln + Me(e, "grow", "positive") + e;
    // transition
    case 4554:
      return ke + Me(e, /([^-])(transform)/g, "$1" + ke + "$2") + e;
    // cursor
    case 6187:
      return Me(Me(Me(e, /(zoom-|grab)/, ke + "$1"), /(image-set)/, ke + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return Me(e, /(image-set\([^]*)/, ke + "$1$`$1");
    // justify-content
    case 4968:
      return Me(Me(e, /(.+:)(flex-)?(.*)/, ke + "box-pack:$3" + ln + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + ke + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Me(e, /(.+)-inline(.+)/, ke + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Tr(e) - 1 - t > 6) switch (en(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (en(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return Me(e, /(.+:)(.+)-([^]+)/, "$1" + ke + "$2-$3$1" + iu + (en(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Rh(e, "stretch") ? NE(Me(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (en(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (en(e, Tr(e) - 3 - (~Rh(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return Me(e, ":", ":" + ke) + e;
        // (inline-)?fl(e)x
        case 101:
          return Me(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + ke + (en(e, 14) === 45 ? "inline-" : "") + "box$3$1" + ke + "$2$3$1" + ln + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (en(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return ke + e + ln + Me(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return ke + e + ln + Me(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return ke + e + ln + Me(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return ke + e + ln + e + e;
  }
  return e;
}
var Vj = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case ag:
      t.return = NE(t.value, t.length);
      break;
    case CE:
      return ha([es(t, {
        value: Me(t.value, "@", "@" + ke)
      })], i);
    case og:
      if (t.length) return Pj(t.props, function(o) {
        switch (_j(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return ha([es(t, {
              props: [Me(o, /:(read-\w+)/, ":" + iu + "$1")]
            })], i);
          // :placeholder
          case "::placeholder":
            return ha([es(t, {
              props: [Me(o, /:(plac\w+)/, ":" + ke + "input-$1")]
            }), es(t, {
              props: [Me(o, /:(plac\w+)/, ":" + iu + "$1")]
            }), es(t, {
              props: [Me(o, /:(plac\w+)/, ln + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, Uj = [Vj], Hj = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(m) {
      var v = m.getAttribute("data-emotion");
      v.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || Uj, o = {}, a, s = [];
  a = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(m) {
      for (var v = m.getAttribute("data-emotion").split(" "), y = 1; y < v.length; y++)
        o[v[y]] = !0;
      s.push(m);
    }
  );
  var l, c = [zj, Wj];
  {
    var u, d = [Rj, $j(function(m) {
      u.insert(m);
    })], f = Ij(c.concat(i, d)), p = function(v) {
      return ha(Nj(v), f);
    };
    l = function(v, y, S, x) {
      u = S, p(v ? v + "{" + y.styles + "}" : y.styles), x && (g.inserted[y.name] = !0);
    };
  }
  var g = {
    key: n,
    sheet: new bj({
      key: n,
      container: a,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: l
  };
  return g.sheet.hydrate(s), g;
}, rc = { exports: {} }, Ie = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mb;
function Kj() {
  if (Mb) return Ie;
  Mb = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var E = w.$$typeof;
      switch (E) {
        case t:
          switch (w = w.type, w) {
            case l:
            case c:
            case r:
            case o:
            case i:
            case d:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case s:
                case u:
                case g:
                case p:
                case a:
                  return w;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function b(w) {
    return x(w) === c;
  }
  return Ie.AsyncMode = l, Ie.ConcurrentMode = c, Ie.ContextConsumer = s, Ie.ContextProvider = a, Ie.Element = t, Ie.ForwardRef = u, Ie.Fragment = r, Ie.Lazy = g, Ie.Memo = p, Ie.Portal = n, Ie.Profiler = o, Ie.StrictMode = i, Ie.Suspense = d, Ie.isAsyncMode = function(w) {
    return b(w) || x(w) === l;
  }, Ie.isConcurrentMode = b, Ie.isContextConsumer = function(w) {
    return x(w) === s;
  }, Ie.isContextProvider = function(w) {
    return x(w) === a;
  }, Ie.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, Ie.isForwardRef = function(w) {
    return x(w) === u;
  }, Ie.isFragment = function(w) {
    return x(w) === r;
  }, Ie.isLazy = function(w) {
    return x(w) === g;
  }, Ie.isMemo = function(w) {
    return x(w) === p;
  }, Ie.isPortal = function(w) {
    return x(w) === n;
  }, Ie.isProfiler = function(w) {
    return x(w) === o;
  }, Ie.isStrictMode = function(w) {
    return x(w) === i;
  }, Ie.isSuspense = function(w) {
    return x(w) === d;
  }, Ie.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === c || w === o || w === i || w === d || w === f || typeof w == "object" && w !== null && (w.$$typeof === g || w.$$typeof === p || w.$$typeof === a || w.$$typeof === s || w.$$typeof === u || w.$$typeof === v || w.$$typeof === y || w.$$typeof === S || w.$$typeof === m);
  }, Ie.typeOf = x, Ie;
}
var $e = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jb;
function qj() {
  return jb || (jb = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, y = e ? Symbol.for("react.responder") : 60118, S = e ? Symbol.for("react.scope") : 60119;
    function x(T) {
      return typeof T == "string" || typeof T == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      T === r || T === c || T === o || T === i || T === d || T === f || typeof T == "object" && T !== null && (T.$$typeof === g || T.$$typeof === p || T.$$typeof === a || T.$$typeof === s || T.$$typeof === u || T.$$typeof === v || T.$$typeof === y || T.$$typeof === S || T.$$typeof === m);
    }
    function b(T) {
      if (typeof T == "object" && T !== null) {
        var de = T.$$typeof;
        switch (de) {
          case t:
            var ee = T.type;
            switch (ee) {
              case l:
              case c:
              case r:
              case o:
              case i:
              case d:
                return ee;
              default:
                var he = ee && ee.$$typeof;
                switch (he) {
                  case s:
                  case u:
                  case g:
                  case p:
                  case a:
                    return he;
                  default:
                    return de;
                }
            }
          case n:
            return de;
        }
      }
    }
    var w = l, E = c, C = s, A = a, k = t, R = u, M = r, P = g, D = p, j = n, N = o, $ = i, F = d, q = !1;
    function B(T) {
      return q || (q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(T) || b(T) === l;
    }
    function L(T) {
      return b(T) === c;
    }
    function Y(T) {
      return b(T) === s;
    }
    function K(T) {
      return b(T) === a;
    }
    function te(T) {
      return typeof T == "object" && T !== null && T.$$typeof === t;
    }
    function J(T) {
      return b(T) === u;
    }
    function Q(T) {
      return b(T) === r;
    }
    function ne(T) {
      return b(T) === g;
    }
    function re(T) {
      return b(T) === p;
    }
    function ie(T) {
      return b(T) === n;
    }
    function U(T) {
      return b(T) === o;
    }
    function H(T) {
      return b(T) === i;
    }
    function Z(T) {
      return b(T) === d;
    }
    $e.AsyncMode = w, $e.ConcurrentMode = E, $e.ContextConsumer = C, $e.ContextProvider = A, $e.Element = k, $e.ForwardRef = R, $e.Fragment = M, $e.Lazy = P, $e.Memo = D, $e.Portal = j, $e.Profiler = N, $e.StrictMode = $, $e.Suspense = F, $e.isAsyncMode = B, $e.isConcurrentMode = L, $e.isContextConsumer = Y, $e.isContextProvider = K, $e.isElement = te, $e.isForwardRef = J, $e.isFragment = Q, $e.isLazy = ne, $e.isMemo = re, $e.isPortal = ie, $e.isProfiler = U, $e.isStrictMode = H, $e.isSuspense = Z, $e.isValidElementType = x, $e.typeOf = b;
  })()), $e;
}
var Nb;
function Yj() {
  return Nb || (Nb = 1, process.env.NODE_ENV === "production" ? rc.exports = Kj() : rc.exports = qj()), rc.exports;
}
var jf, Db;
function Gj() {
  if (Db) return jf;
  Db = 1;
  var e = Yj(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, i = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, o = {};
  o[e.ForwardRef] = r, o[e.Memo] = i;
  function a(g) {
    return e.isMemo(g) ? i : o[g.$$typeof] || t;
  }
  var s = Object.defineProperty, l = Object.getOwnPropertyNames, c = Object.getOwnPropertySymbols, u = Object.getOwnPropertyDescriptor, d = Object.getPrototypeOf, f = Object.prototype;
  function p(g, m, v) {
    if (typeof m != "string") {
      if (f) {
        var y = d(m);
        y && y !== f && p(g, y, v);
      }
      var S = l(m);
      c && (S = S.concat(c(m)));
      for (var x = a(g), b = a(m), w = 0; w < S.length; ++w) {
        var E = S[w];
        if (!n[E] && !(v && v[E]) && !(b && b[E]) && !(x && x[E])) {
          var C = u(m, E);
          try {
            s(g, E, C);
          } catch {
          }
        }
      }
    }
    return g;
  }
  return jf = p, jf;
}
Gj();
var Xj = !0;
function DE(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var lg = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  Xj === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, cg = function(t, n, r) {
  lg(t, n, r);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + i : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function Zj(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var Jj = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Qj = /[A-Z]|^ms/g, eN = /_EMO_([^_]+?)_([^]*?)_EMO_/g, RE = function(t) {
  return t.charCodeAt(1) === 45;
}, Rb = function(t) {
  return t != null && typeof t != "boolean";
}, Nf = /* @__PURE__ */ jE(function(e) {
  return RE(e) ? e : e.replace(Qj, "-$&").toLowerCase();
}), Ib = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(eN, function(r, i, o) {
          return kr = {
            name: i,
            styles: o,
            next: kr
          }, i;
        });
  }
  return Jj[t] !== 1 && !RE(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Us(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return kr = {
          name: i.name,
          styles: i.styles,
          next: kr
        }, i.name;
      var o = n;
      if (o.styles !== void 0) {
        var a = o.next;
        if (a !== void 0)
          for (; a !== void 0; )
            kr = {
              name: a.name,
              styles: a.styles,
              next: kr
            }, a = a.next;
        var s = o.styles + ";";
        return s;
      }
      return tN(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var l = kr, c = n(e);
        return kr = l, Us(e, t, c);
      }
      break;
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function tN(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += Us(e, t, n[i]) + ";";
  else
    for (var o in n) {
      var a = n[o];
      if (typeof a != "object") {
        var s = a;
        t != null && t[s] !== void 0 ? r += o + "{" + t[s] + "}" : Rb(s) && (r += Nf(o) + ":" + Ib(o, s) + ";");
      } else if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
        for (var l = 0; l < a.length; l++)
          Rb(a[l]) && (r += Nf(o) + ":" + Ib(o, a[l]) + ";");
      else {
        var c = Us(e, t, a);
        switch (o) {
          case "animation":
          case "animationName": {
            r += Nf(o) + ":" + c + ";";
            break;
          }
          default:
            r += o + "{" + c + "}";
        }
      }
    }
  return r;
}
var $b = /label:\s*([^\s;{]+)\s*(;|$)/g, kr;
function xl(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  kr = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    r = !1, i += Us(n, t, o);
  else {
    var a = o;
    i += a[0];
  }
  for (var s = 1; s < e.length; s++)
    if (i += Us(n, t, e[s]), r) {
      var l = o;
      i += l[s];
    }
  $b.lastIndex = 0;
  for (var c = "", u; (u = $b.exec(i)) !== null; )
    c += "-" + u[1];
  var d = Zj(i) + c;
  return {
    name: d,
    styles: i,
    next: kr
  };
}
var nN = function(t) {
  return t();
}, IE = _.useInsertionEffect ? _.useInsertionEffect : !1, $E = IE || nN, Lb = IE || _.useLayoutEffect, LE = /* @__PURE__ */ _.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ Hj({
    key: "css"
  }) : null
);
LE.Provider;
var ug = function(t) {
  return /* @__PURE__ */ nn(function(n, r) {
    var i = Vr(LE);
    return t(n, i, r);
  });
}, _d = /* @__PURE__ */ _.createContext({}), dg = {}.hasOwnProperty, $h = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", rN = function(t, n) {
  var r = {};
  for (var i in n)
    dg.call(n, i) && (r[i] = n[i]);
  return r[$h] = t, r;
}, iN = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return lg(n, r, i), $E(function() {
    return cg(n, r, i);
  }), null;
}, oN = /* @__PURE__ */ ug(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var i = e[$h], o = [r], a = "";
  typeof e.className == "string" ? a = DE(t.registered, o, e.className) : e.className != null && (a = e.className + " ");
  var s = xl(o, void 0, _.useContext(_d));
  a += t.key + "-" + s.name;
  var l = {};
  for (var c in e)
    dg.call(e, c) && c !== "css" && c !== $h && (l[c] = e[c]);
  return l.className = a, n && (l.ref = n), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(iN, {
    cache: t,
    serialized: s,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ _.createElement(i, l));
}), aN = oN, Fb = function(t, n) {
  var r = arguments;
  if (n == null || !dg.call(n, "css"))
    return _.createElement.apply(void 0, r);
  var i = r.length, o = new Array(i);
  o[0] = aN, o[1] = rN(t, n);
  for (var a = 2; a < i; a++)
    o[a] = r[a];
  return _.createElement.apply(null, o);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(Fb || (Fb = {}));
var sN = /* @__PURE__ */ ug(function(e, t) {
  var n = e.styles, r = xl([n], void 0, _.useContext(_d)), i = _.useRef();
  return Lb(function() {
    var o = t.key + "-global", a = new t.sheet.constructor({
      key: o,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), s = !1, l = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
    return t.sheet.tags.length && (a.before = t.sheet.tags[0]), l !== null && (s = !0, l.setAttribute("data-emotion", o), a.hydrate([l])), i.current = [a, s], function() {
      a.flush();
    };
  }, [t]), Lb(function() {
    var o = i.current, a = o[0], s = o[1];
    if (s) {
      o[1] = !1;
      return;
    }
    if (r.next !== void 0 && cg(t, r.next, !0), a.tags.length) {
      var l = a.tags[a.tags.length - 1].nextElementSibling;
      a.before = l, a.flush();
    }
    t.insert("", r, a, !1);
  }, [t, r.name]), null;
});
function lN() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return xl(t);
}
function fg() {
  var e = lN.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var cN = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, uN = /* @__PURE__ */ jE(
  function(e) {
    return cN.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), dN = uN, fN = function(t) {
  return t !== "theme";
}, Bb = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? dN : fN;
}, zb = function(t, n, r) {
  var i;
  if (n) {
    var o = n.shouldForwardProp;
    i = t.__emotion_forwardProp && o ? function(a) {
      return t.__emotion_forwardProp(a) && o(a);
    } : o;
  }
  return typeof i != "function" && r && (i = t.__emotion_forwardProp), i;
}, pN = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return lg(n, r, i), $E(function() {
    return cg(n, r, i);
  }), null;
}, hN = function e(t, n) {
  var r = t.__emotion_real === t, i = r && t.__emotion_base || t, o, a;
  n !== void 0 && (o = n.label, a = n.target);
  var s = zb(t, n, r), l = s || Bb(i), c = !l("as");
  return function() {
    var u = arguments, d = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (o !== void 0 && d.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0)
      d.push.apply(d, u);
    else {
      var f = u[0];
      d.push(f[0]);
      for (var p = u.length, g = 1; g < p; g++)
        d.push(u[g], f[g]);
    }
    var m = ug(function(v, y, S) {
      var x = c && v.as || i, b = "", w = [], E = v;
      if (v.theme == null) {
        E = {};
        for (var C in v)
          E[C] = v[C];
        E.theme = _.useContext(_d);
      }
      typeof v.className == "string" ? b = DE(y.registered, w, v.className) : v.className != null && (b = v.className + " ");
      var A = xl(d.concat(w), y.registered, E);
      b += y.key + "-" + A.name, a !== void 0 && (b += " " + a);
      var k = c && s === void 0 ? Bb(x) : l, R = {};
      for (var M in v)
        c && M === "as" || k(M) && (R[M] = v[M]);
      return R.className = b, S && (R.ref = S), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(pN, {
        cache: y,
        serialized: A,
        isStringTag: typeof x == "string"
      }), /* @__PURE__ */ _.createElement(x, R));
    });
    return m.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", m.defaultProps = t.defaultProps, m.__emotion_real = m, m.__emotion_base = i, m.__emotion_styles = d, m.__emotion_forwardProp = s, Object.defineProperty(m, "toString", {
      value: function() {
        return "." + a;
      }
    }), m.withComponent = function(v, y) {
      var S = e(v, ru({}, n, y, {
        shouldForwardProp: zb(m, y, !0)
      }));
      return S.apply(void 0, d);
    }, m;
  };
}, mN = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], ou = hN.bind(null);
mN.forEach(function(e) {
  ou[e] = ou(e);
});
function gN(e) {
  return e == null || Object.keys(e).length === 0;
}
function FE(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? (i) => t(gN(i) ? n : i) : t;
  return /* @__PURE__ */ O.jsx(sN, {
    styles: r
  });
}
process.env.NODE_ENV !== "production" && (FE.propTypes = {
  defaultTheme: h.object,
  styles: h.oneOfType([h.array, h.string, h.object, h.func])
});
/**
 * @mui/styled-engine v7.3.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function vN(e, t) {
  const n = ou(e, t);
  return process.env.NODE_ENV !== "production" ? (...r) => {
    const i = typeof e == "string" ? `"${e}"` : "component";
    return r.length === 0 ? console.error([`MUI: Seems like you called \`styled(${i})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : r.some((o) => o === void 0) && console.error(`MUI: the styled(${i})(...args) API requires all its args to be defined.`), n(...r);
  } : n;
}
function yN(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const Wb = [];
function Ii(e) {
  return Wb[0] = e, xl(Wb);
}
const bN = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function xN(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...i
  } = e, o = bN(t), a = Object.keys(o);
  function s(f) {
    return `@media (min-width:${typeof t[f] == "number" ? t[f] : f}${n})`;
  }
  function l(f) {
    return `@media (max-width:${(typeof t[f] == "number" ? t[f] : f) - r / 100}${n})`;
  }
  function c(f, p) {
    const g = a.indexOf(p);
    return `@media (min-width:${typeof t[f] == "number" ? t[f] : f}${n}) and (max-width:${(g !== -1 && typeof t[a[g]] == "number" ? t[a[g]] : p) - r / 100}${n})`;
  }
  function u(f) {
    return a.indexOf(f) + 1 < a.length ? c(f, a[a.indexOf(f) + 1]) : s(f);
  }
  function d(f) {
    const p = a.indexOf(f);
    return p === 0 ? s(a[1]) : p === a.length - 1 ? l(a[p]) : c(f, a[a.indexOf(f) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: a,
    values: o,
    up: s,
    down: l,
    between: c,
    only: u,
    not: d,
    unit: n,
    ...i
  };
}
const wN = {
  borderRadius: 4
};
function BE(e = 8, t = rg({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (process.env.NODE_ENV !== "production" && (r.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${r.length}`)), (r.length === 0 ? [1] : r).map((o) => {
    const a = t(o);
    return typeof a == "number" ? `${a}px` : a;
  }).join(" "));
  return n.mui = !0, n;
}
function ON(e, t) {
  const n = this;
  if (n.vars) {
    if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
      return {};
    let r = n.getColorSchemeSelector(e);
    return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
      [r]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function pg(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: i,
    shape: o = {},
    ...a
  } = e, s = xN(n), l = BE(i);
  let c = fn({
    breakpoints: s,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: l,
    shape: {
      ...wN,
      ...o
    }
  }, a);
  return c = AM(c), c.applyStyles = ON, c = t.reduce((u, d) => fn(u, d), c), c.unstable_sxConfig = {
    ...wd,
    ...a?.unstable_sxConfig
  }, c.unstable_sx = function(d) {
    return xa({
      sx: d,
      theme: this
    });
  }, c;
}
function SN(e) {
  return Object.keys(e).length === 0;
}
function EN(e = null) {
  const t = _.useContext(_d);
  return !t || SN(t) ? e : t;
}
const _N = pg();
function zE(e = _N) {
  return EN(e);
}
function Df(e) {
  const t = Ii(e);
  return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : e;
}
function WE({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = zE(n), i = t && r[t] || r;
  let o = typeof e == "function" ? e(i) : e;
  return i.modularCssLayers && (Array.isArray(o) ? o = o.map((a) => Df(typeof a == "function" ? a(i) : a)) : o = Df(o)), /* @__PURE__ */ O.jsx(FE, {
    styles: o
  });
}
process.env.NODE_ENV !== "production" && (WE.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  defaultTheme: h.object,
  /**
   * @ignore
   */
  styles: h.oneOfType([h.array, h.func, h.number, h.object, h.string, h.bool]),
  /**
   * @ignore
   */
  themeId: h.string
});
const PN = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function Mt(e, t, n = "Mui") {
  const r = PN[t];
  return r ? `${n}-${r}` : `${hM.generate(e)}-${t}`;
}
function xt(e, t, n = "Mui") {
  const r = {};
  return t.forEach((i) => {
    r[i] = Mt(e, i, n);
  }), r;
}
function VE(e, t = "") {
  return e.displayName || e.name || t;
}
function Vb(e, t, n) {
  const r = VE(t);
  return e.displayName || (r !== "" ? `${n}(${r})` : n);
}
function CN(e) {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return VE(e, "Component");
    if (typeof e == "object")
      switch (e.$$typeof) {
        case Fi.ForwardRef:
          return Vb(e, e.render, "ForwardRef");
        case Fi.Memo:
          return Vb(e, e.type, "memo");
        default:
          return;
      }
  }
}
function UE(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: Ii(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((i) => {
    typeof i.style != "function" && (i.style = Ii(i.style));
  }), r;
}
const AN = pg();
function Rf(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function xo(e, t) {
  return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
}
function TN(e) {
  return e ? (t, n) => n[e] : null;
}
function kN(e, t, n) {
  e.theme = DN(e.theme) ? n : e.theme[t] || e.theme;
}
function Xc(e, t, n) {
  const r = typeof t == "function" ? t(e) : t;
  if (Array.isArray(r))
    return r.flatMap((i) => Xc(e, i, n));
  if (Array.isArray(r?.variants)) {
    let i;
    if (r.isProcessed)
      i = n ? xo(r.style, n) : r.style;
    else {
      const {
        variants: o,
        ...a
      } = r;
      i = n ? xo(Ii(a), n) : a;
    }
    return HE(e, r.variants, [i], n);
  }
  return r?.isProcessed ? n ? xo(Ii(r.style), n) : r.style : n ? xo(Ii(r), n) : r;
}
function HE(e, t, n = [], r = void 0) {
  let i;
  e: for (let o = 0; o < t.length; o += 1) {
    const a = t[o];
    if (typeof a.props == "function") {
      if (i ??= {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }, !a.props(i))
        continue;
    } else
      for (const s in a.props)
        if (e[s] !== a.props[s] && e.ownerState?.[s] !== a.props[s])
          continue e;
    typeof a.style == "function" ? (i ??= {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }, n.push(r ? xo(Ii(a.style(i)), r) : a.style(i))) : n.push(r ? xo(Ii(a.style), r) : a.style);
  }
  return n;
}
function MN(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = AN,
    rootShouldForwardProp: r = Rf,
    slotShouldForwardProp: i = Rf
  } = e;
  function o(s) {
    kN(s, t, n);
  }
  return (s, l = {}) => {
    yN(s, (E) => E.filter((C) => C !== xa));
    const {
      name: c,
      slot: u,
      skipVariantsResolver: d,
      skipSx: f,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: p = TN(KE(u)),
      ...g
    } = l, m = c && c.startsWith("Mui") || u ? "components" : "custom", v = d !== void 0 ? d : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      u && u !== "Root" && u !== "root" || !1
    ), y = f || !1;
    let S = Rf;
    u === "Root" || u === "root" ? S = r : u ? S = i : RN(s) && (S = void 0);
    const x = vN(s, {
      shouldForwardProp: S,
      label: NN(c, u),
      ...g
    }), b = (E) => {
      if (E.__emotion_real === E)
        return E;
      if (typeof E == "function")
        return function(A) {
          return Xc(A, E, A.theme.modularCssLayers ? m : void 0);
        };
      if (ri(E)) {
        const C = UE(E);
        return function(k) {
          return C.variants ? Xc(k, C, k.theme.modularCssLayers ? m : void 0) : k.theme.modularCssLayers ? xo(C.style, m) : C.style;
        };
      }
      return E;
    }, w = (...E) => {
      const C = [], A = E.map(b), k = [];
      if (C.push(o), c && p && k.push(function(D) {
        const N = D.theme.components?.[c]?.styleOverrides;
        if (!N)
          return null;
        const $ = {};
        for (const F in N)
          $[F] = Xc(D, N[F], D.theme.modularCssLayers ? "theme" : void 0);
        return p(D, $);
      }), c && !v && k.push(function(D) {
        const N = D.theme?.components?.[c]?.variants;
        return N ? HE(D, N, [], D.theme.modularCssLayers ? "theme" : void 0) : null;
      }), y || k.push(xa), Array.isArray(A[0])) {
        const P = A.shift(), D = new Array(C.length).fill(""), j = new Array(k.length).fill("");
        let N;
        N = [...D, ...P, ...j], N.raw = [...D, ...P.raw, ...j], C.unshift(N);
      }
      const R = [...C, ...A, ...k], M = x(...R);
      return s.muiName && (M.muiName = s.muiName), process.env.NODE_ENV !== "production" && (M.displayName = jN(c, u, s)), M;
    };
    return x.withConfig && (w.withConfig = x.withConfig), w;
  };
}
function jN(e, t, n) {
  return e ? `${e}${It(t || "")}` : `Styled(${CN(n)})`;
}
function NN(e, t) {
  let n;
  return process.env.NODE_ENV !== "production" && e && (n = `${e}-${KE(t || "Root")}`), n;
}
function DN(e) {
  for (const t in e)
    return !1;
  return !0;
}
function RN(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function KE(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function Lh(e, t, n = !1) {
  const r = {
    ...t
  };
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const o = i;
      if (o === "components" || o === "slots")
        r[o] = {
          ...e[o],
          ...r[o]
        };
      else if (o === "componentsProps" || o === "slotProps") {
        const a = e[o], s = t[o];
        if (!s)
          r[o] = a || {};
        else if (!a)
          r[o] = s;
        else {
          r[o] = {
            ...s
          };
          for (const l in a)
            if (Object.prototype.hasOwnProperty.call(a, l)) {
              const c = l;
              r[o][c] = Lh(a[c], s[c], n);
            }
        }
      } else o === "className" && n && t.className ? r.className = ce(e?.className, t?.className) : o === "style" && n && t.style ? r.style = {
        ...e?.style,
        ...t?.style
      } : r[o] === void 0 && (r[o] = e[o]);
    }
  return r;
}
const Lr = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function IN(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function hg(e, t = 0, n = 1) {
  return process.env.NODE_ENV !== "production" && (e < t || e > n) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${n}].`), IN(e, t, n);
}
function $N(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), process.env.NODE_ENV !== "production" && e.length !== e.trim().length && console.error(`MUI: The color: "${e}" is invalid. Make sure the color input doesn't contain leading/trailing space.`), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, i) => i < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Bi(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return Bi($N(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${e}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : $r(9, e));
  let r = e.substring(t + 1, e.length - 1), i;
  if (n === "color") {
    if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(i))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${i}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : $r(10, i));
  } else
    r = r.split(",");
  return r = r.map((o) => parseFloat(o)), {
    type: n,
    values: r,
    colorSpace: i
  };
}
const LN = (e) => {
  const t = Bi(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, Os = (e, t) => {
  try {
    return LN(e);
  } catch {
    return t && process.env.NODE_ENV !== "production" && console.warn(t), e;
  }
};
function Pd(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((i, o) => o < 3 ? parseInt(i, 10) : i) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function qE(e) {
  e = Bi(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, o = r * Math.min(i, 1 - i), a = (c, u = (c + n / 30) % 12) => i - o * Math.max(Math.min(u - 3, 9 - u, 1), -1);
  let s = "rgb";
  const l = [Math.round(a(0) * 255), Math.round(a(8) * 255), Math.round(a(4) * 255)];
  return e.type === "hsla" && (s += "a", l.push(t[3])), Pd({
    type: s,
    values: l
  });
}
function Fh(e) {
  e = Bi(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Bi(qE(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function Ub(e, t) {
  const n = Fh(e), r = Fh(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function au(e, t) {
  return e = Bi(e), t = hg(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, Pd(e);
}
function oo(e, t, n) {
  try {
    return au(e, t);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), e;
  }
}
function Cd(e, t) {
  if (e = Bi(e), t = hg(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return Pd(e);
}
function Be(e, t, n) {
  try {
    return Cd(e, t);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), e;
  }
}
function Ad(e, t) {
  if (e = Bi(e), t = hg(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return Pd(e);
}
function ze(e, t, n) {
  try {
    return Ad(e, t);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), e;
  }
}
function FN(e, t = 0.15) {
  return Fh(e) > 0.5 ? Cd(e, t) : Ad(e, t);
}
function ic(e, t, n) {
  try {
    return FN(e, t);
  } catch {
    return e;
  }
}
const BN = "exact-prop: ";
function YE(e) {
  return process.env.NODE_ENV === "production" ? e : {
    ...e,
    [BN]: (t) => {
      const n = Object.keys(t).filter((r) => !e.hasOwnProperty(r));
      return n.length > 0 ? new Error(`The following props are not supported: ${n.map((r) => `\`${r}\``).join(", ")}. Please remove them.`) : null;
    }
  };
}
const zN = /* @__PURE__ */ _.createContext();
process.env.NODE_ENV !== "production" && (h.node, h.bool);
const mg = () => _.useContext(zN) ?? !1, WN = /* @__PURE__ */ _.createContext(void 0);
process.env.NODE_ENV !== "production" && (h.node, h.object);
function VN(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const i = t.components[n];
  return i.defaultProps ? Lh(i.defaultProps, r, t.components.mergeClassNameAndStyle) : !i.styleOverrides && !i.variants ? Lh(i, r, t.components.mergeClassNameAndStyle) : r;
}
function UN({
  props: e,
  name: t
}) {
  const n = _.useContext(WN);
  return VN({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
let Hb = 0;
function HN(e) {
  const [t, n] = _.useState(e), r = e || t;
  return _.useEffect(() => {
    t == null && (Hb += 1, n(`mui-${Hb}`));
  }, [t]), r;
}
const KN = {
  ..._
}, Kb = KN.useId;
function GE(e) {
  if (Kb !== void 0) {
    const t = Kb();
    return e ?? t;
  }
  return HN(e);
}
const qb = {
  theme: void 0
};
function qN(e) {
  let t, n;
  return function(i) {
    let o = t;
    return (o === void 0 || i.theme !== n) && (qb.theme = i.theme, o = UE(e(qb)), t = o, n = i.theme), o;
  };
}
function YN(e = "") {
  function t(...r) {
    if (!r.length)
      return "";
    const i = r[0];
    return typeof i == "string" && !i.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${i}${t(...r.slice(1))})` : `, ${i}`;
  }
  return (r, ...i) => `var(--${e ? `${e}-` : ""}${r}${t(...i)})`;
}
const Yb = (e, t, n, r = []) => {
  let i = e;
  t.forEach((o, a) => {
    a === t.length - 1 ? Array.isArray(i) ? i[Number(o)] = n : i && typeof i == "object" && (i[o] = n) : i && typeof i == "object" && (i[o] || (i[o] = r.includes(o) ? [] : {}), i = i[o]);
  });
}, GN = (e, t, n) => {
  function r(i, o = [], a = []) {
    Object.entries(i).forEach(([s, l]) => {
      (!n || n && !n([...o, s])) && l != null && (typeof l == "object" && Object.keys(l).length > 0 ? r(l, [...o, s], Array.isArray(l) ? [...a, s] : a) : t([...o, s], l, a));
    });
  }
  r(e);
}, XN = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function If(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, i = {}, o = {}, a = {};
  return GN(
    e,
    (s, l, c) => {
      if ((typeof l == "string" || typeof l == "number") && (!r || !r(s, l))) {
        const u = `--${n ? `${n}-` : ""}${s.join("-")}`, d = XN(s, l);
        Object.assign(i, {
          [u]: d
        }), Yb(o, s, `var(${u})`, c), Yb(a, s, `var(${u}, ${d})`, c);
      }
    },
    (s) => s[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: i,
    vars: o,
    varsWithDefaults: a
  };
}
function ZN(e, t = {}) {
  const {
    getSelector: n = y,
    disableCssColorScheme: r,
    colorSchemeSelector: i,
    enableContrastVars: o
  } = t, {
    colorSchemes: a = {},
    components: s,
    defaultColorScheme: l = "light",
    ...c
  } = e, {
    vars: u,
    css: d,
    varsWithDefaults: f
  } = If(c, t);
  let p = f;
  const g = {}, {
    [l]: m,
    ...v
  } = a;
  if (Object.entries(v || {}).forEach(([b, w]) => {
    const {
      vars: E,
      css: C,
      varsWithDefaults: A
    } = If(w, t);
    p = fn(p, A), g[b] = {
      css: C,
      vars: E
    };
  }), m) {
    const {
      css: b,
      vars: w,
      varsWithDefaults: E
    } = If(m, t);
    p = fn(p, E), g[l] = {
      css: b,
      vars: w
    };
  }
  function y(b, w) {
    let E = i;
    if (i === "class" && (E = ".%s"), i === "data" && (E = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (E = `[${i}="%s"]`), b) {
      if (E === "media")
        return e.defaultColorScheme === b ? ":root" : {
          [`@media (prefers-color-scheme: ${a[b]?.palette?.mode || b})`]: {
            ":root": w
          }
        };
      if (E)
        return e.defaultColorScheme === b ? `:root, ${E.replace("%s", String(b))}` : E.replace("%s", String(b));
    }
    return ":root";
  }
  return {
    vars: p,
    generateThemeVars: () => {
      let b = {
        ...u
      };
      return Object.entries(g).forEach(([, {
        vars: w
      }]) => {
        b = fn(b, w);
      }), b;
    },
    generateStyleSheets: () => {
      const b = [], w = e.defaultColorScheme || "light";
      function E(k, R) {
        Object.keys(R).length && b.push(typeof k == "string" ? {
          [k]: {
            ...R
          }
        } : k);
      }
      E(n(void 0, {
        ...d
      }), d);
      const {
        [w]: C,
        ...A
      } = g;
      if (C) {
        const {
          css: k
        } = C, R = a[w]?.palette?.mode, M = !r && R ? {
          colorScheme: R,
          ...k
        } : {
          ...k
        };
        E(n(w, {
          ...M
        }), M);
      }
      return Object.entries(A).forEach(([k, {
        css: R
      }]) => {
        const M = a[k]?.palette?.mode, P = !r && M ? {
          colorScheme: M,
          ...R
        } : {
          ...R
        };
        E(n(k, {
          ...P
        }), P);
      }), o && b.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      }), b;
    }
  };
}
function JN(e) {
  return function(n) {
    return e === "media" ? (process.env.NODE_ENV !== "production" && n !== "light" && n !== "dark" && console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${n}'.`), `@media (prefers-color-scheme: ${n})`) : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
  };
}
function $f(e, t) {
  return /* @__PURE__ */ _.isValidElement(e) && t.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    e.type.muiName ?? e.type?._payload?.value?.muiName
  ) !== -1;
}
const Hs = {
  black: "#000",
  white: "#fff"
}, QN = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Jo = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, Qo = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, ts = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, ea = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, ta = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, na = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function XE() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Hs.white,
      default: Hs.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const ZE = XE();
function JE() {
  return {
    text: {
      primary: Hs.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Hs.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const Bh = JE();
function Gb(e, t, n, r) {
  const i = r.light || r, o = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = Ad(e.main, i) : t === "dark" && (e.dark = Cd(e.main, o)));
}
function Xb(e, t, n, r, i) {
  const o = i.light || i, a = i.dark || i * 1.5;
  t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(o * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(a * 100).toFixed(0)}%)`));
}
function eD(e = "light") {
  return e === "dark" ? {
    main: ea[200],
    light: ea[50],
    dark: ea[400]
  } : {
    main: ea[700],
    light: ea[400],
    dark: ea[800]
  };
}
function tD(e = "light") {
  return e === "dark" ? {
    main: Jo[200],
    light: Jo[50],
    dark: Jo[400]
  } : {
    main: Jo[500],
    light: Jo[300],
    dark: Jo[700]
  };
}
function nD(e = "light") {
  return e === "dark" ? {
    main: Qo[500],
    light: Qo[300],
    dark: Qo[700]
  } : {
    main: Qo[700],
    light: Qo[400],
    dark: Qo[800]
  };
}
function rD(e = "light") {
  return e === "dark" ? {
    main: ta[400],
    light: ta[300],
    dark: ta[700]
  } : {
    main: ta[700],
    light: ta[500],
    dark: ta[900]
  };
}
function iD(e = "light") {
  return e === "dark" ? {
    main: na[400],
    light: na[300],
    dark: na[700]
  } : {
    main: na[800],
    light: na[500],
    dark: na[900]
  };
}
function oD(e = "light") {
  return e === "dark" ? {
    main: ts[400],
    light: ts[300],
    dark: ts[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: ts[500],
    dark: ts[900]
  };
}
function aD(e) {
  return `oklch(from ${e} var(--__l) 0 h / var(--__a))`;
}
function gg(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    colorSpace: i,
    ...o
  } = e, a = e.primary || eD(t), s = e.secondary || tD(t), l = e.error || nD(t), c = e.info || rD(t), u = e.success || iD(t), d = e.warning || oD(t);
  function f(v) {
    if (i)
      return aD(v);
    const y = Ub(v, Bh.text.primary) >= n ? Bh.text.primary : ZE.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const S = Ub(v, y);
      S < 3 && console.error([`MUI: The contrast ratio of ${S}:1 for ${y} on ${v}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return y;
  }
  const p = ({
    color: v,
    name: y,
    mainShade: S = 500,
    lightShade: x = 300,
    darkShade: b = 700
  }) => {
    if (v = {
      ...v
    }, !v.main && v[S] && (v.main = v[S]), !v.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${S}\` property.` : $r(11, y ? ` (${y})` : "", S));
    if (typeof v.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(v.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : $r(12, y ? ` (${y})` : "", JSON.stringify(v.main)));
    return i ? (Xb(i, v, "light", x, r), Xb(i, v, "dark", b, r)) : (Gb(v, "light", x, r), Gb(v, "dark", b, r)), v.contrastText || (v.contrastText = f(v.main)), v;
  };
  let g;
  return t === "light" ? g = XE() : t === "dark" && (g = JE()), process.env.NODE_ENV !== "production" && (g || console.error(`MUI: The palette mode \`${t}\` is not supported.`)), fn({
    // A collection of common colors.
    common: {
      ...Hs
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: p({
      color: a,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: p({
      color: s,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: p({
      color: l,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: p({
      color: d,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: p({
      color: c,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: p({
      color: u,
      name: "success"
    }),
    // The grey colors.
    grey: QN,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: f,
    // Generate a rich color object.
    augmentColor: p,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...g
  }, o);
}
function sD(e) {
  const t = {};
  return Object.entries(e).forEach((r) => {
    const [i, o] = r;
    typeof o == "object" && (t[i] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`);
  }), t;
}
function lD(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function cD(e) {
  return Math.round(e * 1e5) / 1e5;
}
const Zb = {
  textTransform: "uppercase"
}, Jb = '"Roboto", "Helvetica", "Arial", sans-serif';
function uD(e, t) {
  const {
    fontFamily: n = Jb,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: i = 300,
    fontWeightRegular: o = 400,
    fontWeightMedium: a = 500,
    fontWeightBold: s = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: l = 16,
    // Apply the CSS properties to all the variants.
    allVariants: c,
    pxToRem: u,
    ...d
  } = typeof t == "function" ? t(e) : t;
  process.env.NODE_ENV !== "production" && (typeof r != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof l != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const f = r / 14, p = u || ((v) => `${v / l * f}rem`), g = (v, y, S, x, b) => ({
    fontFamily: n,
    fontWeight: v,
    fontSize: p(y),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: S,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === Jb ? {
      letterSpacing: `${cD(x / y)}em`
    } : {},
    ...b,
    ...c
  }), m = {
    h1: g(i, 96, 1.167, -1.5),
    h2: g(i, 60, 1.2, -0.5),
    h3: g(o, 48, 1.167, 0),
    h4: g(o, 34, 1.235, 0.25),
    h5: g(o, 24, 1.334, 0),
    h6: g(a, 20, 1.6, 0.15),
    subtitle1: g(o, 16, 1.75, 0.15),
    subtitle2: g(a, 14, 1.57, 0.1),
    body1: g(o, 16, 1.5, 0.15),
    body2: g(o, 14, 1.43, 0.15),
    button: g(a, 14, 1.75, 0.4, Zb),
    caption: g(o, 12, 1.66, 0.4),
    overline: g(o, 12, 2.66, 1, Zb),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return fn({
    htmlFontSize: l,
    pxToRem: p,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: i,
    fontWeightRegular: o,
    fontWeightMedium: a,
    fontWeightBold: s,
    ...m
  }, d, {
    clone: !1
    // No need to clone deep
  });
}
const dD = 0.2, fD = 0.14, pD = 0.12;
function lt(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${dD})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${fD})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${pD})`].join(",");
}
const hD = ["none", lt(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), lt(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), lt(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), lt(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), lt(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), lt(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), lt(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), lt(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), lt(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), lt(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), lt(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), lt(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), lt(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), lt(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), lt(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), lt(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), lt(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), lt(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), lt(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), lt(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), lt(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), lt(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), lt(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), lt(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], mD = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, gD = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function Qb(e) {
  return `${Math.round(e)}ms`;
}
function vD(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function yD(e) {
  const t = {
    ...mD,
    ...e.easing
  }, n = {
    ...gD,
    ...e.duration
  };
  return {
    getAutoHeightDuration: vD,
    create: (i = ["all"], o = {}) => {
      const {
        duration: a = n.standard,
        easing: s = t.easeInOut,
        delay: l = 0,
        ...c
      } = o;
      if (process.env.NODE_ENV !== "production") {
        const u = (f) => typeof f == "string", d = (f) => !Number.isNaN(parseFloat(f));
        !u(i) && !Array.isArray(i) && console.error('MUI: Argument "props" must be a string or Array.'), !d(a) && !u(a) && console.error(`MUI: Argument "duration" must be a number or a string but found ${a}.`), u(s) || console.error('MUI: Argument "easing" must be a string.'), !d(l) && !u(l) && console.error('MUI: Argument "delay" must be a number or a string.'), typeof o != "object" && console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join(`
`)), Object.keys(c).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(c).join(",")}].`);
      }
      return (Array.isArray(i) ? i : [i]).map((u) => `${u} ${typeof a == "string" ? a : Qb(a)} ${s} ${typeof l == "string" ? l : Qb(l)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const bD = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function xD(e) {
  return ri(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function QE(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const i = Object.entries(r);
    for (let o = 0; o < i.length; o++) {
      const [a, s] = i[o];
      !xD(s) || a.startsWith("unstable_") ? delete r[a] : ri(s) && (r[a] = {
        ...s
      }, n(r[a]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function e0(e) {
  return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`;
}
const wD = (e) => {
  if (!Number.isNaN(+e))
    return +e;
  const t = e.match(/\d*\.?\d+/g);
  if (!t)
    return 0;
  let n = 0;
  for (let r = 0; r < t.length; r += 1)
    n += +t[r];
  return n;
};
function OD(e) {
  Object.assign(e, {
    alpha(t, n) {
      const r = this || e;
      return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : au(t, wD(n));
    },
    lighten(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${e0(n)})` : Ad(t, n);
    },
    darken(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${e0(n)})` : Cd(t, n);
    }
  });
}
function zh(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: i,
    palette: o = {},
    transitions: a = {},
    typography: s = {},
    shape: l,
    colorSpace: c,
    ...u
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature." : $r(20));
  const d = gg({
    ...o,
    colorSpace: c
  }), f = pg(e);
  let p = fn(f, {
    mixins: lD(f.breakpoints, r),
    palette: d,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: hD.slice(),
    typography: uD(d, s),
    transitions: yD(a),
    zIndex: {
      ...bD
    }
  });
  if (p = fn(p, u), p = t.reduce((g, m) => fn(g, m), p), process.env.NODE_ENV !== "production") {
    const g = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], m = (v, y) => {
      let S;
      for (S in v) {
        const x = v[S];
        if (g.includes(S) && Object.keys(x).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const b = Mt("", S);
            console.error([`MUI: The \`${y}\` component increases the CSS specificity of the \`${S}\` internal state.`, "You can not override it like this: ", JSON.stringify(v, null, 2), "", `Instead, you need to use the '&.${b}' syntax:`, JSON.stringify({
              root: {
                [`&.${b}`]: x
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          v[S] = {};
        }
      }
    };
    Object.keys(p.components).forEach((v) => {
      const y = p.components[v].styleOverrides;
      y && v.startsWith("Mui") && m(y, v);
    });
  }
  return p.unstable_sxConfig = {
    ...wd,
    ...u?.unstable_sxConfig
  }, p.unstable_sx = function(m) {
    return xa({
      sx: m,
      theme: this
    });
  }, p.toRuntimeSource = QE, OD(p), p;
}
function Wh(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const SD = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = Wh(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function e_(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function t_(e) {
  return e === "dark" ? SD : [];
}
function ED(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    colorSpace: i,
    ...o
  } = e, a = gg({
    ...t,
    colorSpace: i
  });
  return {
    palette: a,
    opacity: {
      ...e_(a.mode),
      ...n
    },
    overlays: r || t_(a.mode),
    ...o
  };
}
function _D(e) {
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const PD = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], CD = (e) => (t, n) => {
  const r = e.rootSelector || ":root", i = e.colorSchemeSelector;
  let o = i;
  if (i === "class" && (o = ".%s"), i === "data" && (o = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (o = `[${i}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const a = {};
      return PD(e.cssVarPrefix).forEach((s) => {
        a[s] = n[s], delete n[s];
      }), o === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: a
        }
      } : o ? {
        [o.replace("%s", t)]: a,
        [`${r}, ${o.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...a
        }
      };
    }
    if (o && o !== "media")
      return `${r}, ${o.replace("%s", String(t))}`;
  } else if (t) {
    if (o === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (o)
      return o.replace("%s", String(t));
  }
  return r;
};
function AD(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function V(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function Ss(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : qE(e);
}
function Xr(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = Os(Ss(e[t]), `MUI: Can't create \`palette.${t}Channel\` because \`palette.${t}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${t}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`));
}
function TD(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Er = (e) => {
  try {
    return e();
  } catch {
  }
}, kD = (e = "mui") => YN(e);
function Lf(e, t, n, r, i) {
  if (!n)
    return;
  n = n === !0 ? {} : n;
  const o = i === "dark" ? "dark" : "light";
  if (!r) {
    t[i] = ED({
      ...n,
      palette: {
        mode: o,
        ...n?.palette
      },
      colorSpace: e
    });
    return;
  }
  const {
    palette: a,
    ...s
  } = zh({
    ...r,
    palette: {
      mode: o,
      ...n?.palette
    },
    colorSpace: e
  });
  return t[i] = {
    ...n,
    palette: a,
    opacity: {
      ...e_(o),
      ...n?.opacity
    },
    overlays: n?.overlays || t_(o)
  }, s;
}
function MD(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: i = !1,
    cssVarPrefix: o = "mui",
    nativeColor: a = !1,
    shouldSkipGeneratingVar: s = _D,
    colorSchemeSelector: l = n.light && n.dark ? "media" : void 0,
    rootSelector: c = ":root",
    ...u
  } = e, d = Object.keys(n)[0], f = r || (n.light && d !== "light" ? "light" : d), p = kD(o), {
    [f]: g,
    light: m,
    dark: v,
    ...y
  } = n, S = {
    ...y
  };
  let x = g;
  if ((f === "dark" && !("dark" in n) || f === "light" && !("light" in n)) && (x = !0), !x)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The \`colorSchemes.${f}\` option is either missing or invalid.` : $r(21, f));
  let b;
  a && (b = "oklch");
  const w = Lf(b, S, x, u, f);
  m && !S.light && Lf(b, S, m, void 0, "light"), v && !S.dark && Lf(b, S, v, void 0, "dark");
  let E = {
    defaultColorScheme: f,
    ...w,
    cssVarPrefix: o,
    colorSchemeSelector: l,
    rootSelector: c,
    getCssVar: p,
    colorSchemes: S,
    font: {
      ...sD(w.typography),
      ...w.font
    },
    spacing: TD(u.spacing)
  };
  Object.keys(E.colorSchemes).forEach((M) => {
    const P = E.colorSchemes[M].palette, D = (N) => {
      const $ = N.split("-"), F = $[1], q = $[2];
      return p(N, P[F][q]);
    };
    P.mode === "light" && (V(P.common, "background", "#fff"), V(P.common, "onBackground", "#000")), P.mode === "dark" && (V(P.common, "background", "#000"), V(P.common, "onBackground", "#fff"));
    function j(N, $, F) {
      if (b) {
        let q;
        return N === oo && (q = `transparent ${((1 - F) * 100).toFixed(0)}%`), N === Be && (q = `#000 ${(F * 100).toFixed(0)}%`), N === ze && (q = `#fff ${(F * 100).toFixed(0)}%`), `color-mix(in ${b}, ${$}, ${q})`;
      }
      return N($, F);
    }
    if (AD(P, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), P.mode === "light") {
      V(P.Alert, "errorColor", j(Be, P.error.light, 0.6)), V(P.Alert, "infoColor", j(Be, P.info.light, 0.6)), V(P.Alert, "successColor", j(Be, P.success.light, 0.6)), V(P.Alert, "warningColor", j(Be, P.warning.light, 0.6)), V(P.Alert, "errorFilledBg", D("palette-error-main")), V(P.Alert, "infoFilledBg", D("palette-info-main")), V(P.Alert, "successFilledBg", D("palette-success-main")), V(P.Alert, "warningFilledBg", D("palette-warning-main")), V(P.Alert, "errorFilledColor", Er(() => P.getContrastText(P.error.main))), V(P.Alert, "infoFilledColor", Er(() => P.getContrastText(P.info.main))), V(P.Alert, "successFilledColor", Er(() => P.getContrastText(P.success.main))), V(P.Alert, "warningFilledColor", Er(() => P.getContrastText(P.warning.main))), V(P.Alert, "errorStandardBg", j(ze, P.error.light, 0.9)), V(P.Alert, "infoStandardBg", j(ze, P.info.light, 0.9)), V(P.Alert, "successStandardBg", j(ze, P.success.light, 0.9)), V(P.Alert, "warningStandardBg", j(ze, P.warning.light, 0.9)), V(P.Alert, "errorIconColor", D("palette-error-main")), V(P.Alert, "infoIconColor", D("palette-info-main")), V(P.Alert, "successIconColor", D("palette-success-main")), V(P.Alert, "warningIconColor", D("palette-warning-main")), V(P.AppBar, "defaultBg", D("palette-grey-100")), V(P.Avatar, "defaultBg", D("palette-grey-400")), V(P.Button, "inheritContainedBg", D("palette-grey-300")), V(P.Button, "inheritContainedHoverBg", D("palette-grey-A100")), V(P.Chip, "defaultBorder", D("palette-grey-400")), V(P.Chip, "defaultAvatarColor", D("palette-grey-700")), V(P.Chip, "defaultIconColor", D("palette-grey-700")), V(P.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), V(P.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), V(P.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), V(P.LinearProgress, "primaryBg", j(ze, P.primary.main, 0.62)), V(P.LinearProgress, "secondaryBg", j(ze, P.secondary.main, 0.62)), V(P.LinearProgress, "errorBg", j(ze, P.error.main, 0.62)), V(P.LinearProgress, "infoBg", j(ze, P.info.main, 0.62)), V(P.LinearProgress, "successBg", j(ze, P.success.main, 0.62)), V(P.LinearProgress, "warningBg", j(ze, P.warning.main, 0.62)), V(P.Skeleton, "bg", b ? j(oo, P.text.primary, 0.11) : `rgba(${D("palette-text-primaryChannel")} / 0.11)`), V(P.Slider, "primaryTrack", j(ze, P.primary.main, 0.62)), V(P.Slider, "secondaryTrack", j(ze, P.secondary.main, 0.62)), V(P.Slider, "errorTrack", j(ze, P.error.main, 0.62)), V(P.Slider, "infoTrack", j(ze, P.info.main, 0.62)), V(P.Slider, "successTrack", j(ze, P.success.main, 0.62)), V(P.Slider, "warningTrack", j(ze, P.warning.main, 0.62));
      const N = b ? j(Be, P.background.default, 0.6825) : ic(P.background.default, 0.8);
      V(P.SnackbarContent, "bg", N), V(P.SnackbarContent, "color", Er(() => b ? Bh.text.primary : P.getContrastText(N))), V(P.SpeedDialAction, "fabHoverBg", ic(P.background.paper, 0.15)), V(P.StepConnector, "border", D("palette-grey-400")), V(P.StepContent, "border", D("palette-grey-400")), V(P.Switch, "defaultColor", D("palette-common-white")), V(P.Switch, "defaultDisabledColor", D("palette-grey-100")), V(P.Switch, "primaryDisabledColor", j(ze, P.primary.main, 0.62)), V(P.Switch, "secondaryDisabledColor", j(ze, P.secondary.main, 0.62)), V(P.Switch, "errorDisabledColor", j(ze, P.error.main, 0.62)), V(P.Switch, "infoDisabledColor", j(ze, P.info.main, 0.62)), V(P.Switch, "successDisabledColor", j(ze, P.success.main, 0.62)), V(P.Switch, "warningDisabledColor", j(ze, P.warning.main, 0.62)), V(P.TableCell, "border", j(ze, j(oo, P.divider, 1), 0.88)), V(P.Tooltip, "bg", j(oo, P.grey[700], 0.92));
    }
    if (P.mode === "dark") {
      V(P.Alert, "errorColor", j(ze, P.error.light, 0.6)), V(P.Alert, "infoColor", j(ze, P.info.light, 0.6)), V(P.Alert, "successColor", j(ze, P.success.light, 0.6)), V(P.Alert, "warningColor", j(ze, P.warning.light, 0.6)), V(P.Alert, "errorFilledBg", D("palette-error-dark")), V(P.Alert, "infoFilledBg", D("palette-info-dark")), V(P.Alert, "successFilledBg", D("palette-success-dark")), V(P.Alert, "warningFilledBg", D("palette-warning-dark")), V(P.Alert, "errorFilledColor", Er(() => P.getContrastText(P.error.dark))), V(P.Alert, "infoFilledColor", Er(() => P.getContrastText(P.info.dark))), V(P.Alert, "successFilledColor", Er(() => P.getContrastText(P.success.dark))), V(P.Alert, "warningFilledColor", Er(() => P.getContrastText(P.warning.dark))), V(P.Alert, "errorStandardBg", j(Be, P.error.light, 0.9)), V(P.Alert, "infoStandardBg", j(Be, P.info.light, 0.9)), V(P.Alert, "successStandardBg", j(Be, P.success.light, 0.9)), V(P.Alert, "warningStandardBg", j(Be, P.warning.light, 0.9)), V(P.Alert, "errorIconColor", D("palette-error-main")), V(P.Alert, "infoIconColor", D("palette-info-main")), V(P.Alert, "successIconColor", D("palette-success-main")), V(P.Alert, "warningIconColor", D("palette-warning-main")), V(P.AppBar, "defaultBg", D("palette-grey-900")), V(P.AppBar, "darkBg", D("palette-background-paper")), V(P.AppBar, "darkColor", D("palette-text-primary")), V(P.Avatar, "defaultBg", D("palette-grey-600")), V(P.Button, "inheritContainedBg", D("palette-grey-800")), V(P.Button, "inheritContainedHoverBg", D("palette-grey-700")), V(P.Chip, "defaultBorder", D("palette-grey-700")), V(P.Chip, "defaultAvatarColor", D("palette-grey-300")), V(P.Chip, "defaultIconColor", D("palette-grey-300")), V(P.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), V(P.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), V(P.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), V(P.LinearProgress, "primaryBg", j(Be, P.primary.main, 0.5)), V(P.LinearProgress, "secondaryBg", j(Be, P.secondary.main, 0.5)), V(P.LinearProgress, "errorBg", j(Be, P.error.main, 0.5)), V(P.LinearProgress, "infoBg", j(Be, P.info.main, 0.5)), V(P.LinearProgress, "successBg", j(Be, P.success.main, 0.5)), V(P.LinearProgress, "warningBg", j(Be, P.warning.main, 0.5)), V(P.Skeleton, "bg", b ? j(oo, P.text.primary, 0.13) : `rgba(${D("palette-text-primaryChannel")} / 0.13)`), V(P.Slider, "primaryTrack", j(Be, P.primary.main, 0.5)), V(P.Slider, "secondaryTrack", j(Be, P.secondary.main, 0.5)), V(P.Slider, "errorTrack", j(Be, P.error.main, 0.5)), V(P.Slider, "infoTrack", j(Be, P.info.main, 0.5)), V(P.Slider, "successTrack", j(Be, P.success.main, 0.5)), V(P.Slider, "warningTrack", j(Be, P.warning.main, 0.5));
      const N = b ? j(ze, P.background.default, 0.985) : ic(P.background.default, 0.98);
      V(P.SnackbarContent, "bg", N), V(P.SnackbarContent, "color", Er(() => b ? ZE.text.primary : P.getContrastText(N))), V(P.SpeedDialAction, "fabHoverBg", ic(P.background.paper, 0.15)), V(P.StepConnector, "border", D("palette-grey-600")), V(P.StepContent, "border", D("palette-grey-600")), V(P.Switch, "defaultColor", D("palette-grey-300")), V(P.Switch, "defaultDisabledColor", D("palette-grey-600")), V(P.Switch, "primaryDisabledColor", j(Be, P.primary.main, 0.55)), V(P.Switch, "secondaryDisabledColor", j(Be, P.secondary.main, 0.55)), V(P.Switch, "errorDisabledColor", j(Be, P.error.main, 0.55)), V(P.Switch, "infoDisabledColor", j(Be, P.info.main, 0.55)), V(P.Switch, "successDisabledColor", j(Be, P.success.main, 0.55)), V(P.Switch, "warningDisabledColor", j(Be, P.warning.main, 0.55)), V(P.TableCell, "border", j(Be, j(oo, P.divider, 1), 0.68)), V(P.Tooltip, "bg", j(oo, P.grey[700], 0.92));
    }
    Xr(P.background, "default"), Xr(P.background, "paper"), Xr(P.common, "background"), Xr(P.common, "onBackground"), Xr(P, "divider"), Object.keys(P).forEach((N) => {
      const $ = P[N];
      N !== "tonalOffset" && $ && typeof $ == "object" && ($.main && V(P[N], "mainChannel", Os(Ss($.main))), $.light && V(P[N], "lightChannel", Os(Ss($.light))), $.dark && V(P[N], "darkChannel", Os(Ss($.dark))), $.contrastText && V(P[N], "contrastTextChannel", Os(Ss($.contrastText))), N === "text" && (Xr(P[N], "primary"), Xr(P[N], "secondary")), N === "action" && ($.active && Xr(P[N], "active"), $.selected && Xr(P[N], "selected")));
    });
  }), E = t.reduce((M, P) => fn(M, P), E);
  const C = {
    prefix: o,
    disableCssColorScheme: i,
    shouldSkipGeneratingVar: s,
    getSelector: CD(E),
    enableContrastVars: a
  }, {
    vars: A,
    generateThemeVars: k,
    generateStyleSheets: R
  } = ZN(E, C);
  return E.vars = A, Object.entries(E.colorSchemes[E.defaultColorScheme]).forEach(([M, P]) => {
    E[M] = P;
  }), E.generateThemeVars = k, E.generateStyleSheets = R, E.generateSpacing = function() {
    return BE(u.spacing, rg(this));
  }, E.getColorSchemeSelector = JN(l), E.spacing = E.generateSpacing(), E.shouldSkipGeneratingVar = s, E.unstable_sxConfig = {
    ...wd,
    ...u?.unstable_sxConfig
  }, E.unstable_sx = function(P) {
    return xa({
      sx: P,
      theme: this
    });
  }, E.toRuntimeSource = QE, E;
}
function t0(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: gg({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function jD(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: i = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: o = n?.mode,
    ...a
  } = e, s = o || "light", l = i?.[s], c = {
    ...i,
    ...n ? {
      [s]: {
        ...typeof l != "boolean" && l,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return zh(e, ...t);
    let u = n;
    "palette" in e || c[s] && (c[s] !== !0 ? u = c[s].palette : s === "dark" && (u = {
      mode: "dark"
    }));
    const d = zh({
      ...e,
      palette: u
    }, ...t);
    return d.defaultColorScheme = s, d.colorSchemes = c, d.palette.mode === "light" && (d.colorSchemes.light = {
      ...c.light !== !0 && c.light,
      palette: d.palette
    }, t0(d, "dark", c.dark)), d.palette.mode === "dark" && (d.colorSchemes.dark = {
      ...c.dark !== !0 && c.dark,
      palette: d.palette
    }, t0(d, "light", c.light)), d;
  }
  return !n && !("light" in c) && s === "light" && (c.light = !0), MD({
    ...a,
    colorSchemes: c,
    defaultColorScheme: s,
    ...typeof r != "boolean" && r
  }, ...t);
}
const vg = jD(), yg = "$$material";
function Td() {
  const e = zE(vg);
  return process.env.NODE_ENV !== "production" && _.useDebugValue(e), e[yg] || e;
}
function n_(e) {
  return /* @__PURE__ */ O.jsx(WE, {
    ...e,
    defaultTheme: vg,
    themeId: yg
  });
}
process.env.NODE_ENV !== "production" && (n_.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The styles you want to apply globally.
   */
  styles: h.oneOfType([h.array, h.func, h.number, h.object, h.string, h.bool])
});
function r_(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Hr = (e) => r_(e) && e !== "classes", xe = MN({
  themeId: yg,
  defaultTheme: vg,
  rootShouldForwardProp: Hr
});
function ND(e) {
  return function(n) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ O.jsx(n_, {
        styles: typeof e == "function" ? (r) => e({
          theme: r,
          ...n
        }) : e
      })
    );
  };
}
const hn = qN;
process.env.NODE_ENV !== "production" && (h.node, h.object.isRequired);
function qt(e) {
  return UN(e);
}
function DD(e) {
  return Mt("MuiSvgIcon", e);
}
xt("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const RD = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, i = {
    root: ["root", t !== "inherit" && `color${It(t)}`, `fontSize${It(n)}`]
  };
  return $t(i, DD, r);
}, ID = xe("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${It(n.color)}`], t[`fontSize${It(n.fontSize)}`]];
  }
})(hn(({
  theme: e
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: e.transitions?.create?.("fill", {
    duration: (e.vars ?? e).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars ?? e).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), su = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: i,
    className: o,
    color: a = "inherit",
    component: s = "svg",
    fontSize: l = "medium",
    htmlColor: c,
    inheritViewBox: u = !1,
    titleAccess: d,
    viewBox: f = "0 0 24 24",
    ...p
  } = r, g = /* @__PURE__ */ _.isValidElement(i) && i.type === "svg", m = {
    ...r,
    color: a,
    component: s,
    fontSize: l,
    instanceFontSize: t.fontSize,
    inheritViewBox: u,
    viewBox: f,
    hasSvgAsChild: g
  }, v = {};
  u || (v.viewBox = f);
  const y = RD(m);
  return /* @__PURE__ */ O.jsxs(ID, {
    as: s,
    className: ce(y.root, o),
    focusable: "false",
    color: c,
    "aria-hidden": d ? void 0 : !0,
    role: d ? "img" : void 0,
    ref: n,
    ...v,
    ...p,
    ...g && i.props,
    ownerState: m,
    children: [g ? i.props.children : i, d ? /* @__PURE__ */ O.jsx("title", {
      children: d
    }) : null]
  });
});
process.env.NODE_ENV !== "production" && (su.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Node passed into the SVG element.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: h.oneOfType([h.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), h.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: h.oneOfType([h.oneOf(["inherit", "large", "medium", "small"]), h.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: h.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: h.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: h.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: h.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: h.string
});
su.muiName = "SvgIcon";
function wl(e, t) {
  function n(r, i) {
    return /* @__PURE__ */ O.jsx(su, {
      "data-testid": process.env.NODE_ENV !== "production" ? `${t}Icon` : void 0,
      ref: i,
      ...r,
      children: e
    });
  }
  return process.env.NODE_ENV !== "production" && (n.displayName = `${t}Icon`), n.muiName = su.muiName, /* @__PURE__ */ _.memo(/* @__PURE__ */ _.forwardRef(n));
}
function i_(e, t = 166) {
  let n;
  function r(...i) {
    const o = () => {
      e.apply(this, i);
    };
    clearTimeout(n), n = setTimeout(o, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function Un(e) {
  return e && e.ownerDocument || document;
}
function pi(e) {
  return Un(e).defaultView || window;
}
function n0(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
function Vh(e) {
  const {
    controlled: t,
    default: n,
    name: r,
    state: i = "value"
  } = e, {
    current: o
  } = _.useRef(t !== void 0), [a, s] = _.useState(n), l = o ? t : a;
  if (process.env.NODE_ENV !== "production") {
    _.useEffect(() => {
      o !== (t !== void 0) && console.error([`MUI: A component is changing the ${o ? "" : "un"}controlled ${i} state of ${r} to be ${o ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [i, r, t]);
    const {
      current: u
    } = _.useRef(n);
    _.useEffect(() => {
      !o && JSON.stringify(n) !== JSON.stringify(u) && console.error([`MUI: A component is changing the default ${i} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`
`));
    }, [JSON.stringify(n)]);
  }
  const c = _.useCallback((u) => {
    o || s(u);
  }, []);
  return [l, c];
}
function ci(e) {
  const t = _.useRef(e);
  return Lr(() => {
    t.current = e;
  }), _.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
function Kt(...e) {
  const t = _.useRef(void 0), n = _.useCallback((r) => {
    const i = e.map((o) => {
      if (o == null)
        return null;
      if (typeof o == "function") {
        const a = o, s = a(r);
        return typeof s == "function" ? s : () => {
          a(null);
        };
      }
      return o.current = r, () => {
        o.current = null;
      };
    });
    return () => {
      i.forEach((o) => o?.());
    };
  }, e);
  return _.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
function $D(e, t) {
  const n = e.charCodeAt(2);
  return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function";
}
function LD(e, t) {
  if (!e)
    return t;
  function n(a, s) {
    const l = {};
    return Object.keys(s).forEach((c) => {
      $D(c, s[c]) && typeof a[c] == "function" && (l[c] = (...u) => {
        a[c](...u), s[c](...u);
      });
    }), l;
  }
  if (typeof e == "function" || typeof t == "function")
    return (a) => {
      const s = typeof t == "function" ? t(a) : t, l = typeof e == "function" ? e({
        ...a,
        ...s
      }) : e, c = ce(a?.className, s?.className, l?.className), u = n(l, s);
      return {
        ...s,
        ...l,
        ...u,
        ...!!c && {
          className: c
        },
        ...s?.style && l?.style && {
          style: {
            ...s.style,
            ...l.style
          }
        },
        ...s?.sx && l?.sx && {
          sx: [...Array.isArray(s.sx) ? s.sx : [s.sx], ...Array.isArray(l.sx) ? l.sx : [l.sx]]
        }
      };
    };
  const r = t, i = n(e, r), o = ce(r?.className, e?.className);
  return {
    ...t,
    ...e,
    ...i,
    ...!!o && {
      className: o
    },
    ...r?.style && e?.style && {
      style: {
        ...r.style,
        ...e.style
      }
    },
    ...r?.sx && e?.sx && {
      sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
    }
  };
}
const FD = wl(/* @__PURE__ */ O.jsx("path", {
  d: "M20 3h-1V1h-2v2H7V1H5v2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 18H4V10h16zm0-13H4V5h16z"
}), "CalendarTodayOutlined"), Ol = wl(/* @__PURE__ */ O.jsx("path", {
  d: "M8 16h8v2H8zm0-4h8v2H8zm6-10H6c-1.1 0-2 .9-2 2v16c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm4 18H6V4h7v5h5z"
}), "DescriptionOutlined"), BD = wl(/* @__PURE__ */ O.jsx("path", {
  d: "M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zm-1-4-1.41-1.41L13 12.17V4h-2v8.17L8.41 9.59 7 11l5 5z"
}), "FileDownloadOutlined"), Yt = wl(/* @__PURE__ */ O.jsx("path", {
  d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"
}), "OpenInNewOutlined");
var o_ = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, r0 = He.createContext && /* @__PURE__ */ He.createContext(o_), zD = ["attr", "size", "title"];
function WD(e, t) {
  if (e == null) return {};
  var n = VD(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function VD(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function lu() {
  return lu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, lu.apply(this, arguments);
}
function i0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i0(Object(n), !0).forEach(function(r) {
      UD(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function UD(e, t, n) {
  return t = HD(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function HD(e) {
  var t = KD(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function KD(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function a_(e) {
  return e && e.map((t, n) => /* @__PURE__ */ He.createElement(t.tag, cu({
    key: n
  }, t.attr), a_(t.child)));
}
function Ge(e) {
  return (t) => /* @__PURE__ */ He.createElement(qD, lu({
    attr: cu({}, e.attr)
  }, t), a_(e.child));
}
function qD(e) {
  var t = (n) => {
    var {
      attr: r,
      size: i,
      title: o
    } = e, a = WD(e, zD), s = i || n.size || "1em", l;
    return n.className && (l = n.className), e.className && (l = (l ? l + " " : "") + e.className), /* @__PURE__ */ He.createElement("svg", lu({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, r, a, {
      className: l,
      style: cu(cu({
        color: e.color || n.color
      }, n.style), e.style),
      height: s,
      width: s,
      xmlns: "http://www.w3.org/2000/svg"
    }), o && /* @__PURE__ */ He.createElement("title", null, o), e.children);
  };
  return r0 !== void 0 ? /* @__PURE__ */ He.createElement(r0.Consumer, null, (n) => t(n)) : t(o_);
}
function YD(e) {
  return Ge({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M384 160c-17.7 0-32-14.3-32-32s14.3-32 32-32l160 0c17.7 0 32 14.3 32 32l0 160c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-82.7L342.6 374.6c-12.5 12.5-32.8 12.5-45.3 0L192 269.3 54.6 406.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160c12.5-12.5 32.8-12.5 45.3 0L320 306.7 466.7 160 384 160z" }, child: [] }] })(e);
}
function GD(e) {
  return Ge({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z" }, child: [] }] })(e);
}
function XD(e) {
  return Ge({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z" }, child: [] }] })(e);
}
function ZD(e) {
  return Ge({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z" }, child: [] }] })(e);
}
function JD(e) {
  return Ge({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z" }, child: [] }] })(e);
}
function kee({ title: e, description: t }) {
  return /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between px-6 my-6", children: [
    /* @__PURE__ */ O.jsxs("div", { children: [
      /* @__PURE__ */ O.jsx("div", { className: "!text-[24px]  text-[#121212] font-semibold", children: e }),
      /* @__PURE__ */ O.jsx("div", { className: "text-gray-500 text-[14px]", children: t })
    ] }),
    /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col sm:flex-row items-start sm:items-center gap-[12px]", children: [
      /* @__PURE__ */ O.jsxs("div", { className: "w-full sm:w-auto flex items-center justify-center gap-[8px] bg-white shadow-sm px-2 md:px-6 py-1 rounded-sm text-[#64748B] text-sm hover:bg-slate-50", children: [
        /* @__PURE__ */ O.jsx(FD, { fontSize: "12" }),
        /* @__PURE__ */ O.jsx("div", { className: " whitespace-nowrap", children: "Last 7 Days" }),
        /* @__PURE__ */ O.jsx(ZD, { fontSize: "12" })
      ] }),
      /* @__PURE__ */ O.jsxs("div", { className: "w-full flex items-center justify-center gap-[8px] bg-white  text-[#884EA7] px-2  md:px-6 py-1 rounded-sm shadow-sm hover:bg-purple-50", children: [
        /* @__PURE__ */ O.jsx("div", { className: "font-medium whitespace-nowrap", children: "Export Report" }),
        /* @__PURE__ */ O.jsx(BD, { fontSize: "12" })
      ] })
    ] })
  ] });
}
function o0(e) {
  return Ge({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z" }, child: [] }] })(e);
}
function QD(e) {
  return Ge({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M192 208c0-17.67-14.33-32-32-32h-16c-35.35 0-64 28.65-64 64v48c0 35.35 28.65 64 64 64h16c17.67 0 32-14.33 32-32V208zm176 144c35.35 0 64-28.65 64-64v-48c0-35.35-28.65-64-64-64h-16c-17.67 0-32 14.33-32 32v112c0 17.67 14.33 32 32 32h16zM256 0C113.18 0 4.58 118.83 0 256v16c0 8.84 7.16 16 16 16h16c8.84 0 16-7.16 16-16v-16c0-114.69 93.31-208 208-208s208 93.31 208 208h-.12c.08 2.43.12 165.72.12 165.72 0 23.35-18.93 42.28-42.28 42.28H320c0-26.51-21.49-48-48-48h-32c-26.51 0-48 21.49-48 48s21.49 48 48 48h181.72c49.86 0 90.28-40.42 90.28-90.28V256C507.42 118.83 398.82 0 256 0z" }, child: [] }] })(e);
}
function bg(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "rect", attr: { width: "16", height: "20", x: "4", y: "2", rx: "2", ry: "2" }, child: [] }, { tag: "path", attr: { d: "M9 22v-4h6v4" }, child: [] }, { tag: "path", attr: { d: "M8 6h.01" }, child: [] }, { tag: "path", attr: { d: "M16 6h.01" }, child: [] }, { tag: "path", attr: { d: "M12 6h.01" }, child: [] }, { tag: "path", attr: { d: "M12 10h.01" }, child: [] }, { tag: "path", attr: { d: "M12 14h.01" }, child: [] }, { tag: "path", attr: { d: "M16 10h.01" }, child: [] }, { tag: "path", attr: { d: "M16 14h.01" }, child: [] }, { tag: "path", attr: { d: "M8 10h.01" }, child: [] }, { tag: "path", attr: { d: "M8 14h.01" }, child: [] }] })(e);
}
function eR(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2" }, child: [] }, { tag: "circle", attr: { cx: "7", cy: "17", r: "2" }, child: [] }, { tag: "path", attr: { d: "M9 17h6" }, child: [] }, { tag: "circle", attr: { cx: "17", cy: "17", r: "2" }, child: [] }] })(e);
}
function s_(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M13 4h3a2 2 0 0 1 2 2v14" }, child: [] }, { tag: "path", attr: { d: "M2 20h3" }, child: [] }, { tag: "path", attr: { d: "M13 20h9" }, child: [] }, { tag: "path", attr: { d: "M10 12v.01" }, child: [] }, { tag: "path", attr: { d: "M13 4.562v16.157a1 1 0 0 1-1.242.97L5 20V5.562a2 2 0 0 1 1.515-1.94l4-1A2 2 0 0 1 13 4.561Z" }, child: [] }] })(e);
}
function tR(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M16 5h6" }, child: [] }, { tag: "path", attr: { d: "M19 2v6" }, child: [] }, { tag: "path", attr: { d: "M21 11.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7.5" }, child: [] }, { tag: "path", attr: { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }, child: [] }, { tag: "circle", attr: { cx: "9", cy: "9", r: "2" }, child: [] }] })(e);
}
function l_(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }, child: [] }] })(e);
}
function a0(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }, child: [] }, { tag: "path", attr: { d: "M14 8H8" }, child: [] }, { tag: "path", attr: { d: "M16 12H8" }, child: [] }, { tag: "path", attr: { d: "M13 16H8" }, child: [] }] })(e);
}
function c_(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z" }, child: [] }, { tag: "path", attr: { d: "m9 12 2 2 4-4" }, child: [] }] })(e);
}
function xg(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M2 6c.6.5 1.2 1 2.5 1C7 7 7 5 9.5 5c2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }, child: [] }, { tag: "path", attr: { d: "M2 12c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }, child: [] }, { tag: "path", attr: { d: "M2 18c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }, child: [] }] })(e);
}
function nR(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" }, child: [] }] })(e);
}
function u_(e) {
  return Ge({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z" }, child: [] }] })(e);
}
function d_(e) {
  return Ge({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M3.5 8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 8Z" }, child: [] }] })(e);
}
function f_(e) {
  return Ge({ attr: { viewBox: "0 0 32 32" }, child: [{ tag: "path", attr: { d: "M 2 7 L 2 24 L 30 24 L 30 7 L 2 7 z M 6 9 L 26 9 C 26 10.105 26.895 11 28 11 L 28 20 C 26.895 20 26 20.895 26 22 L 6 22 C 6 20.895 5.105 20 4 20 L 4 11 C 5.105 11 6 10.105 6 9 z M 16 11 C 13.789 11 12 13.016 12 15.5 C 12 17.984 13.789 20 16 20 C 18.211 20 20 17.984 20 15.5 C 20 13.016 18.211 11 16 11 z M 16 13 C 17.102 13 18 14.121 18 15.5 C 18 16.879 17.102 18 16 18 C 14.898 18 14 16.879 14 15.5 C 14 14.121 14.898 13 16 13 z M 8.5 14 C 7.672 14 7 14.672 7 15.5 C 7 16.328 7.672 17 8.5 17 C 9.328 17 10 16.328 10 15.5 C 10 14.672 9.328 14 8.5 14 z M 23.5 14 C 22.672 14 22 14.672 22 15.5 C 22 16.328 22.672 17 23.5 17 C 24.328 17 25 16.328 25 15.5 C 25 14.672 24.328 14 23.5 14 z" }, child: [] }] })(e);
}
const rR = [
  { name: "Overview", icon: u_ },
  { name: "Community", icon: bg },
  { name: "Financials", icon: f_ },
  { name: "Facilities", icon: s_ },
  { name: "Gate & Security", icon: xg },
  { name: "Helpdesk", icon: QD },
  { name: "Engagement", icon: l_ }
];
function Mee() {
  const [e, t] = Rt("Overview");
  return /* @__PURE__ */ O.jsx("div", { className: "flex gap-[8px] p-3", children: rR.map((n) => {
    const r = n.icon, i = e === n.name;
    return /* @__PURE__ */ O.jsxs(
      "button",
      {
        onClick: () => t(n.name),
        className: `flex items-center gap-[8px] rounded px-4 py-3 text-[14px] leading-[16px] font-medium transition 
              ${i ? "bg-[#FBF5FF] text-[#884EA7]" : "bg-white text-[#64748B] hover:bg-gray-50"}`,
        children: [
          /* @__PURE__ */ O.jsx(r, { className: "h-[15px] w-[15px] font-bold" }),
          n.name
        ]
      },
      n.name
    );
  }) });
}
const s0 = ({ color: e }) => /* @__PURE__ */ O.jsx(
  "span",
  {
    style: {
      display: "inline-block",
      width: "8px",
      height: "8px",
      borderRadius: "50%",
      backgroundColor: e,
      marginRight: "6px"
    }
  }
), Sl = ({ active: e, payload: t }) => !e || !t || !t.length ? null : /* @__PURE__ */ O.jsx("div", { className: "bg-[#121212] text-white !text-[12px] p-3 rounded-lg shadow-lg", children: t.map((n, r) => /* @__PURE__ */ O.jsxs(
  "div",
  {
    className: "capitalize flex gap-[4px] items-center leading-relaxed",
    children: [
      n.color && /* @__PURE__ */ O.jsx(s0, { color: n.color }),
      n.payload.color && /* @__PURE__ */ O.jsx(s0, { color: n.payload.color }),
      /* @__PURE__ */ O.jsx("div", { className: "min-w-[84px] text-[#D1D3D4]", children: n.name }),
      /* @__PURE__ */ O.jsx("div", { className: "font-semibold", children: n.value })
    ]
  },
  r
)) }), p_ = ({ value: e }) => {
  const t = typeof e == "string" ? parseFloat(e.replace("%", "")) : e ?? 0, n = t >= 0;
  return /* @__PURE__ */ O.jsxs(
    "div",
    {
      className: `w-fit p-1 rounded text-[10px] leading-[14px] font-medium flex items-center gap-1 ${n ? "bg-[#F7FEFA] text-[#1FA05B]" : "bg-[#FFF2F2] text-[#AB0000]"}`,
      children: [
        n ? /* @__PURE__ */ O.jsx(XD, {}) : /* @__PURE__ */ O.jsx(GD, {}),
        Math.abs(t).toFixed(1),
        "%"
      ]
    }
  );
}, Vo = ({
  title: e,
  icon: t,
  period: n,
  actionButtons: r,
  children: i,
  footer: o,
  className: a = "",
  childrenClassName: s,
  titleWeight: l
}) => {
  const c = l === "semi-bold" ? 600 : 500;
  return /* @__PURE__ */ O.jsxs(
    "div",
    {
      className: `relative bg-white !border-[0.5px] !border-[#EBEBEB] !rounded-[12px] !shadow-[0_0_12px_0_#EAF2FF] p-[16px] flex flex-col gap-[24px] ${a}`,
      children: [
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[12px]", children: [
            t,
            /* @__PURE__ */ O.jsx(
              "div",
              {
                style: {
                  fontWeight: c,
                  fontSize: "16px",
                  lineHeight: "20px"
                },
                className: "!my-0 !text-[16px] !leading-[20px] !text-[#121212]",
                children: e
              }
            )
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-2", children: [
            r && r,
            n && /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] !leading-[16px] !text-[#64748B]", children: n })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: `flex-1 min-h-0 space-y-[24px] ${s}`, children: i }),
        o && /* @__PURE__ */ O.jsx("div", { className: "mt-3 pt-3 border-t border-gray-100 !text-[12px] text-[#64748B]", children: o })
      ]
    }
  );
};
var Ff = {}, Bf = {}, l0;
function iR() {
  return l0 || (l0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n === "__proto__";
    }
    e.isUnsafeProperty = t;
  })(Bf)), Bf;
}
var zf = {}, c0;
function h_() {
  return c0 || (c0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      switch (typeof n) {
        case "number":
        case "symbol":
          return !1;
        case "string":
          return n.includes(".") || n.includes("[") || n.includes("]");
      }
    }
    e.isDeepKey = t;
  })(zf)), zf;
}
var Wf = {}, u0;
function m_() {
  return u0 || (u0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return typeof n == "string" || typeof n == "symbol" ? n : Object.is(n?.valueOf?.(), -0) ? "-0" : String(n);
    }
    e.toKey = t;
  })(Wf)), Wf;
}
var Vf = {}, d0;
function wg() {
  return d0 || (d0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      const r = [], i = n.length;
      if (i === 0)
        return r;
      let o = 0, a = "", s = "", l = !1;
      for (n.charCodeAt(0) === 46 && (r.push(""), o++); o < i; ) {
        const c = n[o];
        s ? c === "\\" && o + 1 < i ? (o++, a += n[o]) : c === s ? s = "" : a += c : l ? c === '"' || c === "'" ? s = c : c === "]" ? (l = !1, r.push(a), a = "") : a += c : c === "[" ? (l = !0, a && (r.push(a), a = "")) : c === "." ? a && (r.push(a), a = "") : a += c, o++;
      }
      return a && r.push(a), r;
    }
    e.toPath = t;
  })(Vf)), Vf;
}
var f0;
function Og() {
  return f0 || (f0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ iR(), n = /* @__PURE__ */ h_(), r = /* @__PURE__ */ m_(), i = /* @__PURE__ */ wg();
    function o(s, l, c) {
      if (s == null)
        return c;
      switch (typeof l) {
        case "string": {
          if (t.isUnsafeProperty(l))
            return c;
          const u = s[l];
          return u === void 0 ? n.isDeepKey(l) ? o(s, i.toPath(l), c) : c : u;
        }
        case "number":
        case "symbol": {
          typeof l == "number" && (l = r.toKey(l));
          const u = s[l];
          return u === void 0 ? c : u;
        }
        default: {
          if (Array.isArray(l))
            return a(s, l, c);
          if (Object.is(l?.valueOf(), -0) ? l = "-0" : l = String(l), t.isUnsafeProperty(l))
            return c;
          const u = s[l];
          return u === void 0 ? c : u;
        }
      }
    }
    function a(s, l, c) {
      if (l.length === 0)
        return c;
      let u = s;
      for (let d = 0; d < l.length; d++) {
        if (u == null || t.isUnsafeProperty(l[d]))
          return c;
        u = u[l[d]];
      }
      return u === void 0 ? c : u;
    }
    e.get = o;
  })(Ff)), Ff;
}
var Uf, p0;
function oR() {
  return p0 || (p0 = 1, Uf = Og().get), Uf;
}
var aR = /* @__PURE__ */ oR();
const Do = /* @__PURE__ */ xi(aR);
var Ht = (e) => e === 0 ? 0 : e > 0 ? 1 : -1, Hn = (e) => typeof e == "number" && e != +e, wo = (e) => typeof e == "string" && e.indexOf("%") === e.length - 1, me = (e) => (typeof e == "number" || e instanceof Number) && !Hn(e), Fr = (e) => me(e) || typeof e == "string", sR = 0, Ks = (e) => {
  var t = ++sR;
  return "".concat(e || "").concat(t);
}, pn = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (!me(t) && typeof t != "string")
    return r;
  var o;
  if (wo(t)) {
    if (n == null)
      return r;
    var a = t.indexOf("%");
    o = n * parseFloat(t.slice(0, a)) / 100;
  } else
    o = +t;
  return Hn(o) && (o = r), i && n != null && o > n && (o = n), o;
}, g_ = (e) => {
  if (!Array.isArray(e))
    return !1;
  for (var t = e.length, n = {}, r = 0; r < t; r++)
    if (!n[e[r]])
      n[e[r]] = !0;
    else
      return !0;
  return !1;
};
function yt(e, t, n) {
  return me(e) && me(t) ? e + n * (t - e) : t;
}
function v_(e, t, n) {
  if (!(!e || !e.length))
    return e.find((r) => r && (typeof t == "function" ? t(r) : Do(r, t)) === n);
}
var dt = (e) => e === null || typeof e > "u", El = (e) => dt(e) ? e : "".concat(e.charAt(0).toUpperCase()).concat(e.slice(1)), lR = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
function Sg(e) {
  if (typeof e != "string")
    return !1;
  var t = lR;
  return t.includes(e);
}
var cR = ["viewBox", "children"], h0 = ["points", "pathLength"], Hf = {
  svg: cR,
  polygon: h0,
  polyline: h0
}, Eg = (e, t) => {
  if (!e || typeof e == "function" || typeof e == "boolean")
    return null;
  var n = e;
  if (/* @__PURE__ */ bn(e) && (n = e.props), typeof n != "object" && typeof n != "function")
    return null;
  var r = {};
  return Object.keys(n).forEach((i) => {
    Sg(i) && (r[i] = ((o) => n[i](n, o)));
  }), r;
}, uR = (e, t, n) => (r) => (e(t, n, r), null), kd = (e, t, n) => {
  if (e === null || typeof e != "object" && typeof e != "function")
    return null;
  var r = null;
  return Object.keys(e).forEach((i) => {
    var o = e[i];
    Sg(i) && typeof o == "function" && (r || (r = {}), r[i] = uR(o, t, n));
  }), r;
}, dR = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it, and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
];
function y_(e) {
  if (typeof e != "string")
    return !1;
  var t = dR;
  return t.includes(e);
}
function Kr(e) {
  var t = Object.entries(e).filter((n) => {
    var [r] = n;
    return y_(r);
  });
  return Object.fromEntries(t);
}
var m0 = (e) => typeof e == "string" ? e : e ? e.displayName || e.name || "Component" : "", g0 = null, Kf = null, b_ = (e) => {
  if (e === g0 && Array.isArray(Kf))
    return Kf;
  var t = [];
  return mE.forEach(e, (n) => {
    dt(n) || (Fi.isFragment(n) ? t = t.concat(b_(n.props.children)) : t.push(n));
  }), Kf = t, g0 = e, t;
};
function _g(e, t) {
  var n = [], r = [];
  return Array.isArray(t) ? r = t.map((i) => m0(i)) : r = [m0(t)], b_(e).forEach((i) => {
    var o = Do(i, "type.displayName") || Do(i, "type.name");
    r.indexOf(o) !== -1 && n.push(i);
  }), n;
}
var x_ = (e) => e && typeof e == "object" && "clipDot" in e ? !!e.clipDot : !0, fR = (e, t, n, r) => {
  var i;
  if (typeof t == "symbol" || typeof t == "number")
    return !0;
  var o = (i = r && Hf?.[r]) !== null && i !== void 0 ? i : [], a = t.startsWith("data-"), s = typeof e != "function" && (!!r && o.includes(t) || y_(t)), l = !!n && Sg(t);
  return a || s || l;
}, ht = (e, t, n) => {
  if (!e || typeof e == "function" || typeof e == "boolean")
    return null;
  var r = e;
  if (/* @__PURE__ */ bn(e) && (r = e.props), typeof r != "object" && typeof r != "function")
    return null;
  var i = {};
  return Object.keys(r).forEach((o) => {
    var a;
    fR((a = r) === null || a === void 0 ? void 0 : a[o], o, t, n) && (i[o] = r[o]);
  }), i;
}, pR = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function Uh() {
  return Uh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Uh.apply(null, arguments);
}
function hR(e, t) {
  if (e == null) return {};
  var n, r, i = mR(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function mR(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var w_ = /* @__PURE__ */ nn((e, t) => {
  var {
    children: n,
    width: r,
    height: i,
    viewBox: o,
    className: a,
    style: s,
    title: l,
    desc: c
  } = e, u = hR(e, pR), d = o || {
    width: r,
    height: i,
    x: 0,
    y: 0
  }, f = ce("recharts-surface", a);
  return /* @__PURE__ */ _.createElement("svg", Uh({}, ht(u, !0, "svg"), {
    className: f,
    width: r,
    height: i,
    style: s,
    viewBox: "".concat(d.x, " ").concat(d.y, " ").concat(d.width, " ").concat(d.height),
    ref: t
  }), /* @__PURE__ */ _.createElement("title", null, l), /* @__PURE__ */ _.createElement("desc", null, c), n);
}), gR = ["children", "className"];
function Hh() {
  return Hh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Hh.apply(null, arguments);
}
function vR(e, t) {
  if (e == null) return {};
  var n, r, i = yR(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function yR(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var tn = /* @__PURE__ */ _.forwardRef((e, t) => {
  var {
    children: n,
    className: r
  } = e, i = vR(e, gR), o = ce("recharts-layer", r);
  return /* @__PURE__ */ _.createElement("g", Hh({
    className: o
  }, ht(i, !0), {
    ref: t
  }), n);
}), bR = /* @__PURE__ */ hr(null);
function et(e) {
  return function() {
    return e;
  };
}
const O_ = Math.cos, uu = Math.sin, xr = Math.sqrt, du = Math.PI, Md = 2 * du, Kh = Math.PI, qh = 2 * Kh, fo = 1e-6, xR = qh - fo;
function S_(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function wR(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return S_;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, o = r.length; i < o; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
class OR {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? S_ : wR(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, o, a) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +o},${this._y1 = +a}`;
  }
  arcTo(t, n, r, i, o) {
    if (t = +t, n = +n, r = +r, i = +i, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let a = this._x1, s = this._y1, l = r - t, c = i - n, u = a - t, d = s - n, f = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (f > fo) if (!(Math.abs(d * l - c * u) > fo) || !o)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let p = r - a, g = i - s, m = l * l + c * c, v = p * p + g * g, y = Math.sqrt(m), S = Math.sqrt(f), x = o * Math.tan((Kh - Math.acos((m + f - v) / (2 * y * S))) / 2), b = x / S, w = x / y;
      Math.abs(b - 1) > fo && this._append`L${t + b * u},${n + b * d}`, this._append`A${o},${o},0,0,${+(d * p > u * g)},${this._x1 = t + w * l},${this._y1 = n + w * c}`;
    }
  }
  arc(t, n, r, i, o, a) {
    if (t = +t, n = +n, r = +r, a = !!a, r < 0) throw new Error(`negative radius: ${r}`);
    let s = r * Math.cos(i), l = r * Math.sin(i), c = t + s, u = n + l, d = 1 ^ a, f = a ? i - o : o - i;
    this._x1 === null ? this._append`M${c},${u}` : (Math.abs(this._x1 - c) > fo || Math.abs(this._y1 - u) > fo) && this._append`L${c},${u}`, r && (f < 0 && (f = f % qh + qh), f > xR ? this._append`A${r},${r},0,1,${d},${t - s},${n - l}A${r},${r},0,1,${d},${this._x1 = c},${this._y1 = u}` : f > fo && this._append`A${r},${r},0,${+(f >= Kh)},${d},${this._x1 = t + r * Math.cos(o)},${this._y1 = n + r * Math.sin(o)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
}
function Pg(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new OR(t);
}
function Cg(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function E_(e) {
  this._context = e;
}
E_.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function jd(e) {
  return new E_(e);
}
function __(e) {
  return e[0];
}
function P_(e) {
  return e[1];
}
function C_(e, t) {
  var n = et(!0), r = null, i = jd, o = null, a = Pg(s);
  e = typeof e == "function" ? e : e === void 0 ? __ : et(e), t = typeof t == "function" ? t : t === void 0 ? P_ : et(t);
  function s(l) {
    var c, u = (l = Cg(l)).length, d, f = !1, p;
    for (r == null && (o = i(p = a())), c = 0; c <= u; ++c)
      !(c < u && n(d = l[c], c, l)) === f && ((f = !f) ? o.lineStart() : o.lineEnd()), f && o.point(+e(d, c, l), +t(d, c, l));
    if (p) return o = null, p + "" || null;
  }
  return s.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : et(+l), s) : e;
  }, s.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : et(+l), s) : t;
  }, s.defined = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : et(!!l), s) : n;
  }, s.curve = function(l) {
    return arguments.length ? (i = l, r != null && (o = i(r)), s) : i;
  }, s.context = function(l) {
    return arguments.length ? (l == null ? r = o = null : o = i(r = l), s) : r;
  }, s;
}
function oc(e, t, n) {
  var r = null, i = et(!0), o = null, a = jd, s = null, l = Pg(c);
  e = typeof e == "function" ? e : e === void 0 ? __ : et(+e), t = typeof t == "function" ? t : et(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? P_ : et(+n);
  function c(d) {
    var f, p, g, m = (d = Cg(d)).length, v, y = !1, S, x = new Array(m), b = new Array(m);
    for (o == null && (s = a(S = l())), f = 0; f <= m; ++f) {
      if (!(f < m && i(v = d[f], f, d)) === y)
        if (y = !y)
          p = f, s.areaStart(), s.lineStart();
        else {
          for (s.lineEnd(), s.lineStart(), g = f - 1; g >= p; --g)
            s.point(x[g], b[g]);
          s.lineEnd(), s.areaEnd();
        }
      y && (x[f] = +e(v, f, d), b[f] = +t(v, f, d), s.point(r ? +r(v, f, d) : x[f], n ? +n(v, f, d) : b[f]));
    }
    if (S) return s = null, S + "" || null;
  }
  function u() {
    return C_().defined(i).curve(a).context(o);
  }
  return c.x = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : et(+d), r = null, c) : e;
  }, c.x0 = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : et(+d), c) : e;
  }, c.x1 = function(d) {
    return arguments.length ? (r = d == null ? null : typeof d == "function" ? d : et(+d), c) : r;
  }, c.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : et(+d), n = null, c) : t;
  }, c.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : et(+d), c) : t;
  }, c.y1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : et(+d), c) : n;
  }, c.lineX0 = c.lineY0 = function() {
    return u().x(e).y(t);
  }, c.lineY1 = function() {
    return u().x(e).y(n);
  }, c.lineX1 = function() {
    return u().x(r).y(t);
  }, c.defined = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : et(!!d), c) : i;
  }, c.curve = function(d) {
    return arguments.length ? (a = d, o != null && (s = a(o)), c) : a;
  }, c.context = function(d) {
    return arguments.length ? (d == null ? o = s = null : s = a(o = d), c) : o;
  }, c;
}
class A_ {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function SR(e) {
  return new A_(e, !0);
}
function ER(e) {
  return new A_(e, !1);
}
const Ag = {
  draw(e, t) {
    const n = xr(t / du);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, Md);
  }
}, _R = {
  draw(e, t) {
    const n = xr(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, T_ = xr(1 / 3), PR = T_ * 2, CR = {
  draw(e, t) {
    const n = xr(t / PR), r = n * T_;
    e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath();
  }
}, AR = {
  draw(e, t) {
    const n = xr(t), r = -n / 2;
    e.rect(r, r, n, n);
  }
}, TR = 0.8908130915292852, k_ = uu(du / 10) / uu(7 * du / 10), kR = uu(Md / 10) * k_, MR = -O_(Md / 10) * k_, jR = {
  draw(e, t) {
    const n = xr(t * TR), r = kR * n, i = MR * n;
    e.moveTo(0, -n), e.lineTo(r, i);
    for (let o = 1; o < 5; ++o) {
      const a = Md * o / 5, s = O_(a), l = uu(a);
      e.lineTo(l * n, -s * n), e.lineTo(s * r - l * i, l * r + s * i);
    }
    e.closePath();
  }
}, qf = xr(3), NR = {
  draw(e, t) {
    const n = -xr(t / (qf * 3));
    e.moveTo(0, n * 2), e.lineTo(-qf * n, -n), e.lineTo(qf * n, -n), e.closePath();
  }
}, Qn = -0.5, er = xr(3) / 2, Yh = 1 / xr(12), DR = (Yh / 2 + 1) * 3, RR = {
  draw(e, t) {
    const n = xr(t / DR), r = n / 2, i = n * Yh, o = r, a = n * Yh + n, s = -o, l = a;
    e.moveTo(r, i), e.lineTo(o, a), e.lineTo(s, l), e.lineTo(Qn * r - er * i, er * r + Qn * i), e.lineTo(Qn * o - er * a, er * o + Qn * a), e.lineTo(Qn * s - er * l, er * s + Qn * l), e.lineTo(Qn * r + er * i, Qn * i - er * r), e.lineTo(Qn * o + er * a, Qn * a - er * o), e.lineTo(Qn * s + er * l, Qn * l - er * s), e.closePath();
  }
};
function IR(e, t) {
  let n = null, r = Pg(i);
  e = typeof e == "function" ? e : et(e || Ag), t = typeof t == "function" ? t : et(t === void 0 ? 64 : +t);
  function i() {
    let o;
    if (n || (n = o = r()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null;
  }
  return i.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : et(o), i) : e;
  }, i.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : et(+o), i) : t;
  }, i.context = function(o) {
    return arguments.length ? (n = o ?? null, i) : n;
  }, i;
}
function fu() {
}
function pu(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function M_(e) {
  this._context = e;
}
M_.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        pu(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        pu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function $R(e) {
  return new M_(e);
}
function j_(e) {
  this._context = e;
}
j_.prototype = {
  areaStart: fu,
  areaEnd: fu,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        pu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function LR(e) {
  return new j_(e);
}
function N_(e) {
  this._context = e;
}
N_.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        pu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function FR(e) {
  return new N_(e);
}
function D_(e) {
  this._context = e;
}
D_.prototype = {
  areaStart: fu,
  areaEnd: fu,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function BR(e) {
  return new D_(e);
}
function v0(e) {
  return e < 0 ? -1 : 1;
}
function y0(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), s = (o * i + a * r) / (r + i);
  return (v0(o) + v0(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(s)) || 0;
}
function b0(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function Yf(e, t, n) {
  var r = e._x0, i = e._y0, o = e._x1, a = e._y1, s = (o - r) / 3;
  e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a);
}
function hu(e) {
  this._context = e;
}
hu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Yf(this, this._t0, b0(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Yf(this, b0(this, n = y0(this, e, t)), n);
          break;
        default:
          Yf(this, this._t0, n = y0(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function R_(e) {
  this._context = new I_(e);
}
(R_.prototype = Object.create(hu.prototype)).point = function(e, t) {
  hu.prototype.point.call(this, t, e);
};
function I_(e) {
  this._context = e;
}
I_.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i);
  }
};
function zR(e) {
  return new hu(e);
}
function WR(e) {
  return new R_(e);
}
function $_(e) {
  this._context = e;
}
$_.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = x0(e), i = x0(t), o = 0, a = 1; a < n; ++o, ++a)
          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function x0(e) {
  var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), a = new Array(n);
  for (i[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) i[t] = 1, o[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) r = i[t] / o[t - 1], o[t] -= r, a[t] -= r * a[t - 1];
  for (i[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t) i[t] = (a[t] - i[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t) o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function VR(e) {
  return new $_(e);
}
function Nd(e, t) {
  this._context = e, this._t = t;
}
Nd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function UR(e) {
  return new Nd(e, 0.5);
}
function HR(e) {
  return new Nd(e, 0);
}
function KR(e) {
  return new Nd(e, 1);
}
function Oa(e, t) {
  if ((a = e.length) > 1)
    for (var n = 1, r, i, o = e[t[0]], a, s = o.length; n < a; ++n)
      for (i = o, o = e[t[n]], r = 0; r < s; ++r)
        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function Gh(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; ) n[t] = t;
  return n;
}
function qR(e, t) {
  return e[t];
}
function YR(e) {
  const t = [];
  return t.key = e, t;
}
function GR() {
  var e = et([]), t = Gh, n = Oa, r = qR;
  function i(o) {
    var a = Array.from(e.apply(this, arguments), YR), s, l = a.length, c = -1, u;
    for (const d of o)
      for (s = 0, ++c; s < l; ++s)
        (a[s][c] = [0, +r(d, a[s].key, c, o)]).data = d;
    for (s = 0, u = Cg(t(a)); s < l; ++s)
      a[u[s]].index = s;
    return n(a, u), a;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : et(Array.from(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : et(+o), i) : r;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? Gh : typeof o == "function" ? o : et(Array.from(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (n = o ?? Oa, i) : n;
  }, i;
}
function XR(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, i = 0, o = e[0].length, a; i < o; ++i) {
      for (a = n = 0; n < r; ++n) a += e[n][i][1] || 0;
      if (a) for (n = 0; n < r; ++n) e[n][i][1] /= a;
    }
    Oa(e, t);
  }
}
function ZR(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
      for (var a = 0, s = 0; a < i; ++a) s += e[a][n][1] || 0;
      r[n][1] += r[n][0] = -s / 2;
    }
    Oa(e, t);
  }
}
function JR(e, t) {
  if (!(!((a = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, i, o, a; r < o; ++r) {
      for (var s = 0, l = 0, c = 0; s < a; ++s) {
        for (var u = e[t[s]], d = u[r][1] || 0, f = u[r - 1][1] || 0, p = (d - f) / 2, g = 0; g < s; ++g) {
          var m = e[t[g]], v = m[r][1] || 0, y = m[r - 1][1] || 0;
          p += v - y;
        }
        l += d, c += p * d;
      }
      i[r - 1][1] += i[r - 1][0] = n, l && (n -= c / l);
    }
    i[r - 1][1] += i[r - 1][0] = n, Oa(e, t);
  }
}
var QR = ["type", "size", "sizeType"];
function Xh() {
  return Xh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Xh.apply(null, arguments);
}
function w0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function O0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w0(Object(n), !0).forEach(function(r) {
      eI(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function eI(e, t, n) {
  return (t = tI(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function tI(e) {
  var t = nI(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function nI(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rI(e, t) {
  if (e == null) return {};
  var n, r, i = iI(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function iI(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var L_ = {
  symbolCircle: Ag,
  symbolCross: _R,
  symbolDiamond: CR,
  symbolSquare: AR,
  symbolStar: jR,
  symbolTriangle: NR,
  symbolWye: RR
}, oI = Math.PI / 180, aI = (e) => {
  var t = "symbol".concat(El(e));
  return L_[t] || Ag;
}, sI = (e, t, n) => {
  if (t === "area")
    return e;
  switch (n) {
    case "cross":
      return 5 * e * e / 9;
    case "diamond":
      return 0.5 * e * e / Math.sqrt(3);
    case "square":
      return e * e;
    case "star": {
      var r = 18 * oI;
      return 1.25 * e * e * (Math.tan(r) - Math.tan(r * 2) * Math.tan(r) ** 2);
    }
    case "triangle":
      return Math.sqrt(3) * e * e / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * e * e / 8;
    default:
      return Math.PI * e * e / 4;
  }
}, lI = (e, t) => {
  L_["symbol".concat(El(e))] = t;
}, F_ = (e) => {
  var {
    type: t = "circle",
    size: n = 64,
    sizeType: r = "area"
  } = e, i = rI(e, QR), o = O0(O0({}, i), {}, {
    type: t,
    size: n,
    sizeType: r
  }), a = "circle";
  typeof t == "string" && (a = t);
  var s = () => {
    var f = aI(a), p = IR().type(f).size(sI(n, r, a));
    return p();
  }, {
    className: l,
    cx: c,
    cy: u
  } = o, d = ht(o, !0);
  return c === +c && u === +u && n === +n ? /* @__PURE__ */ _.createElement("path", Xh({}, d, {
    className: ce("recharts-symbols", l),
    transform: "translate(".concat(c, ", ").concat(u, ")"),
    d: s()
  })) : null;
};
F_.registerSymbol = lI;
var Gf = {}, Xf = {}, S0;
function cI() {
  return S0 || (S0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r) {
      const i = /* @__PURE__ */ new Map();
      for (let o = 0; o < n.length; o++) {
        const a = n[o], s = r(a);
        i.has(s) || i.set(s, a);
      }
      return Array.from(i.values());
    }
    e.uniqBy = t;
  })(Xf)), Xf;
}
var Zf = {}, E0;
function B_() {
  return E0 || (E0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n;
    }
    e.identity = t;
  })(Zf)), Zf;
}
var Jf = {}, Qf = {}, ep = {}, _0;
function uI() {
  return _0 || (_0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return Number.isSafeInteger(n) && n >= 0;
    }
    e.isLength = t;
  })(ep)), ep;
}
var P0;
function Tg() {
  return P0 || (P0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ uI();
    function n(r) {
      return r != null && typeof r != "function" && t.isLength(r.length);
    }
    e.isArrayLike = n;
  })(Qf)), Qf;
}
var tp = {}, C0;
function dI() {
  return C0 || (C0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return typeof n == "object" && n !== null;
    }
    e.isObjectLike = t;
  })(tp)), tp;
}
var A0;
function fI() {
  return A0 || (A0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ Tg(), n = /* @__PURE__ */ dI();
    function r(i) {
      return n.isObjectLike(i) && t.isArrayLike(i);
    }
    e.isArrayLikeObject = r;
  })(Jf)), Jf;
}
var np = {}, rp = {}, T0;
function pI() {
  return T0 || (T0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ Og();
    function n(r) {
      return function(i) {
        return t.get(i, r);
      };
    }
    e.property = n;
  })(rp)), rp;
}
var ip = {}, op = {}, ap = {}, sp = {}, k0;
function z_() {
  return k0 || (k0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n !== null && (typeof n == "object" || typeof n == "function");
    }
    e.isObject = t;
  })(sp)), sp;
}
var lp = {}, M0;
function W_() {
  return M0 || (M0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n == null || typeof n != "object" && typeof n != "function";
    }
    e.isPrimitive = t;
  })(lp)), lp;
}
var cp = {}, j0;
function V_() {
  return j0 || (j0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r) {
      return n === r || Number.isNaN(n) && Number.isNaN(r);
    }
    e.eq = t;
  })(cp)), cp;
}
var N0;
function hI() {
  return N0 || (N0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ kg(), n = /* @__PURE__ */ z_(), r = /* @__PURE__ */ W_(), i = /* @__PURE__ */ V_();
    function o(d, f, p) {
      return typeof p != "function" ? t.isMatch(d, f) : a(d, f, function g(m, v, y, S, x, b) {
        const w = p(m, v, y, S, x, b);
        return w !== void 0 ? !!w : a(m, v, g, b);
      }, /* @__PURE__ */ new Map());
    }
    function a(d, f, p, g) {
      if (f === d)
        return !0;
      switch (typeof f) {
        case "object":
          return s(d, f, p, g);
        case "function":
          return Object.keys(f).length > 0 ? a(d, { ...f }, p, g) : i.eq(d, f);
        default:
          return n.isObject(d) ? typeof f == "string" ? f === "" : !0 : i.eq(d, f);
      }
    }
    function s(d, f, p, g) {
      if (f == null)
        return !0;
      if (Array.isArray(f))
        return c(d, f, p, g);
      if (f instanceof Map)
        return l(d, f, p, g);
      if (f instanceof Set)
        return u(d, f, p, g);
      const m = Object.keys(f);
      if (d == null)
        return m.length === 0;
      if (m.length === 0)
        return !0;
      if (g && g.has(f))
        return g.get(f) === d;
      g && g.set(f, d);
      try {
        for (let v = 0; v < m.length; v++) {
          const y = m[v];
          if (!r.isPrimitive(d) && !(y in d) || f[y] === void 0 && d[y] !== void 0 || f[y] === null && d[y] !== null || !p(d[y], f[y], y, d, f, g))
            return !1;
        }
        return !0;
      } finally {
        g && g.delete(f);
      }
    }
    function l(d, f, p, g) {
      if (f.size === 0)
        return !0;
      if (!(d instanceof Map))
        return !1;
      for (const [m, v] of f.entries()) {
        const y = d.get(m);
        if (p(y, v, m, d, f, g) === !1)
          return !1;
      }
      return !0;
    }
    function c(d, f, p, g) {
      if (f.length === 0)
        return !0;
      if (!Array.isArray(d))
        return !1;
      const m = /* @__PURE__ */ new Set();
      for (let v = 0; v < f.length; v++) {
        const y = f[v];
        let S = !1;
        for (let x = 0; x < d.length; x++) {
          if (m.has(x))
            continue;
          const b = d[x];
          let w = !1;
          if (p(b, y, v, d, f, g) && (w = !0), w) {
            m.add(x), S = !0;
            break;
          }
        }
        if (!S)
          return !1;
      }
      return !0;
    }
    function u(d, f, p, g) {
      return f.size === 0 ? !0 : d instanceof Set ? c([...d], [...f], p, g) : !1;
    }
    e.isMatchWith = o, e.isSetMatch = u;
  })(ap)), ap;
}
var D0;
function kg() {
  return D0 || (D0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ hI();
    function n(r, i) {
      return t.isMatchWith(r, i, () => {
      });
    }
    e.isMatch = n;
  })(op)), op;
}
var up = {}, dp = {}, fp = {}, R0;
function mI() {
  return R0 || (R0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return Object.getOwnPropertySymbols(n).filter((r) => Object.prototype.propertyIsEnumerable.call(n, r));
    }
    e.getSymbols = t;
  })(fp)), fp;
}
var pp = {}, I0;
function U_() {
  return I0 || (I0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n == null ? n === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(n);
    }
    e.getTag = t;
  })(pp)), pp;
}
var hp = {}, $0;
function H_() {
  return $0 || ($0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = "[object RegExp]", n = "[object String]", r = "[object Number]", i = "[object Boolean]", o = "[object Arguments]", a = "[object Symbol]", s = "[object Date]", l = "[object Map]", c = "[object Set]", u = "[object Array]", d = "[object Function]", f = "[object ArrayBuffer]", p = "[object Object]", g = "[object Error]", m = "[object DataView]", v = "[object Uint8Array]", y = "[object Uint8ClampedArray]", S = "[object Uint16Array]", x = "[object Uint32Array]", b = "[object BigUint64Array]", w = "[object Int8Array]", E = "[object Int16Array]", C = "[object Int32Array]", A = "[object BigInt64Array]", k = "[object Float32Array]", R = "[object Float64Array]";
    e.argumentsTag = o, e.arrayBufferTag = f, e.arrayTag = u, e.bigInt64ArrayTag = A, e.bigUint64ArrayTag = b, e.booleanTag = i, e.dataViewTag = m, e.dateTag = s, e.errorTag = g, e.float32ArrayTag = k, e.float64ArrayTag = R, e.functionTag = d, e.int16ArrayTag = E, e.int32ArrayTag = C, e.int8ArrayTag = w, e.mapTag = l, e.numberTag = r, e.objectTag = p, e.regexpTag = t, e.setTag = c, e.stringTag = n, e.symbolTag = a, e.uint16ArrayTag = S, e.uint32ArrayTag = x, e.uint8ArrayTag = v, e.uint8ClampedArrayTag = y;
  })(hp)), hp;
}
var mp = {}, L0;
function gI() {
  return L0 || (L0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return ArrayBuffer.isView(n) && !(n instanceof DataView);
    }
    e.isTypedArray = t;
  })(mp)), mp;
}
var F0;
function K_() {
  return F0 || (F0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ mI(), n = /* @__PURE__ */ U_(), r = /* @__PURE__ */ H_(), i = /* @__PURE__ */ W_(), o = /* @__PURE__ */ gI();
    function a(u, d) {
      return s(u, void 0, u, /* @__PURE__ */ new Map(), d);
    }
    function s(u, d, f, p = /* @__PURE__ */ new Map(), g = void 0) {
      const m = g?.(u, d, f, p);
      if (m !== void 0)
        return m;
      if (i.isPrimitive(u))
        return u;
      if (p.has(u))
        return p.get(u);
      if (Array.isArray(u)) {
        const v = new Array(u.length);
        p.set(u, v);
        for (let y = 0; y < u.length; y++)
          v[y] = s(u[y], y, f, p, g);
        return Object.hasOwn(u, "index") && (v.index = u.index), Object.hasOwn(u, "input") && (v.input = u.input), v;
      }
      if (u instanceof Date)
        return new Date(u.getTime());
      if (u instanceof RegExp) {
        const v = new RegExp(u.source, u.flags);
        return v.lastIndex = u.lastIndex, v;
      }
      if (u instanceof Map) {
        const v = /* @__PURE__ */ new Map();
        p.set(u, v);
        for (const [y, S] of u)
          v.set(y, s(S, y, f, p, g));
        return v;
      }
      if (u instanceof Set) {
        const v = /* @__PURE__ */ new Set();
        p.set(u, v);
        for (const y of u)
          v.add(s(y, void 0, f, p, g));
        return v;
      }
      if (typeof Buffer < "u" && Buffer.isBuffer(u))
        return u.subarray();
      if (o.isTypedArray(u)) {
        const v = new (Object.getPrototypeOf(u)).constructor(u.length);
        p.set(u, v);
        for (let y = 0; y < u.length; y++)
          v[y] = s(u[y], y, f, p, g);
        return v;
      }
      if (u instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && u instanceof SharedArrayBuffer)
        return u.slice(0);
      if (u instanceof DataView) {
        const v = new DataView(u.buffer.slice(0), u.byteOffset, u.byteLength);
        return p.set(u, v), l(v, u, f, p, g), v;
      }
      if (typeof File < "u" && u instanceof File) {
        const v = new File([u], u.name, {
          type: u.type
        });
        return p.set(u, v), l(v, u, f, p, g), v;
      }
      if (u instanceof Blob) {
        const v = new Blob([u], { type: u.type });
        return p.set(u, v), l(v, u, f, p, g), v;
      }
      if (u instanceof Error) {
        const v = new u.constructor();
        return p.set(u, v), v.message = u.message, v.name = u.name, v.stack = u.stack, v.cause = u.cause, l(v, u, f, p, g), v;
      }
      if (typeof u == "object" && c(u)) {
        const v = Object.create(Object.getPrototypeOf(u));
        return p.set(u, v), l(v, u, f, p, g), v;
      }
      return u;
    }
    function l(u, d, f = u, p, g) {
      const m = [...Object.keys(d), ...t.getSymbols(d)];
      for (let v = 0; v < m.length; v++) {
        const y = m[v], S = Object.getOwnPropertyDescriptor(u, y);
        (S == null || S.writable) && (u[y] = s(d[y], y, f, p, g));
      }
    }
    function c(u) {
      switch (n.getTag(u)) {
        case r.argumentsTag:
        case r.arrayTag:
        case r.arrayBufferTag:
        case r.dataViewTag:
        case r.booleanTag:
        case r.dateTag:
        case r.float32ArrayTag:
        case r.float64ArrayTag:
        case r.int8ArrayTag:
        case r.int16ArrayTag:
        case r.int32ArrayTag:
        case r.mapTag:
        case r.numberTag:
        case r.objectTag:
        case r.regexpTag:
        case r.setTag:
        case r.stringTag:
        case r.symbolTag:
        case r.uint8ArrayTag:
        case r.uint8ClampedArrayTag:
        case r.uint16ArrayTag:
        case r.uint32ArrayTag:
          return !0;
        default:
          return !1;
      }
    }
    e.cloneDeepWith = a, e.cloneDeepWithImpl = s, e.copyProperties = l;
  })(dp)), dp;
}
var B0;
function vI() {
  return B0 || (B0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ K_();
    function n(r) {
      return t.cloneDeepWithImpl(r, void 0, r, /* @__PURE__ */ new Map(), void 0);
    }
    e.cloneDeep = n;
  })(up)), up;
}
var z0;
function yI() {
  return z0 || (z0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ kg(), n = /* @__PURE__ */ vI();
    function r(i) {
      return i = n.cloneDeep(i), (o) => t.isMatch(o, i);
    }
    e.matches = r;
  })(ip)), ip;
}
var gp = {}, vp = {}, yp = {}, W0;
function bI() {
  return W0 || (W0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ K_(), n = /* @__PURE__ */ H_();
    function r(i, o) {
      return t.cloneDeepWith(i, (a, s, l, c) => {
        const u = o?.(a, s, l, c);
        if (u !== void 0)
          return u;
        if (typeof i == "object")
          switch (Object.prototype.toString.call(i)) {
            case n.numberTag:
            case n.stringTag:
            case n.booleanTag: {
              const d = new i.constructor(i?.valueOf());
              return t.copyProperties(d, i), d;
            }
            case n.argumentsTag: {
              const d = {};
              return t.copyProperties(d, i), d.length = i.length, d[Symbol.iterator] = i[Symbol.iterator], d;
            }
            default:
              return;
          }
      });
    }
    e.cloneDeepWith = r;
  })(yp)), yp;
}
var V0;
function xI() {
  return V0 || (V0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ bI();
    function n(r) {
      return t.cloneDeepWith(r);
    }
    e.cloneDeep = n;
  })(vp)), vp;
}
var bp = {}, xp = {}, U0;
function q_() {
  return U0 || (U0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /^(?:0|[1-9]\d*)$/;
    function n(r, i = Number.MAX_SAFE_INTEGER) {
      switch (typeof r) {
        case "number":
          return Number.isInteger(r) && r >= 0 && r < i;
        case "symbol":
          return !1;
        case "string":
          return t.test(r);
      }
    }
    e.isIndex = n;
  })(xp)), xp;
}
var wp = {}, H0;
function wI() {
  return H0 || (H0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ U_();
    function n(r) {
      return r !== null && typeof r == "object" && t.getTag(r) === "[object Arguments]";
    }
    e.isArguments = n;
  })(wp)), wp;
}
var K0;
function OI() {
  return K0 || (K0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ h_(), n = /* @__PURE__ */ q_(), r = /* @__PURE__ */ wI(), i = /* @__PURE__ */ wg();
    function o(a, s) {
      let l;
      if (Array.isArray(s) ? l = s : typeof s == "string" && t.isDeepKey(s) && a?.[s] == null ? l = i.toPath(s) : l = [s], l.length === 0)
        return !1;
      let c = a;
      for (let u = 0; u < l.length; u++) {
        const d = l[u];
        if ((c == null || !Object.hasOwn(c, d)) && !((Array.isArray(c) || r.isArguments(c)) && n.isIndex(d) && d < c.length))
          return !1;
        c = c[d];
      }
      return !0;
    }
    e.has = o;
  })(bp)), bp;
}
var q0;
function SI() {
  return q0 || (q0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ kg(), n = /* @__PURE__ */ m_(), r = /* @__PURE__ */ xI(), i = /* @__PURE__ */ Og(), o = /* @__PURE__ */ OI();
    function a(s, l) {
      switch (typeof s) {
        case "object": {
          Object.is(s?.valueOf(), -0) && (s = "-0");
          break;
        }
        case "number": {
          s = n.toKey(s);
          break;
        }
      }
      return l = r.cloneDeep(l), function(c) {
        const u = i.get(c, s);
        return u === void 0 ? o.has(c, s) : l === void 0 ? u === void 0 : t.isMatch(u, l);
      };
    }
    e.matchesProperty = a;
  })(gp)), gp;
}
var Y0;
function EI() {
  return Y0 || (Y0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ B_(), n = /* @__PURE__ */ pI(), r = /* @__PURE__ */ yI(), i = /* @__PURE__ */ SI();
    function o(a) {
      if (a == null)
        return t.identity;
      switch (typeof a) {
        case "function":
          return a;
        case "object":
          return Array.isArray(a) && a.length === 2 ? i.matchesProperty(a[0], a[1]) : r.matches(a);
        case "string":
        case "symbol":
        case "number":
          return n.property(a);
      }
    }
    e.iteratee = o;
  })(np)), np;
}
var G0;
function _I() {
  return G0 || (G0 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ cI(), n = /* @__PURE__ */ B_(), r = /* @__PURE__ */ fI(), i = /* @__PURE__ */ EI();
    function o(a, s = n.identity) {
      return r.isArrayLikeObject(a) ? t.uniqBy(Array.from(a), i.iteratee(s)) : [];
    }
    e.uniqBy = o;
  })(Gf)), Gf;
}
var Op, X0;
function PI() {
  return X0 || (X0 = 1, Op = _I().uniqBy), Op;
}
var CI = /* @__PURE__ */ PI();
const Z0 = /* @__PURE__ */ xi(CI);
function AI(e, t, n) {
  return t === !0 ? Z0(e, n) : typeof t == "function" ? Z0(e, t) : e;
}
var ac = { exports: {} }, Sp = {}, sc = { exports: {} }, Ep = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var J0;
function TI() {
  if (J0) return Ep;
  J0 = 1;
  var e = He;
  function t(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, a = e.useDebugValue;
  function s(d, f) {
    var p = f(), g = r({ inst: { value: p, getSnapshot: f } }), m = g[0].inst, v = g[1];
    return o(
      function() {
        m.value = p, m.getSnapshot = f, l(m) && v({ inst: m });
      },
      [d, p, f]
    ), i(
      function() {
        return l(m) && v({ inst: m }), d(function() {
          l(m) && v({ inst: m });
        });
      },
      [d]
    ), a(p), p;
  }
  function l(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var p = f();
      return !n(d, p);
    } catch {
      return !0;
    }
  }
  function c(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : s;
  return Ep.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, Ep;
}
var _p = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Q0;
function kI() {
  return Q0 || (Q0 = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(p, g) {
      return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g;
    }
    function t(p, g) {
      u || i.startTransition === void 0 || (u = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var m = g();
      if (!d) {
        var v = g();
        o(m, v) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      v = a({
        inst: { value: m, getSnapshot: g }
      });
      var y = v[0].inst, S = v[1];
      return l(
        function() {
          y.value = m, y.getSnapshot = g, n(y) && S({ inst: y });
        },
        [p, m, g]
      ), s(
        function() {
          return n(y) && S({ inst: y }), p(function() {
            n(y) && S({ inst: y });
          });
        },
        [p]
      ), c(m), m;
    }
    function n(p) {
      var g = p.getSnapshot;
      p = p.value;
      try {
        var m = g();
        return !o(p, m);
      } catch {
        return !0;
      }
    }
    function r(p, g) {
      return g();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var i = He, o = typeof Object.is == "function" ? Object.is : e, a = i.useState, s = i.useEffect, l = i.useLayoutEffect, c = i.useDebugValue, u = !1, d = !1, f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : t;
    _p.useSyncExternalStore = i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), _p;
}
var ex;
function Y_() {
  return ex || (ex = 1, process.env.NODE_ENV === "production" ? sc.exports = TI() : sc.exports = kI()), sc.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tx;
function MI() {
  if (tx) return Sp;
  tx = 1;
  var e = He, t = Y_();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, l = e.useDebugValue;
  return Sp.useSyncExternalStoreWithSelector = function(c, u, d, f, p) {
    var g = o(null);
    if (g.current === null) {
      var m = { hasValue: !1, value: null };
      g.current = m;
    } else m = g.current;
    g = s(
      function() {
        function y(E) {
          if (!S) {
            if (S = !0, x = E, E = f(E), p !== void 0 && m.hasValue) {
              var C = m.value;
              if (p(C, E))
                return b = C;
            }
            return b = E;
          }
          if (C = b, r(x, E)) return C;
          var A = f(E);
          return p !== void 0 && p(C, A) ? (x = E, C) : (x = E, b = A);
        }
        var S = !1, x, b, w = d === void 0 ? null : d;
        return [
          function() {
            return y(u());
          },
          w === null ? void 0 : function() {
            return y(w());
          }
        ];
      },
      [u, d, f, p]
    );
    var v = i(c, g[0], g[1]);
    return a(
      function() {
        m.hasValue = !0, m.value = v;
      },
      [v]
    ), l(v), v;
  }, Sp;
}
var Pp = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nx;
function jI() {
  return nx || (nx = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(c, u) {
      return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = He, n = Y_(), r = typeof Object.is == "function" ? Object.is : e, i = n.useSyncExternalStore, o = t.useRef, a = t.useEffect, s = t.useMemo, l = t.useDebugValue;
    Pp.useSyncExternalStoreWithSelector = function(c, u, d, f, p) {
      var g = o(null);
      if (g.current === null) {
        var m = { hasValue: !1, value: null };
        g.current = m;
      } else m = g.current;
      g = s(
        function() {
          function y(E) {
            if (!S) {
              if (S = !0, x = E, E = f(E), p !== void 0 && m.hasValue) {
                var C = m.value;
                if (p(C, E))
                  return b = C;
              }
              return b = E;
            }
            if (C = b, r(x, E))
              return C;
            var A = f(E);
            return p !== void 0 && p(C, A) ? (x = E, C) : (x = E, b = A);
          }
          var S = !1, x, b, w = d === void 0 ? null : d;
          return [
            function() {
              return y(u());
            },
            w === null ? void 0 : function() {
              return y(w());
            }
          ];
        },
        [u, d, f, p]
      );
      var v = i(c, g[0], g[1]);
      return a(
        function() {
          m.hasValue = !0, m.value = v;
        },
        [v]
      ), l(v), v;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), Pp;
}
var rx;
function NI() {
  return rx || (rx = 1, process.env.NODE_ENV === "production" ? ac.exports = MI() : ac.exports = jI()), ac.exports;
}
var DI = NI(), Mg = /* @__PURE__ */ hr(null), RI = (e) => e, _t = () => {
  var e = Vr(Mg);
  return e ? e.store.dispatch : RI;
}, Zc = () => {
}, II = () => Zc, $I = (e, t) => e === t;
function pe(e) {
  var t = Vr(Mg);
  return DI.useSyncExternalStoreWithSelector(t ? t.subscription.addNestedSub : II, t ? t.store.getState : Zc, t ? t.store.getState : Zc, t ? e : Zc, $I);
}
var LI = (e, t, n) => {
  if (t.length === 1 && t[0] === n) {
    let r = !1;
    try {
      const i = {};
      e(i) === i && (r = !0);
    } catch {
    }
    if (r) {
      let i;
      try {
        throw new Error();
      } catch (o) {
        ({ stack: i } = o);
      }
      console.warn(
        `The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,
        { stack: i }
      );
    }
  }
}, FI = (e, t, n) => {
  const { memoize: r, memoizeOptions: i } = t, { inputSelectorResults: o, inputSelectorResultsCopy: a } = e, s = r(() => ({}), ...i);
  if (!(s.apply(null, o) === s.apply(null, a))) {
    let c;
    try {
      throw new Error();
    } catch (u) {
      ({ stack: c } = u);
    }
    console.warn(
      `An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,
      {
        arguments: n,
        firstInputs: o,
        secondInputs: a,
        stack: c
      }
    );
  }
}, BI = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
function zI(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function")
    throw new TypeError(t);
}
function WI(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object")
    throw new TypeError(t);
}
function VI(e, t = "expected all items to be functions, instead received the following types: ") {
  if (!e.every((n) => typeof n == "function")) {
    const n = e.map(
      (r) => typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
    ).join(", ");
    throw new TypeError(`${t}[${n}]`);
  }
}
var ix = (e) => Array.isArray(e) ? e : [e];
function UI(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return VI(
    t,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), t;
}
function ox(e, t) {
  const n = [], { length: r } = e;
  for (let i = 0; i < r; i++)
    n.push(e[i].apply(null, t));
  return n;
}
var HI = (e, t) => {
  const { identityFunctionCheck: n, inputStabilityCheck: r } = {
    ...BI,
    ...t
  };
  return {
    identityFunctionCheck: {
      shouldRun: n === "always" || n === "once" && e,
      run: LI
    },
    inputStabilityCheck: {
      shouldRun: r === "always" || r === "once" && e,
      run: FI
    }
  };
}, KI = class {
  constructor(e) {
    this.value = e;
  }
  deref() {
    return this.value;
  }
}, qI = typeof WeakRef < "u" ? WeakRef : KI, YI = 0, ax = 1;
function lc() {
  return {
    s: YI,
    v: void 0,
    o: null,
    p: null
  };
}
function G_(e, t = {}) {
  let n = lc();
  const { resultEqualityCheck: r } = t;
  let i, o = 0;
  function a() {
    let s = n;
    const { length: l } = arguments;
    for (let d = 0, f = l; d < f; d++) {
      const p = arguments[d];
      if (typeof p == "function" || typeof p == "object" && p !== null) {
        let g = s.o;
        g === null && (s.o = g = /* @__PURE__ */ new WeakMap());
        const m = g.get(p);
        m === void 0 ? (s = lc(), g.set(p, s)) : s = m;
      } else {
        let g = s.p;
        g === null && (s.p = g = /* @__PURE__ */ new Map());
        const m = g.get(p);
        m === void 0 ? (s = lc(), g.set(p, s)) : s = m;
      }
    }
    const c = s;
    let u;
    if (s.s === ax)
      u = s.v;
    else if (u = e.apply(null, arguments), o++, r) {
      const d = i?.deref?.() ?? i;
      d != null && r(d, u) && (u = d, o !== 0 && o--), i = typeof u == "object" && u !== null || typeof u == "function" ? new qI(u) : u;
    }
    return c.s = ax, c.v = u, u;
  }
  return a.clearCache = () => {
    n = lc(), a.resetResultsCount();
  }, a.resultsCount = () => o, a.resetResultsCount = () => {
    o = 0;
  }, a;
}
function GI(e, ...t) {
  const n = typeof e == "function" ? {
    memoize: e,
    memoizeOptions: t
  } : e, r = (...i) => {
    let o = 0, a = 0, s, l = {}, c = i.pop();
    typeof c == "object" && (l = c, c = i.pop()), zI(
      c,
      `createSelector expects an output function after the inputs, but received: [${typeof c}]`
    );
    const u = {
      ...n,
      ...l
    }, {
      memoize: d,
      memoizeOptions: f = [],
      argsMemoize: p = G_,
      argsMemoizeOptions: g = [],
      devModeChecks: m = {}
    } = u, v = ix(f), y = ix(g), S = UI(i), x = d(function() {
      return o++, c.apply(
        null,
        arguments
      );
    }, ...v);
    let b = !0;
    const w = p(function() {
      a++;
      const C = ox(
        S,
        arguments
      );
      if (s = x.apply(null, C), process.env.NODE_ENV !== "production") {
        const { identityFunctionCheck: A, inputStabilityCheck: k } = HI(b, m);
        if (A.shouldRun && A.run(
          c,
          C,
          s
        ), k.shouldRun) {
          const R = ox(
            S,
            arguments
          );
          k.run(
            { inputSelectorResults: C, inputSelectorResultsCopy: R },
            { memoize: d, memoizeOptions: v },
            arguments
          );
        }
        b && (b = !1);
      }
      return s;
    }, ...y);
    return Object.assign(w, {
      resultFunc: c,
      memoizedResultFunc: x,
      dependencies: S,
      dependencyRecomputations: () => a,
      resetDependencyRecomputations: () => {
        a = 0;
      },
      lastResult: () => s,
      recomputations: () => o,
      resetRecomputations: () => {
        o = 0;
      },
      memoize: d,
      argsMemoize: p
    });
  };
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var z = /* @__PURE__ */ GI(G_), XI = Object.assign(
  (e, t = z) => {
    WI(
      e,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
    );
    const n = Object.keys(e), r = n.map(
      (o) => e[o]
    );
    return t(
      r,
      (...o) => o.reduce((a, s, l) => (a[n[l]] = s, a), {})
    );
  },
  { withTypes: () => XI }
), Cp = {}, Ap = {}, Tp = {}, sx;
function ZI() {
  return sx || (sx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(r) {
      return typeof r == "symbol" ? 1 : r === null ? 2 : r === void 0 ? 3 : r !== r ? 4 : 0;
    }
    const n = (r, i, o) => {
      if (r !== i) {
        const a = t(r), s = t(i);
        if (a === s && a === 0) {
          if (r < i)
            return o === "desc" ? 1 : -1;
          if (r > i)
            return o === "desc" ? -1 : 1;
        }
        return o === "desc" ? s - a : a - s;
      }
      return 0;
    };
    e.compareValues = n;
  })(Tp)), Tp;
}
var kp = {}, Mp = {}, lx;
function X_() {
  return lx || (lx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return typeof n == "symbol" || n instanceof Symbol;
    }
    e.isSymbol = t;
  })(Mp)), Mp;
}
var cx;
function JI() {
  return cx || (cx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ X_(), n = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, r = /^\w*$/;
    function i(o, a) {
      return Array.isArray(o) ? !1 : typeof o == "number" || typeof o == "boolean" || o == null || t.isSymbol(o) ? !0 : typeof o == "string" && (r.test(o) || !n.test(o)) || a != null && Object.hasOwn(a, o);
    }
    e.isKey = i;
  })(kp)), kp;
}
var ux;
function QI() {
  return ux || (ux = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ ZI(), n = /* @__PURE__ */ JI(), r = /* @__PURE__ */ wg();
    function i(o, a, s, l) {
      if (o == null)
        return [];
      s = l ? void 0 : s, Array.isArray(o) || (o = Object.values(o)), Array.isArray(a) || (a = a == null ? [null] : [a]), a.length === 0 && (a = [null]), Array.isArray(s) || (s = s == null ? [] : [s]), s = s.map((p) => String(p));
      const c = (p, g) => {
        let m = p;
        for (let v = 0; v < g.length && m != null; ++v)
          m = m[g[v]];
        return m;
      }, u = (p, g) => g == null || p == null ? g : typeof p == "object" && "key" in p ? Object.hasOwn(g, p.key) ? g[p.key] : c(g, p.path) : typeof p == "function" ? p(g) : Array.isArray(p) ? c(g, p) : typeof g == "object" ? g[p] : g, d = a.map((p) => (Array.isArray(p) && p.length === 1 && (p = p[0]), p == null || typeof p == "function" || Array.isArray(p) || n.isKey(p) ? p : { key: p, path: r.toPath(p) }));
      return o.map((p) => ({
        original: p,
        criteria: d.map((g) => u(g, p))
      })).slice().sort((p, g) => {
        for (let m = 0; m < d.length; m++) {
          const v = t.compareValues(p.criteria[m], g.criteria[m], s[m]);
          if (v !== 0)
            return v;
        }
        return 0;
      }).map((p) => p.original);
    }
    e.orderBy = i;
  })(Ap)), Ap;
}
var jp = {}, dx;
function e$() {
  return dx || (dx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r = 1) {
      const i = [], o = Math.floor(r), a = (s, l) => {
        for (let c = 0; c < s.length; c++) {
          const u = s[c];
          Array.isArray(u) && l < o ? a(u, l + 1) : i.push(u);
        }
      };
      return a(n, 0), i;
    }
    e.flatten = t;
  })(jp)), jp;
}
var Np = {}, fx;
function Z_() {
  return fx || (fx = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ q_(), n = /* @__PURE__ */ Tg(), r = /* @__PURE__ */ z_(), i = /* @__PURE__ */ V_();
    function o(a, s, l) {
      return r.isObject(l) && (typeof s == "number" && n.isArrayLike(l) && t.isIndex(s) && s < l.length || typeof s == "string" && s in l) ? i.eq(l[s], a) : !1;
    }
    e.isIterateeCall = o;
  })(Np)), Np;
}
var px;
function t$() {
  return px || (px = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ QI(), n = /* @__PURE__ */ e$(), r = /* @__PURE__ */ Z_();
    function i(o, ...a) {
      const s = a.length;
      return s > 1 && r.isIterateeCall(o, a[0], a[1]) ? a = [] : s > 2 && r.isIterateeCall(a[0], a[1], a[2]) && (a = [a[0]]), t.orderBy(o, n.flatten(a), ["asc"]);
    }
    e.sortBy = i;
  })(Cp)), Cp;
}
var Dp, hx;
function n$() {
  return hx || (hx = 1, Dp = t$().sortBy), Dp;
}
var r$ = /* @__PURE__ */ n$();
const Dd = /* @__PURE__ */ xi(r$);
var J_ = (e) => e.legend.settings, i$ = (e) => e.legend.size, o$ = (e) => e.legend.payload;
z([o$, J_], (e, t) => {
  var {
    itemSorter: n
  } = t, r = e.flat(1);
  return n ? Dd(r, n) : r;
});
var cc = 1;
function a$() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], [t, n] = Rt({
    height: 0,
    left: 0,
    top: 0,
    width: 0
  }), r = pt(
    (i) => {
      if (i != null) {
        var o = i.getBoundingClientRect(), a = {
          height: o.height,
          left: o.left,
          top: o.top,
          width: o.width
        };
        (Math.abs(a.height - t.height) > cc || Math.abs(a.left - t.left) > cc || Math.abs(a.top - t.top) > cc || Math.abs(a.width - t.width) > cc) && n({
          height: a.height,
          left: a.left,
          top: a.top,
          width: a.width
        });
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t.width, t.height, t.top, t.left, ...e]
  );
  return [t, r];
}
function Jt(e) {
  return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
var s$ = typeof Symbol == "function" && Symbol.observable || "@@observable", mx = s$, Rp = () => Math.random().toString(36).substring(7).split("").join("."), l$ = {
  INIT: `@@redux/INIT${/* @__PURE__ */ Rp()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ Rp()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${Rp()}`
}, Co = l$;
function _l(e) {
  if (typeof e != "object" || e === null)
    return !1;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null;
}
function c$(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  const t = typeof e;
  switch (t) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return t;
  }
  if (Array.isArray(e))
    return "array";
  if (f$(e))
    return "date";
  if (d$(e))
    return "error";
  const n = u$(e);
  switch (n) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return n;
  }
  return Object.prototype.toString.call(e).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function u$(e) {
  return typeof e.constructor == "function" ? e.constructor.name : null;
}
function d$(e) {
  return e instanceof Error || typeof e.message == "string" && e.constructor && typeof e.constructor.stackTraceLimit == "number";
}
function f$(e) {
  return e instanceof Date ? !0 : typeof e.toDateString == "function" && typeof e.getDate == "function" && typeof e.setDate == "function";
}
function Ai(e) {
  let t = typeof e;
  return process.env.NODE_ENV !== "production" && (t = c$(e)), t;
}
function Q_(e, t, n) {
  if (typeof e != "function")
    throw new Error(process.env.NODE_ENV === "production" ? Jt(2) : `Expected the root reducer to be a function. Instead, received: '${Ai(e)}'`);
  if (typeof t == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? Jt(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof t == "function" && typeof n > "u" && (n = t, t = void 0), typeof n < "u") {
    if (typeof n != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Jt(1) : `Expected the enhancer to be a function. Instead, received: '${Ai(n)}'`);
    return n(Q_)(e, t);
  }
  let r = e, i = t, o = /* @__PURE__ */ new Map(), a = o, s = 0, l = !1;
  function c() {
    a === o && (a = /* @__PURE__ */ new Map(), o.forEach((v, y) => {
      a.set(y, v);
    }));
  }
  function u() {
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Jt(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return i;
  }
  function d(v) {
    if (typeof v != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Jt(4) : `Expected the listener to be a function. Instead, received: '${Ai(v)}'`);
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Jt(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    let y = !0;
    c();
    const S = s++;
    return a.set(S, v), function() {
      if (y) {
        if (l)
          throw new Error(process.env.NODE_ENV === "production" ? Jt(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        y = !1, c(), a.delete(S), o = null;
      }
    };
  }
  function f(v) {
    if (!_l(v))
      throw new Error(process.env.NODE_ENV === "production" ? Jt(7) : `Actions must be plain objects. Instead, the actual type was: '${Ai(v)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    if (typeof v.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Jt(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (typeof v.type != "string")
      throw new Error(process.env.NODE_ENV === "production" ? Jt(17) : `Action "type" property must be a string. Instead, the actual type was: '${Ai(v.type)}'. Value was: '${v.type}' (stringified)`);
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Jt(9) : "Reducers may not dispatch actions.");
    try {
      l = !0, i = r(i, v);
    } finally {
      l = !1;
    }
    return (o = a).forEach((S) => {
      S();
    }), v;
  }
  function p(v) {
    if (typeof v != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Jt(10) : `Expected the nextReducer to be a function. Instead, received: '${Ai(v)}`);
    r = v, f({
      type: Co.REPLACE
    });
  }
  function g() {
    const v = d;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(y) {
        if (typeof y != "object" || y === null)
          throw new Error(process.env.NODE_ENV === "production" ? Jt(11) : `Expected the observer to be an object. Instead, received: '${Ai(y)}'`);
        function S() {
          const b = y;
          b.next && b.next(u());
        }
        return S(), {
          unsubscribe: v(S)
        };
      },
      [mx]() {
        return this;
      }
    };
  }
  return f({
    type: Co.INIT
  }), {
    dispatch: f,
    subscribe: d,
    getState: u,
    replaceReducer: p,
    [mx]: g
  };
}
function gx(e) {
  typeof console < "u" && typeof console.error == "function" && console.error(e);
  try {
    throw new Error(e);
  } catch {
  }
}
function p$(e, t, n, r) {
  const i = Object.keys(t), o = n && n.type === Co.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (i.length === 0)
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  if (!_l(e))
    return `The ${o} has unexpected type of "${Ai(e)}". Expected argument to be an object with the following keys: "${i.join('", "')}"`;
  const a = Object.keys(e).filter((s) => !t.hasOwnProperty(s) && !r[s]);
  if (a.forEach((s) => {
    r[s] = !0;
  }), !(n && n.type === Co.REPLACE) && a.length > 0)
    return `Unexpected ${a.length > 1 ? "keys" : "key"} "${a.join('", "')}" found in ${o}. Expected to find one of the known reducer keys instead: "${i.join('", "')}". Unexpected keys will be ignored.`;
}
function h$(e) {
  Object.keys(e).forEach((t) => {
    const n = e[t];
    if (typeof n(void 0, {
      type: Co.INIT
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Jt(12) : `The slice reducer for key "${t}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    if (typeof n(void 0, {
      type: Co.PROBE_UNKNOWN_ACTION()
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Jt(13) : `The slice reducer for key "${t}" returned undefined when probed with a random type. Don't try to handle '${Co.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
  });
}
function e2(e) {
  const t = Object.keys(e), n = {};
  for (let a = 0; a < t.length; a++) {
    const s = t[a];
    process.env.NODE_ENV !== "production" && typeof e[s] > "u" && gx(`No reducer provided for key "${s}"`), typeof e[s] == "function" && (n[s] = e[s]);
  }
  const r = Object.keys(n);
  let i;
  process.env.NODE_ENV !== "production" && (i = {});
  let o;
  try {
    h$(n);
  } catch (a) {
    o = a;
  }
  return function(s = {}, l) {
    if (o)
      throw o;
    if (process.env.NODE_ENV !== "production") {
      const d = p$(s, n, l, i);
      d && gx(d);
    }
    let c = !1;
    const u = {};
    for (let d = 0; d < r.length; d++) {
      const f = r[d], p = n[f], g = s[f], m = p(g, l);
      if (typeof m > "u") {
        const v = l && l.type;
        throw new Error(process.env.NODE_ENV === "production" ? Jt(14) : `When called with an action of type ${v ? `"${String(v)}"` : "(unknown type)"}, the slice reducer for key "${f}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      u[f] = m, c = c || m !== g;
    }
    return c = c || r.length !== Object.keys(s).length, c ? u : s;
  };
}
function mu(...e) {
  return e.length === 0 ? (t) => t : e.length === 1 ? e[0] : e.reduce((t, n) => (...r) => t(n(...r)));
}
function m$(...e) {
  return (t) => (n, r) => {
    const i = t(n, r);
    let o = () => {
      throw new Error(process.env.NODE_ENV === "production" ? Jt(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const a = {
      getState: i.getState,
      dispatch: (l, ...c) => o(l, ...c)
    }, s = e.map((l) => l(a));
    return o = mu(...s)(i.dispatch), {
      ...i,
      dispatch: o
    };
  };
}
function jg(e) {
  return _l(e) && "type" in e && typeof e.type == "string";
}
var t2 = Symbol.for("immer-nothing"), vx = Symbol.for("immer-draftable"), Kn = Symbol.for("immer-state"), g$ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function _n(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = g$[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Sa = Object.getPrototypeOf;
function Ro(e) {
  return !!e && !!e[Kn];
}
function hi(e) {
  return e ? n2(e) || Array.isArray(e) || !!e[vx] || !!e.constructor?.[vx] || Pl(e) || Id(e) : !1;
}
var v$ = Object.prototype.constructor.toString();
function n2(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Sa(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === v$;
}
function gu(e, t) {
  Rd(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Rd(e) {
  const t = e[Kn];
  return t ? t.type_ : Array.isArray(e) ? 1 : Pl(e) ? 2 : Id(e) ? 3 : 0;
}
function Zh(e, t) {
  return Rd(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function r2(e, t, n) {
  const r = Rd(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function y$(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Pl(e) {
  return e instanceof Map;
}
function Id(e) {
  return e instanceof Set;
}
function po(e) {
  return e.copy_ || e.base_;
}
function Jh(e, t) {
  if (Pl(e))
    return new Map(e);
  if (Id(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = n2(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Kn];
    let i = Reflect.ownKeys(r);
    for (let o = 0; o < i.length; o++) {
      const a = i[o], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Sa(e), r);
  } else {
    const r = Sa(e);
    if (r !== null && n)
      return { ...e };
    const i = Object.create(r);
    return Object.assign(i, e);
  }
}
function Ng(e, t = !1) {
  return $d(e) || Ro(e) || !hi(e) || (Rd(e) > 1 && Object.defineProperties(e, {
    set: { value: uc },
    add: { value: uc },
    clear: { value: uc },
    delete: { value: uc }
  }), Object.freeze(e), t && Object.values(e).forEach((n) => Ng(n, !0))), e;
}
function uc() {
  _n(2);
}
function $d(e) {
  return Object.isFrozen(e);
}
var b$ = {};
function Io(e) {
  const t = b$[e];
  return t || _n(0, e), t;
}
var qs;
function i2() {
  return qs;
}
function x$(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function yx(e, t) {
  t && (Io("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Qh(e) {
  em(e), e.drafts_.forEach(w$), e.drafts_ = null;
}
function em(e) {
  e === qs && (qs = e.parent_);
}
function bx(e) {
  return qs = x$(qs, e);
}
function w$(e) {
  const t = e[Kn];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function xx(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Kn].modified_ && (Qh(t), _n(4)), hi(e) && (e = vu(t, e), t.parent_ || yu(t, e)), t.patches_ && Io("Patches").generateReplacementPatches_(
    n[Kn].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = vu(t, n, []), Qh(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== t2 ? e : void 0;
}
function vu(e, t, n) {
  if ($d(t))
    return t;
  const r = t[Kn];
  if (!r)
    return gu(
      t,
      (i, o) => wx(e, r, t, i, o, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return yu(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let o = i, a = !1;
    r.type_ === 3 && (o = new Set(i), i.clear(), a = !0), gu(
      o,
      (s, l) => wx(e, r, i, s, l, n, a)
    ), yu(e, i, !1), n && e.patches_ && Io("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function wx(e, t, n, r, i, o, a) {
  if (process.env.NODE_ENV !== "production" && i === n && _n(5), Ro(i)) {
    const s = o && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Zh(t.assigned_, r) ? o.concat(r) : void 0, l = vu(e, i, s);
    if (r2(n, r, l), Ro(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(i);
  if (hi(i) && !$d(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    vu(e, i), (!t || !t.scope_.parent_) && typeof r != "symbol" && (Pl(n) ? n.has(r) : Object.prototype.propertyIsEnumerable.call(n, r)) && yu(e, i);
  }
}
function yu(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Ng(t, n);
}
function O$(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : i2(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = r, o = Dg;
  n && (i = [r], o = Ys);
  const { revoke: a, proxy: s } = Proxy.revocable(i, o);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Dg = {
  get(e, t) {
    if (t === Kn)
      return e;
    const n = po(e);
    if (!Zh(n, t))
      return S$(e, n, t);
    const r = n[t];
    return e.finalized_ || !hi(r) ? r : r === Ip(e.base_, t) ? ($p(e), e.copy_[t] = nm(r, e)) : r;
  },
  has(e, t) {
    return t in po(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(po(e));
  },
  set(e, t, n) {
    const r = o2(po(e), t);
    if (r?.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const i = Ip(po(e), t), o = i?.[Kn];
      if (o && o.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (y$(n, i) && (n !== void 0 || Zh(e.base_, t)))
        return !0;
      $p(e), tm(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Ip(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, $p(e), tm(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = po(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    _n(11);
  },
  getPrototypeOf(e) {
    return Sa(e.base_);
  },
  setPrototypeOf() {
    _n(12);
  }
}, Ys = {};
gu(Dg, (e, t) => {
  Ys[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ys.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && _n(13), Ys.set.call(this, e, t, void 0);
};
Ys.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && _n(14), Dg.set.call(this, e[0], t, n, e[0]);
};
function Ip(e, t) {
  const n = e[Kn];
  return (n ? po(n) : e)[t];
}
function S$(e, t, n) {
  const r = o2(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    r.get?.call(e.draft_)
  ) : void 0;
}
function o2(e, t) {
  if (!(t in e))
    return;
  let n = Sa(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Sa(n);
  }
}
function tm(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && tm(e.parent_));
}
function $p(e) {
  e.copy_ || (e.copy_ = Jh(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var E$ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const o = n;
        n = t;
        const a = this;
        return function(l = o, ...c) {
          return a.produce(l, (u) => n.call(this, u, ...c));
        };
      }
      typeof n != "function" && _n(6), r !== void 0 && typeof r != "function" && _n(7);
      let i;
      if (hi(t)) {
        const o = bx(this), a = nm(t, void 0);
        let s = !0;
        try {
          i = n(a), s = !1;
        } finally {
          s ? Qh(o) : em(o);
        }
        return yx(o, r), xx(i, o);
      } else if (!t || typeof t != "object") {
        if (i = n(t), i === void 0 && (i = t), i === t2 && (i = void 0), this.autoFreeze_ && Ng(i, !0), r) {
          const o = [], a = [];
          Io("Patches").generateReplacementPatches_(t, i, o, a), r(o, a);
        }
        return i;
      } else
        _n(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, i;
      return [this.produce(t, n, (a, s) => {
        r = a, i = s;
      }), r, i];
    }, typeof e?.autoFreeze == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof e?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    hi(e) || _n(8), Ro(e) && (e = ui(e));
    const t = bx(this), n = nm(e, void 0);
    return n[Kn].isManual_ = !0, em(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Kn];
    (!n || !n.isManual_) && _n(9);
    const { scope_: r } = n;
    return yx(r, t), xx(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const i = t[n];
      if (i.path.length === 0 && i.op === "replace") {
        e = i.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Io("Patches").applyPatches_;
    return Ro(e) ? r(e, t) : this.produce(
      e,
      (i) => r(i, t)
    );
  }
};
function nm(e, t) {
  const n = Pl(e) ? Io("MapSet").proxyMap_(e, t) : Id(e) ? Io("MapSet").proxySet_(e, t) : O$(e, t);
  return (t ? t.scope_ : i2()).drafts_.push(n), n;
}
function ui(e) {
  return Ro(e) || _n(10, e), a2(e);
}
function a2(e) {
  if (!hi(e) || $d(e))
    return e;
  const t = e[Kn];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Jh(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Jh(e, !0);
  return gu(n, (r, i) => {
    r2(n, r, a2(i));
  }), t && (t.finalized_ = !1), n;
}
var _$ = new E$(), s2 = _$.produce;
function l2(e) {
  return ({ dispatch: n, getState: r }) => (i) => (o) => typeof o == "function" ? o(n, r, e) : i(o);
}
var P$ = l2(), C$ = l2, A$ = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length !== 0)
    return typeof arguments[0] == "object" ? mu : mu.apply(null, arguments);
}, T$ = (e) => e && typeof e.match == "function";
function cr(e, t) {
  function n(...r) {
    if (t) {
      let i = t(...r);
      if (!i)
        throw new Error(process.env.NODE_ENV === "production" ? je(0) : "prepareAction did not return an object");
      return {
        type: e,
        payload: i.payload,
        ..."meta" in i && {
          meta: i.meta
        },
        ..."error" in i && {
          error: i.error
        }
      };
    }
    return {
      type: e,
      payload: r[0]
    };
  }
  return n.toString = () => `${e}`, n.type = e, n.match = (r) => jg(r) && r.type === e, n;
}
function k$(e) {
  return typeof e == "function" && "type" in e && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  T$(e);
}
function M$(e) {
  const t = e ? `${e}`.split("/") : [], n = t[t.length - 1] || "actionCreator";
  return `Detected an action creator with type "${e || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${n}())\` instead of \`dispatch(${n})\`. This is necessary even if the action has no payload.`;
}
function j$(e = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (n) => (r) => n(r);
  const {
    isActionCreator: t = k$
  } = e;
  return () => (n) => (r) => (t(r) && console.warn(M$(r.type)), n(r));
}
function c2(e, t) {
  let n = 0;
  return {
    measureTime(r) {
      const i = Date.now();
      try {
        return r();
      } finally {
        const o = Date.now();
        n += o - i;
      }
    },
    warnIfExceeded() {
      n > e && console.warn(`${t} took ${n}ms, which is more than the warning threshold of ${e}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
    }
  };
}
var u2 = class Es extends Array {
  constructor(...t) {
    super(...t), Object.setPrototypeOf(this, Es.prototype);
  }
  static get [Symbol.species]() {
    return Es;
  }
  concat(...t) {
    return super.concat.apply(this, t);
  }
  prepend(...t) {
    return t.length === 1 && Array.isArray(t[0]) ? new Es(...t[0].concat(this)) : new Es(...t.concat(this));
  }
};
function Ox(e) {
  return hi(e) ? s2(e, () => {
  }) : e;
}
function dc(e, t, n) {
  return e.has(t) ? e.get(t) : e.set(t, n(t)).get(t);
}
function N$(e) {
  return typeof e != "object" || e == null || Object.isFrozen(e);
}
function D$(e, t, n) {
  const r = d2(e, t, n);
  return {
    detectMutations() {
      return f2(e, t, r, n);
    }
  };
}
function d2(e, t = [], n, r = "", i = /* @__PURE__ */ new Set()) {
  const o = {
    value: n
  };
  if (!e(n) && !i.has(n)) {
    i.add(n), o.children = {};
    for (const a in n) {
      const s = r ? r + "." + a : a;
      t.length && t.indexOf(s) !== -1 || (o.children[a] = d2(e, t, n[a], s));
    }
  }
  return o;
}
function f2(e, t = [], n, r, i = !1, o = "") {
  const a = n ? n.value : void 0, s = a === r;
  if (i && !s && !Number.isNaN(r))
    return {
      wasMutated: !0,
      path: o
    };
  if (e(a) || e(r))
    return {
      wasMutated: !1
    };
  const l = {};
  for (let u in n.children)
    l[u] = !0;
  for (let u in r)
    l[u] = !0;
  const c = t.length > 0;
  for (let u in l) {
    const d = o ? o + "." + u : u;
    if (c && t.some((g) => g instanceof RegExp ? g.test(d) : d === g))
      continue;
    const f = f2(e, t, n.children[u], r[u], s, d);
    if (f.wasMutated)
      return f;
  }
  return {
    wasMutated: !1
  };
}
function R$(e = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (t) => (n) => t(n);
  {
    let t = function(s, l, c, u) {
      return JSON.stringify(s, n(l, u), c);
    }, n = function(s, l) {
      let c = [], u = [];
      return l || (l = function(d, f) {
        return c[0] === f ? "[Circular ~]" : "[Circular ~." + u.slice(0, c.indexOf(f)).join(".") + "]";
      }), function(d, f) {
        if (c.length > 0) {
          var p = c.indexOf(this);
          ~p ? c.splice(p + 1) : c.push(this), ~p ? u.splice(p, 1 / 0, d) : u.push(d), ~c.indexOf(f) && (f = l.call(this, d, f));
        } else c.push(f);
        return s == null ? f : s.call(this, d, f);
      };
    }, {
      isImmutable: r = N$,
      ignoredPaths: i,
      warnAfter: o = 32
    } = e;
    const a = D$.bind(null, r, i);
    return ({
      getState: s
    }) => {
      let l = s(), c = a(l), u;
      return (d) => (f) => {
        const p = c2(o, "ImmutableStateInvariantMiddleware");
        p.measureTime(() => {
          if (l = s(), u = c.detectMutations(), c = a(l), u.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? je(19) : `A state mutation was detected between dispatches, in the path '${u.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        });
        const g = d(f);
        return p.measureTime(() => {
          if (l = s(), u = c.detectMutations(), c = a(l), u.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? je(20) : `A state mutation was detected inside a dispatch, in the path: ${u.path || ""}. Take a look at the reducer(s) handling the action ${t(f)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        }), p.warnIfExceeded(), g;
      };
    };
  }
}
function p2(e) {
  const t = typeof e;
  return e == null || t === "string" || t === "boolean" || t === "number" || Array.isArray(e) || _l(e);
}
function rm(e, t = "", n = p2, r, i = [], o) {
  let a;
  if (!n(e))
    return {
      keyPath: t || "<root>",
      value: e
    };
  if (typeof e != "object" || e === null || o?.has(e)) return !1;
  const s = r != null ? r(e) : Object.entries(e), l = i.length > 0;
  for (const [c, u] of s) {
    const d = t ? t + "." + c : c;
    if (!(l && i.some((p) => p instanceof RegExp ? p.test(d) : d === p))) {
      if (!n(u))
        return {
          keyPath: d,
          value: u
        };
      if (typeof u == "object" && (a = rm(u, d, n, r, i, o), a))
        return a;
    }
  }
  return o && h2(e) && o.add(e), !1;
}
function h2(e) {
  if (!Object.isFrozen(e)) return !1;
  for (const t of Object.values(e))
    if (!(typeof t != "object" || t === null) && !h2(t))
      return !1;
  return !0;
}
function I$(e = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (t) => (n) => t(n);
  {
    const {
      isSerializable: t = p2,
      getEntries: n,
      ignoredActions: r = [],
      ignoredActionPaths: i = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths: o = [],
      warnAfter: a = 32,
      ignoreState: s = !1,
      ignoreActions: l = !1,
      disableCache: c = !1
    } = e, u = !c && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (d) => (f) => (p) => {
      if (!jg(p))
        return f(p);
      const g = f(p), m = c2(a, "SerializableStateInvariantMiddleware");
      return !l && !(r.length && r.indexOf(p.type) !== -1) && m.measureTime(() => {
        const v = rm(p, "", t, n, i, u);
        if (v) {
          const {
            keyPath: y,
            value: S
          } = v;
          console.error(`A non-serializable value was detected in an action, in the path: \`${y}\`. Value:`, S, `
Take a look at the logic that dispatched this action: `, p, `
(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)`, `
(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)`);
        }
      }), s || (m.measureTime(() => {
        const v = d.getState(), y = rm(v, "", t, n, o, u);
        if (y) {
          const {
            keyPath: S,
            value: x
          } = y;
          console.error(`A non-serializable value was detected in the state, in the path: \`${S}\`. Value:`, x, `
Take a look at the reducer(s) handling this action type: ${p.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
        }
      }), m.warnIfExceeded()), g;
    };
  }
}
function fc(e) {
  return typeof e == "boolean";
}
var $$ = () => function(t) {
  const {
    thunk: n = !0,
    immutableCheck: r = !0,
    serializableCheck: i = !0,
    actionCreatorCheck: o = !0
  } = t ?? {};
  let a = new u2();
  if (n && (fc(n) ? a.push(P$) : a.push(C$(n.extraArgument))), process.env.NODE_ENV !== "production") {
    if (r) {
      let s = {};
      fc(r) || (s = r), a.unshift(R$(s));
    }
    if (i) {
      let s = {};
      fc(i) || (s = i), a.push(I$(s));
    }
    if (o) {
      let s = {};
      fc(o) || (s = o), a.unshift(j$(s));
    }
  }
  return a;
}, L$ = "RTK_autoBatch", Sx = (e) => (t) => {
  setTimeout(t, e);
}, F$ = (e = {
  type: "raf"
}) => (t) => (...n) => {
  const r = t(...n);
  let i = !0, o = !1, a = !1;
  const s = /* @__PURE__ */ new Set(), l = e.type === "tick" ? queueMicrotask : e.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame : Sx(10)
  ) : e.type === "callback" ? e.queueNotification : Sx(e.timeout), c = () => {
    a = !1, o && (o = !1, s.forEach((u) => u()));
  };
  return Object.assign({}, r, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(u) {
      const d = () => i && u(), f = r.subscribe(d);
      return s.add(u), () => {
        f(), s.delete(u);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(u) {
      try {
        return i = !u?.meta?.[L$], o = !i, o && (a || (a = !0, l(c))), r.dispatch(u);
      } finally {
        i = !0;
      }
    }
  });
}, B$ = (e) => function(n) {
  const {
    autoBatch: r = !0
  } = n ?? {};
  let i = new u2(e);
  return r && i.push(F$(typeof r == "object" ? r : void 0)), i;
};
function z$(e) {
  const t = $$(), {
    reducer: n = void 0,
    middleware: r,
    devTools: i = !0,
    duplicateMiddlewareCheck: o = !0,
    preloadedState: a = void 0,
    enhancers: s = void 0
  } = e || {};
  let l;
  if (typeof n == "function")
    l = n;
  else if (_l(n))
    l = e2(n);
  else
    throw new Error(process.env.NODE_ENV === "production" ? je(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  if (process.env.NODE_ENV !== "production" && r && typeof r != "function")
    throw new Error(process.env.NODE_ENV === "production" ? je(2) : "`middleware` field must be a callback");
  let c;
  if (typeof r == "function") {
    if (c = r(t), process.env.NODE_ENV !== "production" && !Array.isArray(c))
      throw new Error(process.env.NODE_ENV === "production" ? je(3) : "when using a middleware builder function, an array of middleware must be returned");
  } else
    c = t();
  if (process.env.NODE_ENV !== "production" && c.some((m) => typeof m != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? je(4) : "each middleware provided to configureStore must be a function");
  if (process.env.NODE_ENV !== "production" && o) {
    let m = /* @__PURE__ */ new Set();
    c.forEach((v) => {
      if (m.has(v))
        throw new Error(process.env.NODE_ENV === "production" ? je(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
      m.add(v);
    });
  }
  let u = mu;
  i && (u = A$({
    // Enable capture of stack traces for dispatched Redux actions
    trace: process.env.NODE_ENV !== "production",
    ...typeof i == "object" && i
  }));
  const d = m$(...c), f = B$(d);
  if (process.env.NODE_ENV !== "production" && s && typeof s != "function")
    throw new Error(process.env.NODE_ENV === "production" ? je(5) : "`enhancers` field must be a callback");
  let p = typeof s == "function" ? s(f) : f();
  if (process.env.NODE_ENV !== "production" && !Array.isArray(p))
    throw new Error(process.env.NODE_ENV === "production" ? je(6) : "`enhancers` callback must return an array");
  if (process.env.NODE_ENV !== "production" && p.some((m) => typeof m != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? je(7) : "each enhancer provided to configureStore must be a function");
  process.env.NODE_ENV !== "production" && c.length && !p.includes(d) && console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  const g = u(...p);
  return Q_(l, a, g);
}
function m2(e) {
  const t = {}, n = [];
  let r;
  const i = {
    addCase(o, a) {
      if (process.env.NODE_ENV !== "production") {
        if (n.length > 0)
          throw new Error(process.env.NODE_ENV === "production" ? je(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        if (r)
          throw new Error(process.env.NODE_ENV === "production" ? je(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
      }
      const s = typeof o == "string" ? o : o.type;
      if (!s)
        throw new Error(process.env.NODE_ENV === "production" ? je(28) : "`builder.addCase` cannot be called with an empty action type");
      if (s in t)
        throw new Error(process.env.NODE_ENV === "production" ? je(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${s}'`);
      return t[s] = a, i;
    },
    addAsyncThunk(o, a) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? je(43) : "`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`");
      return a.pending && (t[o.pending.type] = a.pending), a.rejected && (t[o.rejected.type] = a.rejected), a.fulfilled && (t[o.fulfilled.type] = a.fulfilled), a.settled && n.push({
        matcher: o.settled,
        reducer: a.settled
      }), i;
    },
    addMatcher(o, a) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? je(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
      return n.push({
        matcher: o,
        reducer: a
      }), i;
    },
    addDefaultCase(o) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? je(31) : "`builder.addDefaultCase` can only be called once");
      return r = o, i;
    }
  };
  return e(i), [t, n, r];
}
function W$(e) {
  return typeof e == "function";
}
function V$(e, t) {
  if (process.env.NODE_ENV !== "production" && typeof t == "object")
    throw new Error(process.env.NODE_ENV === "production" ? je(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
  let [n, r, i] = m2(t), o;
  if (W$(e))
    o = () => Ox(e());
  else {
    const s = Ox(e);
    o = () => s;
  }
  function a(s = o(), l) {
    let c = [n[l.type], ...r.filter(({
      matcher: u
    }) => u(l)).map(({
      reducer: u
    }) => u)];
    return c.filter((u) => !!u).length === 0 && (c = [i]), c.reduce((u, d) => {
      if (d)
        if (Ro(u)) {
          const p = d(u, l);
          return p === void 0 ? u : p;
        } else {
          if (hi(u))
            return s2(u, (f) => d(f, l));
          {
            const f = d(u, l);
            if (f === void 0) {
              if (u === null)
                return u;
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return f;
          }
        }
      return u;
    }, s);
  }
  return a.getInitialState = o, a;
}
var U$ = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", H$ = (e = 21) => {
  let t = "", n = e;
  for (; n--; )
    t += U$[Math.random() * 64 | 0];
  return t;
}, K$ = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function q$(e, t) {
  return `${e}/${t}`;
}
function Y$({
  creators: e
} = {}) {
  const t = e?.asyncThunk?.[K$];
  return function(r) {
    const {
      name: i,
      reducerPath: o = i
    } = r;
    if (!i)
      throw new Error(process.env.NODE_ENV === "production" ? je(11) : "`name` is a required option for createSlice");
    typeof process < "u" && process.env.NODE_ENV === "development" && r.initialState === void 0 && console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    const a = (typeof r.reducers == "function" ? r.reducers(X$()) : r.reducers) || {}, s = Object.keys(a), l = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    }, c = {
      addCase(x, b) {
        const w = typeof x == "string" ? x : x.type;
        if (!w)
          throw new Error(process.env.NODE_ENV === "production" ? je(12) : "`context.addCase` cannot be called with an empty action type");
        if (w in l.sliceCaseReducersByType)
          throw new Error(process.env.NODE_ENV === "production" ? je(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + w);
        return l.sliceCaseReducersByType[w] = b, c;
      },
      addMatcher(x, b) {
        return l.sliceMatchers.push({
          matcher: x,
          reducer: b
        }), c;
      },
      exposeAction(x, b) {
        return l.actionCreators[x] = b, c;
      },
      exposeCaseReducer(x, b) {
        return l.sliceCaseReducersByName[x] = b, c;
      }
    };
    s.forEach((x) => {
      const b = a[x], w = {
        reducerName: x,
        type: q$(i, x),
        createNotation: typeof r.reducers == "function"
      };
      J$(b) ? e5(w, b, c, t) : Z$(w, b, c);
    });
    function u() {
      if (process.env.NODE_ENV !== "production" && typeof r.extraReducers == "object")
        throw new Error(process.env.NODE_ENV === "production" ? je(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
      const [x = {}, b = [], w = void 0] = typeof r.extraReducers == "function" ? m2(r.extraReducers) : [r.extraReducers], E = {
        ...x,
        ...l.sliceCaseReducersByType
      };
      return V$(r.initialState, (C) => {
        for (let A in E)
          C.addCase(A, E[A]);
        for (let A of l.sliceMatchers)
          C.addMatcher(A.matcher, A.reducer);
        for (let A of b)
          C.addMatcher(A.matcher, A.reducer);
        w && C.addDefaultCase(w);
      });
    }
    const d = (x) => x, f = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new WeakMap();
    let g;
    function m(x, b) {
      return g || (g = u()), g(x, b);
    }
    function v() {
      return g || (g = u()), g.getInitialState();
    }
    function y(x, b = !1) {
      function w(C) {
        let A = C[x];
        if (typeof A > "u") {
          if (b)
            A = dc(p, w, v);
          else if (process.env.NODE_ENV !== "production")
            throw new Error(process.env.NODE_ENV === "production" ? je(15) : "selectSlice returned undefined for an uninjected slice reducer");
        }
        return A;
      }
      function E(C = d) {
        const A = dc(f, b, () => /* @__PURE__ */ new WeakMap());
        return dc(A, C, () => {
          const k = {};
          for (const [R, M] of Object.entries(r.selectors ?? {}))
            k[R] = G$(M, C, () => dc(p, C, v), b);
          return k;
        });
      }
      return {
        reducerPath: x,
        getSelectors: E,
        get selectors() {
          return E(w);
        },
        selectSlice: w
      };
    }
    const S = {
      name: i,
      reducer: m,
      actions: l.actionCreators,
      caseReducers: l.sliceCaseReducersByName,
      getInitialState: v,
      ...y(o),
      injectInto(x, {
        reducerPath: b,
        ...w
      } = {}) {
        const E = b ?? o;
        return x.inject({
          reducerPath: E,
          reducer: m
        }, w), {
          ...S,
          ...y(E, !0)
        };
      }
    };
    return S;
  };
}
function G$(e, t, n, r) {
  function i(o, ...a) {
    let s = t(o);
    if (typeof s > "u") {
      if (r)
        s = n();
      else if (process.env.NODE_ENV !== "production")
        throw new Error(process.env.NODE_ENV === "production" ? je(16) : "selectState returned undefined for an uninjected slice reducer");
    }
    return e(s, ...a);
  }
  return i.unwrapped = e, i;
}
var Gn = /* @__PURE__ */ Y$();
function X$() {
  function e(t, n) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator: t,
      ...n
    };
  }
  return e.withTypes = () => e, {
    reducer(t) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [t.name](...n) {
          return t(...n);
        }
      }[t.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(t, n) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare: t,
        reducer: n
      };
    },
    asyncThunk: e
  };
}
function Z$({
  type: e,
  reducerName: t,
  createNotation: n
}, r, i) {
  let o, a;
  if ("reducer" in r) {
    if (n && !Q$(r))
      throw new Error(process.env.NODE_ENV === "production" ? je(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    o = r.reducer, a = r.prepare;
  } else
    o = r;
  i.addCase(e, o).exposeCaseReducer(t, o).exposeAction(t, a ? cr(e, a) : cr(e));
}
function J$(e) {
  return e._reducerDefinitionType === "asyncThunk";
}
function Q$(e) {
  return e._reducerDefinitionType === "reducerWithPrepare";
}
function e5({
  type: e,
  reducerName: t
}, n, r, i) {
  if (!i)
    throw new Error(process.env.NODE_ENV === "production" ? je(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  const {
    payloadCreator: o,
    fulfilled: a,
    pending: s,
    rejected: l,
    settled: c,
    options: u
  } = n, d = i(e, o, u);
  r.exposeAction(t, d), a && r.addCase(d.fulfilled, a), s && r.addCase(d.pending, s), l && r.addCase(d.rejected, l), c && r.addMatcher(d.settled, c), r.exposeCaseReducer(t, {
    fulfilled: a || pc,
    pending: s || pc,
    rejected: l || pc,
    settled: c || pc
  });
}
function pc() {
}
var t5 = "task", g2 = "listener", v2 = "completed", Rg = "cancelled", n5 = `task-${Rg}`, r5 = `task-${v2}`, im = `${g2}-${Rg}`, i5 = `${g2}-${v2}`, Ld = class {
  constructor(e) {
    this.code = e, this.message = `${t5} ${Rg} (reason: ${e})`;
  }
  name = "TaskAbortError";
  message;
}, Ig = (e, t) => {
  if (typeof e != "function")
    throw new TypeError(process.env.NODE_ENV === "production" ? je(32) : `${t} is not a function`);
}, bu = () => {
}, y2 = (e, t = bu) => (e.catch(t), e), b2 = (e, t) => (e.addEventListener("abort", t, {
  once: !0
}), () => e.removeEventListener("abort", t)), Ao = (e, t) => {
  const n = e.signal;
  n.aborted || ("reason" in n || Object.defineProperty(n, "reason", {
    enumerable: !0,
    value: t,
    configurable: !0,
    writable: !0
  }), e.abort(t));
}, To = (e) => {
  if (e.aborted) {
    const {
      reason: t
    } = e;
    throw new Ld(t);
  }
};
function x2(e, t) {
  let n = bu;
  return new Promise((r, i) => {
    const o = () => i(new Ld(e.reason));
    if (e.aborted) {
      o();
      return;
    }
    n = b2(e, o), t.finally(() => n()).then(r, i);
  }).finally(() => {
    n = bu;
  });
}
var o5 = async (e, t) => {
  try {
    return await Promise.resolve(), {
      status: "ok",
      value: await e()
    };
  } catch (n) {
    return {
      status: n instanceof Ld ? "cancelled" : "rejected",
      error: n
    };
  } finally {
    t?.();
  }
}, xu = (e) => (t) => y2(x2(e, t).then((n) => (To(e), n))), w2 = (e) => {
  const t = xu(e);
  return (n) => t(new Promise((r) => setTimeout(r, n)));
}, {
  assign: ma
} = Object, Ex = {}, Cl = "listenerMiddleware", a5 = (e, t) => {
  const n = (r) => b2(e, () => Ao(r, e.reason));
  return (r, i) => {
    Ig(r, "taskExecutor");
    const o = new AbortController();
    n(o);
    const a = o5(async () => {
      To(e), To(o.signal);
      const s = await r({
        pause: xu(o.signal),
        delay: w2(o.signal),
        signal: o.signal
      });
      return To(o.signal), s;
    }, () => Ao(o, r5));
    return i?.autoJoin && t.push(a.catch(bu)), {
      result: xu(e)(a),
      cancel() {
        Ao(o, n5);
      }
    };
  };
}, s5 = (e, t) => {
  const n = async (r, i) => {
    To(t);
    let o = () => {
    };
    const s = [new Promise((l, c) => {
      let u = e({
        predicate: r,
        effect: (d, f) => {
          f.unsubscribe(), l([d, f.getState(), f.getOriginalState()]);
        }
      });
      o = () => {
        u(), c();
      };
    })];
    i != null && s.push(new Promise((l) => setTimeout(l, i, null)));
    try {
      const l = await x2(t, Promise.race(s));
      return To(t), l;
    } finally {
      o();
    }
  };
  return (r, i) => y2(n(r, i));
}, O2 = (e) => {
  let {
    type: t,
    actionCreator: n,
    matcher: r,
    predicate: i,
    effect: o
  } = e;
  if (t)
    i = cr(t).match;
  else if (n)
    t = n.type, i = n.match;
  else if (r)
    i = r;
  else if (!i) throw new Error(process.env.NODE_ENV === "production" ? je(21) : "Creating or removing a listener requires one of the known fields for matching an action");
  return Ig(o, "options.listener"), {
    predicate: i,
    type: t,
    effect: o
  };
}, S2 = /* @__PURE__ */ ma((e) => {
  const {
    type: t,
    predicate: n,
    effect: r
  } = O2(e);
  return {
    id: H$(),
    effect: r,
    type: t,
    predicate: n,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(process.env.NODE_ENV === "production" ? je(22) : "Unsubscribe not initialized");
    }
  };
}, {
  withTypes: () => S2
}), _x = (e, t) => {
  const {
    type: n,
    effect: r,
    predicate: i
  } = O2(t);
  return Array.from(e.values()).find((o) => (typeof n == "string" ? o.type === n : o.predicate === i) && o.effect === r);
}, om = (e) => {
  e.pending.forEach((t) => {
    Ao(t, im);
  });
}, l5 = (e) => () => {
  e.forEach(om), e.clear();
}, Px = (e, t, n) => {
  try {
    e(t, n);
  } catch (r) {
    setTimeout(() => {
      throw r;
    }, 0);
  }
}, E2 = /* @__PURE__ */ ma(/* @__PURE__ */ cr(`${Cl}/add`), {
  withTypes: () => E2
}), c5 = /* @__PURE__ */ cr(`${Cl}/removeAll`), _2 = /* @__PURE__ */ ma(/* @__PURE__ */ cr(`${Cl}/remove`), {
  withTypes: () => _2
}), u5 = (...e) => {
  console.error(`${Cl}/error`, ...e);
}, Al = (e = {}) => {
  const t = /* @__PURE__ */ new Map(), {
    extra: n,
    onError: r = u5
  } = e;
  Ig(r, "onError");
  const i = (u) => (u.unsubscribe = () => t.delete(u.id), t.set(u.id, u), (d) => {
    u.unsubscribe(), d?.cancelActive && om(u);
  }), o = (u) => {
    const d = _x(t, u) ?? S2(u);
    return i(d);
  };
  ma(o, {
    withTypes: () => o
  });
  const a = (u) => {
    const d = _x(t, u);
    return d && (d.unsubscribe(), u.cancelActive && om(d)), !!d;
  };
  ma(a, {
    withTypes: () => a
  });
  const s = async (u, d, f, p) => {
    const g = new AbortController(), m = s5(o, g.signal), v = [];
    try {
      u.pending.add(g), await Promise.resolve(u.effect(
        d,
        // Use assign() rather than ... to avoid extra helper functions added to bundle
        ma({}, f, {
          getOriginalState: p,
          condition: (y, S) => m(y, S).then(Boolean),
          take: m,
          delay: w2(g.signal),
          pause: xu(g.signal),
          extra: n,
          signal: g.signal,
          fork: a5(g.signal, v),
          unsubscribe: u.unsubscribe,
          subscribe: () => {
            t.set(u.id, u);
          },
          cancelActiveListeners: () => {
            u.pending.forEach((y, S, x) => {
              y !== g && (Ao(y, im), x.delete(y));
            });
          },
          cancel: () => {
            Ao(g, im), u.pending.delete(g);
          },
          throwIfCancelled: () => {
            To(g.signal);
          }
        })
      ));
    } catch (y) {
      y instanceof Ld || Px(r, y, {
        raisedBy: "effect"
      });
    } finally {
      await Promise.all(v), Ao(g, i5), u.pending.delete(g);
    }
  }, l = l5(t);
  return {
    middleware: (u) => (d) => (f) => {
      if (!jg(f))
        return d(f);
      if (E2.match(f))
        return o(f.payload);
      if (c5.match(f)) {
        l();
        return;
      }
      if (_2.match(f))
        return a(f.payload);
      let p = u.getState();
      const g = () => {
        if (p === Ex)
          throw new Error(process.env.NODE_ENV === "production" ? je(23) : `${Cl}: getOriginalState can only be called synchronously`);
        return p;
      };
      let m;
      try {
        if (m = d(f), t.size > 0) {
          const v = u.getState(), y = Array.from(t.values());
          for (const S of y) {
            let x = !1;
            try {
              x = S.predicate(f, v, p);
            } catch (b) {
              x = !1, Px(r, b, {
                raisedBy: "predicate"
              });
            }
            x && s(S, f, u, g);
          }
        }
      } finally {
        p = Ex;
      }
      return m;
    },
    startListening: o,
    stopListening: a,
    clearListeners: l
  };
};
function je(e) {
  return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
var d5 = {
  layoutType: "horizontal",
  width: 0,
  height: 0,
  margin: {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  },
  scale: 1
}, P2 = Gn({
  name: "chartLayout",
  initialState: d5,
  reducers: {
    setLayout(e, t) {
      e.layoutType = t.payload;
    },
    setChartSize(e, t) {
      e.width = t.payload.width, e.height = t.payload.height;
    },
    setMargin(e, t) {
      var n, r, i, o;
      e.margin.top = (n = t.payload.top) !== null && n !== void 0 ? n : 0, e.margin.right = (r = t.payload.right) !== null && r !== void 0 ? r : 0, e.margin.bottom = (i = t.payload.bottom) !== null && i !== void 0 ? i : 0, e.margin.left = (o = t.payload.left) !== null && o !== void 0 ? o : 0;
    },
    setScale(e, t) {
      e.scale = t.payload;
    }
  }
}), {
  setMargin: f5,
  setLayout: p5,
  setChartSize: h5,
  setScale: m5
} = P2.actions, g5 = P2.reducer;
function Cx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ax(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Cx(Object(n), !0).forEach(function(r) {
      v5(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function v5(e, t, n) {
  return (t = y5(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function y5(e) {
  var t = b5(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function b5(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var wu = Math.PI / 180, x5 = (e) => e * 180 / Math.PI, Tt = (e, t, n, r) => ({
  x: e + Math.cos(-wu * r) * n,
  y: t + Math.sin(-wu * r) * n
}), C2 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  return Math.min(Math.abs(t - (r.left || 0) - (r.right || 0)), Math.abs(n - (r.top || 0) - (r.bottom || 0))) / 2;
}, w5 = (e, t) => {
  var {
    x: n,
    y: r
  } = e, {
    x: i,
    y: o
  } = t;
  return Math.sqrt((n - i) ** 2 + (r - o) ** 2);
}, O5 = (e, t) => {
  var {
    x: n,
    y: r
  } = e, {
    cx: i,
    cy: o
  } = t, a = w5({
    x: n,
    y: r
  }, {
    x: i,
    y: o
  });
  if (a <= 0)
    return {
      radius: a,
      angle: 0
    };
  var s = (n - i) / a, l = Math.acos(s);
  return r > o && (l = 2 * Math.PI - l), {
    radius: a,
    angle: x5(l),
    angleInRadian: l
  };
}, S5 = (e) => {
  var {
    startAngle: t,
    endAngle: n
  } = e, r = Math.floor(t / 360), i = Math.floor(n / 360), o = Math.min(r, i);
  return {
    startAngle: t - o * 360,
    endAngle: n - o * 360
  };
}, E5 = (e, t) => {
  var {
    startAngle: n,
    endAngle: r
  } = t, i = Math.floor(n / 360), o = Math.floor(r / 360), a = Math.min(i, o);
  return e + a * 360;
}, _5 = (e, t) => {
  var {
    x: n,
    y: r
  } = e, {
    radius: i,
    angle: o
  } = O5({
    x: n,
    y: r
  }, t), {
    innerRadius: a,
    outerRadius: s
  } = t;
  if (i < a || i > s || i === 0)
    return null;
  var {
    startAngle: l,
    endAngle: c
  } = S5(t), u = o, d;
  if (l <= c) {
    for (; u > c; )
      u -= 360;
    for (; u < l; )
      u += 360;
    d = u >= l && u <= c;
  } else {
    for (; u > l; )
      u -= 360;
    for (; u < c; )
      u += 360;
    d = u >= c && u <= l;
  }
  return d ? Ax(Ax({}, t), {}, {
    radius: i,
    angle: E5(u, t)
  }) : null;
};
function A2(e, t, n) {
  return Array.isArray(e) && e && t + n !== 0 ? e.slice(t, n + 1) : e;
}
function Tx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function or(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tx(Object(n), !0).forEach(function(r) {
      P5(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function P5(e, t, n) {
  return (t = C5(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function C5(e) {
  var t = A5(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function A5(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function tt(e, t, n) {
  return dt(e) || dt(t) ? n : Fr(t) ? Do(e, t, n) : typeof t == "function" ? t(e) : n;
}
var T5 = (e, t, n, r, i) => {
  var o, a = -1, s = (o = t?.length) !== null && o !== void 0 ? o : 0;
  if (s <= 1 || e == null)
    return 0;
  if (r === "angleAxis" && i != null && Math.abs(Math.abs(i[1] - i[0]) - 360) <= 1e-6)
    for (var l = 0; l < s; l++) {
      var c = l > 0 ? n[l - 1].coordinate : n[s - 1].coordinate, u = n[l].coordinate, d = l >= s - 1 ? n[0].coordinate : n[l + 1].coordinate, f = void 0;
      if (Ht(u - c) !== Ht(d - u)) {
        var p = [];
        if (Ht(d - u) === Ht(i[1] - i[0])) {
          f = d;
          var g = u + i[1] - i[0];
          p[0] = Math.min(g, (g + c) / 2), p[1] = Math.max(g, (g + c) / 2);
        } else {
          f = c;
          var m = d + i[1] - i[0];
          p[0] = Math.min(u, (m + u) / 2), p[1] = Math.max(u, (m + u) / 2);
        }
        var v = [Math.min(u, (f + u) / 2), Math.max(u, (f + u) / 2)];
        if (e > v[0] && e <= v[1] || e >= p[0] && e <= p[1]) {
          ({
            index: a
          } = n[l]);
          break;
        }
      } else {
        var y = Math.min(c, d), S = Math.max(c, d);
        if (e > (y + u) / 2 && e <= (S + u) / 2) {
          ({
            index: a
          } = n[l]);
          break;
        }
      }
    }
  else if (t) {
    for (var x = 0; x < s; x++)
      if (x === 0 && e <= (t[x].coordinate + t[x + 1].coordinate) / 2 || x > 0 && x < s - 1 && e > (t[x].coordinate + t[x - 1].coordinate) / 2 && e <= (t[x].coordinate + t[x + 1].coordinate) / 2 || x === s - 1 && e > (t[x].coordinate + t[x - 1].coordinate) / 2) {
        ({
          index: a
        } = t[x]);
        break;
      }
  }
  return a;
}, k5 = (e, t, n) => {
  if (t && n) {
    var {
      width: r,
      height: i
    } = n, {
      align: o,
      verticalAlign: a,
      layout: s
    } = t;
    if ((s === "vertical" || s === "horizontal" && a === "middle") && o !== "center" && me(e[o]))
      return or(or({}, e), {}, {
        [o]: e[o] + (r || 0)
      });
    if ((s === "horizontal" || s === "vertical" && o === "center") && a !== "middle" && me(e[a]))
      return or(or({}, e), {}, {
        [a]: e[a] + (i || 0)
      });
  }
  return e;
}, Yi = (e, t) => e === "horizontal" && t === "xAxis" || e === "vertical" && t === "yAxis" || e === "centric" && t === "angleAxis" || e === "radial" && t === "radiusAxis", T2 = (e, t, n, r) => {
  if (r)
    return e.map((s) => s.coordinate);
  var i, o, a = e.map((s) => (s.coordinate === t && (i = !0), s.coordinate === n && (o = !0), s.coordinate));
  return i || a.push(t), o || a.push(n), a;
}, k2 = (e, t, n) => {
  if (!e)
    return null;
  var {
    duplicateDomain: r,
    type: i,
    range: o,
    scale: a,
    realScaleType: s,
    isCategorical: l,
    categoricalDomain: c,
    tickCount: u,
    ticks: d,
    niceTicks: f,
    axisType: p
  } = e;
  if (!a)
    return null;
  var g = s === "scaleBand" && a.bandwidth ? a.bandwidth() / 2 : 2, m = i === "category" && a.bandwidth ? a.bandwidth() / g : 0;
  if (m = p === "angleAxis" && o && o.length >= 2 ? Ht(o[0] - o[1]) * 2 * m : m, d || f) {
    var v = (d || f || []).map((y, S) => {
      var x = r ? r.indexOf(y) : y;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: a(x) + m,
        value: y,
        offset: m,
        index: S
      };
    });
    return v.filter((y) => !Hn(y.coordinate));
  }
  return l && c ? c.map((y, S) => ({
    coordinate: a(y) + m,
    value: y,
    index: S,
    offset: m
  })) : a.ticks && u != null ? a.ticks(u).map((y, S) => ({
    coordinate: a(y) + m,
    value: y,
    offset: m,
    index: S
  })) : a.domain().map((y, S) => ({
    coordinate: a(y) + m,
    value: r ? r[y] : y,
    index: S,
    offset: m
  }));
}, kx = 1e-4, M5 = (e) => {
  var t = e.domain();
  if (!(!t || t.length <= 2)) {
    var n = t.length, r = e.range(), i = Math.min(r[0], r[1]) - kx, o = Math.max(r[0], r[1]) + kx, a = e(t[0]), s = e(t[n - 1]);
    (a < i || a > o || s < i || s > o) && e.domain([t[0], t[n - 1]]);
  }
}, j5 = (e, t) => {
  if (!t || t.length !== 2 || !me(t[0]) || !me(t[1]))
    return e;
  var n = Math.min(t[0], t[1]), r = Math.max(t[0], t[1]), i = [e[0], e[1]];
  return (!me(e[0]) || e[0] < n) && (i[0] = n), (!me(e[1]) || e[1] > r) && (i[1] = r), i[0] > r && (i[0] = r), i[1] < n && (i[1] = n), i;
}, N5 = (e) => {
  var t = e.length;
  if (!(t <= 0))
    for (var n = 0, r = e[0].length; n < r; ++n)
      for (var i = 0, o = 0, a = 0; a < t; ++a) {
        var s = Hn(e[a][n][1]) ? e[a][n][0] : e[a][n][1];
        s >= 0 ? (e[a][n][0] = i, e[a][n][1] = i + s, i = e[a][n][1]) : (e[a][n][0] = o, e[a][n][1] = o + s, o = e[a][n][1]);
      }
}, D5 = (e) => {
  var t = e.length;
  if (!(t <= 0))
    for (var n = 0, r = e[0].length; n < r; ++n)
      for (var i = 0, o = 0; o < t; ++o) {
        var a = Hn(e[o][n][1]) ? e[o][n][0] : e[o][n][1];
        a >= 0 ? (e[o][n][0] = i, e[o][n][1] = i + a, i = e[o][n][1]) : (e[o][n][0] = 0, e[o][n][1] = 0);
      }
}, R5 = {
  sign: N5,
  // @ts-expect-error definitelytyped types are incorrect
  expand: XR,
  // @ts-expect-error definitelytyped types are incorrect
  none: Oa,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: ZR,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: JR,
  positive: D5
}, I5 = (e, t, n) => {
  var r = R5[n], i = GR().keys(t).value((o, a) => +tt(o, a, 0)).order(Gh).offset(r);
  return i(e);
};
function $5(e) {
  return e == null ? void 0 : String(e);
}
function Mx(e) {
  var {
    axis: t,
    ticks: n,
    bandSize: r,
    entry: i,
    index: o,
    dataKey: a
  } = e;
  if (t.type === "category") {
    if (!t.allowDuplicatedCategory && t.dataKey && !dt(i[t.dataKey])) {
      var s = v_(n, "value", i[t.dataKey]);
      if (s)
        return s.coordinate + r / 2;
    }
    return n[o] ? n[o].coordinate + r / 2 : null;
  }
  var l = tt(i, dt(a) ? t.dataKey : a);
  return dt(l) ? null : t.scale(l);
}
var jx = (e) => {
  var {
    axis: t,
    ticks: n,
    offset: r,
    bandSize: i,
    entry: o,
    index: a
  } = e;
  if (t.type === "category")
    return n[a] ? n[a].coordinate + r : null;
  var s = tt(o, t.dataKey, t.scale.domain()[a]);
  return dt(s) ? null : t.scale(s) - i / 2 + r;
}, L5 = (e) => {
  var {
    numericAxis: t
  } = e, n = t.scale.domain();
  if (t.type === "number") {
    var r = Math.min(n[0], n[1]), i = Math.max(n[0], n[1]);
    return r <= 0 && i >= 0 ? 0 : i < 0 ? i : r;
  }
  return n[0];
}, F5 = (e) => {
  var t = e.flat(2).filter(me);
  return [Math.min(...t), Math.max(...t)];
}, B5 = (e) => [e[0] === 1 / 0 ? 0 : e[0], e[1] === -1 / 0 ? 0 : e[1]], z5 = (e, t, n) => {
  if (e != null)
    return B5(Object.keys(e).reduce((r, i) => {
      var o = e[i], {
        stackedData: a
      } = o, s = a.reduce((l, c) => {
        var u = A2(c, t, n), d = F5(u);
        return [Math.min(l[0], d[0]), Math.max(l[1], d[1])];
      }, [1 / 0, -1 / 0]);
      return [Math.min(s[0], r[0]), Math.max(s[1], r[1])];
    }, [1 / 0, -1 / 0]));
}, Nx = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, Dx = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, Gs = (e, t, n) => {
  if (e && e.scale && e.scale.bandwidth) {
    var r = e.scale.bandwidth();
    if (!n || r > 0)
      return r;
  }
  if (e && t && t.length >= 2) {
    for (var i = Dd(t, (u) => u.coordinate), o = 1 / 0, a = 1, s = i.length; a < s; a++) {
      var l = i[a], c = i[a - 1];
      o = Math.min((l.coordinate || 0) - (c.coordinate || 0), o);
    }
    return o === 1 / 0 ? 0 : o;
  }
  return n ? void 0 : 0;
};
function Rx(e) {
  var {
    tooltipEntrySettings: t,
    dataKey: n,
    payload: r,
    value: i,
    name: o
  } = e;
  return or(or({}, t), {}, {
    dataKey: n,
    payload: r,
    value: i,
    name: o
  });
}
function La(e, t) {
  if (e)
    return String(e);
  if (typeof t == "string")
    return t;
}
function W5(e, t, n, r, i) {
  if (n === "horizontal" || n === "vertical") {
    var o = e >= i.left && e <= i.left + i.width && t >= i.top && t <= i.top + i.height;
    return o ? {
      x: e,
      y: t
    } : null;
  }
  return r ? _5({
    x: e,
    y: t
  }, r) : null;
}
var V5 = (e, t, n, r) => {
  var i = t.find((c) => c && c.index === n);
  if (i) {
    if (e === "horizontal")
      return {
        x: i.coordinate,
        y: r.y
      };
    if (e === "vertical")
      return {
        x: r.x,
        y: i.coordinate
      };
    if (e === "centric") {
      var o = i.coordinate, {
        radius: a
      } = r;
      return or(or(or({}, r), Tt(r.cx, r.cy, a, o)), {}, {
        angle: o,
        radius: a
      });
    }
    var s = i.coordinate, {
      angle: l
    } = r;
    return or(or(or({}, r), Tt(r.cx, r.cy, s, l)), {}, {
      angle: l,
      radius: s
    });
  }
  return {
    x: 0,
    y: 0
  };
}, U5 = (e, t) => t === "horizontal" ? e.x : t === "vertical" ? e.y : t === "centric" ? e.angle : e.radius, wi = (e) => e.layout.width, Oi = (e) => e.layout.height, H5 = (e) => e.layout.scale, M2 = (e) => e.layout.margin, Fd = z((e) => e.cartesianAxis.xAxis, (e) => Object.values(e)), Bd = z((e) => e.cartesianAxis.yAxis, (e) => Object.values(e)), j2 = "data-recharts-item-index", N2 = "data-recharts-item-data-key", Tl = 60;
function Ix(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ix(Object(n), !0).forEach(function(r) {
      K5(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ix(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function K5(e, t, n) {
  return (t = q5(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function q5(e) {
  var t = Y5(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Y5(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var G5 = (e) => e.brush.height;
function X5(e) {
  var t = Bd(e);
  return t.reduce((n, r) => {
    if (r.orientation === "left" && !r.mirror && !r.hide) {
      var i = typeof r.width == "number" ? r.width : Tl;
      return n + i;
    }
    return n;
  }, 0);
}
function Z5(e) {
  var t = Bd(e);
  return t.reduce((n, r) => {
    if (r.orientation === "right" && !r.mirror && !r.hide) {
      var i = typeof r.width == "number" ? r.width : Tl;
      return n + i;
    }
    return n;
  }, 0);
}
function J5(e) {
  var t = Fd(e);
  return t.reduce((n, r) => r.orientation === "top" && !r.mirror && !r.hide ? n + r.height : n, 0);
}
function Q5(e) {
  var t = Fd(e);
  return t.reduce((n, r) => r.orientation === "bottom" && !r.mirror && !r.hide ? n + r.height : n, 0);
}
var Lt = z([wi, Oi, M2, G5, X5, Z5, J5, Q5, J_, i$], (e, t, n, r, i, o, a, s, l, c) => {
  var u = {
    left: (n.left || 0) + i,
    right: (n.right || 0) + o
  }, d = {
    top: (n.top || 0) + a,
    bottom: (n.bottom || 0) + s
  }, f = hc(hc({}, d), u), p = f.bottom;
  f.bottom += r, f = k5(f, l, c);
  var g = e - f.left - f.right, m = t - f.top - f.bottom;
  return hc(hc({
    brushBottom: p
  }, f), {}, {
    // never return negative values for height and width
    width: Math.max(g, 0),
    height: Math.max(m, 0)
  });
}), eL = z(Lt, (e) => ({
  x: e.left,
  y: e.top,
  width: e.width,
  height: e.height
})), $g = z(wi, Oi, (e, t) => ({
  x: 0,
  y: 0,
  width: e,
  height: t
})), tL = /* @__PURE__ */ hr(null), Nn = () => Vr(tL) != null, zd = (e) => e.brush, Wd = z([zd, Lt, M2], (e, t, n) => ({
  height: e.height,
  x: me(e.x) ? e.x : t.left,
  y: me(e.y) ? e.y : t.top + t.height + t.brushBottom - (n?.bottom || 0),
  width: me(e.width) ? e.width : t.width
})), Lg = () => {
  var e, t = Nn(), n = pe(eL), r = pe(Wd), i = (e = pe(zd)) === null || e === void 0 ? void 0 : e.padding;
  return !t || !r || !i ? n : {
    width: r.width - i.left - i.right,
    height: r.height - i.top - i.bottom,
    x: i.left,
    y: i.top
  };
}, nL = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  width: 0,
  height: 0,
  brushBottom: 0
}, D2 = () => {
  var e;
  return (e = pe(Lt)) !== null && e !== void 0 ? e : nL;
}, R2 = () => pe(wi), I2 = () => pe(Oi), _e = (e) => e.layout.layoutType, Vd = () => pe(_e), rL = {
  settings: {
    layout: "horizontal",
    align: "center",
    verticalAlign: "middle",
    itemSorter: "value"
  },
  size: {
    width: 0,
    height: 0
  },
  payload: []
}, $2 = Gn({
  name: "legend",
  initialState: rL,
  reducers: {
    setLegendSize(e, t) {
      e.size.width = t.payload.width, e.size.height = t.payload.height;
    },
    setLegendSettings(e, t) {
      e.settings.align = t.payload.align, e.settings.layout = t.payload.layout, e.settings.verticalAlign = t.payload.verticalAlign, e.settings.itemSorter = t.payload.itemSorter;
    },
    addLegendPayload(e, t) {
      e.payload.push(t.payload);
    },
    removeLegendPayload(e, t) {
      var n = ui(e).payload.indexOf(t.payload);
      n > -1 && e.payload.splice(n, 1);
    }
  }
}), {
  setLegendSize: jee,
  setLegendSettings: Nee,
  addLegendPayload: L2,
  removeLegendPayload: F2
} = $2.actions, iL = $2.reducer;
function am() {
  return am = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, am.apply(null, arguments);
}
function $x(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $x(Object(n), !0).forEach(function(r) {
      oL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $x(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function oL(e, t, n) {
  return (t = aL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function aL(e) {
  var t = sL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function sL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function lL(e) {
  return Array.isArray(e) && Fr(e[0]) && Fr(e[1]) ? e.join(" ~ ") : e;
}
var cL = (e) => {
  var {
    separator: t = " : ",
    contentStyle: n = {},
    itemStyle: r = {},
    labelStyle: i = {},
    payload: o,
    formatter: a,
    itemSorter: s,
    wrapperClassName: l,
    labelClassName: c,
    label: u,
    labelFormatter: d,
    accessibilityLayer: f = !1
  } = e, p = () => {
    if (o && o.length) {
      var w = {
        padding: 0,
        margin: 0
      }, E = (s ? Dd(o, s) : o).map((C, A) => {
        if (C.type === "none")
          return null;
        var k = C.formatter || a || lL, {
          value: R,
          name: M
        } = C, P = R, D = M;
        if (k) {
          var j = k(R, M, C, A, o);
          if (Array.isArray(j))
            [P, D] = j;
          else if (j != null)
            P = j;
          else
            return null;
        }
        var N = Lp({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: C.color || "#000"
        }, r);
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ _.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(A),
            style: N
          }, Fr(D) ? /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, D) : null, Fr(D) ? /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, t) : null, /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, P), /* @__PURE__ */ _.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, C.unit || ""))
        );
      });
      return /* @__PURE__ */ _.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: w
      }, E);
    }
    return null;
  }, g = Lp({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, n), m = Lp({
    margin: 0
  }, i), v = !dt(u), y = v ? u : "", S = ce("recharts-default-tooltip", l), x = ce("recharts-tooltip-label", c);
  v && d && o !== void 0 && o !== null && (y = d(u, o));
  var b = f ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ _.createElement("div", am({
    className: S,
    style: g
  }, b), /* @__PURE__ */ _.createElement("p", {
    className: x,
    style: m
  }, /* @__PURE__ */ _.isValidElement(y) ? y : "".concat(y)), p());
}, ns = "recharts-tooltip-wrapper", uL = {
  visibility: "hidden"
};
function dL(e) {
  var {
    coordinate: t,
    translateX: n,
    translateY: r
  } = e;
  return ce(ns, {
    ["".concat(ns, "-right")]: me(n) && t && me(t.x) && n >= t.x,
    ["".concat(ns, "-left")]: me(n) && t && me(t.x) && n < t.x,
    ["".concat(ns, "-bottom")]: me(r) && t && me(t.y) && r >= t.y,
    ["".concat(ns, "-top")]: me(r) && t && me(t.y) && r < t.y
  });
}
function Lx(e) {
  var {
    allowEscapeViewBox: t,
    coordinate: n,
    key: r,
    offsetTopLeft: i,
    position: o,
    reverseDirection: a,
    tooltipDimension: s,
    viewBox: l,
    viewBoxDimension: c
  } = e;
  if (o && me(o[r]))
    return o[r];
  var u = n[r] - s - (i > 0 ? i : 0), d = n[r] + i;
  if (t[r])
    return a[r] ? u : d;
  var f = l[r];
  if (f == null)
    return 0;
  if (a[r]) {
    var p = u, g = f;
    return p < g ? Math.max(d, f) : Math.max(u, f);
  }
  if (c == null)
    return 0;
  var m = d + s, v = f + c;
  return m > v ? Math.max(u, f) : Math.max(d, f);
}
function fL(e) {
  var {
    translateX: t,
    translateY: n,
    useTranslate3d: r
  } = e;
  return {
    transform: r ? "translate3d(".concat(t, "px, ").concat(n, "px, 0)") : "translate(".concat(t, "px, ").concat(n, "px)")
  };
}
function pL(e) {
  var {
    allowEscapeViewBox: t,
    coordinate: n,
    offsetTopLeft: r,
    position: i,
    reverseDirection: o,
    tooltipBox: a,
    useTranslate3d: s,
    viewBox: l
  } = e, c, u, d;
  return a.height > 0 && a.width > 0 && n ? (u = Lx({
    allowEscapeViewBox: t,
    coordinate: n,
    key: "x",
    offsetTopLeft: r,
    position: i,
    reverseDirection: o,
    tooltipDimension: a.width,
    viewBox: l,
    viewBoxDimension: l.width
  }), d = Lx({
    allowEscapeViewBox: t,
    coordinate: n,
    key: "y",
    offsetTopLeft: r,
    position: i,
    reverseDirection: o,
    tooltipDimension: a.height,
    viewBox: l,
    viewBoxDimension: l.height
  }), c = fL({
    translateX: u,
    translateY: d,
    useTranslate3d: s
  })) : c = uL, {
    cssProperties: c,
    cssClasses: dL({
      translateX: u,
      translateY: d,
      coordinate: n
    })
  };
}
function Fx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fx(Object(n), !0).forEach(function(r) {
      sm(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function sm(e, t, n) {
  return (t = hL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function hL(e) {
  var t = mL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function mL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
class gL extends gE {
  constructor() {
    super(...arguments), sm(this, "state", {
      dismissed: !1,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      }
    }), sm(this, "handleKeyDown", (t) => {
      if (t.key === "Escape") {
        var n, r, i, o;
        this.setState({
          dismissed: !0,
          dismissedAtCoordinate: {
            x: (n = (r = this.props.coordinate) === null || r === void 0 ? void 0 : r.x) !== null && n !== void 0 ? n : 0,
            y: (i = (o = this.props.coordinate) === null || o === void 0 ? void 0 : o.y) !== null && i !== void 0 ? i : 0
          }
        });
      }
    });
  }
  componentDidMount() {
    document.addEventListener("keydown", this.handleKeyDown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  componentDidUpdate() {
    var t, n;
    this.state.dismissed && (((t = this.props.coordinate) === null || t === void 0 ? void 0 : t.x) !== this.state.dismissedAtCoordinate.x || ((n = this.props.coordinate) === null || n === void 0 ? void 0 : n.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);
  }
  render() {
    var {
      active: t,
      allowEscapeViewBox: n,
      animationDuration: r,
      animationEasing: i,
      children: o,
      coordinate: a,
      hasPayload: s,
      isAnimationActive: l,
      offset: c,
      position: u,
      reverseDirection: d,
      useTranslate3d: f,
      viewBox: p,
      wrapperStyle: g,
      lastBoundingBox: m,
      innerRef: v,
      hasPortalFromProps: y
    } = this.props, {
      cssClasses: S,
      cssProperties: x
    } = pL({
      allowEscapeViewBox: n,
      coordinate: a,
      offsetTopLeft: c,
      position: u,
      reverseDirection: d,
      tooltipBox: {
        height: m.height,
        width: m.width
      },
      useTranslate3d: f,
      viewBox: p
    }), b = y ? {} : mc(mc({
      transition: l && t ? "transform ".concat(r, "ms ").concat(i) : void 0
    }, x), {}, {
      pointerEvents: "none",
      visibility: !this.state.dismissed && t && s ? "visible" : "hidden",
      position: "absolute",
      top: 0,
      left: 0
    }), w = mc(mc({}, b), {}, {
      visibility: !this.state.dismissed && t && s ? "visible" : "hidden"
    }, g);
    return (
      // This element allow listening to the `Escape` key. See https://github.com/recharts/recharts/pull/2925
      /* @__PURE__ */ _.createElement("div", {
        // @ts-expect-error typescript library does not recognize xmlns attribute, but it's required for an HTML chunk inside SVG.
        xmlns: "http://www.w3.org/1999/xhtml",
        tabIndex: -1,
        className: S,
        style: w,
        ref: v
      }, o)
    );
  }
}
var vL = () => !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout), Gi = {
  devToolsEnabled: !1,
  isSsr: vL()
}, B2 = () => pe((e) => e.rootProps.accessibilityLayer);
function qn(e) {
  return Number.isFinite(e);
}
function Ea(e) {
  return typeof e == "number" && e > 0 && Number.isFinite(e);
}
function lm() {
  return lm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, lm.apply(null, arguments);
}
function Bx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bx(Object(n), !0).forEach(function(r) {
      yL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function yL(e, t, n) {
  return (t = bL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function bL(e) {
  var t = xL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function xL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Wx = {
  curveBasisClosed: LR,
  curveBasisOpen: FR,
  curveBasis: $R,
  curveBumpX: SR,
  curveBumpY: ER,
  curveLinearClosed: BR,
  curveLinear: jd,
  curveMonotoneX: zR,
  curveMonotoneY: WR,
  curveNatural: VR,
  curveStep: UR,
  curveStepAfter: KR,
  curveStepBefore: HR
}, gc = (e) => qn(e.x) && qn(e.y), rs = (e) => e.x, is = (e) => e.y, wL = (e, t) => {
  if (typeof e == "function")
    return e;
  var n = "curve".concat(El(e));
  return (n === "curveMonotone" || n === "curveBump") && t ? Wx["".concat(n).concat(t === "vertical" ? "Y" : "X")] : Wx[n] || jd;
}, OL = (e) => {
  var {
    type: t = "linear",
    points: n = [],
    baseLine: r,
    layout: i,
    connectNulls: o = !1
  } = e, a = wL(t, i), s = o ? n.filter(gc) : n, l;
  if (Array.isArray(r)) {
    var c = o ? r.filter((d) => gc(d)) : r, u = s.map((d, f) => zx(zx({}, d), {}, {
      base: c[f]
    }));
    return i === "vertical" ? l = oc().y(is).x1(rs).x0((d) => d.base.x) : l = oc().x(rs).y1(is).y0((d) => d.base.y), l.defined(gc).curve(a), l(u);
  }
  return i === "vertical" && me(r) ? l = oc().y(is).x1(rs).x0(r) : me(r) ? l = oc().x(rs).y1(is).y0(r) : l = C_().x(rs).y(is), l.defined(gc).curve(a), l(s);
}, Fg = (e) => {
  var {
    className: t,
    points: n,
    path: r,
    pathRef: i
  } = e;
  if ((!n || !n.length) && !r)
    return null;
  var o = n && n.length ? OL(e) : r;
  return /* @__PURE__ */ _.createElement("path", lm({}, Kr(e), Eg(e), {
    className: ce("recharts-curve", t),
    d: o === null ? void 0 : o,
    ref: i
  }));
}, SL = ["x", "y", "top", "left", "width", "height", "className"];
function cm() {
  return cm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, cm.apply(null, arguments);
}
function Vx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function EL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vx(Object(n), !0).forEach(function(r) {
      _L(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function _L(e, t, n) {
  return (t = PL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function PL(e) {
  var t = CL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function CL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function AL(e, t) {
  if (e == null) return {};
  var n, r, i = TL(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function TL(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var kL = (e, t, n, r, i, o) => "M".concat(e, ",").concat(i, "v").concat(r, "M").concat(o, ",").concat(t, "h").concat(n), ML = (e) => {
  var {
    x: t = 0,
    y: n = 0,
    top: r = 0,
    left: i = 0,
    width: o = 0,
    height: a = 0,
    className: s
  } = e, l = AL(e, SL), c = EL({
    x: t,
    y: n,
    top: r,
    left: i,
    width: o,
    height: a
  }, l);
  return !me(t) || !me(n) || !me(o) || !me(a) || !me(r) || !me(i) ? null : /* @__PURE__ */ _.createElement("path", cm({}, ht(c, !0), {
    className: ce("recharts-cross", s),
    d: kL(t, n, o, a, r, i)
  }));
};
function jL(e, t, n, r) {
  var i = r / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: e === "horizontal" ? t.x - i : n.left + 0.5,
    y: e === "horizontal" ? n.top + 0.5 : t.y - i,
    width: e === "horizontal" ? r : n.width - 1,
    height: e === "horizontal" ? n.height - 1 : r
  };
}
function Ux(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ux(Object(n), !0).forEach(function(r) {
      DL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ux(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function DL(e, t, n) {
  return (t = RL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function RL(e) {
  var t = IL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function IL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rn(e, t) {
  var n = NL({}, e), r = t, i = Object.keys(t), o = i.reduce((a, s) => (a[s] === void 0 && r[s] !== void 0 && (a[s] = r[s]), a), n);
  return o;
}
function $L() {
}
function Hx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hx(Object(n), !0).forEach(function(r) {
      LL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function LL(e, t, n) {
  return (t = FL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function FL(e) {
  var t = BL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function BL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var zL = (e) => e.replace(/([A-Z])/g, (t) => "-".concat(t.toLowerCase())), z2 = (e, t, n) => e.map((r) => "".concat(zL(r), " ").concat(t, "ms ").concat(n)).join(","), WL = (e, t) => [Object.keys(e), Object.keys(t)].reduce((n, r) => n.filter((i) => r.includes(i))), Xs = (e, t) => Object.keys(t).reduce((n, r) => Kx(Kx({}, n), {}, {
  [r]: e(r, t[r])
}), {});
function qx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qx(Object(n), !0).forEach(function(r) {
      VL(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function VL(e, t, n) {
  return (t = UL(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function UL(e) {
  var t = HL(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function HL(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Ou = (e, t, n) => e + (t - e) * n, um = (e) => {
  var {
    from: t,
    to: n
  } = e;
  return t !== n;
}, W2 = (e, t, n) => {
  var r = Xs((i, o) => {
    if (um(o)) {
      var [a, s] = e(o.from, o.to, o.velocity);
      return Qt(Qt({}, o), {}, {
        from: a,
        velocity: s
      });
    }
    return o;
  }, t);
  return n < 1 ? Xs((i, o) => um(o) ? Qt(Qt({}, o), {}, {
    velocity: Ou(o.velocity, r[i].velocity, n),
    from: Ou(o.from, r[i].from, n)
  }) : o, t) : W2(e, r, n - 1);
};
function KL(e, t, n, r, i, o) {
  var a, s = r.reduce((f, p) => Qt(Qt({}, f), {}, {
    [p]: {
      from: e[p],
      velocity: 0,
      to: t[p]
    }
  }), {}), l = () => Xs((f, p) => p.from, s), c = () => !Object.values(s).filter(um).length, u = null, d = (f) => {
    a || (a = f);
    var p = f - a, g = p / n.dt;
    s = W2(n, s, g), i(Qt(Qt(Qt({}, e), t), l())), a = f, c() || (u = o.setTimeout(d));
  };
  return () => (u = o.setTimeout(d), () => {
    u();
  });
}
function qL(e, t, n, r, i, o, a) {
  var s = null, l = i.reduce((d, f) => Qt(Qt({}, d), {}, {
    [f]: [e[f], t[f]]
  }), {}), c, u = (d) => {
    c || (c = d);
    var f = (d - c) / r, p = Xs((m, v) => Ou(...v, n(f)), l);
    if (o(Qt(Qt(Qt({}, e), t), p)), f < 1)
      s = a.setTimeout(u);
    else {
      var g = Xs((m, v) => Ou(...v, n(1)), l);
      o(Qt(Qt(Qt({}, e), t), g));
    }
  };
  return () => (s = a.setTimeout(u), () => {
    s();
  });
}
const YL = (e, t, n, r, i, o) => {
  var a = WL(e, t);
  return n.isStepper === !0 ? KL(e, t, n, a, i, o) : qL(e, t, n, r, a, i, o);
};
var Su = 1e-4, V2 = (e, t) => [0, 3 * e, 3 * t - 6 * e, 3 * e - 3 * t + 1], U2 = (e, t) => e.map((n, r) => n * t ** r).reduce((n, r) => n + r), Yx = (e, t) => (n) => {
  var r = V2(e, t);
  return U2(r, n);
}, GL = (e, t) => (n) => {
  var r = V2(e, t), i = [...r.map((o, a) => o * a).slice(1), 0];
  return U2(i, n);
}, Gx = function() {
  for (var t, n, r, i, o = arguments.length, a = new Array(o), s = 0; s < o; s++)
    a[s] = arguments[s];
  if (a.length === 1)
    switch (a[0]) {
      case "linear":
        [t, r, n, i] = [0, 0, 1, 1];
        break;
      case "ease":
        [t, r, n, i] = [0.25, 0.1, 0.25, 1];
        break;
      case "ease-in":
        [t, r, n, i] = [0.42, 0, 1, 1];
        break;
      case "ease-out":
        [t, r, n, i] = [0.42, 0, 0.58, 1];
        break;
      case "ease-in-out":
        [t, r, n, i] = [0, 0, 0.58, 1];
        break;
      default: {
        var l = a[0].split("(");
        l[0] === "cubic-bezier" && l[1].split(")")[0].split(",").length === 4 && ([t, r, n, i] = l[1].split(")")[0].split(",").map((g) => parseFloat(g)));
      }
    }
  else a.length === 4 && ([t, r, n, i] = a);
  var c = Yx(t, n), u = Yx(r, i), d = GL(t, n), f = (g) => g > 1 ? 1 : g < 0 ? 0 : g, p = (g) => {
    for (var m = g > 1 ? 1 : g, v = m, y = 0; y < 8; ++y) {
      var S = c(v) - m, x = d(v);
      if (Math.abs(S - m) < Su || x < Su)
        return u(v);
      v = f(v - S / x);
    }
    return u(v);
  };
  return p.isStepper = !1, p;
}, XL = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
    stiff: n = 100,
    damping: r = 8,
    dt: i = 17
  } = t, o = (a, s, l) => {
    var c = -(a - s) * n, u = l * r, d = l + (c - u) * i / 1e3, f = l * i / 1e3 + a;
    return Math.abs(f - s) < Su && Math.abs(d) < Su ? [s, 0] : [f, d];
  };
  return o.isStepper = !0, o.dt = i, o;
}, ZL = (e) => {
  if (typeof e == "string")
    switch (e) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return Gx(e);
      case "spring":
        return XL();
      default:
        if (e.split("(")[0] === "cubic-bezier")
          return Gx(e);
    }
  return typeof e == "function" ? e : null;
};
function JL(e) {
  var t, n = () => null, r = !1, i = null, o = (a) => {
    if (!r) {
      if (Array.isArray(a)) {
        if (!a.length)
          return;
        var s = a, [l, ...c] = s;
        if (typeof l == "number") {
          i = e.setTimeout(o.bind(null, c), l);
          return;
        }
        o(l), i = e.setTimeout(o.bind(null, c));
        return;
      }
      typeof a == "string" && (t = a, n(t)), typeof a == "object" && (t = a, n(t)), typeof a == "function" && a();
    }
  };
  return {
    stop: () => {
      r = !0;
    },
    start: (a) => {
      r = !1, i && (i(), i = null), o(a);
    },
    subscribe: (a) => (n = a, () => {
      n = () => null;
    }),
    getTimeoutController: () => e
  };
}
class QL {
  setTimeout(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = performance.now(), i = null, o = (a) => {
      a - r >= n ? t(a) : typeof requestAnimationFrame == "function" && (i = requestAnimationFrame(o));
    };
    return i = requestAnimationFrame(o), () => {
      cancelAnimationFrame(i);
    };
  }
}
function e4() {
  return JL(new QL());
}
var t4 = /* @__PURE__ */ hr(e4);
function n4(e, t) {
  var n = Vr(t4);
  return Ur(() => t ?? n(e), [e, t, n]);
}
var r4 = {
  begin: 0,
  duration: 1e3,
  easing: "ease",
  isActive: !0,
  canBegin: !0,
  onAnimationEnd: () => {
  },
  onAnimationStart: () => {
  }
}, Xx = {
  t: 0
}, Fp = {
  t: 1
};
function kl(e) {
  var t = rn(e, r4), {
    isActive: n,
    canBegin: r,
    duration: i,
    easing: o,
    begin: a,
    onAnimationEnd: s,
    onAnimationStart: l,
    children: c
  } = t, u = n4(t.animationId, t.animationManager), [d, f] = Rt(n ? Xx : Fp), p = Ue(null);
  return Le(() => {
    n || f(Fp);
  }, [n]), Le(() => {
    if (!n || !r)
      return $L;
    var g = YL(Xx, Fp, ZL(o), i, f, u.getTimeoutController()), m = () => {
      p.current = g();
    };
    return u.start([l, a, m, i, s]), () => {
      u.stop(), p.current && p.current(), s();
    };
  }, [n, r, i, o, a, l, s, u]), c(d.t);
}
function Ml(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-", n = Ue(Ks(t)), r = Ue(e);
  return r.current !== e && (n.current = Ks(t), r.current = e), n.current;
}
function Zx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Zx(Object(n), !0).forEach(function(r) {
      i4(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Zx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function i4(e, t, n) {
  return (t = o4(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function o4(e) {
  var t = a4(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function a4(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Eu() {
  return Eu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Eu.apply(null, arguments);
}
var Qx = (e, t, n, r, i) => {
  var o = Math.min(Math.abs(n) / 2, Math.abs(r) / 2), a = r >= 0 ? 1 : -1, s = n >= 0 ? 1 : -1, l = r >= 0 && n >= 0 || r < 0 && n < 0 ? 1 : 0, c;
  if (o > 0 && i instanceof Array) {
    for (var u = [0, 0, 0, 0], d = 0, f = 4; d < f; d++)
      u[d] = i[d] > o ? o : i[d];
    c = "M".concat(e, ",").concat(t + a * u[0]), u[0] > 0 && (c += "A ".concat(u[0], ",").concat(u[0], ",0,0,").concat(l, ",").concat(e + s * u[0], ",").concat(t)), c += "L ".concat(e + n - s * u[1], ",").concat(t), u[1] > 0 && (c += "A ".concat(u[1], ",").concat(u[1], ",0,0,").concat(l, `,
        `).concat(e + n, ",").concat(t + a * u[1])), c += "L ".concat(e + n, ",").concat(t + r - a * u[2]), u[2] > 0 && (c += "A ".concat(u[2], ",").concat(u[2], ",0,0,").concat(l, `,
        `).concat(e + n - s * u[2], ",").concat(t + r)), c += "L ".concat(e + s * u[3], ",").concat(t + r), u[3] > 0 && (c += "A ".concat(u[3], ",").concat(u[3], ",0,0,").concat(l, `,
        `).concat(e, ",").concat(t + r - a * u[3])), c += "Z";
  } else if (o > 0 && i === +i && i > 0) {
    var p = Math.min(o, i);
    c = "M ".concat(e, ",").concat(t + a * p, `
            A `).concat(p, ",").concat(p, ",0,0,").concat(l, ",").concat(e + s * p, ",").concat(t, `
            L `).concat(e + n - s * p, ",").concat(t, `
            A `).concat(p, ",").concat(p, ",0,0,").concat(l, ",").concat(e + n, ",").concat(t + a * p, `
            L `).concat(e + n, ",").concat(t + r - a * p, `
            A `).concat(p, ",").concat(p, ",0,0,").concat(l, ",").concat(e + n - s * p, ",").concat(t + r, `
            L `).concat(e + s * p, ",").concat(t + r, `
            A `).concat(p, ",").concat(p, ",0,0,").concat(l, ",").concat(e, ",").concat(t + r - a * p, " Z");
  } else
    c = "M ".concat(e, ",").concat(t, " h ").concat(n, " v ").concat(r, " h ").concat(-n, " Z");
  return c;
}, s4 = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: !1,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, H2 = (e) => {
  var t = rn(e, s4), n = Ue(null), [r, i] = Rt(-1);
  Le(() => {
    if (n.current && n.current.getTotalLength)
      try {
        var j = n.current.getTotalLength();
        j && i(j);
      } catch {
      }
  }, []);
  var {
    x: o,
    y: a,
    width: s,
    height: l,
    radius: c,
    className: u
  } = t, {
    animationEasing: d,
    animationDuration: f,
    animationBegin: p,
    isAnimationActive: g,
    isUpdateAnimationActive: m
  } = t, v = Ue(s), y = Ue(l), S = Ue(o), x = Ue(a), b = Ur(() => ({
    x: o,
    y: a,
    width: s,
    height: l,
    radius: c
  }), [o, a, s, l, c]), w = Ml(b, "rectangle-");
  if (o !== +o || a !== +a || s !== +s || l !== +l || s === 0 || l === 0)
    return null;
  var E = ce("recharts-rectangle", u);
  if (!m)
    return /* @__PURE__ */ _.createElement("path", Eu({}, ht(t, !0), {
      className: E,
      d: Qx(o, a, s, l, c)
    }));
  var C = v.current, A = y.current, k = S.current, R = x.current, M = "0px ".concat(r === -1 ? 1 : r, "px"), P = "".concat(r, "px 0px"), D = z2(["strokeDasharray"], f, typeof d == "string" ? d : void 0);
  return /* @__PURE__ */ _.createElement(kl, {
    animationId: w,
    key: w,
    canBegin: r > 0,
    duration: f,
    easing: d,
    isActive: m,
    begin: p
  }, (j) => {
    var N = yt(C, s, j), $ = yt(A, l, j), F = yt(k, o, j), q = yt(R, a, j);
    n.current && (v.current = N, y.current = $, S.current = F, x.current = q);
    var B;
    return g ? j > 0 ? B = {
      transition: D,
      strokeDasharray: P
    } : B = {
      strokeDasharray: M
    } : B = {
      strokeDasharray: P
    }, /* @__PURE__ */ _.createElement("path", Eu({}, ht(t, !0), {
      className: E,
      d: Qx(F, q, N, $, c),
      ref: n,
      style: Jx(Jx({}, B), t.style)
    }));
  });
};
function K2(e) {
  var {
    cx: t,
    cy: n,
    radius: r,
    startAngle: i,
    endAngle: o
  } = e, a = Tt(t, n, r, i), s = Tt(t, n, r, o);
  return {
    points: [a, s],
    cx: t,
    cy: n,
    radius: r,
    startAngle: i,
    endAngle: o
  };
}
function dm() {
  return dm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, dm.apply(null, arguments);
}
var l4 = (e, t) => {
  var n = Ht(t - e), r = Math.min(Math.abs(t - e), 359.999);
  return n * r;
}, vc = (e) => {
  var {
    cx: t,
    cy: n,
    radius: r,
    angle: i,
    sign: o,
    isExternal: a,
    cornerRadius: s,
    cornerIsExternal: l
  } = e, c = s * (a ? 1 : -1) + r, u = Math.asin(s / c) / wu, d = l ? i : i + o * u, f = Tt(t, n, c, d), p = Tt(t, n, r, d), g = l ? i - o * u : i, m = Tt(t, n, c * Math.cos(u * wu), g);
  return {
    center: f,
    circleTangency: p,
    lineTangency: m,
    theta: u
  };
}, q2 = (e) => {
  var {
    cx: t,
    cy: n,
    innerRadius: r,
    outerRadius: i,
    startAngle: o,
    endAngle: a
  } = e, s = l4(o, a), l = o + s, c = Tt(t, n, i, o), u = Tt(t, n, i, l), d = "M ".concat(c.x, ",").concat(c.y, `
    A `).concat(i, ",").concat(i, `,0,
    `).concat(+(Math.abs(s) > 180), ",").concat(+(o > l), `,
    `).concat(u.x, ",").concat(u.y, `
  `);
  if (r > 0) {
    var f = Tt(t, n, r, o), p = Tt(t, n, r, l);
    d += "L ".concat(p.x, ",").concat(p.y, `
            A `).concat(r, ",").concat(r, `,0,
            `).concat(+(Math.abs(s) > 180), ",").concat(+(o <= l), `,
            `).concat(f.x, ",").concat(f.y, " Z");
  } else
    d += "L ".concat(t, ",").concat(n, " Z");
  return d;
}, c4 = (e) => {
  var {
    cx: t,
    cy: n,
    innerRadius: r,
    outerRadius: i,
    cornerRadius: o,
    forceCornerRadius: a,
    cornerIsExternal: s,
    startAngle: l,
    endAngle: c
  } = e, u = Ht(c - l), {
    circleTangency: d,
    lineTangency: f,
    theta: p
  } = vc({
    cx: t,
    cy: n,
    radius: i,
    angle: l,
    sign: u,
    cornerRadius: o,
    cornerIsExternal: s
  }), {
    circleTangency: g,
    lineTangency: m,
    theta: v
  } = vc({
    cx: t,
    cy: n,
    radius: i,
    angle: c,
    sign: -u,
    cornerRadius: o,
    cornerIsExternal: s
  }), y = s ? Math.abs(l - c) : Math.abs(l - c) - p - v;
  if (y < 0)
    return a ? "M ".concat(f.x, ",").concat(f.y, `
        a`).concat(o, ",").concat(o, ",0,0,1,").concat(o * 2, `,0
        a`).concat(o, ",").concat(o, ",0,0,1,").concat(-o * 2, `,0
      `) : q2({
      cx: t,
      cy: n,
      innerRadius: r,
      outerRadius: i,
      startAngle: l,
      endAngle: c
    });
  var S = "M ".concat(f.x, ",").concat(f.y, `
    A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(d.x, ",").concat(d.y, `
    A`).concat(i, ",").concat(i, ",0,").concat(+(y > 180), ",").concat(+(u < 0), ",").concat(g.x, ",").concat(g.y, `
    A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(m.x, ",").concat(m.y, `
  `);
  if (r > 0) {
    var {
      circleTangency: x,
      lineTangency: b,
      theta: w
    } = vc({
      cx: t,
      cy: n,
      radius: r,
      angle: l,
      sign: u,
      isExternal: !0,
      cornerRadius: o,
      cornerIsExternal: s
    }), {
      circleTangency: E,
      lineTangency: C,
      theta: A
    } = vc({
      cx: t,
      cy: n,
      radius: r,
      angle: c,
      sign: -u,
      isExternal: !0,
      cornerRadius: o,
      cornerIsExternal: s
    }), k = s ? Math.abs(l - c) : Math.abs(l - c) - w - A;
    if (k < 0 && o === 0)
      return "".concat(S, "L").concat(t, ",").concat(n, "Z");
    S += "L".concat(C.x, ",").concat(C.y, `
      A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(E.x, ",").concat(E.y, `
      A`).concat(r, ",").concat(r, ",0,").concat(+(k > 180), ",").concat(+(u > 0), ",").concat(x.x, ",").concat(x.y, `
      A`).concat(o, ",").concat(o, ",0,0,").concat(+(u < 0), ",").concat(b.x, ",").concat(b.y, "Z");
  } else
    S += "L".concat(t, ",").concat(n, "Z");
  return S;
}, u4 = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: !1,
  cornerIsExternal: !1
}, Y2 = (e) => {
  var t = rn(e, u4), {
    cx: n,
    cy: r,
    innerRadius: i,
    outerRadius: o,
    cornerRadius: a,
    forceCornerRadius: s,
    cornerIsExternal: l,
    startAngle: c,
    endAngle: u,
    className: d
  } = t;
  if (o < i || c === u)
    return null;
  var f = ce("recharts-sector", d), p = o - i, g = pn(a, p, 0, !0), m;
  return g > 0 && Math.abs(c - u) < 360 ? m = c4({
    cx: n,
    cy: r,
    innerRadius: i,
    outerRadius: o,
    cornerRadius: Math.min(g, p / 2),
    forceCornerRadius: s,
    cornerIsExternal: l,
    startAngle: c,
    endAngle: u
  }) : m = q2({
    cx: n,
    cy: r,
    innerRadius: i,
    outerRadius: o,
    startAngle: c,
    endAngle: u
  }), /* @__PURE__ */ _.createElement("path", dm({}, ht(t, !0), {
    className: f,
    d: m
  }));
};
function d4(e, t, n) {
  var r, i, o, a;
  if (e === "horizontal")
    r = t.x, o = r, i = n.top, a = n.top + n.height;
  else if (e === "vertical")
    i = t.y, a = i, r = n.left, o = n.left + n.width;
  else if (t.cx != null && t.cy != null)
    if (e === "centric") {
      var {
        cx: s,
        cy: l,
        innerRadius: c,
        outerRadius: u,
        angle: d
      } = t, f = Tt(s, l, c, d), p = Tt(s, l, u, d);
      r = f.x, i = f.y, o = p.x, a = p.y;
    } else
      return K2(t);
  return [{
    x: r,
    y: i
  }, {
    x: o,
    y: a
  }];
}
var Bp = {}, zp = {}, Wp = {}, e1;
function f4() {
  return e1 || (e1 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ X_();
    function n(r) {
      return t.isSymbol(r) ? NaN : Number(r);
    }
    e.toNumber = n;
  })(Wp)), Wp;
}
var t1;
function p4() {
  return t1 || (t1 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ f4();
    function n(r) {
      return r ? (r = t.toNumber(r), r === 1 / 0 || r === -1 / 0 ? (r < 0 ? -1 : 1) * Number.MAX_VALUE : r === r ? r : 0) : r === 0 ? r : 0;
    }
    e.toFinite = n;
  })(zp)), zp;
}
var n1;
function h4() {
  return n1 || (n1 = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ Z_(), n = /* @__PURE__ */ p4();
    function r(i, o, a) {
      a && typeof a != "number" && t.isIterateeCall(i, o, a) && (o = a = void 0), i = n.toFinite(i), o === void 0 ? (o = i, i = 0) : o = n.toFinite(o), a = a === void 0 ? i < o ? 1 : -1 : n.toFinite(a);
      const s = Math.max(Math.ceil((o - i) / (a || 1)), 0), l = new Array(s);
      for (let c = 0; c < s; c++)
        l[c] = i, i += a;
      return l;
    }
    e.range = r;
  })(Bp)), Bp;
}
var Vp, r1;
function m4() {
  return r1 || (r1 = 1, Vp = h4().range), Vp;
}
var g4 = /* @__PURE__ */ m4();
const G2 = /* @__PURE__ */ xi(g4);
function $i(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function v4(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Bg(e) {
  let t, n, r;
  e.length !== 2 ? (t = $i, n = (s, l) => $i(e(s), l), r = (s, l) => e(s) - l) : (t = e === $i || e === v4 ? e : y4, n = e, r = e);
  function i(s, l, c = 0, u = s.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = c + u >>> 1;
        n(s[d], l) < 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function o(s, l, c = 0, u = s.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = c + u >>> 1;
        n(s[d], l) <= 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function a(s, l, c = 0, u = s.length) {
    const d = i(s, l, c, u - 1);
    return d > c && r(s[d - 1], l) > -r(s[d], l) ? d - 1 : d;
  }
  return { left: i, center: a, right: o };
}
function y4() {
  return 0;
}
function X2(e) {
  return e === null ? NaN : +e;
}
function* b4(e, t) {
  for (let n of e)
    n != null && (n = +n) >= n && (yield n);
}
const x4 = Bg($i), jl = x4.right;
Bg(X2).center;
class i1 extends Map {
  constructor(t, n = S4) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [r, i] of t) this.set(r, i);
  }
  get(t) {
    return super.get(o1(this, t));
  }
  has(t) {
    return super.has(o1(this, t));
  }
  set(t, n) {
    return super.set(w4(this, t), n);
  }
  delete(t) {
    return super.delete(O4(this, t));
  }
}
function o1({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function w4({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function O4({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function S4(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function E4(e = $i) {
  if (e === $i) return Z2;
  if (typeof e != "function") throw new TypeError("compare is not a function");
  return (t, n) => {
    const r = e(t, n);
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function Z2(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
const _4 = Math.sqrt(50), P4 = Math.sqrt(10), C4 = Math.sqrt(2);
function _u(e, t, n) {
  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), o = r / Math.pow(10, i), a = o >= _4 ? 10 : o >= P4 ? 5 : o >= C4 ? 2 : 1;
  let s, l, c;
  return i < 0 ? (c = Math.pow(10, -i) / a, s = Math.round(e * c), l = Math.round(t * c), s / c < e && ++s, l / c > t && --l, c = -c) : (c = Math.pow(10, i) * a, s = Math.round(e / c), l = Math.round(t / c), s * c < e && ++s, l * c > t && --l), l < s && 0.5 <= n && n < 2 ? _u(e, t, n * 2) : [s, l, c];
}
function fm(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const r = t < e, [i, o, a] = r ? _u(t, e, n) : _u(e, t, n);
  if (!(o >= i)) return [];
  const s = o - i + 1, l = new Array(s);
  if (r)
    if (a < 0) for (let c = 0; c < s; ++c) l[c] = (o - c) / -a;
    else for (let c = 0; c < s; ++c) l[c] = (o - c) * a;
  else if (a < 0) for (let c = 0; c < s; ++c) l[c] = (i + c) / -a;
  else for (let c = 0; c < s; ++c) l[c] = (i + c) * a;
  return l;
}
function pm(e, t, n) {
  return t = +t, e = +e, n = +n, _u(e, t, n)[2];
}
function hm(e, t, n) {
  t = +t, e = +e, n = +n;
  const r = t < e, i = r ? pm(t, e, n) : pm(e, t, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function a1(e, t) {
  let n;
  for (const r of e)
    r != null && (n < r || n === void 0 && r >= r) && (n = r);
  return n;
}
function s1(e, t) {
  let n;
  for (const r of e)
    r != null && (n > r || n === void 0 && r >= r) && (n = r);
  return n;
}
function J2(e, t, n = 0, r = 1 / 0, i) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r)) return e;
  for (i = i === void 0 ? Z2 : E4(i); r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, c = t - n + 1, u = Math.log(l), d = 0.5 * Math.exp(2 * u / 3), f = 0.5 * Math.sqrt(u * d * (l - d) / l) * (c - l / 2 < 0 ? -1 : 1), p = Math.max(n, Math.floor(t - c * d / l + f)), g = Math.min(r, Math.floor(t + (l - c) * d / l + f));
      J2(e, t, p, g, i);
    }
    const o = e[t];
    let a = n, s = r;
    for (os(e, n, t), i(e[r], o) > 0 && os(e, n, r); a < s; ) {
      for (os(e, a, s), ++a, --s; i(e[a], o) < 0; ) ++a;
      for (; i(e[s], o) > 0; ) --s;
    }
    i(e[n], o) === 0 ? os(e, n, s) : (++s, os(e, s, r)), s <= t && (n = s + 1), t <= s && (r = s - 1);
  }
  return e;
}
function os(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function A4(e, t, n) {
  if (e = Float64Array.from(b4(e)), !(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2) return s1(e);
    if (t >= 1) return a1(e);
    var r, i = (r - 1) * t, o = Math.floor(i), a = a1(J2(e, o).subarray(0, o + 1)), s = s1(e.subarray(o + 1));
    return a + (s - a) * (i - o);
  }
}
function T4(e, t, n = X2) {
  if (!(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2) return +n(e[0], 0, e);
    if (t >= 1) return +n(e[r - 1], r - 1, e);
    var r, i = (r - 1) * t, o = Math.floor(i), a = +n(e[o], o, e), s = +n(e[o + 1], o + 1, e);
    return a + (s - a) * (i - o);
  }
}
function k4(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e + r * n;
  return o;
}
function gr(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Si(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const mm = Symbol("implicit");
function zg() {
  var e = new i1(), t = [], n = [], r = mm;
  function i(o) {
    let a = e.get(o);
    if (a === void 0) {
      if (r !== mm) return r;
      e.set(o, a = t.push(o) - 1);
    }
    return n[a % n.length];
  }
  return i.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new i1();
    for (const a of o)
      e.has(a) || e.set(a, t.push(a) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (n = Array.from(o), i) : n.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return zg(t, n).unknown(r);
  }, gr.apply(i, arguments), i;
}
function Wg() {
  var e = zg().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, o, a, s = !1, l = 0, c = 0, u = 0.5;
  delete e.unknown;
  function d() {
    var f = t().length, p = i < r, g = p ? i : r, m = p ? r : i;
    o = (m - g) / Math.max(1, f - l + c * 2), s && (o = Math.floor(o)), g += (m - g - o * (f - l)) * u, a = o * (1 - l), s && (g = Math.round(g), a = Math.round(a));
    var v = k4(f).map(function(y) {
      return g + o * y;
    });
    return n(p ? v.reverse() : v);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), d()) : t();
  }, e.range = function(f) {
    return arguments.length ? ([r, i] = f, r = +r, i = +i, d()) : [r, i];
  }, e.rangeRound = function(f) {
    return [r, i] = f, r = +r, i = +i, s = !0, d();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return o;
  }, e.round = function(f) {
    return arguments.length ? (s = !!f, d()) : s;
  }, e.padding = function(f) {
    return arguments.length ? (l = Math.min(1, c = +f), d()) : l;
  }, e.paddingInner = function(f) {
    return arguments.length ? (l = Math.min(1, f), d()) : l;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (c = +f, d()) : c;
  }, e.align = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), d()) : u;
  }, e.copy = function() {
    return Wg(t(), [r, i]).round(s).paddingInner(l).paddingOuter(c).align(u);
  }, gr.apply(d(), arguments);
}
function Q2(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Q2(t());
  }, e;
}
function M4() {
  return Q2(Wg.apply(null, arguments).paddingInner(1));
}
function Vg(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function eP(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function Nl() {
}
var Zs = 0.7, Pu = 1 / Zs, ga = "\\s*([+-]?\\d+)\\s*", Js = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Dr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", j4 = /^#([0-9a-f]{3,8})$/, N4 = new RegExp(`^rgb\\(${ga},${ga},${ga}\\)$`), D4 = new RegExp(`^rgb\\(${Dr},${Dr},${Dr}\\)$`), R4 = new RegExp(`^rgba\\(${ga},${ga},${ga},${Js}\\)$`), I4 = new RegExp(`^rgba\\(${Dr},${Dr},${Dr},${Js}\\)$`), $4 = new RegExp(`^hsl\\(${Js},${Dr},${Dr}\\)$`), L4 = new RegExp(`^hsla\\(${Js},${Dr},${Dr},${Js}\\)$`), l1 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Vg(Nl, Qs, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: c1,
  // Deprecated! Use color.formatHex.
  formatHex: c1,
  formatHex8: F4,
  formatHsl: B4,
  formatRgb: u1,
  toString: u1
});
function c1() {
  return this.rgb().formatHex();
}
function F4() {
  return this.rgb().formatHex8();
}
function B4() {
  return tP(this).formatHsl();
}
function u1() {
  return this.rgb().formatRgb();
}
function Qs(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = j4.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? d1(t) : n === 3 ? new Cn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? yc(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? yc(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = N4.exec(e)) ? new Cn(t[1], t[2], t[3], 1) : (t = D4.exec(e)) ? new Cn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = R4.exec(e)) ? yc(t[1], t[2], t[3], t[4]) : (t = I4.exec(e)) ? yc(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = $4.exec(e)) ? h1(t[1], t[2] / 100, t[3] / 100, 1) : (t = L4.exec(e)) ? h1(t[1], t[2] / 100, t[3] / 100, t[4]) : l1.hasOwnProperty(e) ? d1(l1[e]) : e === "transparent" ? new Cn(NaN, NaN, NaN, 0) : null;
}
function d1(e) {
  return new Cn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function yc(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Cn(e, t, n, r);
}
function z4(e) {
  return e instanceof Nl || (e = Qs(e)), e ? (e = e.rgb(), new Cn(e.r, e.g, e.b, e.opacity)) : new Cn();
}
function gm(e, t, n, r) {
  return arguments.length === 1 ? z4(e) : new Cn(e, t, n, r ?? 1);
}
function Cn(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
Vg(Cn, gm, eP(Nl, {
  brighter(e) {
    return e = e == null ? Pu : Math.pow(Pu, e), new Cn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Zs : Math.pow(Zs, e), new Cn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Cn(ko(this.r), ko(this.g), ko(this.b), Cu(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: f1,
  // Deprecated! Use color.formatHex.
  formatHex: f1,
  formatHex8: W4,
  formatRgb: p1,
  toString: p1
}));
function f1() {
  return `#${Oo(this.r)}${Oo(this.g)}${Oo(this.b)}`;
}
function W4() {
  return `#${Oo(this.r)}${Oo(this.g)}${Oo(this.b)}${Oo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function p1() {
  const e = Cu(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${ko(this.r)}, ${ko(this.g)}, ${ko(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Cu(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function ko(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Oo(e) {
  return e = ko(e), (e < 16 ? "0" : "") + e.toString(16);
}
function h1(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new yr(e, t, n, r);
}
function tP(e) {
  if (e instanceof yr) return new yr(e.h, e.s, e.l, e.opacity);
  if (e instanceof Nl || (e = Qs(e)), !e) return new yr();
  if (e instanceof yr) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), a = NaN, s = o - i, l = (o + i) / 2;
  return s ? (t === o ? a = (n - r) / s + (n < r) * 6 : n === o ? a = (r - t) / s + 2 : a = (t - n) / s + 4, s /= l < 0.5 ? o + i : 2 - o - i, a *= 60) : s = l > 0 && l < 1 ? 0 : a, new yr(a, s, l, e.opacity);
}
function V4(e, t, n, r) {
  return arguments.length === 1 ? tP(e) : new yr(e, t, n, r ?? 1);
}
function yr(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
Vg(yr, V4, eP(Nl, {
  brighter(e) {
    return e = e == null ? Pu : Math.pow(Pu, e), new yr(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Zs : Math.pow(Zs, e), new yr(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new Cn(
      Up(e >= 240 ? e - 240 : e + 120, i, r),
      Up(e, i, r),
      Up(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new yr(m1(this.h), bc(this.s), bc(this.l), Cu(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Cu(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${m1(this.h)}, ${bc(this.s) * 100}%, ${bc(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function m1(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function bc(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Up(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const Ug = (e) => () => e;
function U4(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function H4(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function K4(e) {
  return (e = +e) == 1 ? nP : function(t, n) {
    return n - t ? H4(t, n, e) : Ug(isNaN(t) ? n : t);
  };
}
function nP(e, t) {
  var n = t - e;
  return n ? U4(e, n) : Ug(isNaN(e) ? t : e);
}
const g1 = (function e(t) {
  var n = K4(t);
  function r(i, o) {
    var a = n((i = gm(i)).r, (o = gm(o)).r), s = n(i.g, o.g), l = n(i.b, o.b), c = nP(i.opacity, o.opacity);
    return function(u) {
      return i.r = a(u), i.g = s(u), i.b = l(u), i.opacity = c(u), i + "";
    };
  }
  return r.gamma = e, r;
})(1);
function q4(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(o) {
    for (i = 0; i < n; ++i) r[i] = e[i] * (1 - o) + t[i] * o;
    return r;
  };
}
function Y4(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function G4(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), o = new Array(n), a;
  for (a = 0; a < r; ++a) i[a] = Fa(e[a], t[a]);
  for (; a < n; ++a) o[a] = t[a];
  return function(s) {
    for (a = 0; a < r; ++a) o[a] = i[a](s);
    return o;
  };
}
function X4(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function Au(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function Z4(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = Fa(e[i], t[i]) : r[i] = t[i];
  return function(o) {
    for (i in n) r[i] = n[i](o);
    return r;
  };
}
var vm = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Hp = new RegExp(vm.source, "g");
function J4(e) {
  return function() {
    return e;
  };
}
function Q4(e) {
  return function(t) {
    return e(t) + "";
  };
}
function eF(e, t) {
  var n = vm.lastIndex = Hp.lastIndex = 0, r, i, o, a = -1, s = [], l = [];
  for (e = e + "", t = t + ""; (r = vm.exec(e)) && (i = Hp.exec(t)); )
    (o = i.index) > n && (o = t.slice(n, o), s[a] ? s[a] += o : s[++a] = o), (r = r[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null, l.push({ i: a, x: Au(r, i) })), n = Hp.lastIndex;
  return n < t.length && (o = t.slice(n), s[a] ? s[a] += o : s[++a] = o), s.length < 2 ? l[0] ? Q4(l[0].x) : J4(t) : (t = l.length, function(c) {
    for (var u = 0, d; u < t; ++u) s[(d = l[u]).i] = d.x(c);
    return s.join("");
  });
}
function Fa(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? Ug(t) : (n === "number" ? Au : n === "string" ? (r = Qs(t)) ? (t = r, g1) : eF : t instanceof Qs ? g1 : t instanceof Date ? X4 : Y4(t) ? q4 : Array.isArray(t) ? G4 : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Z4 : Au)(e, t);
}
function Hg(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
function tF(e, t) {
  t === void 0 && (t = e, e = Fa);
  for (var n = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); n < r; ) o[n] = e(i, i = t[++n]);
  return function(a) {
    var s = Math.max(0, Math.min(r - 1, Math.floor(a *= r)));
    return o[s](a - s);
  };
}
function nF(e) {
  return function() {
    return e;
  };
}
function Tu(e) {
  return +e;
}
var v1 = [0, 1];
function yn(e) {
  return e;
}
function ym(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : nF(isNaN(t) ? NaN : 0.5);
}
function rF(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function iF(e, t, n) {
  var r = e[0], i = e[1], o = t[0], a = t[1];
  return i < r ? (r = ym(i, r), o = n(a, o)) : (r = ym(r, i), o = n(o, a)), function(s) {
    return o(r(s));
  };
}
function oF(e, t, n) {
  var r = Math.min(e.length, t.length) - 1, i = new Array(r), o = new Array(r), a = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )
    i[a] = ym(e[a], e[a + 1]), o[a] = n(t[a], t[a + 1]);
  return function(s) {
    var l = jl(e, s, 1, r) - 1;
    return o[l](i[l](s));
  };
}
function Dl(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function Ud() {
  var e = v1, t = v1, n = Fa, r, i, o, a = yn, s, l, c;
  function u() {
    var f = Math.min(e.length, t.length);
    return a !== yn && (a = rF(e[0], e[f - 1])), s = f > 2 ? oF : iF, l = c = null, d;
  }
  function d(f) {
    return f == null || isNaN(f = +f) ? o : (l || (l = s(e.map(r), t, n)))(r(a(f)));
  }
  return d.invert = function(f) {
    return a(i((c || (c = s(t, e.map(r), Au)))(f)));
  }, d.domain = function(f) {
    return arguments.length ? (e = Array.from(f, Tu), u()) : e.slice();
  }, d.range = function(f) {
    return arguments.length ? (t = Array.from(f), u()) : t.slice();
  }, d.rangeRound = function(f) {
    return t = Array.from(f), n = Hg, u();
  }, d.clamp = function(f) {
    return arguments.length ? (a = f ? !0 : yn, u()) : a !== yn;
  }, d.interpolate = function(f) {
    return arguments.length ? (n = f, u()) : n;
  }, d.unknown = function(f) {
    return arguments.length ? (o = f, d) : o;
  }, function(f, p) {
    return r = f, i = p, u();
  };
}
function Kg() {
  return Ud()(yn, yn);
}
function aF(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function ku(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
  var n, r = e.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(n + 1)
  ];
}
function _a(e) {
  return e = ku(Math.abs(e)), e ? e[1] : NaN;
}
function sF(e, t) {
  return function(n, r) {
    for (var i = n.length, o = [], a = 0, s = e[0], l = 0; i > 0 && s > 0 && (l + s + 1 > r && (s = Math.max(1, r - l)), o.push(n.substring(i -= s, i + s)), !((l += s + 1) > r)); )
      s = e[a = (a + 1) % e.length];
    return o.reverse().join(t);
  };
}
function lF(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var cF = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function el(e) {
  if (!(t = cF.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new qg({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
el.prototype = qg.prototype;
function qg(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
qg.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function uF(e) {
  e: for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
    switch (e[n]) {
      case ".":
        r = i = n;
        break;
      case "0":
        r === 0 && (r = n), i = n;
        break;
      default:
        if (!+e[n]) break e;
        r > 0 && (r = 0);
        break;
    }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
}
var rP;
function dF(e, t) {
  var n = ku(e, t);
  if (!n) return e + "";
  var r = n[0], i = n[1], o = i - (rP = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;
  return o === a ? r : o > a ? r + new Array(o - a + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + ku(e, Math.max(0, t + o - 1))[0];
}
function y1(e, t) {
  var n = ku(e, t);
  if (!n) return e + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const b1 = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: aF,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => y1(e * 100, t),
  r: y1,
  s: dF,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function x1(e) {
  return e;
}
var w1 = Array.prototype.map, O1 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function fF(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? x1 : sF(w1.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? x1 : lF(w1.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", s = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function c(d) {
    d = el(d);
    var f = d.fill, p = d.align, g = d.sign, m = d.symbol, v = d.zero, y = d.width, S = d.comma, x = d.precision, b = d.trim, w = d.type;
    w === "n" ? (S = !0, w = "g") : b1[w] || (x === void 0 && (x = 12), b = !0, w = "g"), (v || f === "0" && p === "=") && (v = !0, f = "0", p = "=");
    var E = m === "$" ? n : m === "#" && /[boxX]/.test(w) ? "0" + w.toLowerCase() : "", C = m === "$" ? r : /[%p]/.test(w) ? a : "", A = b1[w], k = /[defgprs%]/.test(w);
    x = x === void 0 ? 6 : /[gprs]/.test(w) ? Math.max(1, Math.min(21, x)) : Math.max(0, Math.min(20, x));
    function R(M) {
      var P = E, D = C, j, N, $;
      if (w === "c")
        D = A(M) + D, M = "";
      else {
        M = +M;
        var F = M < 0 || 1 / M < 0;
        if (M = isNaN(M) ? l : A(Math.abs(M), x), b && (M = uF(M)), F && +M == 0 && g !== "+" && (F = !1), P = (F ? g === "(" ? g : s : g === "-" || g === "(" ? "" : g) + P, D = (w === "s" ? O1[8 + rP / 3] : "") + D + (F && g === "(" ? ")" : ""), k) {
          for (j = -1, N = M.length; ++j < N; )
            if ($ = M.charCodeAt(j), 48 > $ || $ > 57) {
              D = ($ === 46 ? i + M.slice(j + 1) : M.slice(j)) + D, M = M.slice(0, j);
              break;
            }
        }
      }
      S && !v && (M = t(M, 1 / 0));
      var q = P.length + M.length + D.length, B = q < y ? new Array(y - q + 1).join(f) : "";
      switch (S && v && (M = t(B + M, B.length ? y - D.length : 1 / 0), B = ""), p) {
        case "<":
          M = P + M + D + B;
          break;
        case "=":
          M = P + B + M + D;
          break;
        case "^":
          M = B.slice(0, q = B.length >> 1) + P + M + D + B.slice(q);
          break;
        default:
          M = B + P + M + D;
          break;
      }
      return o(M);
    }
    return R.toString = function() {
      return d + "";
    }, R;
  }
  function u(d, f) {
    var p = c((d = el(d), d.type = "f", d)), g = Math.max(-8, Math.min(8, Math.floor(_a(f) / 3))) * 3, m = Math.pow(10, -g), v = O1[8 + g / 3];
    return function(y) {
      return p(m * y) + v;
    };
  }
  return {
    format: c,
    formatPrefix: u
  };
}
var xc, Yg, iP;
pF({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function pF(e) {
  return xc = fF(e), Yg = xc.format, iP = xc.formatPrefix, xc;
}
function hF(e) {
  return Math.max(0, -_a(Math.abs(e)));
}
function mF(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(_a(t) / 3))) * 3 - _a(Math.abs(e)));
}
function gF(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, _a(t) - _a(e)) + 1;
}
function oP(e, t, n, r) {
  var i = hm(e, t, n), o;
  switch (r = el(r ?? ",f"), r.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(o = mF(i, a)) && (r.precision = o), iP(r, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(o = gF(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = o - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(o = hF(i)) && (r.precision = o - (r.type === "%") * 2);
      break;
    }
  }
  return Yg(r);
}
function Xi(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var r = t();
    return fm(r[0], r[r.length - 1], n ?? 10);
  }, e.tickFormat = function(n, r) {
    var i = t();
    return oP(i[0], i[i.length - 1], n ?? 10, r);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, o = r.length - 1, a = r[i], s = r[o], l, c, u = 10;
    for (s < a && (c = a, a = s, s = c, c = i, i = o, o = c); u-- > 0; ) {
      if (c = pm(a, s, n), c === l)
        return r[i] = a, r[o] = s, t(r);
      if (c > 0)
        a = Math.floor(a / c) * c, s = Math.ceil(s / c) * c;
      else if (c < 0)
        a = Math.ceil(a * c) / c, s = Math.floor(s * c) / c;
      else
        break;
      l = c;
    }
    return e;
  }, e;
}
function aP() {
  var e = Kg();
  return e.copy = function() {
    return Dl(e, aP());
  }, gr.apply(e, arguments), Xi(e);
}
function sP(e) {
  var t;
  function n(r) {
    return r == null || isNaN(r = +r) ? t : r;
  }
  return n.invert = n, n.domain = n.range = function(r) {
    return arguments.length ? (e = Array.from(r, Tu), n) : e.slice();
  }, n.unknown = function(r) {
    return arguments.length ? (t = r, n) : t;
  }, n.copy = function() {
    return sP(e).unknown(t);
  }, e = arguments.length ? Array.from(e, Tu) : [0, 1], Xi(n);
}
function lP(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], o = e[r], a;
  return o < i && (a = n, n = r, r = a, a = i, i = o, o = a), e[n] = t.floor(i), e[r] = t.ceil(o), e;
}
function S1(e) {
  return Math.log(e);
}
function E1(e) {
  return Math.exp(e);
}
function vF(e) {
  return -Math.log(-e);
}
function yF(e) {
  return -Math.exp(-e);
}
function bF(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function xF(e) {
  return e === 10 ? bF : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function wF(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function _1(e) {
  return (t, n) => -e(-t, n);
}
function Gg(e) {
  const t = e(S1, E1), n = t.domain;
  let r = 10, i, o;
  function a() {
    return i = wF(r), o = xF(r), n()[0] < 0 ? (i = _1(i), o = _1(o), e(vF, yF)) : e(S1, E1), t;
  }
  return t.base = function(s) {
    return arguments.length ? (r = +s, a()) : r;
  }, t.domain = function(s) {
    return arguments.length ? (n(s), a()) : n();
  }, t.ticks = (s) => {
    const l = n();
    let c = l[0], u = l[l.length - 1];
    const d = u < c;
    d && ([c, u] = [u, c]);
    let f = i(c), p = i(u), g, m;
    const v = s == null ? 10 : +s;
    let y = [];
    if (!(r % 1) && p - f < v) {
      if (f = Math.floor(f), p = Math.ceil(p), c > 0) {
        for (; f <= p; ++f)
          for (g = 1; g < r; ++g)
            if (m = f < 0 ? g / o(-f) : g * o(f), !(m < c)) {
              if (m > u) break;
              y.push(m);
            }
      } else for (; f <= p; ++f)
        for (g = r - 1; g >= 1; --g)
          if (m = f > 0 ? g / o(-f) : g * o(f), !(m < c)) {
            if (m > u) break;
            y.push(m);
          }
      y.length * 2 < v && (y = fm(c, u, v));
    } else
      y = fm(f, p, Math.min(p - f, v)).map(o);
    return d ? y.reverse() : y;
  }, t.tickFormat = (s, l) => {
    if (s == null && (s = 10), l == null && (l = r === 10 ? "s" : ","), typeof l != "function" && (!(r % 1) && (l = el(l)).precision == null && (l.trim = !0), l = Yg(l)), s === 1 / 0) return l;
    const c = Math.max(1, r * s / t.ticks().length);
    return (u) => {
      let d = u / o(Math.round(i(u)));
      return d * r < r - 0.5 && (d *= r), d <= c ? l(u) : "";
    };
  }, t.nice = () => n(lP(n(), {
    floor: (s) => o(Math.floor(i(s))),
    ceil: (s) => o(Math.ceil(i(s)))
  })), t;
}
function cP() {
  const e = Gg(Ud()).domain([1, 10]);
  return e.copy = () => Dl(e, cP()).base(e.base()), gr.apply(e, arguments), e;
}
function P1(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function C1(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function Xg(e) {
  var t = 1, n = e(P1(t), C1(t));
  return n.constant = function(r) {
    return arguments.length ? e(P1(t = +r), C1(t)) : t;
  }, Xi(n);
}
function uP() {
  var e = Xg(Ud());
  return e.copy = function() {
    return Dl(e, uP()).constant(e.constant());
  }, gr.apply(e, arguments);
}
function A1(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function OF(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function SF(e) {
  return e < 0 ? -e * e : e * e;
}
function Zg(e) {
  var t = e(yn, yn), n = 1;
  function r() {
    return n === 1 ? e(yn, yn) : n === 0.5 ? e(OF, SF) : e(A1(n), A1(1 / n));
  }
  return t.exponent = function(i) {
    return arguments.length ? (n = +i, r()) : n;
  }, Xi(t);
}
function Jg() {
  var e = Zg(Ud());
  return e.copy = function() {
    return Dl(e, Jg()).exponent(e.exponent());
  }, gr.apply(e, arguments), e;
}
function EF() {
  return Jg.apply(null, arguments).exponent(0.5);
}
function T1(e) {
  return Math.sign(e) * e * e;
}
function _F(e) {
  return Math.sign(e) * Math.sqrt(Math.abs(e));
}
function dP() {
  var e = Kg(), t = [0, 1], n = !1, r;
  function i(o) {
    var a = _F(e(o));
    return isNaN(a) ? r : n ? Math.round(a) : a;
  }
  return i.invert = function(o) {
    return e.invert(T1(o));
  }, i.domain = function(o) {
    return arguments.length ? (e.domain(o), i) : e.domain();
  }, i.range = function(o) {
    return arguments.length ? (e.range((t = Array.from(o, Tu)).map(T1)), i) : t.slice();
  }, i.rangeRound = function(o) {
    return i.range(o).round(!0);
  }, i.round = function(o) {
    return arguments.length ? (n = !!o, i) : n;
  }, i.clamp = function(o) {
    return arguments.length ? (e.clamp(o), i) : e.clamp();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return dP(e.domain(), t).round(n).clamp(e.clamp()).unknown(r);
  }, gr.apply(i, arguments), Xi(i);
}
function fP() {
  var e = [], t = [], n = [], r;
  function i() {
    var a = 0, s = Math.max(1, t.length);
    for (n = new Array(s - 1); ++a < s; ) n[a - 1] = T4(e, a / s);
    return o;
  }
  function o(a) {
    return a == null || isNaN(a = +a) ? r : t[jl(n, a)];
  }
  return o.invertExtent = function(a) {
    var s = t.indexOf(a);
    return s < 0 ? [NaN, NaN] : [
      s > 0 ? n[s - 1] : e[0],
      s < n.length ? n[s] : e[e.length - 1]
    ];
  }, o.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let s of a) s != null && !isNaN(s = +s) && e.push(s);
    return e.sort($i), i();
  }, o.range = function(a) {
    return arguments.length ? (t = Array.from(a), i()) : t.slice();
  }, o.unknown = function(a) {
    return arguments.length ? (r = a, o) : r;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return fP().domain(e).range(t).unknown(r);
  }, gr.apply(o, arguments);
}
function pP() {
  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], o;
  function a(l) {
    return l != null && l <= l ? i[jl(r, l, 0, n)] : o;
  }
  function s() {
    var l = -1;
    for (r = new Array(n); ++l < n; ) r[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
    return a;
  }
  return a.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, s()) : [e, t];
  }, a.range = function(l) {
    return arguments.length ? (n = (i = Array.from(l)).length - 1, s()) : i.slice();
  }, a.invertExtent = function(l) {
    var c = i.indexOf(l);
    return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]];
  }, a.unknown = function(l) {
    return arguments.length && (o = l), a;
  }, a.thresholds = function() {
    return r.slice();
  }, a.copy = function() {
    return pP().domain([e, t]).range(i).unknown(o);
  }, gr.apply(Xi(a), arguments);
}
function hP() {
  var e = [0.5], t = [0, 1], n, r = 1;
  function i(o) {
    return o != null && o <= o ? t[jl(e, o, 0, r)] : n;
  }
  return i.domain = function(o) {
    return arguments.length ? (e = Array.from(o), r = Math.min(e.length, t.length - 1), i) : e.slice();
  }, i.range = function(o) {
    return arguments.length ? (t = Array.from(o), r = Math.min(e.length, t.length - 1), i) : t.slice();
  }, i.invertExtent = function(o) {
    var a = t.indexOf(o);
    return [e[a - 1], e[a]];
  }, i.unknown = function(o) {
    return arguments.length ? (n = o, i) : n;
  }, i.copy = function() {
    return hP().domain(e).range(t).unknown(n);
  }, gr.apply(i, arguments);
}
const Kp = /* @__PURE__ */ new Date(), qp = /* @__PURE__ */ new Date();
function Ft(e, t, n, r) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), i.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), i.round = (o) => {
    const a = i(o), s = i.ceil(o);
    return o - a < s - o ? a : s;
  }, i.offset = (o, a) => (t(o = /* @__PURE__ */ new Date(+o), a == null ? 1 : Math.floor(a)), o), i.range = (o, a, s) => {
    const l = [];
    if (o = i.ceil(o), s = s == null ? 1 : Math.floor(s), !(o < a) || !(s > 0)) return l;
    let c;
    do
      l.push(c = /* @__PURE__ */ new Date(+o)), t(o, s), e(o);
    while (c < o && o < a);
    return l;
  }, i.filter = (o) => Ft((a) => {
    if (a >= a) for (; e(a), !o(a); ) a.setTime(a - 1);
  }, (a, s) => {
    if (a >= a)
      if (s < 0) for (; ++s <= 0; )
        for (; t(a, -1), !o(a); )
          ;
      else for (; --s >= 0; )
        for (; t(a, 1), !o(a); )
          ;
  }), n && (i.count = (o, a) => (Kp.setTime(+o), qp.setTime(+a), e(Kp), e(qp), Math.floor(n(Kp, qp))), i.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(r ? (a) => r(a) % o === 0 : (a) => i.count(0, a) % o === 0) : i)), i;
}
const Mu = Ft(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Mu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Ft((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Mu);
Mu.range;
const ai = 1e3, ar = ai * 60, si = ar * 60, mi = si * 24, Qg = mi * 7, k1 = mi * 30, Yp = mi * 365, So = Ft((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * ai);
}, (e, t) => (t - e) / ai, (e) => e.getUTCSeconds());
So.range;
const ev = Ft((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ai);
}, (e, t) => {
  e.setTime(+e + t * ar);
}, (e, t) => (t - e) / ar, (e) => e.getMinutes());
ev.range;
const tv = Ft((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * ar);
}, (e, t) => (t - e) / ar, (e) => e.getUTCMinutes());
tv.range;
const nv = Ft((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ai - e.getMinutes() * ar);
}, (e, t) => {
  e.setTime(+e + t * si);
}, (e, t) => (t - e) / si, (e) => e.getHours());
nv.range;
const rv = Ft((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * si);
}, (e, t) => (t - e) / si, (e) => e.getUTCHours());
rv.range;
const Rl = Ft(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * ar) / mi,
  (e) => e.getDate() - 1
);
Rl.range;
const Hd = Ft((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / mi, (e) => e.getUTCDate() - 1);
Hd.range;
const mP = Ft((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / mi, (e) => Math.floor(e / mi));
mP.range;
function Uo(e) {
  return Ft((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * ar) / Qg);
}
const Kd = Uo(0), ju = Uo(1), PF = Uo(2), CF = Uo(3), Pa = Uo(4), AF = Uo(5), TF = Uo(6);
Kd.range;
ju.range;
PF.range;
CF.range;
Pa.range;
AF.range;
TF.range;
function Ho(e) {
  return Ft((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / Qg);
}
const qd = Ho(0), Nu = Ho(1), kF = Ho(2), MF = Ho(3), Ca = Ho(4), jF = Ho(5), NF = Ho(6);
qd.range;
Nu.range;
kF.range;
MF.range;
Ca.range;
jF.range;
NF.range;
const iv = Ft((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
iv.range;
const ov = Ft((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
ov.range;
const gi = Ft((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
gi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ft((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
gi.range;
const vi = Ft((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
vi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ft((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
vi.range;
function gP(e, t, n, r, i, o) {
  const a = [
    [So, 1, ai],
    [So, 5, 5 * ai],
    [So, 15, 15 * ai],
    [So, 30, 30 * ai],
    [o, 1, ar],
    [o, 5, 5 * ar],
    [o, 15, 15 * ar],
    [o, 30, 30 * ar],
    [i, 1, si],
    [i, 3, 3 * si],
    [i, 6, 6 * si],
    [i, 12, 12 * si],
    [r, 1, mi],
    [r, 2, 2 * mi],
    [n, 1, Qg],
    [t, 1, k1],
    [t, 3, 3 * k1],
    [e, 1, Yp]
  ];
  function s(c, u, d) {
    const f = u < c;
    f && ([c, u] = [u, c]);
    const p = d && typeof d.range == "function" ? d : l(c, u, d), g = p ? p.range(c, +u + 1) : [];
    return f ? g.reverse() : g;
  }
  function l(c, u, d) {
    const f = Math.abs(u - c) / d, p = Bg(([, , v]) => v).right(a, f);
    if (p === a.length) return e.every(hm(c / Yp, u / Yp, d));
    if (p === 0) return Mu.every(Math.max(hm(c, u, d), 1));
    const [g, m] = a[f / a[p - 1][2] < a[p][2] / f ? p - 1 : p];
    return g.every(m);
  }
  return [s, l];
}
const [DF, RF] = gP(vi, ov, qd, mP, rv, tv), [IF, $F] = gP(gi, iv, Kd, Rl, nv, ev);
function Gp(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Xp(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function as(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function LF(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, o = e.days, a = e.shortDays, s = e.months, l = e.shortMonths, c = ss(i), u = ls(i), d = ss(o), f = ls(o), p = ss(a), g = ls(a), m = ss(s), v = ls(s), y = ss(l), S = ls(l), x = {
    a: F,
    A: q,
    b: B,
    B: L,
    c: null,
    d: I1,
    e: I1,
    f: sB,
    g: vB,
    G: bB,
    H: iB,
    I: oB,
    j: aB,
    L: vP,
    m: lB,
    M: cB,
    p: Y,
    q: K,
    Q: F1,
    s: B1,
    S: uB,
    u: dB,
    U: fB,
    V: pB,
    w: hB,
    W: mB,
    x: null,
    X: null,
    y: gB,
    Y: yB,
    Z: xB,
    "%": L1
  }, b = {
    a: te,
    A: J,
    b: Q,
    B: ne,
    c: null,
    d: $1,
    e: $1,
    f: EB,
    g: DB,
    G: IB,
    H: wB,
    I: OB,
    j: SB,
    L: bP,
    m: _B,
    M: PB,
    p: re,
    q: ie,
    Q: F1,
    s: B1,
    S: CB,
    u: AB,
    U: TB,
    V: kB,
    w: MB,
    W: jB,
    x: null,
    X: null,
    y: NB,
    Y: RB,
    Z: $B,
    "%": L1
  }, w = {
    a: R,
    A: M,
    b: P,
    B: D,
    c: j,
    d: D1,
    e: D1,
    f: eB,
    g: N1,
    G: j1,
    H: R1,
    I: R1,
    j: XF,
    L: QF,
    m: GF,
    M: ZF,
    p: k,
    q: YF,
    Q: nB,
    s: rB,
    S: JF,
    u: VF,
    U: UF,
    V: HF,
    w: WF,
    W: KF,
    x: N,
    X: $,
    y: N1,
    Y: j1,
    Z: qF,
    "%": tB
  };
  x.x = E(n, x), x.X = E(r, x), x.c = E(t, x), b.x = E(n, b), b.X = E(r, b), b.c = E(t, b);
  function E(U, H) {
    return function(Z) {
      var T = [], de = -1, ee = 0, he = U.length, be, Se, Ce;
      for (Z instanceof Date || (Z = /* @__PURE__ */ new Date(+Z)); ++de < he; )
        U.charCodeAt(de) === 37 && (T.push(U.slice(ee, de)), (Se = M1[be = U.charAt(++de)]) != null ? be = U.charAt(++de) : Se = be === "e" ? " " : "0", (Ce = H[be]) && (be = Ce(Z, Se)), T.push(be), ee = de + 1);
      return T.push(U.slice(ee, de)), T.join("");
    };
  }
  function C(U, H) {
    return function(Z) {
      var T = as(1900, void 0, 1), de = A(T, U, Z += "", 0), ee, he;
      if (de != Z.length) return null;
      if ("Q" in T) return new Date(T.Q);
      if ("s" in T) return new Date(T.s * 1e3 + ("L" in T ? T.L : 0));
      if (H && !("Z" in T) && (T.Z = 0), "p" in T && (T.H = T.H % 12 + T.p * 12), T.m === void 0 && (T.m = "q" in T ? T.q : 0), "V" in T) {
        if (T.V < 1 || T.V > 53) return null;
        "w" in T || (T.w = 1), "Z" in T ? (ee = Xp(as(T.y, 0, 1)), he = ee.getUTCDay(), ee = he > 4 || he === 0 ? Nu.ceil(ee) : Nu(ee), ee = Hd.offset(ee, (T.V - 1) * 7), T.y = ee.getUTCFullYear(), T.m = ee.getUTCMonth(), T.d = ee.getUTCDate() + (T.w + 6) % 7) : (ee = Gp(as(T.y, 0, 1)), he = ee.getDay(), ee = he > 4 || he === 0 ? ju.ceil(ee) : ju(ee), ee = Rl.offset(ee, (T.V - 1) * 7), T.y = ee.getFullYear(), T.m = ee.getMonth(), T.d = ee.getDate() + (T.w + 6) % 7);
      } else ("W" in T || "U" in T) && ("w" in T || (T.w = "u" in T ? T.u % 7 : "W" in T ? 1 : 0), he = "Z" in T ? Xp(as(T.y, 0, 1)).getUTCDay() : Gp(as(T.y, 0, 1)).getDay(), T.m = 0, T.d = "W" in T ? (T.w + 6) % 7 + T.W * 7 - (he + 5) % 7 : T.w + T.U * 7 - (he + 6) % 7);
      return "Z" in T ? (T.H += T.Z / 100 | 0, T.M += T.Z % 100, Xp(T)) : Gp(T);
    };
  }
  function A(U, H, Z, T) {
    for (var de = 0, ee = H.length, he = Z.length, be, Se; de < ee; ) {
      if (T >= he) return -1;
      if (be = H.charCodeAt(de++), be === 37) {
        if (be = H.charAt(de++), Se = w[be in M1 ? H.charAt(de++) : be], !Se || (T = Se(U, Z, T)) < 0) return -1;
      } else if (be != Z.charCodeAt(T++))
        return -1;
    }
    return T;
  }
  function k(U, H, Z) {
    var T = c.exec(H.slice(Z));
    return T ? (U.p = u.get(T[0].toLowerCase()), Z + T[0].length) : -1;
  }
  function R(U, H, Z) {
    var T = p.exec(H.slice(Z));
    return T ? (U.w = g.get(T[0].toLowerCase()), Z + T[0].length) : -1;
  }
  function M(U, H, Z) {
    var T = d.exec(H.slice(Z));
    return T ? (U.w = f.get(T[0].toLowerCase()), Z + T[0].length) : -1;
  }
  function P(U, H, Z) {
    var T = y.exec(H.slice(Z));
    return T ? (U.m = S.get(T[0].toLowerCase()), Z + T[0].length) : -1;
  }
  function D(U, H, Z) {
    var T = m.exec(H.slice(Z));
    return T ? (U.m = v.get(T[0].toLowerCase()), Z + T[0].length) : -1;
  }
  function j(U, H, Z) {
    return A(U, t, H, Z);
  }
  function N(U, H, Z) {
    return A(U, n, H, Z);
  }
  function $(U, H, Z) {
    return A(U, r, H, Z);
  }
  function F(U) {
    return a[U.getDay()];
  }
  function q(U) {
    return o[U.getDay()];
  }
  function B(U) {
    return l[U.getMonth()];
  }
  function L(U) {
    return s[U.getMonth()];
  }
  function Y(U) {
    return i[+(U.getHours() >= 12)];
  }
  function K(U) {
    return 1 + ~~(U.getMonth() / 3);
  }
  function te(U) {
    return a[U.getUTCDay()];
  }
  function J(U) {
    return o[U.getUTCDay()];
  }
  function Q(U) {
    return l[U.getUTCMonth()];
  }
  function ne(U) {
    return s[U.getUTCMonth()];
  }
  function re(U) {
    return i[+(U.getUTCHours() >= 12)];
  }
  function ie(U) {
    return 1 + ~~(U.getUTCMonth() / 3);
  }
  return {
    format: function(U) {
      var H = E(U += "", x);
      return H.toString = function() {
        return U;
      }, H;
    },
    parse: function(U) {
      var H = C(U += "", !1);
      return H.toString = function() {
        return U;
      }, H;
    },
    utcFormat: function(U) {
      var H = E(U += "", b);
      return H.toString = function() {
        return U;
      }, H;
    },
    utcParse: function(U) {
      var H = C(U += "", !0);
      return H.toString = function() {
        return U;
      }, H;
    }
  };
}
var M1 = { "-": "", _: " ", 0: "0" }, Gt = /^\s*\d+/, FF = /^%/, BF = /[\\^$*+?|[\]().{}]/g;
function Ae(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", o = i.length;
  return r + (o < n ? new Array(n - o + 1).join(t) + i : i);
}
function zF(e) {
  return e.replace(BF, "\\$&");
}
function ss(e) {
  return new RegExp("^(?:" + e.map(zF).join("|") + ")", "i");
}
function ls(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function WF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function VF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function UF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function HF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function KF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function j1(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function N1(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function qF(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function YF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function GF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function D1(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function XF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function R1(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function ZF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function JF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function QF(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function eB(e, t, n) {
  var r = Gt.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function tB(e, t, n) {
  var r = FF.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function nB(e, t, n) {
  var r = Gt.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function rB(e, t, n) {
  var r = Gt.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function I1(e, t) {
  return Ae(e.getDate(), t, 2);
}
function iB(e, t) {
  return Ae(e.getHours(), t, 2);
}
function oB(e, t) {
  return Ae(e.getHours() % 12 || 12, t, 2);
}
function aB(e, t) {
  return Ae(1 + Rl.count(gi(e), e), t, 3);
}
function vP(e, t) {
  return Ae(e.getMilliseconds(), t, 3);
}
function sB(e, t) {
  return vP(e, t) + "000";
}
function lB(e, t) {
  return Ae(e.getMonth() + 1, t, 2);
}
function cB(e, t) {
  return Ae(e.getMinutes(), t, 2);
}
function uB(e, t) {
  return Ae(e.getSeconds(), t, 2);
}
function dB(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function fB(e, t) {
  return Ae(Kd.count(gi(e) - 1, e), t, 2);
}
function yP(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Pa(e) : Pa.ceil(e);
}
function pB(e, t) {
  return e = yP(e), Ae(Pa.count(gi(e), e) + (gi(e).getDay() === 4), t, 2);
}
function hB(e) {
  return e.getDay();
}
function mB(e, t) {
  return Ae(ju.count(gi(e) - 1, e), t, 2);
}
function gB(e, t) {
  return Ae(e.getFullYear() % 100, t, 2);
}
function vB(e, t) {
  return e = yP(e), Ae(e.getFullYear() % 100, t, 2);
}
function yB(e, t) {
  return Ae(e.getFullYear() % 1e4, t, 4);
}
function bB(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Pa(e) : Pa.ceil(e), Ae(e.getFullYear() % 1e4, t, 4);
}
function xB(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ae(t / 60 | 0, "0", 2) + Ae(t % 60, "0", 2);
}
function $1(e, t) {
  return Ae(e.getUTCDate(), t, 2);
}
function wB(e, t) {
  return Ae(e.getUTCHours(), t, 2);
}
function OB(e, t) {
  return Ae(e.getUTCHours() % 12 || 12, t, 2);
}
function SB(e, t) {
  return Ae(1 + Hd.count(vi(e), e), t, 3);
}
function bP(e, t) {
  return Ae(e.getUTCMilliseconds(), t, 3);
}
function EB(e, t) {
  return bP(e, t) + "000";
}
function _B(e, t) {
  return Ae(e.getUTCMonth() + 1, t, 2);
}
function PB(e, t) {
  return Ae(e.getUTCMinutes(), t, 2);
}
function CB(e, t) {
  return Ae(e.getUTCSeconds(), t, 2);
}
function AB(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function TB(e, t) {
  return Ae(qd.count(vi(e) - 1, e), t, 2);
}
function xP(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Ca(e) : Ca.ceil(e);
}
function kB(e, t) {
  return e = xP(e), Ae(Ca.count(vi(e), e) + (vi(e).getUTCDay() === 4), t, 2);
}
function MB(e) {
  return e.getUTCDay();
}
function jB(e, t) {
  return Ae(Nu.count(vi(e) - 1, e), t, 2);
}
function NB(e, t) {
  return Ae(e.getUTCFullYear() % 100, t, 2);
}
function DB(e, t) {
  return e = xP(e), Ae(e.getUTCFullYear() % 100, t, 2);
}
function RB(e, t) {
  return Ae(e.getUTCFullYear() % 1e4, t, 4);
}
function IB(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Ca(e) : Ca.ceil(e), Ae(e.getUTCFullYear() % 1e4, t, 4);
}
function $B() {
  return "+0000";
}
function L1() {
  return "%";
}
function F1(e) {
  return +e;
}
function B1(e) {
  return Math.floor(+e / 1e3);
}
var ra, wP, OP;
LB({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function LB(e) {
  return ra = LF(e), wP = ra.format, ra.parse, OP = ra.utcFormat, ra.utcParse, ra;
}
function FB(e) {
  return new Date(e);
}
function BB(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function av(e, t, n, r, i, o, a, s, l, c) {
  var u = Kg(), d = u.invert, f = u.domain, p = c(".%L"), g = c(":%S"), m = c("%I:%M"), v = c("%I %p"), y = c("%a %d"), S = c("%b %d"), x = c("%B"), b = c("%Y");
  function w(E) {
    return (l(E) < E ? p : s(E) < E ? g : a(E) < E ? m : o(E) < E ? v : r(E) < E ? i(E) < E ? y : S : n(E) < E ? x : b)(E);
  }
  return u.invert = function(E) {
    return new Date(d(E));
  }, u.domain = function(E) {
    return arguments.length ? f(Array.from(E, BB)) : f().map(FB);
  }, u.ticks = function(E) {
    var C = f();
    return e(C[0], C[C.length - 1], E ?? 10);
  }, u.tickFormat = function(E, C) {
    return C == null ? w : c(C);
  }, u.nice = function(E) {
    var C = f();
    return (!E || typeof E.range != "function") && (E = t(C[0], C[C.length - 1], E ?? 10)), E ? f(lP(C, E)) : u;
  }, u.copy = function() {
    return Dl(u, av(e, t, n, r, i, o, a, s, l, c));
  }, u;
}
function zB() {
  return gr.apply(av(IF, $F, gi, iv, Kd, Rl, nv, ev, So, wP).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function WB() {
  return gr.apply(av(DF, RF, vi, ov, qd, Hd, rv, tv, So, OP).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function Yd() {
  var e = 0, t = 1, n, r, i, o, a = yn, s = !1, l;
  function c(d) {
    return d == null || isNaN(d = +d) ? l : a(i === 0 ? 0.5 : (d = (o(d) - n) * i, s ? Math.max(0, Math.min(1, d)) : d));
  }
  c.domain = function(d) {
    return arguments.length ? ([e, t] = d, n = o(e = +e), r = o(t = +t), i = n === r ? 0 : 1 / (r - n), c) : [e, t];
  }, c.clamp = function(d) {
    return arguments.length ? (s = !!d, c) : s;
  }, c.interpolator = function(d) {
    return arguments.length ? (a = d, c) : a;
  };
  function u(d) {
    return function(f) {
      var p, g;
      return arguments.length ? ([p, g] = f, a = d(p, g), c) : [a(0), a(1)];
    };
  }
  return c.range = u(Fa), c.rangeRound = u(Hg), c.unknown = function(d) {
    return arguments.length ? (l = d, c) : l;
  }, function(d) {
    return o = d, n = d(e), r = d(t), i = n === r ? 0 : 1 / (r - n), c;
  };
}
function Zi(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function SP() {
  var e = Xi(Yd()(yn));
  return e.copy = function() {
    return Zi(e, SP());
  }, Si.apply(e, arguments);
}
function EP() {
  var e = Gg(Yd()).domain([1, 10]);
  return e.copy = function() {
    return Zi(e, EP()).base(e.base());
  }, Si.apply(e, arguments);
}
function _P() {
  var e = Xg(Yd());
  return e.copy = function() {
    return Zi(e, _P()).constant(e.constant());
  }, Si.apply(e, arguments);
}
function sv() {
  var e = Zg(Yd());
  return e.copy = function() {
    return Zi(e, sv()).exponent(e.exponent());
  }, Si.apply(e, arguments);
}
function VB() {
  return sv.apply(null, arguments).exponent(0.5);
}
function PP() {
  var e = [], t = yn;
  function n(r) {
    if (r != null && !isNaN(r = +r)) return t((jl(e, r, 1) - 1) / (e.length - 1));
  }
  return n.domain = function(r) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of r) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort($i), n;
  }, n.interpolator = function(r) {
    return arguments.length ? (t = r, n) : t;
  }, n.range = function() {
    return e.map((r, i) => t(i / (e.length - 1)));
  }, n.quantiles = function(r) {
    return Array.from({ length: r + 1 }, (i, o) => A4(e, o / r));
  }, n.copy = function() {
    return PP(t).domain(e);
  }, Si.apply(n, arguments);
}
function Gd() {
  var e = 0, t = 0.5, n = 1, r = 1, i, o, a, s, l, c = yn, u, d = !1, f;
  function p(m) {
    return isNaN(m = +m) ? f : (m = 0.5 + ((m = +u(m)) - o) * (r * m < r * o ? s : l), c(d ? Math.max(0, Math.min(1, m)) : m));
  }
  p.domain = function(m) {
    return arguments.length ? ([e, t, n] = m, i = u(e = +e), o = u(t = +t), a = u(n = +n), s = i === o ? 0 : 0.5 / (o - i), l = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, p) : [e, t, n];
  }, p.clamp = function(m) {
    return arguments.length ? (d = !!m, p) : d;
  }, p.interpolator = function(m) {
    return arguments.length ? (c = m, p) : c;
  };
  function g(m) {
    return function(v) {
      var y, S, x;
      return arguments.length ? ([y, S, x] = v, c = tF(m, [y, S, x]), p) : [c(0), c(0.5), c(1)];
    };
  }
  return p.range = g(Fa), p.rangeRound = g(Hg), p.unknown = function(m) {
    return arguments.length ? (f = m, p) : f;
  }, function(m) {
    return u = m, i = m(e), o = m(t), a = m(n), s = i === o ? 0 : 0.5 / (o - i), l = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, p;
  };
}
function CP() {
  var e = Xi(Gd()(yn));
  return e.copy = function() {
    return Zi(e, CP());
  }, Si.apply(e, arguments);
}
function AP() {
  var e = Gg(Gd()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return Zi(e, AP()).base(e.base());
  }, Si.apply(e, arguments);
}
function TP() {
  var e = Xg(Gd());
  return e.copy = function() {
    return Zi(e, TP()).constant(e.constant());
  }, Si.apply(e, arguments);
}
function lv() {
  var e = Zg(Gd());
  return e.copy = function() {
    return Zi(e, lv()).exponent(e.exponent());
  }, Si.apply(e, arguments);
}
function UB() {
  return lv.apply(null, arguments).exponent(0.5);
}
const _s = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: Wg,
  scaleDiverging: CP,
  scaleDivergingLog: AP,
  scaleDivergingPow: lv,
  scaleDivergingSqrt: UB,
  scaleDivergingSymlog: TP,
  scaleIdentity: sP,
  scaleImplicit: mm,
  scaleLinear: aP,
  scaleLog: cP,
  scaleOrdinal: zg,
  scalePoint: M4,
  scalePow: Jg,
  scaleQuantile: fP,
  scaleQuantize: pP,
  scaleRadial: dP,
  scaleSequential: SP,
  scaleSequentialLog: EP,
  scaleSequentialPow: sv,
  scaleSequentialQuantile: PP,
  scaleSequentialSqrt: VB,
  scaleSequentialSymlog: _P,
  scaleSqrt: EF,
  scaleSymlog: uP,
  scaleThreshold: hP,
  scaleTime: zB,
  scaleUtc: WB,
  tickFormat: oP
}, Symbol.toStringTag, { value: "Module" }));
var Ji = (e) => e.chartData, cv = z([Ji], (e) => {
  var t = e.chartData != null ? e.chartData.length - 1 : 0;
  return {
    chartData: e.chartData,
    computedData: e.computedData,
    dataEndIndex: t,
    dataStartIndex: 0
  };
}), Xd = (e, t, n, r) => r ? cv(e) : Ji(e);
function Aa(e) {
  if (Array.isArray(e) && e.length === 2) {
    var [t, n] = e;
    if (qn(t) && qn(n))
      return !0;
  }
  return !1;
}
function z1(e, t, n) {
  return n ? e : [Math.min(e[0], t[0]), Math.max(e[1], t[1])];
}
function HB(e, t) {
  if (t && typeof e != "function" && Array.isArray(e) && e.length === 2) {
    var [n, r] = e, i, o;
    if (qn(n))
      i = n;
    else if (typeof n == "function")
      return;
    if (qn(r))
      o = r;
    else if (typeof r == "function")
      return;
    var a = [i, o];
    if (Aa(a))
      return a;
  }
}
function KB(e, t, n) {
  if (!(!n && t == null)) {
    if (typeof e == "function" && t != null)
      try {
        var r = e(t, n);
        if (Aa(r))
          return z1(r, t, n);
      } catch {
      }
    if (Array.isArray(e) && e.length === 2) {
      var [i, o] = e, a, s;
      if (i === "auto")
        t != null && (a = Math.min(...t));
      else if (me(i))
        a = i;
      else if (typeof i == "function")
        try {
          t != null && (a = i(t?.[0]));
        } catch {
        }
      else if (typeof i == "string" && Nx.test(i)) {
        var l = Nx.exec(i);
        if (l == null || t == null)
          a = void 0;
        else {
          var c = +l[1];
          a = t[0] - c;
        }
      } else
        a = t?.[0];
      if (o === "auto")
        t != null && (s = Math.max(...t));
      else if (me(o))
        s = o;
      else if (typeof o == "function")
        try {
          t != null && (s = o(t?.[1]));
        } catch {
        }
      else if (typeof o == "string" && Dx.test(o)) {
        var u = Dx.exec(o);
        if (u == null || t == null)
          s = void 0;
        else {
          var d = +u[1];
          s = t[1] + d;
        }
      } else
        s = t?.[1];
      var f = [a, s];
      if (Aa(f))
        return t == null ? f : z1(f, t, n);
    }
  }
}
var Ba = 1e9, qB = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, dv, ut = !0, ur = "[DecimalError] ", Mo = ur + "Invalid argument: ", uv = ur + "Exponent out of range: ", za = Math.floor, ho = Math.pow, YB = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, zn, Vt = 1e7, it = 7, kP = 9007199254740991, Du = za(kP / it), le = {};
le.absoluteValue = le.abs = function() {
  var e = new this.constructor(this);
  return e.s && (e.s = 1), e;
};
le.comparedTo = le.cmp = function(e) {
  var t, n, r, i, o = this;
  if (e = new o.constructor(e), o.s !== e.s) return o.s || -e.s;
  if (o.e !== e.e) return o.e > e.e ^ o.s < 0 ? 1 : -1;
  for (r = o.d.length, i = e.d.length, t = 0, n = r < i ? r : i; t < n; ++t)
    if (o.d[t] !== e.d[t]) return o.d[t] > e.d[t] ^ o.s < 0 ? 1 : -1;
  return r === i ? 0 : r > i ^ o.s < 0 ? 1 : -1;
};
le.decimalPlaces = le.dp = function() {
  var e = this, t = e.d.length - 1, n = (t - e.e) * it;
  if (t = e.d[t], t) for (; t % 10 == 0; t /= 10) n--;
  return n < 0 ? 0 : n;
};
le.dividedBy = le.div = function(e) {
  return di(this, new this.constructor(e));
};
le.dividedToIntegerBy = le.idiv = function(e) {
  var t = this, n = t.constructor;
  return Qe(di(t, new n(e), 0, 1), n.precision);
};
le.equals = le.eq = function(e) {
  return !this.cmp(e);
};
le.exponent = function() {
  return kt(this);
};
le.greaterThan = le.gt = function(e) {
  return this.cmp(e) > 0;
};
le.greaterThanOrEqualTo = le.gte = function(e) {
  return this.cmp(e) >= 0;
};
le.isInteger = le.isint = function() {
  return this.e > this.d.length - 2;
};
le.isNegative = le.isneg = function() {
  return this.s < 0;
};
le.isPositive = le.ispos = function() {
  return this.s > 0;
};
le.isZero = function() {
  return this.s === 0;
};
le.lessThan = le.lt = function(e) {
  return this.cmp(e) < 0;
};
le.lessThanOrEqualTo = le.lte = function(e) {
  return this.cmp(e) < 1;
};
le.logarithm = le.log = function(e) {
  var t, n = this, r = n.constructor, i = r.precision, o = i + 5;
  if (e === void 0)
    e = new r(10);
  else if (e = new r(e), e.s < 1 || e.eq(zn)) throw Error(ur + "NaN");
  if (n.s < 1) throw Error(ur + (n.s ? "NaN" : "-Infinity"));
  return n.eq(zn) ? new r(0) : (ut = !1, t = di(tl(n, o), tl(e, o), o), ut = !0, Qe(t, i));
};
le.minus = le.sub = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? NP(t, e) : MP(t, (e.s = -e.s, e));
};
le.modulo = le.mod = function(e) {
  var t, n = this, r = n.constructor, i = r.precision;
  if (e = new r(e), !e.s) throw Error(ur + "NaN");
  return n.s ? (ut = !1, t = di(n, e, 0, 1).times(e), ut = !0, n.minus(t)) : Qe(new r(n), i);
};
le.naturalExponential = le.exp = function() {
  return jP(this);
};
le.naturalLogarithm = le.ln = function() {
  return tl(this);
};
le.negated = le.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s || 0, e;
};
le.plus = le.add = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? MP(t, e) : NP(t, (e.s = -e.s, e));
};
le.precision = le.sd = function(e) {
  var t, n, r, i = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(Mo + e);
  if (t = kt(i) + 1, r = i.d.length - 1, n = r * it + 1, r = i.d[r], r) {
    for (; r % 10 == 0; r /= 10) n--;
    for (r = i.d[0]; r >= 10; r /= 10) n++;
  }
  return e && t > n ? t : n;
};
le.squareRoot = le.sqrt = function() {
  var e, t, n, r, i, o, a, s = this, l = s.constructor;
  if (s.s < 1) {
    if (!s.s) return new l(0);
    throw Error(ur + "NaN");
  }
  for (e = kt(s), ut = !1, i = Math.sqrt(+s), i == 0 || i == 1 / 0 ? (t = jr(s.d), (t.length + e) % 2 == 0 && (t += "0"), i = Math.sqrt(t), e = za((e + 1) / 2) - (e < 0 || e % 2), i == 1 / 0 ? t = "5e" + e : (t = i.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), r = new l(t)) : r = new l(i.toString()), n = l.precision, i = a = n + 3; ; )
    if (o = r, r = o.plus(di(s, o, a + 2)).times(0.5), jr(o.d).slice(0, a) === (t = jr(r.d)).slice(0, a)) {
      if (t = t.slice(a - 3, a + 1), i == a && t == "4999") {
        if (Qe(o, n + 1, 0), o.times(o).eq(s)) {
          r = o;
          break;
        }
      } else if (t != "9999")
        break;
      a += 4;
    }
  return ut = !0, Qe(r, n);
};
le.times = le.mul = function(e) {
  var t, n, r, i, o, a, s, l, c, u = this, d = u.constructor, f = u.d, p = (e = new d(e)).d;
  if (!u.s || !e.s) return new d(0);
  for (e.s *= u.s, n = u.e + e.e, l = f.length, c = p.length, l < c && (o = f, f = p, p = o, a = l, l = c, c = a), o = [], a = l + c, r = a; r--; ) o.push(0);
  for (r = c; --r >= 0; ) {
    for (t = 0, i = l + r; i > r; )
      s = o[i] + p[r] * f[i - r - 1] + t, o[i--] = s % Vt | 0, t = s / Vt | 0;
    o[i] = (o[i] + t) % Vt | 0;
  }
  for (; !o[--a]; ) o.pop();
  return t ? ++n : o.shift(), e.d = o, e.e = n, ut ? Qe(e, d.precision) : e;
};
le.toDecimalPlaces = le.todp = function(e, t) {
  var n = this, r = n.constructor;
  return n = new r(n), e === void 0 ? n : (Br(e, 0, Ba), t === void 0 ? t = r.rounding : Br(t, 0, 8), Qe(n, e + kt(n) + 1, t));
};
le.toExponential = function(e, t) {
  var n, r = this, i = r.constructor;
  return e === void 0 ? n = $o(r, !0) : (Br(e, 0, Ba), t === void 0 ? t = i.rounding : Br(t, 0, 8), r = Qe(new i(r), e + 1, t), n = $o(r, !0, e + 1)), n;
};
le.toFixed = function(e, t) {
  var n, r, i = this, o = i.constructor;
  return e === void 0 ? $o(i) : (Br(e, 0, Ba), t === void 0 ? t = o.rounding : Br(t, 0, 8), r = Qe(new o(i), e + kt(i) + 1, t), n = $o(r.abs(), !1, e + kt(r) + 1), i.isneg() && !i.isZero() ? "-" + n : n);
};
le.toInteger = le.toint = function() {
  var e = this, t = e.constructor;
  return Qe(new t(e), kt(e) + 1, t.rounding);
};
le.toNumber = function() {
  return +this;
};
le.toPower = le.pow = function(e) {
  var t, n, r, i, o, a, s = this, l = s.constructor, c = 12, u = +(e = new l(e));
  if (!e.s) return new l(zn);
  if (s = new l(s), !s.s) {
    if (e.s < 1) throw Error(ur + "Infinity");
    return s;
  }
  if (s.eq(zn)) return s;
  if (r = l.precision, e.eq(zn)) return Qe(s, r);
  if (t = e.e, n = e.d.length - 1, a = t >= n, o = s.s, a) {
    if ((n = u < 0 ? -u : u) <= kP) {
      for (i = new l(zn), t = Math.ceil(r / it + 4), ut = !1; n % 2 && (i = i.times(s), V1(i.d, t)), n = za(n / 2), n !== 0; )
        s = s.times(s), V1(s.d, t);
      return ut = !0, e.s < 0 ? new l(zn).div(i) : Qe(i, r);
    }
  } else if (o < 0) throw Error(ur + "NaN");
  return o = o < 0 && e.d[Math.max(t, n)] & 1 ? -1 : 1, s.s = 1, ut = !1, i = e.times(tl(s, r + c)), ut = !0, i = jP(i), i.s = o, i;
};
le.toPrecision = function(e, t) {
  var n, r, i = this, o = i.constructor;
  return e === void 0 ? (n = kt(i), r = $o(i, n <= o.toExpNeg || n >= o.toExpPos)) : (Br(e, 1, Ba), t === void 0 ? t = o.rounding : Br(t, 0, 8), i = Qe(new o(i), e, t), n = kt(i), r = $o(i, e <= n || n <= o.toExpNeg, e)), r;
};
le.toSignificantDigits = le.tosd = function(e, t) {
  var n = this, r = n.constructor;
  return e === void 0 ? (e = r.precision, t = r.rounding) : (Br(e, 1, Ba), t === void 0 ? t = r.rounding : Br(t, 0, 8)), Qe(new r(n), e, t);
};
le.toString = le.valueOf = le.val = le.toJSON = le[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var e = this, t = kt(e), n = e.constructor;
  return $o(e, t <= n.toExpNeg || t >= n.toExpPos);
};
function MP(e, t) {
  var n, r, i, o, a, s, l, c, u = e.constructor, d = u.precision;
  if (!e.s || !t.s)
    return t.s || (t = new u(e)), ut ? Qe(t, d) : t;
  if (l = e.d, c = t.d, a = e.e, i = t.e, l = l.slice(), o = a - i, o) {
    for (o < 0 ? (r = l, o = -o, s = c.length) : (r = c, i = a, s = l.length), a = Math.ceil(d / it), s = a > s ? a + 1 : s + 1, o > s && (o = s, r.length = 1), r.reverse(); o--; ) r.push(0);
    r.reverse();
  }
  for (s = l.length, o = c.length, s - o < 0 && (o = s, r = c, c = l, l = r), n = 0; o; )
    n = (l[--o] = l[o] + c[o] + n) / Vt | 0, l[o] %= Vt;
  for (n && (l.unshift(n), ++i), s = l.length; l[--s] == 0; ) l.pop();
  return t.d = l, t.e = i, ut ? Qe(t, d) : t;
}
function Br(e, t, n) {
  if (e !== ~~e || e < t || e > n)
    throw Error(Mo + e);
}
function jr(e) {
  var t, n, r, i = e.length - 1, o = "", a = e[0];
  if (i > 0) {
    for (o += a, t = 1; t < i; t++)
      r = e[t] + "", n = it - r.length, n && (o += Ti(n)), o += r;
    a = e[t], r = a + "", n = it - r.length, n && (o += Ti(n));
  } else if (a === 0)
    return "0";
  for (; a % 10 === 0; ) a /= 10;
  return o + a;
}
var di = /* @__PURE__ */ (function() {
  function e(r, i) {
    var o, a = 0, s = r.length;
    for (r = r.slice(); s--; )
      o = r[s] * i + a, r[s] = o % Vt | 0, a = o / Vt | 0;
    return a && r.unshift(a), r;
  }
  function t(r, i, o, a) {
    var s, l;
    if (o != a)
      l = o > a ? 1 : -1;
    else
      for (s = l = 0; s < o; s++)
        if (r[s] != i[s]) {
          l = r[s] > i[s] ? 1 : -1;
          break;
        }
    return l;
  }
  function n(r, i, o) {
    for (var a = 0; o--; )
      r[o] -= a, a = r[o] < i[o] ? 1 : 0, r[o] = a * Vt + r[o] - i[o];
    for (; !r[0] && r.length > 1; ) r.shift();
  }
  return function(r, i, o, a) {
    var s, l, c, u, d, f, p, g, m, v, y, S, x, b, w, E, C, A, k = r.constructor, R = r.s == i.s ? 1 : -1, M = r.d, P = i.d;
    if (!r.s) return new k(r);
    if (!i.s) throw Error(ur + "Division by zero");
    for (l = r.e - i.e, C = P.length, w = M.length, p = new k(R), g = p.d = [], c = 0; P[c] == (M[c] || 0); ) ++c;
    if (P[c] > (M[c] || 0) && --l, o == null ? S = o = k.precision : a ? S = o + (kt(r) - kt(i)) + 1 : S = o, S < 0) return new k(0);
    if (S = S / it + 2 | 0, c = 0, C == 1)
      for (u = 0, P = P[0], S++; (c < w || u) && S--; c++)
        x = u * Vt + (M[c] || 0), g[c] = x / P | 0, u = x % P | 0;
    else {
      for (u = Vt / (P[0] + 1) | 0, u > 1 && (P = e(P, u), M = e(M, u), C = P.length, w = M.length), b = C, m = M.slice(0, C), v = m.length; v < C; ) m[v++] = 0;
      A = P.slice(), A.unshift(0), E = P[0], P[1] >= Vt / 2 && ++E;
      do
        u = 0, s = t(P, m, C, v), s < 0 ? (y = m[0], C != v && (y = y * Vt + (m[1] || 0)), u = y / E | 0, u > 1 ? (u >= Vt && (u = Vt - 1), d = e(P, u), f = d.length, v = m.length, s = t(d, m, f, v), s == 1 && (u--, n(d, C < f ? A : P, f))) : (u == 0 && (s = u = 1), d = P.slice()), f = d.length, f < v && d.unshift(0), n(m, d, v), s == -1 && (v = m.length, s = t(P, m, C, v), s < 1 && (u++, n(m, C < v ? A : P, v))), v = m.length) : s === 0 && (u++, m = [0]), g[c++] = u, s && m[0] ? m[v++] = M[b] || 0 : (m = [M[b]], v = 1);
      while ((b++ < w || m[0] !== void 0) && S--);
    }
    return g[0] || g.shift(), p.e = l, Qe(p, a ? o + kt(p) + 1 : o);
  };
})();
function jP(e, t) {
  var n, r, i, o, a, s, l = 0, c = 0, u = e.constructor, d = u.precision;
  if (kt(e) > 16) throw Error(uv + kt(e));
  if (!e.s) return new u(zn);
  for (ut = !1, s = d, a = new u(0.03125); e.abs().gte(0.1); )
    e = e.times(a), c += 5;
  for (r = Math.log(ho(2, c)) / Math.LN10 * 2 + 5 | 0, s += r, n = i = o = new u(zn), u.precision = s; ; ) {
    if (i = Qe(i.times(e), s), n = n.times(++l), a = o.plus(di(i, n, s)), jr(a.d).slice(0, s) === jr(o.d).slice(0, s)) {
      for (; c--; ) o = Qe(o.times(o), s);
      return u.precision = d, t == null ? (ut = !0, Qe(o, d)) : o;
    }
    o = a;
  }
}
function kt(e) {
  for (var t = e.e * it, n = e.d[0]; n >= 10; n /= 10) t++;
  return t;
}
function Zp(e, t, n) {
  if (t > e.LN10.sd())
    throw ut = !0, n && (e.precision = n), Error(ur + "LN10 precision limit exceeded");
  return Qe(new e(e.LN10), t);
}
function Ti(e) {
  for (var t = ""; e--; ) t += "0";
  return t;
}
function tl(e, t) {
  var n, r, i, o, a, s, l, c, u, d = 1, f = 10, p = e, g = p.d, m = p.constructor, v = m.precision;
  if (p.s < 1) throw Error(ur + (p.s ? "NaN" : "-Infinity"));
  if (p.eq(zn)) return new m(0);
  if (t == null ? (ut = !1, c = v) : c = t, p.eq(10))
    return t == null && (ut = !0), Zp(m, c);
  if (c += f, m.precision = c, n = jr(g), r = n.charAt(0), o = kt(p), Math.abs(o) < 15e14) {
    for (; r < 7 && r != 1 || r == 1 && n.charAt(1) > 3; )
      p = p.times(e), n = jr(p.d), r = n.charAt(0), d++;
    o = kt(p), r > 1 ? (p = new m("0." + n), o++) : p = new m(r + "." + n.slice(1));
  } else
    return l = Zp(m, c + 2, v).times(o + ""), p = tl(new m(r + "." + n.slice(1)), c - f).plus(l), m.precision = v, t == null ? (ut = !0, Qe(p, v)) : p;
  for (s = a = p = di(p.minus(zn), p.plus(zn), c), u = Qe(p.times(p), c), i = 3; ; ) {
    if (a = Qe(a.times(u), c), l = s.plus(di(a, new m(i), c)), jr(l.d).slice(0, c) === jr(s.d).slice(0, c))
      return s = s.times(2), o !== 0 && (s = s.plus(Zp(m, c + 2, v).times(o + ""))), s = di(s, new m(d), c), m.precision = v, t == null ? (ut = !0, Qe(s, v)) : s;
    s = l, i += 2;
  }
}
function W1(e, t) {
  var n, r, i;
  for ((n = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (r = t.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +t.slice(r + 1), t = t.substring(0, r)) : n < 0 && (n = t.length), r = 0; t.charCodeAt(r) === 48; ) ++r;
  for (i = t.length; t.charCodeAt(i - 1) === 48; ) --i;
  if (t = t.slice(r, i), t) {
    if (i -= r, n = n - r - 1, e.e = za(n / it), e.d = [], r = (n + 1) % it, n < 0 && (r += it), r < i) {
      for (r && e.d.push(+t.slice(0, r)), i -= it; r < i; ) e.d.push(+t.slice(r, r += it));
      t = t.slice(r), r = it - t.length;
    } else
      r -= i;
    for (; r--; ) t += "0";
    if (e.d.push(+t), ut && (e.e > Du || e.e < -Du)) throw Error(uv + n);
  } else
    e.s = 0, e.e = 0, e.d = [0];
  return e;
}
function Qe(e, t, n) {
  var r, i, o, a, s, l, c, u, d = e.d;
  for (a = 1, o = d[0]; o >= 10; o /= 10) a++;
  if (r = t - a, r < 0)
    r += it, i = t, c = d[u = 0];
  else {
    if (u = Math.ceil((r + 1) / it), o = d.length, u >= o) return e;
    for (c = o = d[u], a = 1; o >= 10; o /= 10) a++;
    r %= it, i = r - it + a;
  }
  if (n !== void 0 && (o = ho(10, a - i - 1), s = c / o % 10 | 0, l = t < 0 || d[u + 1] !== void 0 || c % o, l = n < 4 ? (s || l) && (n == 0 || n == (e.s < 0 ? 3 : 2)) : s > 5 || s == 5 && (n == 4 || l || n == 6 && // Check whether the digit to the left of the rounding digit is odd.
  (r > 0 ? i > 0 ? c / ho(10, a - i) : 0 : d[u - 1]) % 10 & 1 || n == (e.s < 0 ? 8 : 7))), t < 1 || !d[0])
    return l ? (o = kt(e), d.length = 1, t = t - o - 1, d[0] = ho(10, (it - t % it) % it), e.e = za(-t / it) || 0) : (d.length = 1, d[0] = e.e = e.s = 0), e;
  if (r == 0 ? (d.length = u, o = 1, u--) : (d.length = u + 1, o = ho(10, it - r), d[u] = i > 0 ? (c / ho(10, a - i) % ho(10, i) | 0) * o : 0), l)
    for (; ; )
      if (u == 0) {
        (d[0] += o) == Vt && (d[0] = 1, ++e.e);
        break;
      } else {
        if (d[u] += o, d[u] != Vt) break;
        d[u--] = 0, o = 1;
      }
  for (r = d.length; d[--r] === 0; ) d.pop();
  if (ut && (e.e > Du || e.e < -Du))
    throw Error(uv + kt(e));
  return e;
}
function NP(e, t) {
  var n, r, i, o, a, s, l, c, u, d, f = e.constructor, p = f.precision;
  if (!e.s || !t.s)
    return t.s ? t.s = -t.s : t = new f(e), ut ? Qe(t, p) : t;
  if (l = e.d, d = t.d, r = t.e, c = e.e, l = l.slice(), a = c - r, a) {
    for (u = a < 0, u ? (n = l, a = -a, s = d.length) : (n = d, r = c, s = l.length), i = Math.max(Math.ceil(p / it), s) + 2, a > i && (a = i, n.length = 1), n.reverse(), i = a; i--; ) n.push(0);
    n.reverse();
  } else {
    for (i = l.length, s = d.length, u = i < s, u && (s = i), i = 0; i < s; i++)
      if (l[i] != d[i]) {
        u = l[i] < d[i];
        break;
      }
    a = 0;
  }
  for (u && (n = l, l = d, d = n, t.s = -t.s), s = l.length, i = d.length - s; i > 0; --i) l[s++] = 0;
  for (i = d.length; i > a; ) {
    if (l[--i] < d[i]) {
      for (o = i; o && l[--o] === 0; ) l[o] = Vt - 1;
      --l[o], l[i] += Vt;
    }
    l[i] -= d[i];
  }
  for (; l[--s] === 0; ) l.pop();
  for (; l[0] === 0; l.shift()) --r;
  return l[0] ? (t.d = l, t.e = r, ut ? Qe(t, p) : t) : new f(0);
}
function $o(e, t, n) {
  var r, i = kt(e), o = jr(e.d), a = o.length;
  return t ? (n && (r = n - a) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Ti(r) : a > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (i < 0 ? "e" : "e+") + i) : i < 0 ? (o = "0." + Ti(-i - 1) + o, n && (r = n - a) > 0 && (o += Ti(r))) : i >= a ? (o += Ti(i + 1 - a), n && (r = n - i - 1) > 0 && (o = o + "." + Ti(r))) : ((r = i + 1) < a && (o = o.slice(0, r) + "." + o.slice(r)), n && (r = n - a) > 0 && (i + 1 === a && (o += "."), o += Ti(r))), e.s < 0 ? "-" + o : o;
}
function V1(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function DP(e) {
  var t, n, r;
  function i(o) {
    var a = this;
    if (!(a instanceof i)) return new i(o);
    if (a.constructor = i, o instanceof i) {
      a.s = o.s, a.e = o.e, a.d = (o = o.d) ? o.slice() : o;
      return;
    }
    if (typeof o == "number") {
      if (o * 0 !== 0)
        throw Error(Mo + o);
      if (o > 0)
        a.s = 1;
      else if (o < 0)
        o = -o, a.s = -1;
      else {
        a.s = 0, a.e = 0, a.d = [0];
        return;
      }
      if (o === ~~o && o < 1e7) {
        a.e = 0, a.d = [o];
        return;
      }
      return W1(a, o.toString());
    } else if (typeof o != "string")
      throw Error(Mo + o);
    if (o.charCodeAt(0) === 45 ? (o = o.slice(1), a.s = -1) : a.s = 1, YB.test(o)) W1(a, o);
    else throw Error(Mo + o);
  }
  if (i.prototype = le, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = DP, i.config = i.set = GB, e === void 0 && (e = {}), e)
    for (r = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t = 0; t < r.length; ) e.hasOwnProperty(n = r[t++]) || (e[n] = this[n]);
  return i.config(e), i;
}
function GB(e) {
  if (!e || typeof e != "object")
    throw Error(ur + "Object expected");
  var t, n, r, i = [
    "precision",
    1,
    Ba,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (t = 0; t < i.length; t += 3)
    if ((r = e[n = i[t]]) !== void 0)
      if (za(r) === r && r >= i[t + 1] && r <= i[t + 2]) this[n] = r;
      else throw Error(Mo + n + ": " + r);
  if ((r = e[n = "LN10"]) !== void 0)
    if (r == Math.LN10) this[n] = new this(r);
    else throw Error(Mo + n + ": " + r);
  return this;
}
var dv = DP(qB);
zn = new dv(1);
const Ve = dv;
var XB = (e) => e, RP = {}, IP = (e) => e === RP, U1 = (e) => function t() {
  return arguments.length === 0 || arguments.length === 1 && IP(arguments.length <= 0 ? void 0 : arguments[0]) ? t : e(...arguments);
}, $P = (e, t) => e === 1 ? t : U1(function() {
  for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
    r[i] = arguments[i];
  var o = r.filter((a) => a !== RP).length;
  return o >= e ? t(...r) : $P(e - o, U1(function() {
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    var c = r.map((u) => IP(u) ? s.shift() : u);
    return t(...c, ...s);
  }));
}), Zd = (e) => $P(e.length, e), bm = (e, t) => {
  for (var n = [], r = e; r < t; ++r)
    n[r - e] = r;
  return n;
}, ZB = Zd((e, t) => Array.isArray(t) ? t.map(e) : Object.keys(t).map((n) => t[n]).map(e)), JB = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  if (!n.length)
    return XB;
  var i = n.reverse(), o = i[0], a = i.slice(1);
  return function() {
    return a.reduce((s, l) => l(s), o(...arguments));
  };
}, xm = (e) => Array.isArray(e) ? e.reverse() : e.split("").reverse().join(""), LP = (e) => {
  var t = null, n = null;
  return function() {
    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
      i[o] = arguments[o];
    return t && i.every((a, s) => {
      var l;
      return a === ((l = t) === null || l === void 0 ? void 0 : l[s]);
    }) || (t = i, n = e(...i)), n;
  };
};
function FP(e) {
  var t;
  return e === 0 ? t = 1 : t = Math.floor(new Ve(e).abs().log(10).toNumber()) + 1, t;
}
function BP(e, t, n) {
  for (var r = new Ve(e), i = 0, o = []; r.lt(t) && i < 1e5; )
    o.push(r.toNumber()), r = r.add(n), i++;
  return o;
}
Zd((e, t, n) => {
  var r = +e, i = +t;
  return r + n * (i - r);
});
Zd((e, t, n) => {
  var r = t - +e;
  return r = r || 1 / 0, (n - e) / r;
});
Zd((e, t, n) => {
  var r = t - +e;
  return r = r || 1 / 0, Math.max(0, Math.min(1, (n - e) / r));
});
var zP = (e) => {
  var [t, n] = e, [r, i] = [t, n];
  return t > n && ([r, i] = [n, t]), [r, i];
}, WP = (e, t, n) => {
  if (e.lte(0))
    return new Ve(0);
  var r = FP(e.toNumber()), i = new Ve(10).pow(r), o = e.div(i), a = r !== 1 ? 0.05 : 0.1, s = new Ve(Math.ceil(o.div(a).toNumber())).add(n).mul(a), l = s.mul(i);
  return t ? new Ve(l.toNumber()) : new Ve(Math.ceil(l.toNumber()));
}, QB = (e, t, n) => {
  var r = new Ve(1), i = new Ve(e);
  if (!i.isint() && n) {
    var o = Math.abs(e);
    o < 1 ? (r = new Ve(10).pow(FP(e) - 1), i = new Ve(Math.floor(i.div(r).toNumber())).mul(r)) : o > 1 && (i = new Ve(Math.floor(e)));
  } else e === 0 ? i = new Ve(Math.floor((t - 1) / 2)) : n || (i = new Ve(Math.floor(e)));
  var a = Math.floor((t - 1) / 2), s = JB(ZB((l) => i.add(new Ve(l - a).mul(r)).toNumber()), bm);
  return s(0, t);
}, VP = function(t, n, r, i) {
  var o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((n - t) / (r - 1)))
    return {
      step: new Ve(0),
      tickMin: new Ve(0),
      tickMax: new Ve(0)
    };
  var a = WP(new Ve(n).sub(t).div(r - 1), i, o), s;
  t <= 0 && n >= 0 ? s = new Ve(0) : (s = new Ve(t).add(n).div(2), s = s.sub(new Ve(s).mod(a)));
  var l = Math.ceil(s.sub(t).div(a).toNumber()), c = Math.ceil(new Ve(n).sub(s).div(a).toNumber()), u = l + c + 1;
  return u > r ? VP(t, n, r, i, o + 1) : (u < r && (c = n > 0 ? c + (r - u) : c, l = n > 0 ? l : l + (r - u)), {
    step: a,
    tickMin: s.sub(new Ve(l).mul(a)),
    tickMax: s.add(new Ve(c).mul(a))
  });
};
function e6(e) {
  var [t, n] = e, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = Math.max(r, 2), [a, s] = zP([t, n]);
  if (a === -1 / 0 || s === 1 / 0) {
    var l = s === 1 / 0 ? [a, ...bm(0, r - 1).map(() => 1 / 0)] : [...bm(0, r - 1).map(() => -1 / 0), s];
    return t > n ? xm(l) : l;
  }
  if (a === s)
    return QB(a, r, i);
  var {
    step: c,
    tickMin: u,
    tickMax: d
  } = VP(a, s, o, i, 0), f = BP(u, d.add(new Ve(0.1).mul(c)), c);
  return t > n ? xm(f) : f;
}
function t6(e, t) {
  var [n, r] = e, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, [o, a] = zP([n, r]);
  if (o === -1 / 0 || a === 1 / 0)
    return [n, r];
  if (o === a)
    return [o];
  var s = Math.max(t, 2), l = WP(new Ve(a).sub(o).div(s - 1), i, 0), c = [...BP(new Ve(o), new Ve(a), l), a];
  return i === !1 && (c = c.map((u) => Math.round(u))), n > r ? xm(c) : c;
}
var n6 = LP(e6), r6 = LP(t6), UP = (e) => e.rootProps.maxBarSize, i6 = (e) => e.rootProps.barGap, HP = (e) => e.rootProps.barCategoryGap, o6 = (e) => e.rootProps.barSize, Il = (e) => e.rootProps.stackOffset, fv = (e) => e.options.chartName, pv = (e) => e.rootProps.syncId, KP = (e) => e.rootProps.syncMethod, hv = (e) => e.options.eventEmitter, ii = {
  allowDuplicatedCategory: !0,
  // if I set this to false then Tooltip synchronisation stops working in Radar, wtf
  angleAxisId: 0,
  reversed: !1,
  scale: "auto",
  tick: !0,
  type: "category"
}, Ln = {
  allowDataOverflow: !1,
  allowDuplicatedCategory: !0,
  radiusAxisId: 0,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  type: "number"
}, Jd = (e, t) => {
  if (!(!e || !t))
    return e != null && e.reversed ? [t[1], t[0]] : t;
}, a6 = {
  allowDataOverflow: !1,
  allowDecimals: !1,
  allowDuplicatedCategory: !1,
  // defaultPolarAngleAxisProps.allowDuplicatedCategory has it set to true but the actual axis rendering ignores the prop because reasons,
  dataKey: void 0,
  domain: void 0,
  id: ii.angleAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: ii.reversed,
  scale: ii.scale,
  tick: ii.tick,
  tickCount: void 0,
  ticks: void 0,
  type: ii.type,
  unit: void 0
}, s6 = {
  allowDataOverflow: Ln.allowDataOverflow,
  allowDecimals: !1,
  allowDuplicatedCategory: Ln.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: Ln.radiusAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: Ln.scale,
  tick: Ln.tick,
  tickCount: Ln.tickCount,
  ticks: void 0,
  type: Ln.type,
  unit: void 0
}, l6 = {
  allowDataOverflow: !1,
  allowDecimals: !1,
  allowDuplicatedCategory: ii.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: ii.angleAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: ii.scale,
  tick: ii.tick,
  tickCount: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0
}, c6 = {
  allowDataOverflow: Ln.allowDataOverflow,
  allowDecimals: !1,
  allowDuplicatedCategory: Ln.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: Ln.radiusAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: Ln.scale,
  tick: Ln.tick,
  tickCount: Ln.tickCount,
  ticks: void 0,
  type: "category",
  unit: void 0
}, mv = (e, t) => e.polarAxis.angleAxis[t] != null ? e.polarAxis.angleAxis[t] : e.layout.layoutType === "radial" ? l6 : a6, gv = (e, t) => e.polarAxis.radiusAxis[t] != null ? e.polarAxis.radiusAxis[t] : e.layout.layoutType === "radial" ? c6 : s6, Qd = (e) => e.polarOptions, vv = z([wi, Oi, Lt], C2), qP = z([Qd, vv], (e, t) => {
  if (e != null)
    return pn(e.innerRadius, t, 0);
}), YP = z([Qd, vv], (e, t) => {
  if (e != null)
    return pn(e.outerRadius, t, t * 0.8);
}), u6 = (e) => {
  if (e == null)
    return [0, 0];
  var {
    startAngle: t,
    endAngle: n
  } = e;
  return [t, n];
}, GP = z([Qd], u6);
z([mv, GP], Jd);
var XP = z([vv, qP, YP], (e, t, n) => {
  if (!(e == null || t == null || n == null))
    return [t, n];
});
z([gv, XP], Jd);
var ZP = z([_e, Qd, qP, YP, wi, Oi], (e, t, n, r, i, o) => {
  if (!(e !== "centric" && e !== "radial" || t == null || n == null || r == null)) {
    var {
      cx: a,
      cy: s,
      startAngle: l,
      endAngle: c
    } = t;
    return {
      cx: pn(a, i, i / 2),
      cy: pn(s, o, o / 2),
      innerRadius: n,
      outerRadius: r,
      startAngle: l,
      endAngle: c,
      clockWise: !1
      // this property look useful, why not use it?
    };
  }
}), ft = (e, t) => t, $l = (e, t, n) => n;
function yv(e) {
  return e?.id;
}
var Bt = (e) => {
  var t = _e(e);
  return t === "horizontal" ? "xAxis" : t === "vertical" ? "yAxis" : t === "centric" ? "angleAxis" : "radiusAxis";
}, Wa = (e) => e.tooltip.settings.axisId, Xt = (e) => {
  var t = Bt(e), n = Wa(e);
  return Ll(e, t, n);
}, JP = z([Xt], (e) => e?.dataKey);
function QP(e, t, n) {
  var {
    chartData: r = []
  } = t, {
    allowDuplicatedCategory: i,
    dataKey: o
  } = n, a = /* @__PURE__ */ new Map();
  return e.forEach((s) => {
    var l, c = (l = s.data) !== null && l !== void 0 ? l : r;
    if (!(c == null || c.length === 0)) {
      var u = yv(s);
      c.forEach((d, f) => {
        var p = o == null || i ? f : String(tt(d, o, null)), g = tt(d, s.dataKey, 0), m;
        a.has(p) ? m = a.get(p) : m = {}, Object.assign(m, {
          [u]: g
        }), a.set(p, m);
      });
    }
  }), Array.from(a.values());
}
function ef(e) {
  return e.stackId != null && e.dataKey != null;
}
function H1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ru(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H1(Object(n), !0).forEach(function(r) {
      d6(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function d6(e, t, n) {
  return (t = f6(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function f6(e) {
  var t = p6(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function p6(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var wm = [0, "auto"], Rn = {
  allowDataOverflow: !1,
  allowDecimals: !0,
  allowDuplicatedCategory: !0,
  angle: 0,
  dataKey: void 0,
  domain: void 0,
  height: 30,
  hide: !0,
  id: 0,
  includeHidden: !1,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: !1,
  name: void 0,
  orientation: "bottom",
  padding: {
    left: 0,
    right: 0
  },
  reversed: !1,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "category",
  unit: void 0
}, eC = (e, t) => e.cartesianAxis.xAxis[t], Ei = (e, t) => {
  var n = eC(e, t);
  return n ?? Rn;
}, In = {
  allowDataOverflow: !1,
  allowDecimals: !0,
  allowDuplicatedCategory: !0,
  angle: 0,
  dataKey: void 0,
  domain: wm,
  hide: !0,
  id: 0,
  includeHidden: !1,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: !1,
  name: void 0,
  orientation: "left",
  padding: {
    top: 0,
    bottom: 0
  },
  reversed: !1,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0,
  width: Tl
}, tC = (e, t) => e.cartesianAxis.yAxis[t], _i = (e, t) => {
  var n = tC(e, t);
  return n ?? In;
}, h6 = {
  domain: [0, "auto"],
  includeHidden: !1,
  reversed: !1,
  allowDataOverflow: !1,
  allowDuplicatedCategory: !1,
  dataKey: void 0,
  id: 0,
  name: "",
  range: [64, 64],
  scale: "auto",
  type: "number",
  unit: ""
}, bv = (e, t) => {
  var n = e.cartesianAxis.zAxis[t];
  return n ?? h6;
}, Pt = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return Ei(e, n);
    case "yAxis":
      return _i(e, n);
    case "zAxis":
      return bv(e, n);
    case "angleAxis":
      return mv(e, n);
    case "radiusAxis":
      return gv(e, n);
    default:
      throw new Error("Unexpected axis type: ".concat(t));
  }
}, m6 = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return Ei(e, n);
    case "yAxis":
      return _i(e, n);
    default:
      throw new Error("Unexpected axis type: ".concat(t));
  }
}, Ll = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return Ei(e, n);
    case "yAxis":
      return _i(e, n);
    case "angleAxis":
      return mv(e, n);
    case "radiusAxis":
      return gv(e, n);
    default:
      throw new Error("Unexpected axis type: ".concat(t));
  }
}, nC = (e) => e.graphicalItems.cartesianItems.some((t) => t.type === "bar") || e.graphicalItems.polarItems.some((t) => t.type === "radialBar");
function xv(e, t) {
  return (n) => {
    switch (e) {
      case "xAxis":
        return "xAxisId" in n && n.xAxisId === t;
      case "yAxis":
        return "yAxisId" in n && n.yAxisId === t;
      case "zAxis":
        return "zAxisId" in n && n.zAxisId === t;
      case "angleAxis":
        return "angleAxisId" in n && n.angleAxisId === t;
      case "radiusAxis":
        return "radiusAxisId" in n && n.radiusAxisId === t;
      default:
        return !1;
    }
  };
}
var tf = (e) => e.graphicalItems.cartesianItems, g6 = z([ft, $l], xv), wv = (e, t, n) => e.filter(n).filter((r) => t?.includeHidden === !0 ? !0 : !r.hide), Fl = z([tf, Pt, g6], wv), rC = z([Fl], (e) => e.filter((t) => t.type === "area" || t.type === "bar").filter(ef)), iC = (e) => e.filter((t) => !("stackId" in t) || t.stackId === void 0), oC = z([Fl], iC), Ov = (e) => e.map((t) => t.data).filter(Boolean).flat(1), v6 = z([Fl], Ov), Sv = (e, t) => {
  var {
    chartData: n = [],
    dataStartIndex: r,
    dataEndIndex: i
  } = t;
  return e.length > 0 ? e : n.slice(r, i + 1);
}, Ev = z([v6, Xd], Sv), _v = (e, t, n) => t?.dataKey != null ? e.map((r) => ({
  value: tt(r, t.dataKey)
})) : n.length > 0 ? n.map((r) => r.dataKey).flatMap((r) => e.map((i) => ({
  value: tt(i, r)
}))) : e.map((r) => ({
  value: r
})), nf = z([Ev, Pt, Fl], _v);
function aC(e, t) {
  switch (e) {
    case "xAxis":
      return t.direction === "x";
    case "yAxis":
      return t.direction === "y";
    default:
      return !1;
  }
}
function Ko(e) {
  return e.filter((t) => Fr(t) || t instanceof Date).map(Number).filter((t) => Hn(t) === !1);
}
function y6(e, t, n) {
  return !n || typeof t != "number" || Hn(t) ? [] : n.length ? Ko(n.flatMap((r) => {
    var i = tt(e, r.dataKey), o, a;
    if (Array.isArray(i) ? [o, a] = i : o = a = i, !(!qn(o) || !qn(a)))
      return [t - o, t + a];
  })) : [];
}
var b6 = z([rC, Xd, Xt], QP), sC = (e, t, n) => {
  var r = {}, i = t.reduce((o, a) => (a.stackId == null || (o[a.stackId] == null && (o[a.stackId] = []), o[a.stackId].push(a)), o), r);
  return Object.fromEntries(Object.entries(i).map((o) => {
    var [a, s] = o, l = s.map(yv);
    return [a, {
      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that
      stackedData: I5(e, l, n),
      graphicalItems: s
    }];
  }));
}, Om = z([b6, rC, Il], sC), lC = (e, t, n) => {
  var {
    dataStartIndex: r,
    dataEndIndex: i
  } = t;
  if (n !== "zAxis") {
    var o = z5(e, r, i);
    if (!(o != null && o[0] === 0 && o[1] === 0))
      return o;
  }
}, x6 = z([Om, Ji, ft], lC), cC = (e, t, n, r, i) => n.length > 0 ? e.flatMap((o) => n.flatMap((a) => {
  var s, l, c = (s = r[a.id]) === null || s === void 0 ? void 0 : s.filter((d) => aC(i, d)), u = tt(o, (l = t.dataKey) !== null && l !== void 0 ? l : a.dataKey);
  return {
    value: u,
    errorDomain: y6(o, u, c)
  };
})).filter(Boolean) : t?.dataKey != null ? e.map((o) => ({
  value: tt(o, t.dataKey),
  errorDomain: []
})) : e.map((o) => ({
  value: o,
  errorDomain: []
})), rf = (e) => e.errorBars, uC = (e, t, n) => e.flatMap((r) => t[r.id]).filter(Boolean).filter((r) => aC(n, r));
z([oC, rf, ft], uC);
var w6 = z([Ev, Pt, oC, rf, ft], cC);
function O6(e) {
  var {
    value: t
  } = e;
  if (Fr(t) || t instanceof Date)
    return t;
}
var K1 = (e) => {
  var t = e.flatMap((r) => [r.value, r.errorDomain]).flat(1), n = Ko(t);
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, S6 = (e, t, n) => {
  var r = e.map(O6).filter((i) => i != null);
  return n && (t.dataKey == null || t.allowDuplicatedCategory && g_(r)) ? G2(0, e.length) : t.allowDuplicatedCategory ? r : Array.from(new Set(r));
}, Pv = (e) => {
  var t;
  if (e == null || !("domain" in e))
    return wm;
  if (e.domain != null)
    return e.domain;
  if (e.ticks != null) {
    if (e.type === "number") {
      var n = Ko(e.ticks);
      return [Math.min(...n), Math.max(...n)];
    }
    if (e.type === "category")
      return e.ticks.map(String);
  }
  return (t = e?.domain) !== null && t !== void 0 ? t : wm;
}, Iu = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  var i = n.filter(Boolean);
  if (i.length !== 0) {
    var o = i.flat(), a = Math.min(...o), s = Math.max(...o);
    return [a, s];
  }
}, dC = (e) => e.referenceElements.dots, Va = (e, t, n) => e.filter((r) => r.ifOverflow === "extendDomain").filter((r) => t === "xAxis" ? r.xAxisId === n : r.yAxisId === n), E6 = z([dC, ft, $l], Va), fC = (e) => e.referenceElements.areas, _6 = z([fC, ft, $l], Va), pC = (e) => e.referenceElements.lines, P6 = z([pC, ft, $l], Va), hC = (e, t) => {
  var n = Ko(e.map((r) => t === "xAxis" ? r.x : r.y));
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, C6 = z(E6, ft, hC), mC = (e, t) => {
  var n = Ko(e.flatMap((r) => [t === "xAxis" ? r.x1 : r.y1, t === "xAxis" ? r.x2 : r.y2]));
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, A6 = z([_6, ft], mC), gC = (e, t) => {
  var n = Ko(e.map((r) => t === "xAxis" ? r.x : r.y));
  if (n.length !== 0)
    return [Math.min(...n), Math.max(...n)];
}, T6 = z(P6, ft, gC), k6 = z(C6, T6, A6, (e, t, n) => Iu(e, n, t)), vC = z([Pt], Pv), Cv = (e, t, n, r, i, o, a) => {
  var s = HB(t, e.allowDataOverflow);
  if (s != null)
    return s;
  var l = o === "vertical" && a === "xAxis" || o === "horizontal" && a === "yAxis", c = l ? Iu(n, i, K1(r)) : Iu(i, K1(r));
  return KB(t, c, e.allowDataOverflow);
}, M6 = z([Pt, vC, x6, w6, k6, _e, ft], Cv), j6 = [0, 1], Av = (e, t, n, r, i, o, a) => {
  if (!((e == null || n == null || n.length === 0) && a === void 0)) {
    var {
      dataKey: s,
      type: l
    } = e, c = Yi(t, o);
    return c && s == null ? G2(0, n.length) : l === "category" ? S6(r, e, c) : i === "expand" ? j6 : a;
  }
}, Tv = z([Pt, _e, Ev, nf, Il, ft, M6], Av), yC = (e, t, n, r, i) => {
  if (e != null) {
    var {
      scale: o,
      type: a
    } = e;
    if (o === "auto")
      return t === "radial" && i === "radiusAxis" ? "band" : t === "radial" && i === "angleAxis" ? "linear" : a === "category" && r && (r.indexOf("LineChart") >= 0 || r.indexOf("AreaChart") >= 0 || r.indexOf("ComposedChart") >= 0 && !n) ? "point" : a === "category" ? "band" : "linear";
    if (typeof o == "string") {
      var s = "scale".concat(El(o));
      return s in _s ? s : "point";
    }
  }
}, Ua = z([Pt, _e, nC, fv, ft], yC);
function N6(e) {
  if (e != null) {
    if (e in _s)
      return _s[e]();
    var t = "scale".concat(El(e));
    if (t in _s)
      return _s[t]();
  }
}
function kv(e, t, n, r) {
  if (!(n == null || r == null)) {
    if (typeof e.scale == "function")
      return e.scale.copy().domain(n).range(r);
    var i = N6(t);
    if (i != null) {
      var o = i.domain(n).range(r);
      return M5(o), o;
    }
  }
}
var Mv = (e, t, n) => {
  var r = Pv(t);
  if (!(n !== "auto" && n !== "linear")) {
    if (t != null && t.tickCount && Array.isArray(r) && (r[0] === "auto" || r[1] === "auto") && Aa(e))
      return n6(e, t.tickCount, t.allowDecimals);
    if (t != null && t.tickCount && t.type === "number" && Aa(e))
      return r6(e, t.tickCount, t.allowDecimals);
  }
}, jv = z([Tv, Ll, Ua], Mv), Nv = (e, t, n, r) => {
  if (
    /*
     * Angle axis for some reason uses nice ticks when rendering axis tick labels,
     * but doesn't use nice ticks for extending domain like all the other axes do.
     * Not really sure why? Is there a good reason,
     * or is it just because someone added support for nice ticks to the other axes and forgot this one?
     */
    r !== "angleAxis" && e?.type === "number" && Aa(t) && Array.isArray(n) && n.length > 0
  ) {
    var i = t[0], o = n[0], a = t[1], s = n[n.length - 1];
    return [Math.min(i, o), Math.max(a, s)];
  }
  return t;
}, D6 = z([Pt, Tv, jv, ft], Nv), R6 = z(nf, Pt, (e, t) => {
  if (!(!t || t.type !== "number")) {
    var n = 1 / 0, r = Array.from(Ko(e.map((s) => s.value))).sort((s, l) => s - l);
    if (r.length < 2)
      return 1 / 0;
    var i = r[r.length - 1] - r[0];
    if (i === 0)
      return 1 / 0;
    for (var o = 0; o < r.length - 1; o++) {
      var a = r[o + 1] - r[o];
      n = Math.min(n, a);
    }
    return n / i;
  }
}), bC = z(R6, _e, HP, Lt, (e, t, n, r) => r, (e, t, n, r, i) => {
  if (!qn(e))
    return 0;
  var o = t === "vertical" ? r.height : r.width;
  if (i === "gap")
    return e * o / 2;
  if (i === "no-gap") {
    var a = pn(n, e * o), s = e * o / 2;
    return s - a - (s - a) / o * a;
  }
  return 0;
}), I6 = (e, t) => {
  var n = Ei(e, t);
  return n == null || typeof n.padding != "string" ? 0 : bC(e, "xAxis", t, n.padding);
}, $6 = (e, t) => {
  var n = _i(e, t);
  return n == null || typeof n.padding != "string" ? 0 : bC(e, "yAxis", t, n.padding);
}, L6 = z(Ei, I6, (e, t) => {
  var n, r;
  if (e == null)
    return {
      left: 0,
      right: 0
    };
  var {
    padding: i
  } = e;
  return typeof i == "string" ? {
    left: t,
    right: t
  } : {
    left: ((n = i.left) !== null && n !== void 0 ? n : 0) + t,
    right: ((r = i.right) !== null && r !== void 0 ? r : 0) + t
  };
}), F6 = z(_i, $6, (e, t) => {
  var n, r;
  if (e == null)
    return {
      top: 0,
      bottom: 0
    };
  var {
    padding: i
  } = e;
  return typeof i == "string" ? {
    top: t,
    bottom: t
  } : {
    top: ((n = i.top) !== null && n !== void 0 ? n : 0) + t,
    bottom: ((r = i.bottom) !== null && r !== void 0 ? r : 0) + t
  };
}), B6 = z([Lt, L6, Wd, zd, (e, t, n) => n], (e, t, n, r, i) => {
  var {
    padding: o
  } = r;
  return i ? [o.left, n.width - o.right] : [e.left + t.left, e.left + e.width - t.right];
}), z6 = z([Lt, _e, F6, Wd, zd, (e, t, n) => n], (e, t, n, r, i, o) => {
  var {
    padding: a
  } = i;
  return o ? [r.height - a.bottom, a.top] : t === "horizontal" ? [e.top + e.height - n.bottom, e.top + n.top] : [e.top + n.top, e.top + e.height - n.bottom];
}), Bl = (e, t, n, r) => {
  var i;
  switch (t) {
    case "xAxis":
      return B6(e, n, r);
    case "yAxis":
      return z6(e, n, r);
    case "zAxis":
      return (i = bv(e, n)) === null || i === void 0 ? void 0 : i.range;
    case "angleAxis":
      return GP(e);
    case "radiusAxis":
      return XP(e, n);
    default:
      return;
  }
}, xC = z([Pt, Bl], Jd), Ha = z([Pt, Ua, D6, xC], kv);
z([Fl, rf, ft], uC);
function wC(e, t) {
  return e.id < t.id ? -1 : e.id > t.id ? 1 : 0;
}
var of = (e, t) => t, af = (e, t, n) => n, W6 = z(Fd, of, af, (e, t, n) => e.filter((r) => r.orientation === t).filter((r) => r.mirror === n).sort(wC)), V6 = z(Bd, of, af, (e, t, n) => e.filter((r) => r.orientation === t).filter((r) => r.mirror === n).sort(wC)), OC = (e, t) => ({
  width: e.width,
  height: t.height
}), U6 = (e, t) => {
  var n = typeof t.width == "number" ? t.width : Tl;
  return {
    width: n,
    height: e.height
  };
}, SC = z(Lt, Ei, OC), H6 = (e, t, n) => {
  switch (t) {
    case "top":
      return e.top;
    case "bottom":
      return n - e.bottom;
    default:
      return 0;
  }
}, K6 = (e, t, n) => {
  switch (t) {
    case "left":
      return e.left;
    case "right":
      return n - e.right;
    default:
      return 0;
  }
}, q6 = z(Oi, Lt, W6, of, af, (e, t, n, r, i) => {
  var o = {}, a;
  return n.forEach((s) => {
    var l = OC(t, s);
    a == null && (a = H6(t, r, e));
    var c = r === "top" && !i || r === "bottom" && i;
    o[s.id] = a - Number(c) * l.height, a += (c ? -1 : 1) * l.height;
  }), o;
}), Y6 = z(wi, Lt, V6, of, af, (e, t, n, r, i) => {
  var o = {}, a;
  return n.forEach((s) => {
    var l = U6(t, s);
    a == null && (a = K6(t, r, e));
    var c = r === "left" && !i || r === "right" && i;
    o[s.id] = a - Number(c) * l.width, a += (c ? -1 : 1) * l.width;
  }), o;
}), G6 = (e, t) => {
  var n = Ei(e, t);
  if (n != null)
    return q6(e, n.orientation, n.mirror);
}, X6 = z([Lt, Ei, G6, (e, t) => t], (e, t, n, r) => {
  if (t != null) {
    var i = n?.[r];
    return i == null ? {
      x: e.left,
      y: 0
    } : {
      x: e.left,
      y: i
    };
  }
}), Z6 = (e, t) => {
  var n = _i(e, t);
  if (n != null)
    return Y6(e, n.orientation, n.mirror);
}, J6 = z([Lt, _i, Z6, (e, t) => t], (e, t, n, r) => {
  if (t != null) {
    var i = n?.[r];
    return i == null ? {
      x: 0,
      y: e.top
    } : {
      x: i,
      y: e.top
    };
  }
}), EC = z(Lt, _i, (e, t) => {
  var n = typeof t.width == "number" ? t.width : Tl;
  return {
    width: n,
    height: e.height
  };
}), q1 = (e, t, n) => {
  switch (t) {
    case "xAxis":
      return SC(e, n).width;
    case "yAxis":
      return EC(e, n).height;
    default:
      return;
  }
}, _C = (e, t, n, r) => {
  if (n != null) {
    var {
      allowDuplicatedCategory: i,
      type: o,
      dataKey: a
    } = n, s = Yi(e, r), l = t.map((c) => c.value);
    if (a && s && o === "category" && i && g_(l))
      return l;
  }
}, Dv = z([_e, nf, Pt, ft], _C), PC = (e, t, n, r) => {
  if (!(n == null || n.dataKey == null)) {
    var {
      type: i,
      scale: o
    } = n, a = Yi(e, r);
    if (a && (i === "number" || o !== "auto"))
      return t.map((s) => s.value);
  }
}, Rv = z([_e, nf, Ll, ft], PC), Y1 = z([_e, m6, Ua, Ha, Dv, Rv, Bl, jv, ft], (e, t, n, r, i, o, a, s, l) => {
  if (t == null)
    return null;
  var c = Yi(e, l);
  return {
    angle: t.angle,
    interval: t.interval,
    minTickGap: t.minTickGap,
    orientation: t.orientation,
    tick: t.tick,
    tickCount: t.tickCount,
    tickFormatter: t.tickFormatter,
    ticks: t.ticks,
    type: t.type,
    unit: t.unit,
    axisType: l,
    categoricalDomain: o,
    duplicateDomain: i,
    isCategorical: c,
    niceTicks: s,
    range: a,
    realScaleType: n,
    scale: r
  };
}), Q6 = (e, t, n, r, i, o, a, s, l) => {
  if (!(t == null || r == null)) {
    var c = Yi(e, l), {
      type: u,
      ticks: d,
      tickCount: f
    } = t, p = n === "scaleBand" && typeof r.bandwidth == "function" ? r.bandwidth() / 2 : 2, g = u === "category" && r.bandwidth ? r.bandwidth() / p : 0;
    g = l === "angleAxis" && o != null && o.length >= 2 ? Ht(o[0] - o[1]) * 2 * g : g;
    var m = d || i;
    if (m) {
      var v = m.map((y, S) => {
        var x = a ? a.indexOf(y) : y;
        return {
          index: S,
          // If the scaleContent is not a number, the coordinate will be NaN.
          // That could be the case for example with a PointScale and a string as domain.
          coordinate: r(x) + g,
          value: y,
          offset: g
        };
      });
      return v.filter((y) => !Hn(y.coordinate));
    }
    return c && s ? s.map((y, S) => ({
      coordinate: r(y) + g,
      value: y,
      index: S,
      offset: g
    })) : r.ticks ? r.ticks(f).map((y) => ({
      coordinate: r(y) + g,
      value: y,
      offset: g
    })) : r.domain().map((y, S) => ({
      coordinate: r(y) + g,
      value: a ? a[y] : y,
      index: S,
      offset: g
    }));
  }
}, CC = z([_e, Ll, Ua, Ha, jv, Bl, Dv, Rv, ft], Q6), e3 = (e, t, n, r, i, o, a) => {
  if (!(t == null || n == null || r == null || r[0] === r[1])) {
    var s = Yi(e, a), {
      tickCount: l
    } = t, c = 0;
    return c = a === "angleAxis" && r?.length >= 2 ? Ht(r[0] - r[1]) * 2 * c : c, s && o ? o.map((u, d) => ({
      coordinate: n(u) + c,
      value: u,
      index: d,
      offset: c
    })) : n.ticks ? n.ticks(l).map((u) => ({
      coordinate: n(u) + c,
      value: u,
      offset: c
    })) : n.domain().map((u, d) => ({
      coordinate: n(u) + c,
      value: i ? i[u] : u,
      index: d,
      offset: c
    }));
  }
}, zi = z([_e, Ll, Ha, Bl, Dv, Rv, ft], e3), Wi = z(Pt, Ha, (e, t) => {
  if (!(e == null || t == null))
    return Ru(Ru({}, e), {}, {
      scale: t
    });
}), t3 = z([Pt, Ua, Tv, xC], kv);
z((e, t, n) => bv(e, n), t3, (e, t) => {
  if (!(e == null || t == null))
    return Ru(Ru({}, e), {}, {
      scale: t
    });
});
var n3 = z([_e, Fd, Bd], (e, t, n) => {
  switch (e) {
    case "horizontal":
      return t.some((r) => r.reversed) ? "right-to-left" : "left-to-right";
    case "vertical":
      return n.some((r) => r.reversed) ? "bottom-to-top" : "top-to-bottom";
    // TODO: make this better. For now, right arrow triggers "forward", left arrow "back"
    // however, the tooltip moves an unintuitive direction because of how the indices are rendered
    case "centric":
    case "radial":
      return "left-to-right";
    default:
      return;
  }
}), AC = (e) => e.options.defaultTooltipEventType, TC = (e) => e.options.validateTooltipEventTypes;
function kC(e, t, n) {
  if (e == null)
    return t;
  var r = e ? "axis" : "item";
  return n == null ? t : n.includes(r) ? r : t;
}
function Iv(e, t) {
  var n = AC(e), r = TC(e);
  return kC(t, n, r);
}
function r3(e) {
  return pe((t) => Iv(t, e));
}
var MC = (e, t) => {
  var n, r = Number(t);
  if (!(Hn(r) || t == null))
    return r >= 0 ? e == null || (n = e[r]) === null || n === void 0 ? void 0 : n.value : void 0;
}, i3 = (e) => e.tooltip.settings, Mi = {
  active: !1,
  index: null,
  dataKey: void 0,
  coordinate: void 0
}, o3 = {
  itemInteraction: {
    click: Mi,
    hover: Mi
  },
  axisInteraction: {
    click: Mi,
    hover: Mi
  },
  keyboardInteraction: Mi,
  syncInteraction: {
    active: !1,
    index: null,
    dataKey: void 0,
    label: void 0,
    coordinate: void 0
  },
  tooltipItemPayloads: [],
  settings: {
    shared: void 0,
    trigger: "hover",
    axisId: 0,
    active: !1,
    defaultIndex: void 0
  }
}, jC = Gn({
  name: "tooltip",
  initialState: o3,
  reducers: {
    addTooltipEntrySettings(e, t) {
      e.tooltipItemPayloads.push(t.payload);
    },
    removeTooltipEntrySettings(e, t) {
      var n = ui(e).tooltipItemPayloads.indexOf(t.payload);
      n > -1 && e.tooltipItemPayloads.splice(n, 1);
    },
    setTooltipSettingsState(e, t) {
      e.settings = t.payload;
    },
    setActiveMouseOverItemIndex(e, t) {
      e.syncInteraction.active = !1, e.keyboardInteraction.active = !1, e.itemInteraction.hover.active = !0, e.itemInteraction.hover.index = t.payload.activeIndex, e.itemInteraction.hover.dataKey = t.payload.activeDataKey, e.itemInteraction.hover.coordinate = t.payload.activeCoordinate;
    },
    mouseLeaveChart(e) {
      e.itemInteraction.hover.active = !1, e.axisInteraction.hover.active = !1;
    },
    mouseLeaveItem(e) {
      e.itemInteraction.hover.active = !1;
    },
    setActiveClickItemIndex(e, t) {
      e.syncInteraction.active = !1, e.itemInteraction.click.active = !0, e.keyboardInteraction.active = !1, e.itemInteraction.click.index = t.payload.activeIndex, e.itemInteraction.click.dataKey = t.payload.activeDataKey, e.itemInteraction.click.coordinate = t.payload.activeCoordinate;
    },
    setMouseOverAxisIndex(e, t) {
      e.syncInteraction.active = !1, e.axisInteraction.hover.active = !0, e.keyboardInteraction.active = !1, e.axisInteraction.hover.index = t.payload.activeIndex, e.axisInteraction.hover.dataKey = t.payload.activeDataKey, e.axisInteraction.hover.coordinate = t.payload.activeCoordinate;
    },
    setMouseClickAxisIndex(e, t) {
      e.syncInteraction.active = !1, e.keyboardInteraction.active = !1, e.axisInteraction.click.active = !0, e.axisInteraction.click.index = t.payload.activeIndex, e.axisInteraction.click.dataKey = t.payload.activeDataKey, e.axisInteraction.click.coordinate = t.payload.activeCoordinate;
    },
    setSyncInteraction(e, t) {
      e.syncInteraction = t.payload;
    },
    setKeyboardInteraction(e, t) {
      e.keyboardInteraction.active = t.payload.active, e.keyboardInteraction.index = t.payload.activeIndex, e.keyboardInteraction.coordinate = t.payload.activeCoordinate, e.keyboardInteraction.dataKey = t.payload.activeDataKey;
    }
  }
}), {
  addTooltipEntrySettings: a3,
  removeTooltipEntrySettings: s3,
  setTooltipSettingsState: l3,
  setActiveMouseOverItemIndex: NC,
  mouseLeaveItem: c3,
  mouseLeaveChart: DC,
  setActiveClickItemIndex: u3,
  setMouseOverAxisIndex: RC,
  setMouseClickAxisIndex: d3,
  setSyncInteraction: Sm,
  setKeyboardInteraction: Em
} = jC.actions, f3 = jC.reducer;
function G1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G1(Object(n), !0).forEach(function(r) {
      p3(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function p3(e, t, n) {
  return (t = h3(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function h3(e) {
  var t = m3(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function m3(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function g3(e, t, n) {
  return t === "axis" ? n === "click" ? e.axisInteraction.click : e.axisInteraction.hover : n === "click" ? e.itemInteraction.click : e.itemInteraction.hover;
}
function v3(e) {
  return e.index != null;
}
var IC = (e, t, n, r) => {
  if (t == null)
    return Mi;
  var i = g3(e, t, n);
  if (i == null)
    return Mi;
  if (i.active)
    return i;
  if (e.keyboardInteraction.active)
    return e.keyboardInteraction;
  if (e.syncInteraction.active && e.syncInteraction.index != null)
    return e.syncInteraction;
  var o = e.settings.active === !0;
  if (v3(i)) {
    if (o)
      return wc(wc({}, i), {}, {
        active: !0
      });
  } else if (r != null)
    return {
      active: !0,
      coordinate: void 0,
      dataKey: void 0,
      index: r
    };
  return wc(wc({}, Mi), {}, {
    coordinate: i.coordinate
  });
}, $v = (e, t) => {
  var n = e?.index;
  if (n == null)
    return null;
  var r = Number(n);
  if (!qn(r))
    return n;
  var i = 0, o = 1 / 0;
  return t.length > 0 && (o = t.length - 1), String(Math.max(i, Math.min(r, o)));
}, $C = (e, t, n, r, i, o, a, s) => {
  if (!(o == null || s == null)) {
    var l = a[0], c = l == null ? void 0 : s(l.positions, o);
    if (c != null)
      return c;
    var u = i?.[Number(o)];
    if (u)
      switch (n) {
        case "horizontal":
          return {
            x: u.coordinate,
            y: (r.top + t) / 2
          };
        default:
          return {
            x: (r.left + e) / 2,
            y: u.coordinate
          };
      }
  }
}, LC = (e, t, n, r) => {
  if (t === "axis")
    return e.tooltipItemPayloads;
  if (e.tooltipItemPayloads.length === 0)
    return [];
  var i;
  return n === "hover" ? i = e.itemInteraction.hover.dataKey : i = e.itemInteraction.click.dataKey, i == null && r != null ? [e.tooltipItemPayloads[0]] : e.tooltipItemPayloads.filter((o) => {
    var a;
    return ((a = o.settings) === null || a === void 0 ? void 0 : a.dataKey) === i;
  });
}, zl = (e) => e.options.tooltipPayloadSearcher, Ka = (e) => e.tooltip;
function X1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Z1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X1(Object(n), !0).forEach(function(r) {
      y3(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function y3(e, t, n) {
  return (t = b3(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function b3(e) {
  var t = x3(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function x3(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function w3(e, t) {
  return e ?? t;
}
var FC = (e, t, n, r, i, o, a) => {
  if (!(t == null || o == null)) {
    var {
      chartData: s,
      computedData: l,
      dataStartIndex: c,
      dataEndIndex: u
    } = n, d = [];
    return e.reduce((f, p) => {
      var g, {
        dataDefinedOnItem: m,
        settings: v
      } = p, y = w3(m, s), S = Array.isArray(y) ? A2(y, c, u) : y, x = (g = v?.dataKey) !== null && g !== void 0 ? g : r, b = v?.nameKey, w;
      if (r && Array.isArray(S) && /*
       * findEntryInArray won't work for Scatter because Scatter provides an array of arrays
       * as tooltip payloads and findEntryInArray is not prepared to handle that.
       * Sad but also ScatterChart only allows 'item' tooltipEventType
       * and also this is only a problem if there are multiple Scatters and each has its own data array
       * so let's fix that some other time.
       */
      !Array.isArray(S[0]) && /*
       * If the tooltipEventType is 'axis', we should search for the dataKey in the sliced data
       * because thanks to allowDuplicatedCategory=false, the order of elements in the array
       * no longer matches the order of elements in the original data
       * and so we need to search by the active dataKey + label rather than by index.
       *
       * The same happens if multiple graphical items are present in the chart
       * and each of them has its own data array. Those arrays get concatenated
       * and again the tooltip index no longer matches the original data.
       *
       * On the other hand the tooltipEventType 'item' should always search by index
       * because we get the index from interacting over the individual elements
       * which is always accurate, irrespective of the allowDuplicatedCategory setting.
       */
      a === "axis" ? w = v_(S, r, i) : w = o(S, t, l, b), Array.isArray(w))
        w.forEach((C) => {
          var A = Z1(Z1({}, v), {}, {
            name: C.name,
            unit: C.unit,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            color: void 0,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            fill: void 0
          });
          f.push(Rx({
            tooltipEntrySettings: A,
            dataKey: C.dataKey,
            payload: C.payload,
            // @ts-expect-error getValueByDataKey does not validate the output type
            value: tt(C.payload, C.dataKey),
            name: C.name
          }));
        });
      else {
        var E;
        f.push(Rx({
          tooltipEntrySettings: v,
          dataKey: x,
          payload: w,
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: tt(w, x),
          // @ts-expect-error getValueByDataKey does not validate the output type
          name: (E = tt(w, b)) !== null && E !== void 0 ? E : v?.name
        }));
      }
      return f;
    }, d);
  }
}, Lv = z([Xt, _e, nC, fv, Bt], yC), O3 = z([(e) => e.graphicalItems.cartesianItems, (e) => e.graphicalItems.polarItems], (e, t) => [...e, ...t]), S3 = z([Bt, Wa], xv), Wl = z([O3, Xt, S3], wv), E3 = z([Wl], (e) => e.filter(ef)), _3 = z([Wl], Ov), qa = z([_3, Ji], Sv), P3 = z([E3, Ji, Xt], QP), Fv = z([qa, Xt, Wl], _v), C3 = z([Xt], Pv), A3 = z([Wl], (e) => e.filter(ef)), T3 = z([P3, A3, Il], sC), k3 = z([T3, Ji, Bt], lC), M3 = z([Wl], iC), j3 = z([qa, Xt, M3, rf, Bt], cC), N3 = z([dC, Bt, Wa], Va), D3 = z([N3, Bt], hC), R3 = z([fC, Bt, Wa], Va), I3 = z([R3, Bt], mC), $3 = z([pC, Bt, Wa], Va), L3 = z([$3, Bt], gC), F3 = z([D3, L3, I3], Iu), B3 = z([Xt, C3, k3, j3, F3, _e, Bt], Cv), BC = z([Xt, _e, qa, Fv, Il, Bt, B3], Av), z3 = z([BC, Xt, Lv], Mv), W3 = z([Xt, BC, z3, Bt], Nv), zC = (e) => {
  var t = Bt(e), n = Wa(e), r = !1;
  return Bl(e, t, n, r);
}, WC = z([Xt, zC], Jd), VC = z([Xt, Lv, W3, WC], kv), V3 = z([_e, Fv, Xt, Bt], _C), U3 = z([_e, Fv, Xt, Bt], PC), H3 = (e, t, n, r, i, o, a, s) => {
  if (t) {
    var {
      type: l
    } = t, c = Yi(e, s);
    if (r) {
      var u = n === "scaleBand" && r.bandwidth ? r.bandwidth() / 2 : 2, d = l === "category" && r.bandwidth ? r.bandwidth() / u : 0;
      return d = s === "angleAxis" && i != null && i?.length >= 2 ? Ht(i[0] - i[1]) * 2 * d : d, c && a ? a.map((f, p) => ({
        coordinate: r(f) + d,
        value: f,
        index: p,
        offset: d
      })) : r.domain().map((f, p) => ({
        coordinate: r(f) + d,
        value: o ? o[f] : f,
        index: p,
        offset: d
      }));
    }
  }
}, Pi = z([_e, Xt, Lv, VC, zC, V3, U3, Bt], H3), Bv = z([AC, TC, i3], (e, t, n) => kC(n.shared, e, t)), UC = (e) => e.tooltip.settings.trigger, zv = (e) => e.tooltip.settings.defaultIndex, sf = z([Ka, Bv, UC, zv], IC), Vi = z([sf, qa], $v), HC = z([Pi, Vi], MC), KC = z([sf], (e) => {
  if (e)
    return e.dataKey;
}), qC = z([Ka, Bv, UC, zv], LC), K3 = z([wi, Oi, _e, Lt, Pi, zv, qC, zl], $C), q3 = z([sf, K3], (e, t) => e != null && e.coordinate ? e.coordinate : t), Y3 = z([sf], (e) => e.active), G3 = z([qC, Vi, Ji, JP, HC, zl, Bv], FC), X3 = z([G3], (e) => {
  if (e != null) {
    var t = e.map((n) => n.payload).filter((n) => n != null);
    return Array.from(new Set(t));
  }
});
function J1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Q1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? J1(Object(n), !0).forEach(function(r) {
      Z3(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Z3(e, t, n) {
  return (t = J3(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function J3(e) {
  var t = Q3(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Q3(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var e8 = () => pe(Xt), t8 = () => {
  var e = e8(), t = pe(Pi), n = pe(VC);
  return Gs(Q1(Q1({}, e), {}, {
    scale: n
  }), t);
}, n8 = () => pe(fv), Wv = (e, t) => t, YC = (e, t, n) => n, Vv = (e, t, n, r) => r, r8 = z(Pi, (e) => Dd(e, (t) => t.coordinate)), Uv = z([Ka, Wv, YC, Vv], IC), GC = z([Uv, qa], $v), i8 = (e, t, n) => {
  if (t != null) {
    var r = Ka(e);
    return t === "axis" ? n === "hover" ? r.axisInteraction.hover.dataKey : r.axisInteraction.click.dataKey : n === "hover" ? r.itemInteraction.hover.dataKey : r.itemInteraction.click.dataKey;
  }
}, XC = z([Ka, Wv, YC, Vv], LC), $u = z([wi, Oi, _e, Lt, Pi, Vv, XC, zl], $C), o8 = z([Uv, $u], (e, t) => {
  var n;
  return (n = e.coordinate) !== null && n !== void 0 ? n : t;
}), ZC = z(Pi, GC, MC), a8 = z([XC, GC, Ji, JP, ZC, zl, Wv], FC), s8 = z([Uv], (e) => ({
  isActive: e.active,
  activeIndex: e.index
})), l8 = (e, t, n, r, i, o, a, s) => {
  if (!(!e || !t || !r || !i || !o)) {
    var l = W5(e.chartX, e.chartY, t, n, s);
    if (l) {
      var c = U5(l, t), u = T5(c, a, o, r, i), d = V5(t, o, u, l);
      return {
        activeIndex: String(u),
        activeCoordinate: d
      };
    }
  }
};
function _m() {
  return _m = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, _m.apply(null, arguments);
}
function ew(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ew(Object(n), !0).forEach(function(r) {
      c8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ew(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function c8(e, t, n) {
  return (t = u8(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function u8(e) {
  var t = d8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function d8(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function f8(e) {
  var {
    coordinate: t,
    payload: n,
    index: r,
    offset: i,
    tooltipAxisBandSize: o,
    layout: a,
    cursor: s,
    tooltipEventType: l,
    chartName: c
  } = e, u = t, d = n, f = r;
  if (!s || !u || c !== "ScatterChart" && l !== "axis")
    return null;
  var p, g;
  if (c === "ScatterChart")
    p = u, g = ML;
  else if (c === "BarChart")
    p = jL(a, u, i, o), g = H2;
  else if (a === "radial") {
    var {
      cx: m,
      cy: v,
      radius: y,
      startAngle: S,
      endAngle: x
    } = K2(u);
    p = {
      cx: m,
      cy: v,
      startAngle: S,
      endAngle: x,
      innerRadius: y,
      outerRadius: y
    }, g = Y2;
  } else
    p = {
      points: d4(a, u, i)
    }, g = Fg;
  var b = typeof s == "object" && "className" in s ? s.className : void 0, w = Oc(Oc(Oc(Oc({
    stroke: "#ccc",
    pointerEvents: "none"
  }, i), p), ht(s, !1)), {}, {
    payload: d,
    payloadIndex: f,
    className: ce("recharts-tooltip-cursor", b)
  });
  return /* @__PURE__ */ bn(s) ? /* @__PURE__ */ sr(s, w) : /* @__PURE__ */ vE(g, w);
}
function p8(e) {
  var t = t8(), n = D2(), r = Vd(), i = n8();
  return /* @__PURE__ */ _.createElement(f8, _m({}, e, {
    coordinate: e.coordinate,
    index: e.index,
    payload: e.payload,
    offset: n,
    layout: r,
    tooltipAxisBandSize: t,
    chartName: i
  }));
}
var JC = /* @__PURE__ */ hr(null), h8 = () => Vr(JC), Jp = { exports: {} }, tw;
function m8() {
  return tw || (tw = 1, (function(e) {
    var t = Object.prototype.hasOwnProperty, n = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
    function i(l, c, u) {
      this.fn = l, this.context = c, this.once = u || !1;
    }
    function o(l, c, u, d, f) {
      if (typeof u != "function")
        throw new TypeError("The listener must be a function");
      var p = new i(u, d || l, f), g = n ? n + c : c;
      return l._events[g] ? l._events[g].fn ? l._events[g] = [l._events[g], p] : l._events[g].push(p) : (l._events[g] = p, l._eventsCount++), l;
    }
    function a(l, c) {
      --l._eventsCount === 0 ? l._events = new r() : delete l._events[c];
    }
    function s() {
      this._events = new r(), this._eventsCount = 0;
    }
    s.prototype.eventNames = function() {
      var c = [], u, d;
      if (this._eventsCount === 0) return c;
      for (d in u = this._events)
        t.call(u, d) && c.push(n ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;
    }, s.prototype.listeners = function(c) {
      var u = n ? n + c : c, d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, p = d.length, g = new Array(p); f < p; f++)
        g[f] = d[f].fn;
      return g;
    }, s.prototype.listenerCount = function(c) {
      var u = n ? n + c : c, d = this._events[u];
      return d ? d.fn ? 1 : d.length : 0;
    }, s.prototype.emit = function(c, u, d, f, p, g) {
      var m = n ? n + c : c;
      if (!this._events[m]) return !1;
      var v = this._events[m], y = arguments.length, S, x;
      if (v.fn) {
        switch (v.once && this.removeListener(c, v.fn, void 0, !0), y) {
          case 1:
            return v.fn.call(v.context), !0;
          case 2:
            return v.fn.call(v.context, u), !0;
          case 3:
            return v.fn.call(v.context, u, d), !0;
          case 4:
            return v.fn.call(v.context, u, d, f), !0;
          case 5:
            return v.fn.call(v.context, u, d, f, p), !0;
          case 6:
            return v.fn.call(v.context, u, d, f, p, g), !0;
        }
        for (x = 1, S = new Array(y - 1); x < y; x++)
          S[x - 1] = arguments[x];
        v.fn.apply(v.context, S);
      } else {
        var b = v.length, w;
        for (x = 0; x < b; x++)
          switch (v[x].once && this.removeListener(c, v[x].fn, void 0, !0), y) {
            case 1:
              v[x].fn.call(v[x].context);
              break;
            case 2:
              v[x].fn.call(v[x].context, u);
              break;
            case 3:
              v[x].fn.call(v[x].context, u, d);
              break;
            case 4:
              v[x].fn.call(v[x].context, u, d, f);
              break;
            default:
              if (!S) for (w = 1, S = new Array(y - 1); w < y; w++)
                S[w - 1] = arguments[w];
              v[x].fn.apply(v[x].context, S);
          }
      }
      return !0;
    }, s.prototype.on = function(c, u, d) {
      return o(this, c, u, d, !1);
    }, s.prototype.once = function(c, u, d) {
      return o(this, c, u, d, !0);
    }, s.prototype.removeListener = function(c, u, d, f) {
      var p = n ? n + c : c;
      if (!this._events[p]) return this;
      if (!u)
        return a(this, p), this;
      var g = this._events[p];
      if (g.fn)
        g.fn === u && (!f || g.once) && (!d || g.context === d) && a(this, p);
      else {
        for (var m = 0, v = [], y = g.length; m < y; m++)
          (g[m].fn !== u || f && !g[m].once || d && g[m].context !== d) && v.push(g[m]);
        v.length ? this._events[p] = v.length === 1 ? v[0] : v : a(this, p);
      }
      return this;
    }, s.prototype.removeAllListeners = function(c) {
      var u;
      return c ? (u = n ? n + c : c, this._events[u] && a(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
    }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, e.exports = s;
  })(Jp)), Jp.exports;
}
var g8 = m8();
const v8 = /* @__PURE__ */ xi(g8);
var nl = new v8(), Pm = "recharts.syncEvent.tooltip", nw = "recharts.syncEvent.brush";
function Hv(e, t) {
  if (t) {
    var n = Number.parseInt(t, 10);
    if (!Hn(n))
      return e?.[n];
  }
}
var y8 = {
  chartName: "",
  tooltipPayloadSearcher: void 0,
  eventEmitter: void 0,
  defaultTooltipEventType: "axis"
}, QC = Gn({
  name: "options",
  initialState: y8,
  reducers: {
    createEventEmitter: (e) => {
      e.eventEmitter == null && (e.eventEmitter = Symbol("rechartsEventEmitter"));
    }
  }
}), b8 = QC.reducer, {
  createEventEmitter: x8
} = QC.actions;
function w8(e) {
  return e.tooltip.syncInteraction;
}
var O8 = {
  chartData: void 0,
  computedData: void 0,
  dataStartIndex: 0,
  dataEndIndex: 0
}, eA = Gn({
  name: "chartData",
  initialState: O8,
  reducers: {
    setChartData(e, t) {
      if (e.chartData = t.payload, t.payload == null) {
        e.dataStartIndex = 0, e.dataEndIndex = 0;
        return;
      }
      t.payload.length > 0 && e.dataEndIndex !== t.payload.length - 1 && (e.dataEndIndex = t.payload.length - 1);
    },
    setComputedData(e, t) {
      e.computedData = t.payload;
    },
    setDataStartEndIndexes(e, t) {
      var {
        startIndex: n,
        endIndex: r
      } = t.payload;
      n != null && (e.dataStartIndex = n), r != null && (e.dataEndIndex = r);
    }
  }
}), {
  setChartData: rw,
  setDataStartEndIndexes: S8,
  setComputedData: Dee
} = eA.actions, E8 = eA.reducer, _8 = ["x", "y"];
function iw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ao(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iw(Object(n), !0).forEach(function(r) {
      P8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function P8(e, t, n) {
  return (t = C8(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function C8(e) {
  var t = A8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function A8(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function T8(e, t) {
  if (e == null) return {};
  var n, r, i = k8(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function k8(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var tA = () => {
};
function M8() {
  var e = pe(pv), t = pe(hv), n = _t(), r = pe(KP), i = pe(Pi), o = Vd(), a = Lg(), s = pe((l) => l.rootProps.className);
  Le(() => {
    if (e == null)
      return tA;
    var l = (c, u, d) => {
      if (t !== d && e === c) {
        if (r === "index") {
          var f;
          if (a && u !== null && u !== void 0 && (f = u.payload) !== null && f !== void 0 && f.coordinate) {
            var p = u.payload.coordinate, {
              x: g,
              y: m
            } = p, v = T8(p, _8), y = ao(ao(ao({}, v), typeof g == "number" && {
              x: Math.max(a.x, Math.min(g, a.x + a.width))
            }), typeof m == "number" && {
              y: Math.max(a.y, Math.min(m, a.y + a.height))
            }), S = ao(ao({}, u), {}, {
              payload: ao(ao({}, u.payload), {}, {
                coordinate: y
              })
            });
            n(S);
          } else
            n(u);
          return;
        }
        if (i != null) {
          var x;
          if (typeof r == "function") {
            var b = {
              activeTooltipIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
              isTooltipActive: u.payload.active,
              activeIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
              activeLabel: u.payload.label,
              activeDataKey: u.payload.dataKey,
              activeCoordinate: u.payload.coordinate
            }, w = r(i, b);
            x = i[w];
          } else r === "value" && (x = i.find((D) => String(D.value) === u.payload.label));
          var {
            coordinate: E
          } = u.payload;
          if (x == null || u.payload.active === !1 || E == null || a == null) {
            n(Sm({
              active: !1,
              coordinate: void 0,
              dataKey: void 0,
              index: null,
              label: void 0
            }));
            return;
          }
          var {
            x: C,
            y: A
          } = E, k = Math.min(C, a.x + a.width), R = Math.min(A, a.y + a.height), M = {
            x: o === "horizontal" ? x.coordinate : k,
            y: o === "horizontal" ? R : x.coordinate
          }, P = Sm({
            active: u.payload.active,
            coordinate: M,
            dataKey: u.payload.dataKey,
            index: String(x.index),
            label: u.payload.label
          });
          n(P);
        }
      }
    };
    return nl.on(Pm, l), () => {
      nl.off(Pm, l);
    };
  }, [s, n, t, e, r, i, o, a]);
}
function j8() {
  var e = pe(pv), t = pe(hv), n = _t();
  Le(() => {
    if (e == null)
      return tA;
    var r = (i, o, a) => {
      t !== a && e === i && n(S8(o));
    };
    return nl.on(nw, r), () => {
      nl.off(nw, r);
    };
  }, [n, t, e]);
}
function N8() {
  var e = _t();
  Le(() => {
    e(x8());
  }, [e]), M8(), j8();
}
function D8(e, t, n, r, i, o) {
  var a = pe((f) => i8(f, e, t)), s = pe(hv), l = pe(pv), c = pe(KP), u = pe(w8), d = u?.active;
  Le(() => {
    if (!d && l != null && s != null) {
      var f = Sm({
        active: o,
        coordinate: n,
        dataKey: a,
        index: i,
        label: typeof r == "number" ? String(r) : r
      });
      nl.emit(Pm, l, f, s);
    }
  }, [d, n, a, i, r, s, l, c, o]);
}
function ow(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ow(Object(n), !0).forEach(function(r) {
      R8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ow(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function R8(e, t, n) {
  return (t = I8(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function I8(e) {
  var t = $8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function $8(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function L8(e) {
  return e.dataKey;
}
function F8(e, t) {
  return /* @__PURE__ */ _.isValidElement(e) ? /* @__PURE__ */ _.cloneElement(e, t) : typeof e == "function" ? /* @__PURE__ */ _.createElement(e, t) : /* @__PURE__ */ _.createElement(cL, t);
}
var sw = [], B8 = {
  allowEscapeViewBox: {
    x: !1,
    y: !1
  },
  animationDuration: 400,
  animationEasing: "ease",
  axisId: 0,
  contentStyle: {},
  cursor: !0,
  filterNull: !0,
  isAnimationActive: !Gi.isSsr,
  itemSorter: "name",
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: !1,
    y: !1
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  wrapperStyle: {}
};
function qo(e) {
  var t = rn(e, B8), {
    active: n,
    allowEscapeViewBox: r,
    animationDuration: i,
    animationEasing: o,
    content: a,
    filterNull: s,
    isAnimationActive: l,
    offset: c,
    payloadUniqBy: u,
    position: d,
    reverseDirection: f,
    useTranslate3d: p,
    wrapperStyle: g,
    cursor: m,
    shared: v,
    trigger: y,
    defaultIndex: S,
    portal: x,
    axisId: b
  } = t, w = _t(), E = typeof S == "number" ? String(S) : S;
  Le(() => {
    w(l3({
      shared: v,
      trigger: y,
      axisId: b,
      active: n,
      defaultIndex: E
    }));
  }, [w, v, y, b, n, E]);
  var C = Lg(), A = B2(), k = r3(v), {
    activeIndex: R,
    isActive: M
  } = pe((Q) => s8(Q, k, y, E)), P = pe((Q) => a8(Q, k, y, E)), D = pe((Q) => ZC(Q, k, y, E)), j = pe((Q) => o8(Q, k, y, E)), N = P, $ = h8(), F = n ?? M, [q, B] = a$([N, F]), L = k === "axis" ? D : void 0;
  D8(k, y, j, L, R, F);
  var Y = x ?? $;
  if (Y == null)
    return null;
  var K = N ?? sw;
  F || (K = sw), s && K.length && (K = AI(N.filter((Q) => Q.value != null && (Q.hide !== !0 || t.includeHidden)), u, L8));
  var te = K.length > 0, J = /* @__PURE__ */ _.createElement(gL, {
    allowEscapeViewBox: r,
    animationDuration: i,
    animationEasing: o,
    isAnimationActive: l,
    active: F,
    coordinate: j,
    hasPayload: te,
    offset: c,
    position: d,
    reverseDirection: f,
    useTranslate3d: p,
    viewBox: C,
    wrapperStyle: g,
    lastBoundingBox: q,
    innerRef: B,
    hasPortalFromProps: !!x
  }, F8(a, aw(aw({}, t), {}, {
    // @ts-expect-error renderContent method expects the payload to be mutable, TODO make it immutable
    payload: K,
    label: L,
    active: F,
    coordinate: j,
    accessibilityLayer: A
  })));
  return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ xE(J, Y), F && /* @__PURE__ */ _.createElement(p8, {
    cursor: m,
    tooltipEventType: k,
    coordinate: j,
    payload: N,
    index: R
  }));
}
var Qp = {}, eh = {}, th = {}, lw;
function z8() {
  return lw || (lw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n, r, { signal: i, edges: o } = {}) {
      let a, s = null;
      const l = o != null && o.includes("leading"), c = o == null || o.includes("trailing"), u = () => {
        s !== null && (n.apply(a, s), a = void 0, s = null);
      }, d = () => {
        c && u(), m();
      };
      let f = null;
      const p = () => {
        f != null && clearTimeout(f), f = setTimeout(() => {
          f = null, d();
        }, r);
      }, g = () => {
        f !== null && (clearTimeout(f), f = null);
      }, m = () => {
        g(), a = void 0, s = null;
      }, v = () => {
        u();
      }, y = function(...S) {
        if (i?.aborted)
          return;
        a = this, s = S;
        const x = f == null;
        p(), l && x && u();
      };
      return y.schedule = p, y.cancel = m, y.flush = v, i?.addEventListener("abort", m, { once: !0 }), y;
    }
    e.debounce = t;
  })(th)), th;
}
var cw;
function W8() {
  return cw || (cw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ z8();
    function n(r, i = 0, o = {}) {
      typeof o != "object" && (o = {});
      const { leading: a = !1, trailing: s = !0, maxWait: l } = o, c = Array(2);
      a && (c[0] = "leading"), s && (c[1] = "trailing");
      let u, d = null;
      const f = t.debounce(function(...m) {
        u = r.apply(this, m), d = null;
      }, i, { edges: c }), p = function(...m) {
        return l != null && (d === null && (d = Date.now()), Date.now() - d >= l) ? (u = r.apply(this, m), d = Date.now(), f.cancel(), f.schedule(), u) : (f.apply(this, m), u);
      }, g = () => (f.flush(), u);
      return p.cancel = f.cancel, p.flush = g, p;
    }
    e.debounce = n;
  })(eh)), eh;
}
var uw;
function V8() {
  return uw || (uw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ W8();
    function n(r, i = 0, o = {}) {
      const { leading: a = !0, trailing: s = !0 } = o;
      return t.debounce(r, i, {
        leading: a,
        maxWait: i,
        trailing: s
      });
    }
    e.throttle = n;
  })(Qp)), Qp;
}
var nh, dw;
function U8() {
  return dw || (dw = 1, nh = V8().throttle), nh;
}
var H8 = /* @__PURE__ */ U8();
const K8 = /* @__PURE__ */ xi(H8);
var q8 = process.env.NODE_ENV !== "production", js = function(t, n) {
  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
    i[o - 2] = arguments[o];
  if (q8 && typeof console < "u" && console.warn && (n === void 0 && console.warn("LogUtils requires an error message argument"), !t))
    if (n === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var a = 0;
      console.warn(n.replace(/%s/g, () => i[a++]));
    }
};
function fw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fw(Object(n), !0).forEach(function(r) {
      Y8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Y8(e, t, n) {
  return (t = G8(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function G8(e) {
  var t = X8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function X8(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Yo = /* @__PURE__ */ nn((e, t) => {
  var {
    aspect: n,
    initialDimension: r = {
      width: -1,
      height: -1
    },
    width: i = "100%",
    height: o = "100%",
    /*
     * default min-width to 0 if not specified - 'auto' causes issues with flexbox
     * https://github.com/recharts/recharts/issues/172
     */
    minWidth: a = 0,
    minHeight: s,
    maxHeight: l,
    children: c,
    debounce: u = 0,
    id: d,
    className: f,
    onResize: p,
    style: g = {}
  } = e, m = Ue(null), v = Ue();
  v.current = p, yE(t, () => m.current);
  var [y, S] = Rt({
    containerWidth: r.width,
    containerHeight: r.height
  }), x = pt((w, E) => {
    S((C) => {
      var A = Math.round(w), k = Math.round(E);
      return C.containerWidth === A && C.containerHeight === k ? C : {
        containerWidth: A,
        containerHeight: k
      };
    });
  }, []);
  Le(() => {
    var w = (k) => {
      var R, {
        width: M,
        height: P
      } = k[0].contentRect;
      x(M, P), (R = v.current) === null || R === void 0 || R.call(v, M, P);
    };
    u > 0 && (w = K8(w, u, {
      trailing: !0,
      leading: !1
    }));
    var E = new ResizeObserver(w), {
      width: C,
      height: A
    } = m.current.getBoundingClientRect();
    return x(C, A), E.observe(m.current), () => {
      E.disconnect();
    };
  }, [x, u]);
  var b = Ur(() => {
    var {
      containerWidth: w,
      containerHeight: E
    } = y;
    if (w < 0 || E < 0)
      return null;
    js(wo(i) || wo(o), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, i, o), js(!n || n > 0, "The aspect(%s) must be greater than zero.", n);
    var C = wo(i) ? w : i, A = wo(o) ? E : o;
    return n && n > 0 && (C ? A = C / n : A && (C = A * n), l && A > l && (A = l)), js(C > 0 || A > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, C, A, i, o, a, s, n), _.Children.map(c, (k) => /* @__PURE__ */ sr(k, {
      width: C,
      height: A,
      // calculate the actual size and override it.
      style: rh({
        width: C,
        height: A
      }, k.props.style)
    }));
  }, [n, c, o, l, s, a, y, i]);
  return /* @__PURE__ */ _.createElement("div", {
    id: d ? "".concat(d) : void 0,
    className: ce("recharts-responsive-container", f),
    style: rh(rh({}, g), {}, {
      width: i,
      height: o,
      minWidth: a,
      minHeight: s,
      maxHeight: l
    }),
    ref: m
  }, /* @__PURE__ */ _.createElement("div", {
    style: {
      width: 0,
      height: 0,
      overflow: "visible"
    }
  }, b));
}), zr = (e) => null;
zr.displayName = "Cell";
function Z8(e, t, n) {
  return (t = J8(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function J8(e) {
  var t = Q8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Q8(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
class ez {
  constructor(t) {
    Z8(this, "cache", /* @__PURE__ */ new Map()), this.maxSize = t;
  }
  get(t) {
    var n = this.cache.get(t);
    return n !== void 0 && (this.cache.delete(t), this.cache.set(t, n)), n;
  }
  set(t, n) {
    if (this.cache.has(t))
      this.cache.delete(t);
    else if (this.cache.size >= this.maxSize) {
      var r = this.cache.keys().next().value;
      this.cache.delete(r);
    }
    this.cache.set(t, n);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
}
function pw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pw(Object(n), !0).forEach(function(r) {
      nz(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function nz(e, t, n) {
  return (t = rz(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function rz(e) {
  var t = iz(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function iz(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var oz = {
  cacheSize: 2e3,
  enableCache: !0
}, nA = tz({}, oz), hw = new ez(nA.cacheSize), az = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
}, mw = "recharts_measurement_span";
function sz(e, t) {
  var n = t.fontSize || "", r = t.fontFamily || "", i = t.fontWeight || "", o = t.fontStyle || "", a = t.letterSpacing || "", s = t.textTransform || "";
  return "".concat(e, "|").concat(n, "|").concat(r, "|").concat(i, "|").concat(o, "|").concat(a, "|").concat(s);
}
var gw = (e, t) => {
  try {
    var n = document.getElementById(mw);
    n || (n = document.createElement("span"), n.setAttribute("id", mw), n.setAttribute("aria-hidden", "true"), document.body.appendChild(n)), Object.assign(n.style, az, t), n.textContent = "".concat(e);
    var r = n.getBoundingClientRect();
    return {
      width: r.width,
      height: r.height
    };
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
}, Ns = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (t == null || Gi.isSsr)
    return {
      width: 0,
      height: 0
    };
  if (!nA.enableCache)
    return gw(t, n);
  var r = sz(t, n), i = hw.get(r);
  if (i)
    return i;
  var o = gw(t, n);
  return hw.set(r, o), o;
}, vw = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, yw = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, lz = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, cz = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/, rA = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
}, uz = Object.keys(rA), da = "NaN";
function dz(e, t) {
  return e * rA[t];
}
class En {
  static parse(t) {
    var n, [, r, i] = (n = cz.exec(t)) !== null && n !== void 0 ? n : [];
    return new En(parseFloat(r), i ?? "");
  }
  constructor(t, n) {
    this.num = t, this.unit = n, this.num = t, this.unit = n, Hn(t) && (this.unit = ""), n !== "" && !lz.test(n) && (this.num = NaN, this.unit = ""), uz.includes(n) && (this.num = dz(t, n), this.unit = "px");
  }
  add(t) {
    return this.unit !== t.unit ? new En(NaN, "") : new En(this.num + t.num, this.unit);
  }
  subtract(t) {
    return this.unit !== t.unit ? new En(NaN, "") : new En(this.num - t.num, this.unit);
  }
  multiply(t) {
    return this.unit !== "" && t.unit !== "" && this.unit !== t.unit ? new En(NaN, "") : new En(this.num * t.num, this.unit || t.unit);
  }
  divide(t) {
    return this.unit !== "" && t.unit !== "" && this.unit !== t.unit ? new En(NaN, "") : new En(this.num / t.num, this.unit || t.unit);
  }
  toString() {
    return "".concat(this.num).concat(this.unit);
  }
  isNaN() {
    return Hn(this.num);
  }
}
function iA(e) {
  if (e.includes(da))
    return da;
  for (var t = e; t.includes("*") || t.includes("/"); ) {
    var n, [, r, i, o] = (n = vw.exec(t)) !== null && n !== void 0 ? n : [], a = En.parse(r ?? ""), s = En.parse(o ?? ""), l = i === "*" ? a.multiply(s) : a.divide(s);
    if (l.isNaN())
      return da;
    t = t.replace(vw, l.toString());
  }
  for (; t.includes("+") || /.-\d+(?:\.\d+)?/.test(t); ) {
    var c, [, u, d, f] = (c = yw.exec(t)) !== null && c !== void 0 ? c : [], p = En.parse(u ?? ""), g = En.parse(f ?? ""), m = d === "+" ? p.add(g) : p.subtract(g);
    if (m.isNaN())
      return da;
    t = t.replace(yw, m.toString());
  }
  return t;
}
var bw = /\(([^()]*)\)/;
function fz(e) {
  for (var t = e, n; (n = bw.exec(t)) != null; ) {
    var [, r] = n;
    t = t.replace(bw, iA(r));
  }
  return t;
}
function pz(e) {
  var t = e.replace(/\s+/g, "");
  return t = fz(t), t = iA(t), t;
}
function hz(e) {
  try {
    return pz(e);
  } catch {
    return da;
  }
}
function ih(e) {
  var t = hz(e.slice(5, -1));
  return t === da ? "" : t;
}
var mz = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], gz = ["dx", "dy", "angle", "className", "breakAll"];
function Cm() {
  return Cm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Cm.apply(null, arguments);
}
function xw(e, t) {
  if (e == null) return {};
  var n, r, i = vz(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function vz(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var oA = /[ \f\n\r\t\v\u2028\u2029]+/, aA = (e) => {
  var {
    children: t,
    breakAll: n,
    style: r
  } = e;
  try {
    var i = [];
    dt(t) || (n ? i = t.toString().split("") : i = t.toString().split(oA));
    var o = i.map((s) => ({
      word: s,
      width: Ns(s, r).width
    })), a = n ? 0 : Ns("", r).width;
    return {
      wordsWithComputedWidth: o,
      spaceWidth: a
    };
  } catch {
    return null;
  }
}, yz = (e, t, n, r, i) => {
  var {
    maxLines: o,
    children: a,
    style: s,
    breakAll: l
  } = e, c = me(o), u = a, d = function() {
    var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return M.reduce((P, D) => {
      var {
        word: j,
        width: N
      } = D, $ = P[P.length - 1];
      if ($ && (r == null || i || $.width + N + n < Number(r)))
        $.words.push(j), $.width += N + n;
      else {
        var F = {
          words: [j],
          width: N
        };
        P.push(F);
      }
      return P;
    }, []);
  }, f = d(t), p = (R) => R.reduce((M, P) => M.width > P.width ? M : P);
  if (!c || i)
    return f;
  var g = f.length > o || p(f).width > Number(r);
  if (!g)
    return f;
  for (var m = "", v = (R) => {
    var M = u.slice(0, R), P = aA({
      breakAll: l,
      style: s,
      children: M + m
    }).wordsWithComputedWidth, D = d(P), j = D.length > o || p(D).width > Number(r);
    return [j, D];
  }, y = 0, S = u.length - 1, x = 0, b; y <= S && x <= u.length - 1; ) {
    var w = Math.floor((y + S) / 2), E = w - 1, [C, A] = v(E), [k] = v(w);
    if (!C && !k && (y = w + 1), C && k && (S = w - 1), !C && k) {
      b = A;
      break;
    }
    x++;
  }
  return b || f;
}, ww = (e) => {
  var t = dt(e) ? [] : e.toString().split(oA);
  return [{
    words: t
  }];
}, bz = (e) => {
  var {
    width: t,
    scaleToFit: n,
    children: r,
    style: i,
    breakAll: o,
    maxLines: a
  } = e;
  if ((t || n) && !Gi.isSsr) {
    var s, l, c = aA({
      breakAll: o,
      children: r,
      style: i
    });
    if (c) {
      var {
        wordsWithComputedWidth: u,
        spaceWidth: d
      } = c;
      s = u, l = d;
    } else
      return ww(r);
    return yz({
      breakAll: o,
      children: r,
      maxLines: a,
      style: i
    }, s, l, t, n);
  }
  return ww(r);
}, Ow = "#808080", lf = /* @__PURE__ */ nn((e, t) => {
  var {
    x: n = 0,
    y: r = 0,
    lineHeight: i = "1em",
    // Magic number from d3
    capHeight: o = "0.71em",
    scaleToFit: a = !1,
    textAnchor: s = "start",
    // Maintain compat with existing charts / default SVG behavior
    verticalAnchor: l = "end",
    fill: c = Ow
  } = e, u = xw(e, mz), d = Ur(() => bz({
    breakAll: u.breakAll,
    children: u.children,
    maxLines: u.maxLines,
    scaleToFit: a,
    style: u.style,
    width: u.width
  }), [u.breakAll, u.children, u.maxLines, a, u.style, u.width]), {
    dx: f,
    dy: p,
    angle: g,
    className: m,
    breakAll: v
  } = u, y = xw(u, gz);
  if (!Fr(n) || !Fr(r) || d.length === 0)
    return null;
  var S = n + (me(f) ? f : 0), x = r + (me(p) ? p : 0), b;
  switch (l) {
    case "start":
      b = ih("calc(".concat(o, ")"));
      break;
    case "middle":
      b = ih("calc(".concat((d.length - 1) / 2, " * -").concat(i, " + (").concat(o, " / 2))"));
      break;
    default:
      b = ih("calc(".concat(d.length - 1, " * -").concat(i, ")"));
      break;
  }
  var w = [];
  if (a) {
    var E = d[0].width, {
      width: C
    } = u;
    w.push("scale(".concat(me(C) ? C / E : 1, ")"));
  }
  return g && w.push("rotate(".concat(g, ", ").concat(S, ", ").concat(x, ")")), w.length && (y.transform = w.join(" ")), /* @__PURE__ */ _.createElement("text", Cm({}, ht(y, !0), {
    ref: t,
    x: S,
    y: x,
    className: ce("recharts-text", m),
    textAnchor: s,
    fill: c.includes("url") ? Ow : c
  }), d.map((A, k) => {
    var R = A.words.join(v ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ _.createElement("tspan", {
        x: S,
        dy: k === 0 ? b : i,
        key: "".concat(R, "-").concat(k)
      }, R)
    );
  }));
});
lf.displayName = "Text";
var xz = ["labelRef"];
function wz(e, t) {
  if (e == null) return {};
  var n, r, i = Oz(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function Oz(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Sw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ot(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sw(Object(n), !0).forEach(function(r) {
      Sz(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Sz(e, t, n) {
  return (t = Ez(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Ez(e) {
  var t = _z(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function _z(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function oi() {
  return oi = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, oi.apply(null, arguments);
}
var sA = /* @__PURE__ */ hr(null), Pz = (e) => {
  var {
    x: t,
    y: n,
    width: r,
    height: i,
    children: o
  } = e, a = Ur(() => ({
    x: t,
    y: n,
    width: r,
    height: i
  }), [t, n, r, i]);
  return /* @__PURE__ */ _.createElement(sA.Provider, {
    value: a
  }, o);
}, lA = () => {
  var e = Vr(sA), t = Lg();
  return e || t;
}, Cz = /* @__PURE__ */ hr(null), Az = () => {
  var e = Vr(Cz), t = pe(ZP);
  return e || t;
}, Tz = (e) => {
  var {
    value: t,
    formatter: n
  } = e, r = dt(e.children) ? t : e.children;
  return typeof n == "function" ? n(r) : r;
}, Kv = (e) => e != null && typeof e == "function", kz = (e, t) => {
  var n = Ht(t - e), r = Math.min(Math.abs(t - e), 360);
  return n * r;
}, Mz = (e, t, n, r, i) => {
  var {
    offset: o,
    className: a
  } = e, {
    cx: s,
    cy: l,
    innerRadius: c,
    outerRadius: u,
    startAngle: d,
    endAngle: f,
    clockWise: p
  } = i, g = (c + u) / 2, m = kz(d, f), v = m >= 0 ? 1 : -1, y, S;
  switch (t) {
    case "insideStart":
      y = d + v * o, S = p;
      break;
    case "insideEnd":
      y = f - v * o, S = !p;
      break;
    case "end":
      y = f + v * o, S = p;
      break;
    default:
      throw new Error("Unsupported position ".concat(t));
  }
  S = m <= 0 ? S : !S;
  var x = Tt(s, l, g, y), b = Tt(s, l, g, y + (S ? 1 : -1) * 359), w = "M".concat(x.x, ",").concat(x.y, `
    A`).concat(g, ",").concat(g, ",0,1,").concat(S ? 0 : 1, `,
    `).concat(b.x, ",").concat(b.y), E = dt(e.id) ? Ks("recharts-radial-line-") : e.id;
  return /* @__PURE__ */ _.createElement("text", oi({}, r, {
    dominantBaseline: "central",
    className: ce("recharts-radial-bar-label", a)
  }), /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement("path", {
    id: E,
    d: w
  })), /* @__PURE__ */ _.createElement("textPath", {
    xlinkHref: "#".concat(E)
  }, n));
}, jz = (e, t, n) => {
  var {
    cx: r,
    cy: i,
    innerRadius: o,
    outerRadius: a,
    startAngle: s,
    endAngle: l
  } = e, c = (s + l) / 2;
  if (n === "outside") {
    var {
      x: u,
      y: d
    } = Tt(r, i, a + t, c);
    return {
      x: u,
      y: d,
      textAnchor: u >= r ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (n === "center")
    return {
      x: r,
      y: i,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  if (n === "centerTop")
    return {
      x: r,
      y: i,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  if (n === "centerBottom")
    return {
      x: r,
      y: i,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  var f = (o + a) / 2, {
    x: p,
    y: g
  } = Tt(r, i, f, c);
  return {
    x: p,
    y: g,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
}, cA = (e) => "cx" in e && me(e.cx), Nz = (e, t) => {
  var {
    parentViewBox: n,
    offset: r,
    position: i
  } = e, o;
  n != null && !cA(n) && (o = n);
  var {
    x: a,
    y: s,
    width: l,
    height: c
  } = t, u = c >= 0 ? 1 : -1, d = u * r, f = u > 0 ? "end" : "start", p = u > 0 ? "start" : "end", g = l >= 0 ? 1 : -1, m = g * r, v = g > 0 ? "end" : "start", y = g > 0 ? "start" : "end";
  if (i === "top") {
    var S = {
      x: a + l / 2,
      y: s - u * r,
      textAnchor: "middle",
      verticalAnchor: f
    };
    return Ot(Ot({}, S), o ? {
      height: Math.max(s - o.y, 0),
      width: l
    } : {});
  }
  if (i === "bottom") {
    var x = {
      x: a + l / 2,
      y: s + c + d,
      textAnchor: "middle",
      verticalAnchor: p
    };
    return Ot(Ot({}, x), o ? {
      height: Math.max(o.y + o.height - (s + c), 0),
      width: l
    } : {});
  }
  if (i === "left") {
    var b = {
      x: a - m,
      y: s + c / 2,
      textAnchor: v,
      verticalAnchor: "middle"
    };
    return Ot(Ot({}, b), o ? {
      width: Math.max(b.x - o.x, 0),
      height: c
    } : {});
  }
  if (i === "right") {
    var w = {
      x: a + l + m,
      y: s + c / 2,
      textAnchor: y,
      verticalAnchor: "middle"
    };
    return Ot(Ot({}, w), o ? {
      width: Math.max(o.x + o.width - w.x, 0),
      height: c
    } : {});
  }
  var E = o ? {
    width: l,
    height: c
  } : {};
  return i === "insideLeft" ? Ot({
    x: a + m,
    y: s + c / 2,
    textAnchor: y,
    verticalAnchor: "middle"
  }, E) : i === "insideRight" ? Ot({
    x: a + l - m,
    y: s + c / 2,
    textAnchor: v,
    verticalAnchor: "middle"
  }, E) : i === "insideTop" ? Ot({
    x: a + l / 2,
    y: s + d,
    textAnchor: "middle",
    verticalAnchor: p
  }, E) : i === "insideBottom" ? Ot({
    x: a + l / 2,
    y: s + c - d,
    textAnchor: "middle",
    verticalAnchor: f
  }, E) : i === "insideTopLeft" ? Ot({
    x: a + m,
    y: s + d,
    textAnchor: y,
    verticalAnchor: p
  }, E) : i === "insideTopRight" ? Ot({
    x: a + l - m,
    y: s + d,
    textAnchor: v,
    verticalAnchor: p
  }, E) : i === "insideBottomLeft" ? Ot({
    x: a + m,
    y: s + c - d,
    textAnchor: y,
    verticalAnchor: f
  }, E) : i === "insideBottomRight" ? Ot({
    x: a + l - m,
    y: s + c - d,
    textAnchor: v,
    verticalAnchor: f
  }, E) : i && typeof i == "object" && (me(i.x) || wo(i.x)) && (me(i.y) || wo(i.y)) ? Ot({
    x: a + pn(i.x, l),
    y: s + pn(i.y, c),
    textAnchor: "end",
    verticalAnchor: "end"
  }, E) : Ot({
    x: a + l / 2,
    y: s + c / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, E);
}, Dz = {
  offset: 5
};
function ki(e) {
  var t = rn(e, Dz), {
    viewBox: n,
    position: r,
    value: i,
    children: o,
    content: a,
    className: s = "",
    textBreakAll: l,
    labelRef: c
  } = t, u = Az(), d = lA(), f = r === "center" ? d : u ?? d, p = n || f;
  if (!p || dt(i) && dt(o) && !/* @__PURE__ */ bn(a) && typeof a != "function")
    return null;
  var g = Ot(Ot({}, t), {}, {
    viewBox: p
  });
  if (/* @__PURE__ */ bn(a)) {
    var {
      labelRef: m
    } = g, v = wz(g, xz);
    return /* @__PURE__ */ sr(a, v);
  }
  var y;
  if (typeof a == "function") {
    if (y = /* @__PURE__ */ vE(a, g), /* @__PURE__ */ bn(y))
      return y;
  } else
    y = Tz(t);
  var S = cA(p), x = ht(t, !0);
  if (S && (r === "insideStart" || r === "insideEnd" || r === "end"))
    return Mz(t, r, y, x, p);
  var b = S ? jz(p, t.offset, t.position) : Nz(t, p);
  return /* @__PURE__ */ _.createElement(lf, oi({
    ref: c,
    className: ce("recharts-label", s)
  }, x, b, {
    breakAll: l
  }), y);
}
ki.displayName = "Label";
var Rz = (e, t, n) => {
  if (!e)
    return null;
  var r = {
    viewBox: t,
    labelRef: n
  };
  return e === !0 ? /* @__PURE__ */ _.createElement(ki, oi({
    key: "label-implicit"
  }, r)) : Fr(e) ? /* @__PURE__ */ _.createElement(ki, oi({
    key: "label-implicit",
    value: e
  }, r)) : /* @__PURE__ */ bn(e) ? e.type === ki ? /* @__PURE__ */ sr(e, Ot({
    key: "label-implicit"
  }, r)) : /* @__PURE__ */ _.createElement(ki, oi({
    key: "label-implicit",
    content: e
  }, r)) : Kv(e) ? /* @__PURE__ */ _.createElement(ki, oi({
    key: "label-implicit",
    content: e
  }, r)) : e && typeof e == "object" ? /* @__PURE__ */ _.createElement(ki, oi({}, e, {
    key: "label-implicit"
  }, r)) : null;
};
function Iz(e) {
  var {
    label: t
  } = e, n = lA();
  return Rz(t, n) || null;
}
var oh = {}, ah = {}, Ew;
function $z() {
  return Ew || (Ew = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return n[n.length - 1];
    }
    e.last = t;
  })(ah)), ah;
}
var sh = {}, _w;
function Lz() {
  return _w || (_w = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      return Array.isArray(n) ? n : Array.from(n);
    }
    e.toArray = t;
  })(sh)), sh;
}
var Pw;
function Fz() {
  return Pw || (Pw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    const t = /* @__PURE__ */ $z(), n = /* @__PURE__ */ Lz(), r = /* @__PURE__ */ Tg();
    function i(o) {
      if (r.isArrayLike(o))
        return t.last(n.toArray(o));
    }
    e.last = i;
  })(oh)), oh;
}
var lh, Cw;
function Bz() {
  return Cw || (Cw = 1, lh = Fz().last), lh;
}
var zz = /* @__PURE__ */ Bz();
const Wz = /* @__PURE__ */ xi(zz);
var Vz = ["valueAccessor"], Uz = ["dataKey", "clockWise", "id", "textBreakAll"];
function Lu() {
  return Lu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Lu.apply(null, arguments);
}
function Aw(e, t) {
  if (e == null) return {};
  var n, r, i = Hz(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function Hz(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var Kz = (e) => Array.isArray(e.value) ? Wz(e.value) : e.value, uA = /* @__PURE__ */ hr(void 0), dA = uA.Provider, fA = /* @__PURE__ */ hr(void 0), qz = fA.Provider;
function Yz() {
  return Vr(uA);
}
function Gz() {
  return Vr(fA);
}
function Jc(e) {
  var {
    valueAccessor: t = Kz
  } = e, n = Aw(e, Vz), {
    dataKey: r,
    clockWise: i,
    id: o,
    textBreakAll: a
  } = n, s = Aw(n, Uz), l = Yz(), c = Gz(), u = l || c;
  return !u || !u.length ? null : /* @__PURE__ */ _.createElement(tn, {
    className: "recharts-label-list"
  }, u.map((d, f) => {
    var p, g = dt(r) ? t(d, f) : tt(d && d.payload, r), m = dt(o) ? {} : {
      id: "".concat(o, "-").concat(f)
    };
    return /* @__PURE__ */ _.createElement(ki, Lu({}, ht(d, !0), s, m, {
      /*
       * Prefer to use the explicit fill from LabelList props.
       * Only in an absence of that, fall back to the fill of the entry.
       * The entry fill can be quite difficult to see especially in Bar, Pie, RadialBar in inside positions.
       * On the other hand it's quite convenient in Scatter, Line, or when the position is outside the Bar, Pie filled shapes.
       */
      fill: (p = n.fill) !== null && p !== void 0 ? p : d.fill,
      parentViewBox: d.parentViewBox,
      value: g,
      textBreakAll: a,
      viewBox: d.viewBox,
      key: "label-".concat(f),
      index: f
    }));
  }));
}
Jc.displayName = "LabelList";
function qv(e) {
  var {
    label: t
  } = e;
  return t ? t === !0 ? /* @__PURE__ */ _.createElement(Jc, {
    key: "labelList-implicit"
  }) : /* @__PURE__ */ _.isValidElement(t) || Kv(t) ? /* @__PURE__ */ _.createElement(Jc, {
    key: "labelList-implicit",
    content: t
  }) : typeof t == "object" ? /* @__PURE__ */ _.createElement(Jc, Lu({
    key: "labelList-implicit"
  }, t, {
    type: String(t.type)
  })) : null : null;
}
function Am() {
  return Am = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Am.apply(null, arguments);
}
var pA = (e) => {
  var {
    cx: t,
    cy: n,
    r,
    className: i
  } = e, o = ce("recharts-dot", i);
  return t === +t && n === +n && r === +r ? /* @__PURE__ */ _.createElement("circle", Am({}, Kr(e), Eg(e), {
    className: o,
    cx: t,
    cy: n,
    r
  })) : null;
}, hA = (e) => e.graphicalItems.polarItems, Xz = z([ft, $l], xv), Yv = z([hA, Pt, Xz], wv), Zz = z([Yv], Ov), Gv = z([Zz, cv], Sv), Jz = z([Gv, Pt, Yv], _v), Qz = z([Gv, Pt, Yv], (e, t, n) => n.length > 0 ? e.flatMap((r) => n.flatMap((i) => {
  var o, a = tt(r, (o = t.dataKey) !== null && o !== void 0 ? o : i.dataKey);
  return {
    value: a,
    errorDomain: []
    // polar charts do not have error bars
  };
})).filter(Boolean) : t?.dataKey != null ? e.map((r) => ({
  value: tt(r, t.dataKey),
  errorDomain: []
})) : e.map((r) => ({
  value: r,
  errorDomain: []
}))), Tw = () => {
}, eW = z([Pt, vC, Tw, Qz, Tw, _e, ft], Cv), mA = z([Pt, _e, Gv, Jz, Il, ft, eW], Av), tW = z([mA, Pt, Ua], Mv);
z([Pt, mA, tW, ft], Nv);
var nW = {
  radiusAxis: {},
  angleAxis: {}
}, gA = Gn({
  name: "polarAxis",
  initialState: nW,
  reducers: {
    addRadiusAxis(e, t) {
      e.radiusAxis[t.payload.id] = t.payload;
    },
    removeRadiusAxis(e, t) {
      delete e.radiusAxis[t.payload.id];
    },
    addAngleAxis(e, t) {
      e.angleAxis[t.payload.id] = t.payload;
    },
    removeAngleAxis(e, t) {
      delete e.angleAxis[t.payload.id];
    }
  }
}), {
  addRadiusAxis: Ree,
  removeRadiusAxis: Iee,
  addAngleAxis: $ee,
  removeAngleAxis: Lee
} = gA.actions, rW = gA.reducer;
function kw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kw(Object(n), !0).forEach(function(r) {
      iW(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function iW(e, t, n) {
  return (t = oW(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function oW(e) {
  var t = aW(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function aW(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var sW = (e, t) => t, Xv = z([hA, sW], (e, t) => e.filter((n) => n.type === "pie").find((n) => n.id === t)), lW = [], Zv = (e, t, n) => n?.length === 0 ? lW : n, vA = z([cv, Xv, Zv], (e, t, n) => {
  var {
    chartData: r
  } = e;
  if (t != null) {
    var i;
    if (t?.data != null && t.data.length > 0 ? i = t.data : i = r, (!i || !i.length) && n != null && (i = n.map((o) => Mw(Mw({}, t.presentationProps), o.props))), i != null)
      return i;
  }
}), cW = z([vA, Xv, Zv], (e, t, n) => {
  if (!(e == null || t == null))
    return e.map((r, i) => {
      var o, a = tt(r, t.nameKey, t.name), s;
      return n != null && (o = n[i]) !== null && o !== void 0 && (o = o.props) !== null && o !== void 0 && o.fill ? s = n[i].props.fill : typeof r == "object" && r != null && "fill" in r ? s = r.fill : s = t.fill, {
        value: La(a, t.dataKey),
        color: s,
        payload: r,
        type: t.legendType
      };
    });
}), uW = z([vA, Xv, Zv, Lt], (e, t, n, r) => {
  if (!(t == null || e == null))
    return sV({
      offset: r,
      pieSettings: t,
      displayedData: e,
      cells: n
    });
}), ch = {}, jw;
function dW() {
  return jw || (jw = 1, (function(e) {
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    function t(n) {
      if (typeof n != "object" || n == null)
        return !1;
      if (Object.getPrototypeOf(n) === null)
        return !0;
      if (Object.prototype.toString.call(n) !== "[object Object]") {
        const i = n[Symbol.toStringTag];
        return i == null || !Object.getOwnPropertyDescriptor(n, Symbol.toStringTag)?.writable ? !1 : n.toString() === `[object ${i}]`;
      }
      let r = n;
      for (; Object.getPrototypeOf(r) !== null; )
        r = Object.getPrototypeOf(r);
      return Object.getPrototypeOf(n) === r;
    }
    e.isPlainObject = t;
  })(ch)), ch;
}
var uh, Nw;
function fW() {
  return Nw || (Nw = 1, uh = dW().isPlainObject), uh;
}
var pW = /* @__PURE__ */ fW();
const hW = /* @__PURE__ */ xi(pW);
function Dw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Dw(Object(n), !0).forEach(function(r) {
      mW(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Dw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function mW(e, t, n) {
  return (t = gW(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function gW(e) {
  var t = vW(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function vW(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Fu() {
  return Fu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Fu.apply(null, arguments);
}
var Iw = (e, t, n, r, i) => {
  var o = n - r, a;
  return a = "M ".concat(e, ",").concat(t), a += "L ".concat(e + n, ",").concat(t), a += "L ".concat(e + n - o / 2, ",").concat(t + i), a += "L ".concat(e + n - o / 2 - r, ",").concat(t + i), a += "L ".concat(e, ",").concat(t, " Z"), a;
}, yW = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, bW = (e) => {
  var t = rn(e, yW), {
    x: n,
    y: r,
    upperWidth: i,
    lowerWidth: o,
    height: a,
    className: s
  } = t, {
    animationEasing: l,
    animationDuration: c,
    animationBegin: u,
    isUpdateAnimationActive: d
  } = t, f = Ue(), [p, g] = Rt(-1), m = Ue(i), v = Ue(o), y = Ue(a), S = Ue(n), x = Ue(r), b = Ml(e, "trapezoid-");
  if (Le(() => {
    if (f.current && f.current.getTotalLength)
      try {
        var j = f.current.getTotalLength();
        j && g(j);
      } catch {
      }
  }, []), n !== +n || r !== +r || i !== +i || o !== +o || a !== +a || i === 0 && o === 0 || a === 0)
    return null;
  var w = ce("recharts-trapezoid", s);
  if (!d)
    return /* @__PURE__ */ _.createElement("g", null, /* @__PURE__ */ _.createElement("path", Fu({}, ht(t, !0), {
      className: w,
      d: Iw(n, r, i, o, a)
    })));
  var E = m.current, C = v.current, A = y.current, k = S.current, R = x.current, M = "0px ".concat(p === -1 ? 1 : p, "px"), P = "".concat(p, "px 0px"), D = z2(["strokeDasharray"], c, l);
  return /* @__PURE__ */ _.createElement(kl, {
    animationId: b,
    key: b,
    canBegin: p > 0,
    duration: c,
    easing: l,
    isActive: d,
    begin: u
  }, (j) => {
    var N = yt(E, i, j), $ = yt(C, o, j), F = yt(A, a, j), q = yt(k, n, j), B = yt(R, r, j);
    f.current && (m.current = N, v.current = $, y.current = F, S.current = q, x.current = B);
    var L = j > 0 ? {
      transition: D,
      strokeDasharray: P
    } : {
      strokeDasharray: M
    };
    return /* @__PURE__ */ _.createElement("path", Fu({}, ht(t, !0), {
      className: w,
      d: Iw(q, B, N, $, F),
      ref: f,
      style: Rw(Rw({}, L), t.style)
    }));
  });
}, xW = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function wW(e, t) {
  if (e == null) return {};
  var n, r, i = OW(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function OW(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function $w(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $w(Object(n), !0).forEach(function(r) {
      SW(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $w(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function SW(e, t, n) {
  return (t = EW(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function EW(e) {
  var t = _W(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function _W(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function PW(e, t) {
  return Bu(Bu({}, t), e);
}
function CW(e, t) {
  return e === "symbols";
}
function Lw(e) {
  var {
    shapeType: t,
    elementProps: n
  } = e;
  switch (t) {
    case "rectangle":
      return /* @__PURE__ */ _.createElement(H2, n);
    case "trapezoid":
      return /* @__PURE__ */ _.createElement(bW, n);
    case "sector":
      return /* @__PURE__ */ _.createElement(Y2, n);
    case "symbols":
      if (CW(t))
        return /* @__PURE__ */ _.createElement(F_, n);
      break;
    default:
      return null;
  }
}
function AW(e) {
  return /* @__PURE__ */ bn(e) ? e.props : e;
}
function yA(e) {
  var {
    option: t,
    shapeType: n,
    propTransformer: r = PW,
    activeClassName: i = "recharts-active-shape",
    isActive: o
  } = e, a = wW(e, xW), s;
  if (/* @__PURE__ */ bn(t))
    s = /* @__PURE__ */ sr(t, Bu(Bu({}, a), AW(t)));
  else if (typeof t == "function")
    s = t(a);
  else if (hW(t) && typeof t != "boolean") {
    var l = r(t, a);
    s = /* @__PURE__ */ _.createElement(Lw, {
      shapeType: n,
      elementProps: l
    });
  } else {
    var c = a;
    s = /* @__PURE__ */ _.createElement(Lw, {
      shapeType: n,
      elementProps: c
    });
  }
  return o ? /* @__PURE__ */ _.createElement(tn, {
    className: i
  }, s) : s;
}
var Jv = (e, t) => {
  var n = _t();
  return (r, i) => (o) => {
    e?.(r, i, o), n(NC({
      activeIndex: String(i),
      activeDataKey: t,
      activeCoordinate: r.tooltipPosition
    }));
  };
}, Qv = (e) => {
  var t = _t();
  return (n, r) => (i) => {
    e?.(n, r, i), t(c3());
  };
}, ey = (e, t) => {
  var n = _t();
  return (r, i) => (o) => {
    e?.(r, i, o), n(u3({
      activeIndex: String(i),
      activeDataKey: t,
      activeCoordinate: r.tooltipPosition
    }));
  };
};
function ty(e) {
  var {
    fn: t,
    args: n
  } = e, r = _t(), i = Nn();
  return Le(() => {
    if (!i) {
      var o = t(n);
      return r(a3(o)), () => {
        r(s3(o));
      };
    }
  }, [t, n, r, i]), null;
}
var bA = () => {
};
function xA(e) {
  var {
    legendPayload: t
  } = e, n = _t(), r = Nn();
  return Le(() => r ? bA : (n(L2(t)), () => {
    n(F2(t));
  }), [n, r, t]), null;
}
function TW(e) {
  var {
    legendPayload: t
  } = e, n = _t(), r = pe(_e);
  return Le(() => r !== "centric" && r !== "radial" ? bA : (n(L2(t)), () => {
    n(F2(t));
  }), [n, r, t]), null;
}
var dh, kW = () => {
  var [e] = _.useState(() => Ks("uid-"));
  return e;
}, MW = (dh = _.useId) !== null && dh !== void 0 ? dh : kW;
function jW(e, t) {
  var n = MW();
  return t || (e ? "".concat(e, "-").concat(n) : n);
}
var NW = /* @__PURE__ */ hr(void 0), ny = (e) => {
  var {
    id: t,
    type: n,
    children: r
  } = e, i = jW("recharts-".concat(n), t);
  return /* @__PURE__ */ _.createElement(NW.Provider, {
    value: i
  }, r(i));
}, DW = {
  cartesianItems: [],
  polarItems: []
}, wA = Gn({
  name: "graphicalItems",
  initialState: DW,
  reducers: {
    addCartesianGraphicalItem(e, t) {
      e.cartesianItems.push(t.payload);
    },
    replaceCartesianGraphicalItem(e, t) {
      var {
        prev: n,
        next: r
      } = t.payload, i = ui(e).cartesianItems.indexOf(n);
      i > -1 && (e.cartesianItems[i] = r);
    },
    removeCartesianGraphicalItem(e, t) {
      var n = ui(e).cartesianItems.indexOf(t.payload);
      n > -1 && e.cartesianItems.splice(n, 1);
    },
    addPolarGraphicalItem(e, t) {
      e.polarItems.push(t.payload);
    },
    removePolarGraphicalItem(e, t) {
      var n = ui(e).polarItems.indexOf(t.payload);
      n > -1 && e.polarItems.splice(n, 1);
    }
  }
}), {
  addCartesianGraphicalItem: RW,
  replaceCartesianGraphicalItem: IW,
  removeCartesianGraphicalItem: $W,
  addPolarGraphicalItem: LW,
  removePolarGraphicalItem: FW
} = wA.actions, BW = wA.reducer;
function OA(e) {
  var t = _t(), n = Ue(null);
  return Le(() => {
    n.current === null ? t(RW(e)) : n.current !== e && t(IW({
      prev: n.current,
      next: e
    })), n.current = e;
  }, [t, e]), Le(() => () => {
    n.current && (t($W(n.current)), n.current = null);
  }, [t]), null;
}
function zW(e) {
  var t = _t();
  return Le(() => (t(LW(e)), () => {
    t(FW(e));
  }), [t, e]), null;
}
var WW = ["onMouseEnter", "onClick", "onMouseLeave"], VW = ["id"], UW = ["id"];
function ry(e, t) {
  if (e == null) return {};
  var n, r, i = HW(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function HW(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Fw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ct(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fw(Object(n), !0).forEach(function(r) {
      KW(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function KW(e, t, n) {
  return (t = qW(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function qW(e) {
  var t = YW(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function YW(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ui() {
  return Ui = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ui.apply(null, arguments);
}
function GW(e) {
  var t = Ur(() => _g(e.children, zr), [e.children]), n = pe((r) => cW(r, e.id, t));
  return n == null ? null : /* @__PURE__ */ _.createElement(TW, {
    legendPayload: n
  });
}
function XW(e) {
  var {
    dataKey: t,
    nameKey: n,
    sectors: r,
    stroke: i,
    strokeWidth: o,
    fill: a,
    name: s,
    hide: l,
    tooltipType: c
  } = e;
  return {
    dataDefinedOnItem: r.map((u) => u.tooltipPayload),
    positions: r.map((u) => u.tooltipPosition),
    settings: {
      stroke: i,
      strokeWidth: o,
      fill: a,
      dataKey: t,
      nameKey: n,
      name: La(s, t),
      hide: l,
      type: c,
      color: a,
      unit: ""
      // why doesn't Pie support unit?
    }
  };
}
var ZW = (e, t) => e > t ? "start" : e < t ? "end" : "middle", JW = (e, t, n) => pn(typeof t == "function" ? t(e) : t, n, n * 0.8), QW = (e, t, n) => {
  var {
    top: r,
    left: i,
    width: o,
    height: a
  } = t, s = C2(o, a), l = i + pn(e.cx, o, o / 2), c = r + pn(e.cy, a, a / 2), u = pn(e.innerRadius, s, 0), d = JW(n, e.outerRadius, s), f = e.maxRadius || Math.sqrt(o * o + a * a) / 2;
  return {
    cx: l,
    cy: c,
    innerRadius: u,
    outerRadius: d,
    maxRadius: f
  };
}, eV = (e, t) => {
  var n = Ht(t - e), r = Math.min(Math.abs(t - e), 360);
  return n * r;
};
function tV(e) {
  return e && typeof e == "object" && "className" in e && typeof e.className == "string" ? e.className : "";
}
var nV = (e, t) => {
  if (/* @__PURE__ */ _.isValidElement(e))
    return /* @__PURE__ */ _.cloneElement(e, t);
  if (typeof e == "function")
    return e(t);
  var n = ce("recharts-pie-label-line", typeof e != "boolean" ? e.className : "");
  return /* @__PURE__ */ _.createElement(Fg, Ui({}, t, {
    type: "linear",
    className: n
  }));
}, rV = (e, t, n) => {
  if (/* @__PURE__ */ _.isValidElement(e))
    return /* @__PURE__ */ _.cloneElement(e, t);
  var r = n;
  if (typeof e == "function" && (r = e(t), /* @__PURE__ */ _.isValidElement(r)))
    return r;
  var i = ce("recharts-pie-label-text", tV(e));
  return /* @__PURE__ */ _.createElement(lf, Ui({}, t, {
    alignmentBaseline: "middle",
    className: i
  }), r);
};
function iV(e) {
  var {
    sectors: t,
    props: n,
    showLabels: r
  } = e, {
    label: i,
    labelLine: o,
    dataKey: a
  } = n;
  if (!r || !i || !t)
    return null;
  var s = Kr(n), l = ht(i, !1), c = ht(o, !1), u = typeof i == "object" && "offsetRadius" in i && typeof i.offsetRadius == "number" && i.offsetRadius || 20, d = t.map((f, p) => {
    var g = (f.startAngle + f.endAngle) / 2, m = Tt(f.cx, f.cy, f.outerRadius + u, g), v = ct(ct(ct(ct({}, s), f), {}, {
      stroke: "none"
    }, l), {}, {
      index: p,
      textAnchor: ZW(m.x, f.cx)
    }, m), y = ct(ct(ct(ct({}, s), f), {}, {
      fill: "none",
      stroke: f.fill
    }, c), {}, {
      index: p,
      points: [Tt(f.cx, f.cy, f.outerRadius, g), m],
      key: "line"
    });
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ _.createElement(tn, {
        key: "label-".concat(f.startAngle, "-").concat(f.endAngle, "-").concat(f.midAngle, "-").concat(p)
      }, o && nV(o, y), rV(i, v, tt(f, a)))
    );
  });
  return /* @__PURE__ */ _.createElement(tn, {
    className: "recharts-pie-labels"
  }, d);
}
function oV(e) {
  var {
    sectors: t,
    props: n,
    showLabels: r
  } = e, {
    label: i
  } = n;
  return typeof i == "object" && i != null && "position" in i ? /* @__PURE__ */ _.createElement(qv, {
    label: i
  }) : /* @__PURE__ */ _.createElement(iV, {
    sectors: t,
    props: n,
    showLabels: r
  });
}
function aV(e) {
  var {
    sectors: t,
    activeShape: n,
    inactiveShape: r,
    allOtherPieProps: i
  } = e, o = pe(Vi), {
    onMouseEnter: a,
    onClick: s,
    onMouseLeave: l
  } = i, c = ry(i, WW), u = Jv(a, i.dataKey), d = Qv(l), f = ey(s, i.dataKey);
  return t == null || t.length === 0 ? null : /* @__PURE__ */ _.createElement(_.Fragment, null, t.map((p, g) => {
    if (p?.startAngle === 0 && p?.endAngle === 0 && t.length !== 1) return null;
    var m = n && String(g) === o, v = o ? r : null, y = m ? n : v, S = ct(ct({}, p), {}, {
      stroke: p.stroke,
      tabIndex: -1,
      [j2]: g,
      [N2]: i.dataKey
    });
    return /* @__PURE__ */ _.createElement(tn, Ui({
      tabIndex: -1,
      className: "recharts-pie-sector"
    }, kd(c, p, g), {
      // @ts-expect-error the types need a bit of attention
      onMouseEnter: u(p, g),
      onMouseLeave: d(p, g),
      onClick: f(p, g),
      key: "sector-".concat(p?.startAngle, "-").concat(p?.endAngle, "-").concat(p.midAngle, "-").concat(g)
    }), /* @__PURE__ */ _.createElement(yA, Ui({
      option: y,
      isActive: m,
      shapeType: "sector"
    }, S)));
  }));
}
function sV(e) {
  var t, {
    pieSettings: n,
    displayedData: r,
    cells: i,
    offset: o
  } = e, {
    cornerRadius: a,
    startAngle: s,
    endAngle: l,
    dataKey: c,
    nameKey: u,
    tooltipType: d
  } = n, f = Math.abs(n.minAngle), p = eV(s, l), g = Math.abs(p), m = r.length <= 1 ? 0 : (t = n.paddingAngle) !== null && t !== void 0 ? t : 0, v = r.filter((E) => tt(E, c, 0) !== 0).length, y = (g >= 360 ? v : v - 1) * m, S = g - v * f - y, x = r.reduce((E, C) => {
    var A = tt(C, c, 0);
    return E + (me(A) ? A : 0);
  }, 0), b;
  if (x > 0) {
    var w;
    b = r.map((E, C) => {
      var A = tt(E, c, 0), k = tt(E, u, C), R = QW(n, o, E), M = (me(A) ? A : 0) / x, P, D = ct(ct({}, E), i && i[C] && i[C].props);
      C ? P = w.endAngle + Ht(p) * m * (A !== 0 ? 1 : 0) : P = s;
      var j = P + Ht(p) * ((A !== 0 ? f : 0) + M * S), N = (P + j) / 2, $ = (R.innerRadius + R.outerRadius) / 2, F = [{
        name: k,
        value: A,
        payload: D,
        dataKey: c,
        type: d
      }], q = Tt(R.cx, R.cy, $, N);
      return w = ct(ct(ct(ct({}, n.presentationProps), {}, {
        percent: M,
        cornerRadius: a,
        name: k,
        tooltipPayload: F,
        midAngle: N,
        middleRadius: $,
        tooltipPosition: q
      }, D), R), {}, {
        value: A,
        startAngle: P,
        endAngle: j,
        payload: D,
        paddingAngle: Ht(p) * m
      }), w;
    });
  }
  return b;
}
function lV(e) {
  var {
    showLabels: t,
    sectors: n,
    children: r
  } = e, i = Ur(() => !t || !n ? [] : n.map((o) => ({
    value: o.value,
    payload: o.payload,
    clockWise: !1,
    parentViewBox: void 0,
    viewBox: {
      cx: o.cx,
      cy: o.cy,
      innerRadius: o.innerRadius,
      outerRadius: o.outerRadius,
      startAngle: o.startAngle,
      endAngle: o.endAngle,
      clockWise: !1
    },
    fill: o.fill
  })), [n, t]);
  return /* @__PURE__ */ _.createElement(qz, {
    value: t ? i : void 0
  }, r);
}
function cV(e) {
  var {
    props: t,
    previousSectorsRef: n
  } = e, {
    sectors: r,
    isAnimationActive: i,
    animationBegin: o,
    animationDuration: a,
    animationEasing: s,
    activeShape: l,
    inactiveShape: c,
    onAnimationStart: u,
    onAnimationEnd: d
  } = t, f = Ml(t, "recharts-pie-"), p = n.current, [g, m] = Rt(!1), v = pt(() => {
    typeof d == "function" && d(), m(!1);
  }, [d]), y = pt(() => {
    typeof u == "function" && u(), m(!0);
  }, [u]);
  return /* @__PURE__ */ _.createElement(lV, {
    showLabels: !g,
    sectors: r
  }, /* @__PURE__ */ _.createElement(kl, {
    animationId: f,
    begin: o,
    duration: a,
    isActive: i,
    easing: s,
    onAnimationStart: y,
    onAnimationEnd: v,
    key: f
  }, (S) => {
    var x = [], b = r && r[0], w = b?.startAngle;
    return r?.forEach((E, C) => {
      var A = p && p[C], k = C > 0 ? Do(E, "paddingAngle", 0) : 0;
      if (A) {
        var R = yt(A.endAngle - A.startAngle, E.endAngle - E.startAngle, S), M = ct(ct({}, E), {}, {
          startAngle: w + k,
          endAngle: w + R + k
        });
        x.push(M), w = M.endAngle;
      } else {
        var {
          endAngle: P,
          startAngle: D
        } = E, j = yt(0, P - D, S), N = ct(ct({}, E), {}, {
          startAngle: w + k,
          endAngle: w + j + k
        });
        x.push(N), w = N.endAngle;
      }
    }), n.current = x, /* @__PURE__ */ _.createElement(tn, null, /* @__PURE__ */ _.createElement(aV, {
      sectors: x,
      activeShape: l,
      inactiveShape: c,
      allOtherPieProps: t
    }));
  }), /* @__PURE__ */ _.createElement(oV, {
    showLabels: !g,
    sectors: r,
    props: t
  }), t.children);
}
var uV = {
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  cx: "50%",
  cy: "50%",
  dataKey: "value",
  endAngle: 360,
  fill: "#808080",
  hide: !1,
  innerRadius: 0,
  isAnimationActive: !Gi.isSsr,
  labelLine: !0,
  legendType: "rect",
  minAngle: 0,
  nameKey: "name",
  outerRadius: "80%",
  paddingAngle: 0,
  rootTabIndex: 0,
  startAngle: 0,
  stroke: "#fff"
};
function dV(e) {
  var {
    id: t
  } = e, n = ry(e, VW), {
    hide: r,
    className: i,
    rootTabIndex: o
  } = e, a = Ur(() => _g(e.children, zr), [e.children]), s = pe((u) => uW(u, t, a)), l = Ue(null), c = ce("recharts-pie", i);
  return r || s == null ? (l.current = null, /* @__PURE__ */ _.createElement(tn, {
    tabIndex: o,
    className: c
  })) : /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(ty, {
    fn: XW,
    args: ct(ct({}, e), {}, {
      sectors: s
    })
  }), /* @__PURE__ */ _.createElement(tn, {
    tabIndex: o,
    className: c
  }, /* @__PURE__ */ _.createElement(cV, {
    props: ct(ct({}, n), {}, {
      sectors: s
    }),
    previousSectorsRef: l
  })));
}
function Vl(e) {
  var t = rn(e, uV), {
    id: n
  } = t, r = ry(t, UW), i = Kr(r);
  return /* @__PURE__ */ _.createElement(ny, {
    id: n,
    type: "pie"
  }, (o) => /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(zW, {
    type: "pie",
    id: o,
    data: r.data,
    dataKey: r.dataKey,
    hide: r.hide,
    angleAxisId: 0,
    radiusAxisId: 0,
    name: r.name,
    nameKey: r.nameKey,
    tooltipType: r.tooltipType,
    legendType: r.legendType,
    fill: r.fill,
    cx: r.cx,
    cy: r.cy,
    startAngle: r.startAngle,
    endAngle: r.endAngle,
    paddingAngle: r.paddingAngle,
    minAngle: r.minAngle,
    innerRadius: r.innerRadius,
    outerRadius: r.outerRadius,
    cornerRadius: r.cornerRadius,
    presentationProps: i,
    maxRadius: t.maxRadius
  }), /* @__PURE__ */ _.createElement(GW, Ui({}, r, {
    id: o
  })), /* @__PURE__ */ _.createElement(dV, Ui({}, r, {
    id: o
  }))));
}
Vl.displayName = "Pie";
function Bw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bw(Object(n), !0).forEach(function(r) {
      fV(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function fV(e, t, n) {
  return (t = pV(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function pV(e) {
  var t = hV(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function hV(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var mV = {
  xAxis: {},
  yAxis: {},
  zAxis: {}
}, SA = Gn({
  name: "cartesianAxis",
  initialState: mV,
  reducers: {
    addXAxis(e, t) {
      e.xAxis[t.payload.id] = t.payload;
    },
    removeXAxis(e, t) {
      delete e.xAxis[t.payload.id];
    },
    addYAxis(e, t) {
      e.yAxis[t.payload.id] = t.payload;
    },
    removeYAxis(e, t) {
      delete e.yAxis[t.payload.id];
    },
    addZAxis(e, t) {
      e.zAxis[t.payload.id] = t.payload;
    },
    removeZAxis(e, t) {
      delete e.zAxis[t.payload.id];
    },
    updateYAxisWidth(e, t) {
      var {
        id: n,
        width: r
      } = t.payload;
      e.yAxis[n] && (e.yAxis[n] = zw(zw({}, e.yAxis[n]), {}, {
        width: r
      }));
    }
  }
}), {
  addXAxis: gV,
  removeXAxis: vV,
  addYAxis: yV,
  removeYAxis: bV,
  addZAxis: Fee,
  removeZAxis: Bee,
  updateYAxisWidth: xV
} = SA.actions, wV = SA.reducer, OV = z([Lt], (e) => {
  if (e)
    return {
      top: e.top,
      bottom: e.bottom,
      left: e.left,
      right: e.right
    };
}), SV = z([OV, wi, Oi], (e, t, n) => {
  if (!(!e || t == null || n == null))
    return {
      x: e.left,
      y: e.top,
      width: Math.max(0, t - e.left - e.right),
      height: Math.max(0, n - e.top - e.bottom)
    };
}), iy = () => pe(SV), EV = () => pe(X3);
function Ww(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ww(Object(n), !0).forEach(function(r) {
      _V(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ww(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function _V(e, t, n) {
  return (t = PV(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function PV(e) {
  var t = CV(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function CV(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var AV = (e) => {
  var {
    point: t,
    childIndex: n,
    mainColor: r,
    activeDot: i,
    dataKey: o
  } = e;
  if (i === !1 || t.x == null || t.y == null)
    return null;
  var a = Vw(Vw({
    index: n,
    dataKey: o,
    cx: t.x,
    cy: t.y,
    r: 4,
    fill: r ?? "none",
    strokeWidth: 2,
    stroke: "#fff",
    payload: t.payload,
    value: t.value
  }, ht(i, !1)), Eg(i)), s;
  return /* @__PURE__ */ bn(i) ? s = /* @__PURE__ */ sr(i, a) : typeof i == "function" ? s = i(a) : s = /* @__PURE__ */ _.createElement(pA, a), /* @__PURE__ */ _.createElement(tn, {
    className: "recharts-active-dot"
  }, s);
};
function TV(e) {
  var {
    points: t,
    mainColor: n,
    activeDot: r,
    itemDataKey: i
  } = e, o = pe(Vi), a = EV();
  if (t == null || a == null)
    return null;
  var s = t.find((l) => a.includes(l.payload));
  return dt(s) ? null : AV({
    point: s,
    childIndex: Number(o),
    mainColor: n,
    dataKey: i,
    activeDot: r
  });
}
var kV = process.env.NODE_ENV === "production", fh = "Invariant failed";
function Uw(e, t) {
  if (kV)
    throw new Error(fh);
  var n = typeof t == "function" ? t() : t, r = n ? "".concat(fh, ": ").concat(n) : fh;
  throw new Error(r);
}
var MV = ["x", "y"];
function Tm() {
  return Tm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Tm.apply(null, arguments);
}
function Hw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hw(Object(n), !0).forEach(function(r) {
      jV(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jV(e, t, n) {
  return (t = NV(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function NV(e) {
  var t = DV(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function DV(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function RV(e, t) {
  if (e == null) return {};
  var n, r, i = IV(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function IV(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function $V(e, t) {
  var {
    x: n,
    y: r
  } = e, i = RV(e, MV), o = "".concat(n), a = parseInt(o, 10), s = "".concat(r), l = parseInt(s, 10), c = "".concat(t.height || i.height), u = parseInt(c, 10), d = "".concat(t.width || i.width), f = parseInt(d, 10);
  return cs(cs(cs(cs(cs({}, t), i), a ? {
    x: a
  } : {}), l ? {
    y: l
  } : {}), {}, {
    height: u,
    width: f,
    name: t.name,
    radius: t.radius
  });
}
function oy(e) {
  return /* @__PURE__ */ _.createElement(yA, Tm({
    shapeType: "rectangle",
    propTransformer: $V,
    activeClassName: "recharts-active-bar"
  }, e));
}
var LV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (r, i) => {
    if (me(t)) return t;
    var o = me(r) || dt(r);
    return o ? t(r, i) : (o || (process.env.NODE_ENV !== "production" ? Uw(!1, "minPointSize callback function received a value with type of ".concat(typeof r, ". Currently only numbers or null/undefined are supported.")) : Uw()), n);
  };
}, FV = {}, EA = Gn({
  name: "errorBars",
  initialState: FV,
  reducers: {
    addErrorBar: (e, t) => {
      var {
        itemId: n,
        errorBar: r
      } = t.payload;
      e[n] || (e[n] = []), e[n].push(r);
    },
    replaceErrorBar: (e, t) => {
      var {
        itemId: n,
        prev: r,
        next: i
      } = t.payload;
      e[n] && (e[n] = e[n].map((o) => o.dataKey === r.dataKey && o.direction === r.direction ? i : o));
    },
    removeErrorBar: (e, t) => {
      var {
        itemId: n,
        errorBar: r
      } = t.payload;
      e[n] && (e[n] = e[n].filter((i) => i.dataKey !== r.dataKey || i.direction !== r.direction));
    }
  }
}), {
  addErrorBar: zee,
  replaceErrorBar: Wee,
  removeErrorBar: Vee
} = EA.actions, BV = EA.reducer, zV = ["children"];
function WV(e, t) {
  if (e == null) return {};
  var n, r, i = VV(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function VV(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var UV = {
  data: [],
  xAxisId: "xAxis-0",
  yAxisId: "yAxis-0",
  dataPointFormatter: () => ({
    x: 0,
    y: 0,
    value: 0
  }),
  errorBarOffset: 0
}, HV = /* @__PURE__ */ hr(UV);
function _A(e) {
  var {
    children: t
  } = e, n = WV(e, zV);
  return /* @__PURE__ */ _.createElement(HV.Provider, {
    value: n
  }, t);
}
function ay(e, t) {
  var n, r, i = pe((c) => Ei(c, e)), o = pe((c) => _i(c, t)), a = (n = i?.allowDataOverflow) !== null && n !== void 0 ? n : Rn.allowDataOverflow, s = (r = o?.allowDataOverflow) !== null && r !== void 0 ? r : In.allowDataOverflow, l = a || s;
  return {
    needClip: l,
    needClipX: a,
    needClipY: s
  };
}
function PA(e) {
  var {
    xAxisId: t,
    yAxisId: n,
    clipPathId: r
  } = e, i = iy(), {
    needClipX: o,
    needClipY: a,
    needClip: s
  } = ay(t, n);
  if (!s)
    return null;
  var {
    x: l,
    y: c,
    width: u,
    height: d
  } = i;
  return /* @__PURE__ */ _.createElement("clipPath", {
    id: "clipPath-".concat(r)
  }, /* @__PURE__ */ _.createElement("rect", {
    x: o ? l : l - u / 2,
    y: a ? c : c - d / 2,
    width: o ? u : u * 2,
    height: a ? d : d * 2
  }));
}
var KV = ["onMouseEnter", "onMouseLeave", "onClick"], qV = ["value", "background", "tooltipPosition"], YV = ["id"], GV = ["onMouseEnter", "onClick", "onMouseLeave"];
function Hi() {
  return Hi = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Hi.apply(null, arguments);
}
function Kw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kw(Object(n), !0).forEach(function(r) {
      XV(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Kw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function XV(e, t, n) {
  return (t = ZV(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function ZV(e) {
  var t = JV(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function JV(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zu(e, t) {
  if (e == null) return {};
  var n, r, i = QV(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function QV(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var e7 = (e) => {
  var {
    dataKey: t,
    name: n,
    fill: r,
    legendType: i,
    hide: o
  } = e;
  return [{
    inactive: o,
    dataKey: t,
    type: i,
    color: r,
    value: La(n, t),
    payload: e
  }];
};
function t7(e) {
  var {
    dataKey: t,
    stroke: n,
    strokeWidth: r,
    fill: i,
    name: o,
    hide: a,
    unit: s
  } = e;
  return {
    dataDefinedOnItem: void 0,
    positions: void 0,
    settings: {
      stroke: n,
      strokeWidth: r,
      fill: i,
      dataKey: t,
      nameKey: void 0,
      name: La(o, t),
      hide: a,
      type: e.tooltipType,
      color: e.fill,
      unit: s
    }
  };
}
function n7(e) {
  var t = pe(Vi), {
    data: n,
    dataKey: r,
    background: i,
    allOtherBarProps: o
  } = e, {
    onMouseEnter: a,
    onMouseLeave: s,
    onClick: l
  } = o, c = zu(o, KV), u = Jv(a, r), d = Qv(s), f = ey(l, r);
  if (!i || n == null)
    return null;
  var p = ht(i, !1);
  return /* @__PURE__ */ _.createElement(_.Fragment, null, n.map((g, m) => {
    var {
      value: v,
      background: y,
      tooltipPosition: S
    } = g, x = zu(g, qV);
    if (!y)
      return null;
    var b = u(g, m), w = d(g, m), E = f(g, m), C = vn(vn(vn(vn(vn({
      option: i,
      isActive: String(m) === t
    }, x), {}, {
      // @ts-expect-error BarRectangle props do not accept `fill` property.
      fill: "#eee"
    }, y), p), kd(c, g, m)), {}, {
      onMouseEnter: b,
      onMouseLeave: w,
      onClick: E,
      dataKey: r,
      index: m,
      className: "recharts-bar-background-rectangle"
    });
    return /* @__PURE__ */ _.createElement(oy, Hi({
      key: "background-bar-".concat(C.index)
    }, C));
  }));
}
function r7(e) {
  var {
    showLabels: t,
    children: n,
    rects: r
  } = e, i = r?.map((o) => {
    var a = {
      x: o.x,
      y: o.y,
      width: o.width,
      height: o.height
    };
    return vn(vn({}, a), {}, {
      value: o.value,
      payload: o.payload,
      parentViewBox: o.parentViewBox,
      viewBox: a,
      fill: o.fill
    });
  });
  return /* @__PURE__ */ _.createElement(dA, {
    value: t ? i : void 0
  }, n);
}
function i7(e) {
  var {
    shape: t,
    activeBar: n,
    baseProps: r,
    entry: i,
    index: o,
    dataKey: a
  } = e, s = pe(Vi), l = pe(KC), c = n && String(o) === s && (l == null || a === l), u = c ? n : t;
  return /* @__PURE__ */ _.createElement(oy, Hi({}, r, i, {
    isActive: c,
    option: u,
    index: o,
    dataKey: a
  }));
}
function o7(e) {
  var {
    shape: t,
    baseProps: n,
    entry: r,
    index: i,
    dataKey: o
  } = e;
  return /* @__PURE__ */ _.createElement(oy, Hi({}, n, r, {
    isActive: !1,
    option: t,
    index: i,
    dataKey: o
  }));
}
function a7(e) {
  var {
    data: t,
    props: n
  } = e, r = Kr(n), {
    id: i
  } = r, o = zu(r, YV), {
    shape: a,
    dataKey: s,
    activeBar: l
  } = n, {
    onMouseEnter: c,
    onClick: u,
    onMouseLeave: d
  } = n, f = zu(n, GV), p = Jv(c, s), g = Qv(d), m = ey(u, s);
  return t ? /* @__PURE__ */ _.createElement(_.Fragment, null, t.map((v, y) => /* @__PURE__ */ _.createElement(tn, Hi({
    className: "recharts-bar-rectangle"
  }, kd(f, v, y), {
    // @ts-expect-error BarRectangleItem type definition says it's missing properties, but I can see them present in debugger!
    onMouseEnter: p(v, y),
    onMouseLeave: g(v, y),
    onClick: m(v, y),
    key: "rectangle-".concat(v?.x, "-").concat(v?.y, "-").concat(v?.value, "-").concat(y)
  }), l ? /* @__PURE__ */ _.createElement(i7, {
    shape: a,
    activeBar: l,
    baseProps: o,
    entry: v,
    index: y,
    dataKey: s
  }) : (
    /*
     * If the `activeBar` prop is falsy, then let's call the variant without hooks.
     * Using the `selectActiveTooltipIndex` selector is usually fast
     * but in charts with large-ish amount of data even the few nanoseconds add up to a noticeable jank.
     * If the activeBar is false then we don't need to know which index is active - because we won't use it anyway.
     * So let's just skip the hooks altogether. That way, React can skip rendering the component,
     * and can skip the tree reconciliation for its children too.
     * Because we can't call hooks conditionally, we need to have a separate component for that.
     */
    /* @__PURE__ */ _.createElement(o7, {
      shape: a,
      baseProps: o,
      entry: v,
      index: y,
      dataKey: s
    })
  )))) : null;
}
function s7(e) {
  var {
    props: t,
    previousRectanglesRef: n
  } = e, {
    data: r,
    layout: i,
    isAnimationActive: o,
    animationBegin: a,
    animationDuration: s,
    animationEasing: l,
    onAnimationEnd: c,
    onAnimationStart: u
  } = t, d = n.current, f = Ml(t, "recharts-bar-"), [p, g] = Rt(!1), m = !p, v = pt(() => {
    typeof c == "function" && c(), g(!1);
  }, [c]), y = pt(() => {
    typeof u == "function" && u(), g(!0);
  }, [u]);
  return /* @__PURE__ */ _.createElement(r7, {
    showLabels: m,
    rects: r
  }, /* @__PURE__ */ _.createElement(kl, {
    animationId: f,
    begin: a,
    duration: s,
    isActive: o,
    easing: l,
    onAnimationEnd: v,
    onAnimationStart: y,
    key: f
  }, (S) => {
    var x = S === 1 ? r : r?.map((b, w) => {
      var E = d && d[w];
      if (E)
        return vn(vn({}, b), {}, {
          x: yt(E.x, b.x, S),
          y: yt(E.y, b.y, S),
          width: yt(E.width, b.width, S),
          height: yt(E.height, b.height, S)
        });
      if (i === "horizontal") {
        var C = yt(0, b.height, S);
        return vn(vn({}, b), {}, {
          y: b.y + b.height - C,
          height: C
        });
      }
      var A = yt(0, b.width, S);
      return vn(vn({}, b), {}, {
        width: A
      });
    });
    return S > 0 && (n.current = x ?? null), x == null ? null : /* @__PURE__ */ _.createElement(tn, null, /* @__PURE__ */ _.createElement(a7, {
      props: t,
      data: x
    }));
  }), /* @__PURE__ */ _.createElement(qv, {
    label: t.label
  }), t.children);
}
function l7(e) {
  var t = Ue(null);
  return /* @__PURE__ */ _.createElement(s7, {
    previousRectanglesRef: t,
    props: e
  });
}
var CA = 0, c7 = (e, t) => {
  var n = Array.isArray(e.value) ? e.value[1] : e.value;
  return {
    x: e.x,
    y: e.y,
    value: n,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: tt(e, t)
  };
};
class u7 extends gE {
  render() {
    var {
      hide: t,
      data: n,
      dataKey: r,
      className: i,
      xAxisId: o,
      yAxisId: a,
      needClip: s,
      background: l,
      id: c
    } = this.props;
    if (t || n == null)
      return null;
    var u = ce("recharts-bar", i), d = c;
    return /* @__PURE__ */ _.createElement(tn, {
      className: u,
      id: c
    }, s && /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement(PA, {
      clipPathId: d,
      xAxisId: o,
      yAxisId: a
    })), /* @__PURE__ */ _.createElement(tn, {
      className: "recharts-bar-rectangles",
      clipPath: s ? "url(#clipPath-".concat(d, ")") : void 0
    }, /* @__PURE__ */ _.createElement(n7, {
      data: n,
      dataKey: r,
      background: l,
      allOtherBarProps: this.props
    }), /* @__PURE__ */ _.createElement(l7, this.props)));
  }
}
var d7 = {
  activeBar: !1,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease",
  hide: !1,
  isAnimationActive: !Gi.isSsr,
  legendType: "rect",
  minPointSize: CA,
  xAxisId: 0,
  yAxisId: 0
};
function f7(e) {
  var {
    xAxisId: t,
    yAxisId: n,
    hide: r,
    legendType: i,
    minPointSize: o,
    activeBar: a,
    animationBegin: s,
    animationDuration: l,
    animationEasing: c,
    isAnimationActive: u
  } = e, {
    needClip: d
  } = ay(t, n), f = Vd(), p = Nn(), g = _g(e.children, zr), m = pe((S) => B7(S, t, n, p, e.id, g));
  if (f !== "vertical" && f !== "horizontal")
    return null;
  var v, y = m?.[0];
  return y == null || y.height == null || y.width == null ? v = 0 : v = f === "vertical" ? y.height / 2 : y.width / 2, /* @__PURE__ */ _.createElement(_A, {
    xAxisId: t,
    yAxisId: n,
    data: m,
    dataPointFormatter: c7,
    errorBarOffset: v
  }, /* @__PURE__ */ _.createElement(u7, Hi({}, e, {
    layout: f,
    needClip: d,
    data: m,
    xAxisId: t,
    yAxisId: n,
    hide: r,
    legendType: i,
    minPointSize: o,
    activeBar: a,
    animationBegin: s,
    animationDuration: l,
    animationEasing: c,
    isAnimationActive: u
  })));
}
function p7(e) {
  var {
    layout: t,
    barSettings: {
      dataKey: n,
      minPointSize: r
    },
    pos: i,
    bandSize: o,
    xAxis: a,
    yAxis: s,
    xAxisTicks: l,
    yAxisTicks: c,
    stackedData: u,
    displayedData: d,
    offset: f,
    cells: p,
    parentViewBox: g
  } = e, m = t === "horizontal" ? s : a, v = u ? m.scale.domain() : null, y = L5({
    numericAxis: m
  });
  return d.map((S, x) => {
    var b, w, E, C, A, k;
    u ? b = j5(u[x], v) : (b = tt(S, n), Array.isArray(b) || (b = [y, b]));
    var R = LV(r, CA)(b[1], x);
    if (t === "horizontal") {
      var M, [P, D] = [s.scale(b[0]), s.scale(b[1])];
      w = jx({
        axis: a,
        ticks: l,
        bandSize: o,
        offset: i.offset,
        entry: S,
        index: x
      }), E = (M = D ?? P) !== null && M !== void 0 ? M : void 0, C = i.size;
      var j = P - D;
      if (A = Hn(j) ? 0 : j, k = {
        x: w,
        y: f.top,
        width: C,
        height: f.height
      }, Math.abs(R) > 0 && Math.abs(A) < Math.abs(R)) {
        var N = Ht(A || R) * (Math.abs(R) - Math.abs(A));
        E -= N, A += N;
      }
    } else {
      var [$, F] = [a.scale(b[0]), a.scale(b[1])];
      if (w = $, E = jx({
        axis: s,
        ticks: c,
        bandSize: o,
        offset: i.offset,
        entry: S,
        index: x
      }), C = F - $, A = i.size, k = {
        x: f.left,
        y: E,
        width: f.width,
        height: A
      }, Math.abs(R) > 0 && Math.abs(C) < Math.abs(R)) {
        var q = Ht(C || R) * (Math.abs(R) - Math.abs(C));
        C += q;
      }
    }
    if (w == null || E == null || C == null || A == null)
      return null;
    var B = vn(vn({}, S), {}, {
      x: w,
      y: E,
      width: C,
      height: A,
      value: u ? b : b[1],
      payload: S,
      background: k,
      tooltipPosition: {
        x: w + C / 2,
        y: E + A / 2
      },
      parentViewBox: g
    }, p && p[x] && p[x].props);
    return B;
  }).filter(Boolean);
}
function h7(e) {
  var t = rn(e, d7), n = Nn();
  return /* @__PURE__ */ _.createElement(ny, {
    id: t.id,
    type: "bar"
  }, (r) => /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(xA, {
    legendPayload: e7(t)
  }), /* @__PURE__ */ _.createElement(ty, {
    fn: t7,
    args: t
  }), /* @__PURE__ */ _.createElement(OA, {
    type: "bar",
    id: r,
    data: void 0,
    xAxisId: t.xAxisId,
    yAxisId: t.yAxisId,
    zAxisId: 0,
    dataKey: t.dataKey,
    stackId: $5(t.stackId),
    hide: t.hide,
    barSize: t.barSize,
    minPointSize: t.minPointSize,
    maxBarSize: t.maxBarSize,
    isPanorama: n
  }), /* @__PURE__ */ _.createElement(f7, Hi({}, t, {
    id: r
  }))));
}
var AA = /* @__PURE__ */ _.memo(h7);
AA.displayName = "Bar";
function qw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qw(Object(n), !0).forEach(function(r) {
      m7(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function m7(e, t, n) {
  return (t = g7(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function g7(e) {
  var t = v7(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function v7(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var y7 = (e, t) => t, b7 = (e, t, n) => n, x7 = (e, t, n, r) => r, w7 = (e, t, n, r, i) => i, Ul = z([tf, w7], (e, t) => e.filter((n) => n.type === "bar").find((n) => n.id === t)), O7 = z([Ul], (e) => e?.maxBarSize), S7 = (e, t, n, r, i, o) => o, Yw = (e, t, n) => {
  var r = n ?? e;
  if (!dt(r))
    return pn(r, t, 0);
}, E7 = z([_e, tf, y7, b7, x7], (e, t, n, r, i) => t.filter((o) => e === "horizontal" ? o.xAxisId === n : o.yAxisId === r).filter((o) => o.isPanorama === i).filter((o) => o.hide === !1).filter((o) => o.type === "bar")), _7 = (e, t, n, r) => {
  var i = _e(e);
  return i === "horizontal" ? Om(e, "yAxis", n, r) : Om(e, "xAxis", t, r);
}, P7 = (e, t, n) => {
  var r = _e(e);
  return r === "horizontal" ? q1(e, "xAxis", t) : q1(e, "yAxis", n);
}, C7 = (e, t, n) => {
  var r = {}, i = e.filter(ef), o = e.filter((c) => c.stackId == null), a = i.reduce((c, u) => (c[u.stackId] || (c[u.stackId] = []), c[u.stackId].push(u), c), r), s = Object.entries(a).map((c) => {
    var [u, d] = c, f = d.map((g) => g.dataKey), p = Yw(t, n, d[0].barSize);
    return {
      stackId: u,
      dataKeys: f,
      barSize: p
    };
  }), l = o.map((c) => {
    var u = [c.dataKey].filter((f) => f != null), d = Yw(t, n, c.barSize);
    return {
      stackId: void 0,
      dataKeys: u,
      barSize: d
    };
  });
  return [...s, ...l];
}, A7 = z([E7, o6, P7], C7), T7 = (e, t, n, r, i) => {
  var o, a, s = Ul(e, t, n, r, i);
  if (s != null) {
    var l = _e(e), c = UP(e), {
      maxBarSize: u
    } = s, d = dt(u) ? c : u, f, p;
    return l === "horizontal" ? (f = Wi(e, "xAxis", t, r), p = zi(e, "xAxis", t, r)) : (f = Wi(e, "yAxis", n, r), p = zi(e, "yAxis", n, r)), (o = (a = Gs(f, p, !0)) !== null && a !== void 0 ? a : d) !== null && o !== void 0 ? o : 0;
  }
}, TA = (e, t, n, r) => {
  var i = _e(e), o, a;
  return i === "horizontal" ? (o = Wi(e, "xAxis", t, r), a = zi(e, "xAxis", t, r)) : (o = Wi(e, "yAxis", n, r), a = zi(e, "yAxis", n, r)), Gs(o, a);
};
function k7(e, t, n, r, i) {
  var o = r.length;
  if (!(o < 1)) {
    var a = pn(e, n, 0, !0), s, l = [];
    if (qn(r[0].barSize)) {
      var c = !1, u = n / o, d = r.reduce((y, S) => y + (S.barSize || 0), 0);
      d += (o - 1) * a, d >= n && (d -= (o - 1) * a, a = 0), d >= n && u > 0 && (c = !0, u *= 0.9, d = o * u);
      var f = (n - d) / 2 >> 0, p = {
        offset: f - a,
        size: 0
      };
      s = r.reduce((y, S) => {
        var x, b = {
          stackId: S.stackId,
          dataKeys: S.dataKeys,
          position: {
            offset: p.offset + p.size + a,
            size: c ? u : (x = S.barSize) !== null && x !== void 0 ? x : 0
          }
        }, w = [...y, b];
        return p = w[w.length - 1].position, w;
      }, l);
    } else {
      var g = pn(t, n, 0, !0);
      n - 2 * g - (o - 1) * a <= 0 && (a = 0);
      var m = (n - 2 * g - (o - 1) * a) / o;
      m > 1 && (m >>= 0);
      var v = qn(i) ? Math.min(m, i) : m;
      s = r.reduce((y, S, x) => [...y, {
        stackId: S.stackId,
        dataKeys: S.dataKeys,
        position: {
          offset: g + (m + a) * x + (m - v) / 2,
          size: v
        }
      }], l);
    }
    return s;
  }
}
var M7 = (e, t, n, r, i, o, a) => {
  var s = dt(a) ? t : a, l = k7(n, r, i !== o ? i : o, e, s);
  return i !== o && l != null && (l = l.map((c) => Sc(Sc({}, c), {}, {
    position: Sc(Sc({}, c.position), {}, {
      offset: c.position.offset - i / 2
    })
  }))), l;
}, j7 = z([A7, UP, i6, HP, T7, TA, O7], M7), N7 = (e, t, n, r) => Wi(e, "xAxis", t, r), D7 = (e, t, n, r) => Wi(e, "yAxis", n, r), R7 = (e, t, n, r) => zi(e, "xAxis", t, r), I7 = (e, t, n, r) => zi(e, "yAxis", n, r), $7 = z([j7, Ul], (e, t) => {
  if (!(e == null || t == null)) {
    var n = e.find((r) => r.stackId === t.stackId && t.dataKey != null && r.dataKeys.includes(t.dataKey));
    if (n != null)
      return n.position;
  }
}), L7 = (e, t) => {
  var n = yv(t);
  if (!(!e || n == null || t == null)) {
    var {
      stackId: r
    } = t;
    if (r != null) {
      var i = e[r];
      if (i) {
        var {
          stackedData: o
        } = i;
        if (o)
          return o.find((a) => a.key === n);
      }
    }
  }
}, F7 = z([_7, Ul], L7), B7 = z([Lt, $g, N7, D7, R7, I7, $7, _e, Xd, TA, F7, Ul, S7], (e, t, n, r, i, o, a, s, l, c, u, d, f) => {
  var {
    chartData: p,
    dataStartIndex: g,
    dataEndIndex: m
  } = l;
  if (!(d == null || a == null || t == null || s !== "horizontal" && s !== "vertical" || n == null || r == null || i == null || o == null || c == null)) {
    var {
      data: v
    } = d, y;
    if (v != null && v.length > 0 ? y = v : y = p?.slice(g, m + 1), y != null)
      return p7({
        layout: s,
        barSettings: d,
        pos: a,
        parentViewBox: t,
        bandSize: c,
        xAxis: n,
        yAxis: r,
        xAxisTicks: i,
        yAxisTicks: o,
        stackedData: u,
        displayedData: y,
        offset: e,
        cells: f
      });
  }
}), kA = (e) => {
  var {
    chartData: t
  } = e, n = _t(), r = Nn();
  return Le(() => r ? () => {
  } : (n(rw(t)), () => {
    n(rw(void 0));
  }), [t, n, r]), null;
}, Gw = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
}, MA = Gn({
  name: "brush",
  initialState: Gw,
  reducers: {
    setBrushSettings(e, t) {
      return t.payload == null ? Gw : t.payload;
    }
  }
}), {
  setBrushSettings: Uee
} = MA.actions, z7 = MA.reducer;
function W7(e, t, n) {
  return (t = V7(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function V7(e) {
  var t = U7(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function U7(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
class sy {
  static create(t) {
    return new sy(t);
  }
  constructor(t) {
    this.scale = t;
  }
  get domain() {
    return this.scale.domain;
  }
  get range() {
    return this.scale.range;
  }
  get rangeMin() {
    return this.range()[0];
  }
  get rangeMax() {
    return this.range()[1];
  }
  get bandwidth() {
    return this.scale.bandwidth;
  }
  apply(t) {
    var {
      bandAware: n,
      position: r
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (t !== void 0) {
      if (r)
        switch (r) {
          case "start":
            return this.scale(t);
          case "middle": {
            var i = this.bandwidth ? this.bandwidth() / 2 : 0;
            return this.scale(t) + i;
          }
          case "end": {
            var o = this.bandwidth ? this.bandwidth() : 0;
            return this.scale(t) + o;
          }
          default:
            return this.scale(t);
        }
      if (n) {
        var a = this.bandwidth ? this.bandwidth() / 2 : 0;
        return this.scale(t) + a;
      }
      return this.scale(t);
    }
  }
  isInRange(t) {
    var n = this.range(), r = n[0], i = n[n.length - 1];
    return r <= i ? t >= r && t <= i : t >= i && t <= r;
  }
}
W7(sy, "EPS", 1e-4);
function H7(e) {
  return (e % 180 + 180) % 180;
}
var K7 = function(t) {
  var {
    width: n,
    height: r
  } = t, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = H7(i), a = o * Math.PI / 180, s = Math.atan(r / n), l = a > s && a < Math.PI - s ? r / Math.sin(a) : n / Math.cos(a);
  return Math.abs(l);
}, q7 = {
  dots: [],
  areas: [],
  lines: []
}, jA = Gn({
  name: "referenceElements",
  initialState: q7,
  reducers: {
    addDot: (e, t) => {
      e.dots.push(t.payload);
    },
    removeDot: (e, t) => {
      var n = ui(e).dots.findIndex((r) => r === t.payload);
      n !== -1 && e.dots.splice(n, 1);
    },
    addArea: (e, t) => {
      e.areas.push(t.payload);
    },
    removeArea: (e, t) => {
      var n = ui(e).areas.findIndex((r) => r === t.payload);
      n !== -1 && e.areas.splice(n, 1);
    },
    addLine: (e, t) => {
      e.lines.push(t.payload);
    },
    removeLine: (e, t) => {
      var n = ui(e).lines.findIndex((r) => r === t.payload);
      n !== -1 && e.lines.splice(n, 1);
    }
  }
}), {
  addDot: Hee,
  removeDot: Kee,
  addArea: qee,
  removeArea: Yee,
  addLine: Gee,
  removeLine: Xee
} = jA.actions, Y7 = jA.reducer, G7 = /* @__PURE__ */ hr(void 0), X7 = (e) => {
  var {
    children: t
  } = e, [n] = Rt("".concat(Ks("recharts"), "-clip")), r = iy();
  if (r == null)
    return null;
  var {
    x: i,
    y: o,
    width: a,
    height: s
  } = r;
  return /* @__PURE__ */ _.createElement(G7.Provider, {
    value: n
  }, /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement("clipPath", {
    id: n
  }, /* @__PURE__ */ _.createElement("rect", {
    x: i,
    y: o,
    height: s,
    width: a
  }))), t);
};
function Ta(e, t) {
  for (var n in e)
    if ({}.hasOwnProperty.call(e, n) && (!{}.hasOwnProperty.call(t, n) || e[n] !== t[n]))
      return !1;
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r) && !{}.hasOwnProperty.call(e, r))
      return !1;
  return !0;
}
function NA(e, t, n) {
  if (t < 1)
    return [];
  if (t === 1 && n === void 0)
    return e;
  for (var r = [], i = 0; i < e.length; i += t)
    r.push(e[i]);
  return r;
}
function Z7(e, t, n) {
  var r = {
    width: e.width + t.width,
    height: e.height + t.height
  };
  return K7(r, n);
}
function J7(e, t, n) {
  var r = n === "width", {
    x: i,
    y: o,
    width: a,
    height: s
  } = e;
  return t === 1 ? {
    start: r ? i : o,
    end: r ? i + a : o + s
  } : {
    start: r ? i + a : o + s,
    end: r ? i : o
  };
}
function Wu(e, t, n, r, i) {
  if (e * t < e * r || e * t > e * i)
    return !1;
  var o = n();
  return e * (t - e * o / 2 - r) >= 0 && e * (t + e * o / 2 - i) <= 0;
}
function Q7(e, t) {
  return NA(e, t + 1);
}
function e9(e, t, n, r, i) {
  for (var o = (r || []).slice(), {
    start: a,
    end: s
  } = t, l = 0, c = 1, u = a, d = function() {
    var g = r?.[l];
    if (g === void 0)
      return {
        v: NA(r, c)
      };
    var m = l, v, y = () => (v === void 0 && (v = n(g, m)), v), S = g.coordinate, x = l === 0 || Wu(e, S, y, u, s);
    x || (l = 0, u = a, c += 1), x && (u = S + e * (y() / 2 + i), l += c);
  }, f; c <= o.length; )
    if (f = d(), f) return f.v;
  return [];
}
function Xw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xw(Object(n), !0).forEach(function(r) {
      t9(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function t9(e, t, n) {
  return (t = n9(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function n9(e) {
  var t = r9(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function r9(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function i9(e, t, n, r, i) {
  for (var o = (r || []).slice(), a = o.length, {
    start: s
  } = t, {
    end: l
  } = t, c = function(f) {
    var p = o[f], g, m = () => (g === void 0 && (g = n(p, f)), g);
    if (f === a - 1) {
      var v = e * (p.coordinate + e * m() / 2 - l);
      o[f] = p = cn(cn({}, p), {}, {
        tickCoord: v > 0 ? p.coordinate - v * e : p.coordinate
      });
    } else
      o[f] = p = cn(cn({}, p), {}, {
        tickCoord: p.coordinate
      });
    var y = Wu(e, p.tickCoord, m, s, l);
    y && (l = p.tickCoord - e * (m() / 2 + i), o[f] = cn(cn({}, p), {}, {
      isShow: !0
    }));
  }, u = a - 1; u >= 0; u--)
    c(u);
  return o;
}
function o9(e, t, n, r, i, o) {
  var a = (r || []).slice(), s = a.length, {
    start: l,
    end: c
  } = t;
  if (o) {
    var u = r[s - 1], d = n(u, s - 1), f = e * (u.coordinate + e * d / 2 - c);
    a[s - 1] = u = cn(cn({}, u), {}, {
      tickCoord: f > 0 ? u.coordinate - f * e : u.coordinate
    });
    var p = Wu(e, u.tickCoord, () => d, l, c);
    p && (c = u.tickCoord - e * (d / 2 + i), a[s - 1] = cn(cn({}, u), {}, {
      isShow: !0
    }));
  }
  for (var g = o ? s - 1 : s, m = function(S) {
    var x = a[S], b, w = () => (b === void 0 && (b = n(x, S)), b);
    if (S === 0) {
      var E = e * (x.coordinate - e * w() / 2 - l);
      a[S] = x = cn(cn({}, x), {}, {
        tickCoord: E < 0 ? x.coordinate - E * e : x.coordinate
      });
    } else
      a[S] = x = cn(cn({}, x), {}, {
        tickCoord: x.coordinate
      });
    var C = Wu(e, x.tickCoord, w, l, c);
    C && (l = x.tickCoord + e * (w() / 2 + i), a[S] = cn(cn({}, x), {}, {
      isShow: !0
    }));
  }, v = 0; v < g; v++)
    m(v);
  return a;
}
function ly(e, t, n) {
  var {
    tick: r,
    ticks: i,
    viewBox: o,
    minTickGap: a,
    orientation: s,
    interval: l,
    tickFormatter: c,
    unit: u,
    angle: d
  } = e;
  if (!i || !i.length || !r)
    return [];
  if (me(l) || Gi.isSsr) {
    var f;
    return (f = Q7(i, me(l) ? l : 0)) !== null && f !== void 0 ? f : [];
  }
  var p = [], g = s === "top" || s === "bottom" ? "width" : "height", m = u && g === "width" ? Ns(u, {
    fontSize: t,
    letterSpacing: n
  }) : {
    width: 0,
    height: 0
  }, v = (x, b) => {
    var w = typeof c == "function" ? c(x.value, b) : x.value;
    return g === "width" ? Z7(Ns(w, {
      fontSize: t,
      letterSpacing: n
    }), m, d) : Ns(w, {
      fontSize: t,
      letterSpacing: n
    })[g];
  }, y = i.length >= 2 ? Ht(i[1].coordinate - i[0].coordinate) : 1, S = J7(o, y, g);
  return l === "equidistantPreserveStart" ? e9(y, S, v, i, a) : (l === "preserveStart" || l === "preserveStartEnd" ? p = o9(y, S, v, i, a, l === "preserveStartEnd") : p = i9(y, S, v, i, a), p.filter((x) => x.isShow));
}
var a9 = (e) => {
  var {
    ticks: t,
    label: n,
    labelGapWithTick: r = 5,
    // Default gap between label and tick
    tickSize: i = 0,
    tickMargin: o = 0
  } = e, a = 0;
  if (t) {
    t.forEach((u) => {
      if (u) {
        var d = u.getBoundingClientRect();
        d.width > a && (a = d.width);
      }
    });
    var s = n ? n.getBoundingClientRect().width : 0, l = i + o, c = a + l + s + (n ? r : 0);
    return Math.round(c);
  }
  return 0;
}, s9 = ["axisLine", "width", "height", "className", "hide", "ticks"], l9 = ["viewBox"], c9 = ["viewBox"];
function km(e, t) {
  if (e == null) return {};
  var n, r, i = u9(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function u9(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Lo() {
  return Lo = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Lo.apply(null, arguments);
}
function Zw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Zw(Object(n), !0).forEach(function(r) {
      d9(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Zw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function d9(e, t, n) {
  return (t = f9(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function f9(e) {
  var t = p9(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function p9(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var cy = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
};
function h9(e) {
  var {
    x: t,
    y: n,
    width: r,
    height: i,
    orientation: o,
    mirror: a,
    axisLine: s,
    otherSvgProps: l
  } = e;
  if (!s)
    return null;
  var c = Nt(Nt(Nt({}, l), ht(s, !1)), {}, {
    fill: "none"
  });
  if (o === "top" || o === "bottom") {
    var u = +(o === "top" && !a || o === "bottom" && a);
    c = Nt(Nt({}, c), {}, {
      x1: t,
      y1: n + u * i,
      x2: t + r,
      y2: n + u * i
    });
  } else {
    var d = +(o === "left" && !a || o === "right" && a);
    c = Nt(Nt({}, c), {}, {
      x1: t + d * r,
      y1: n,
      x2: t + d * r,
      y2: n + i
    });
  }
  return /* @__PURE__ */ _.createElement("line", Lo({}, c, {
    className: ce("recharts-cartesian-axis-line", Do(s, "className"))
  }));
}
function m9(e, t, n, r, i, o, a, s, l) {
  var c, u, d, f, p, g, m = s ? -1 : 1, v = e.tickSize || a, y = me(e.tickCoord) ? e.tickCoord : e.coordinate;
  switch (o) {
    case "top":
      c = u = e.coordinate, f = n + +!s * i, d = f - m * v, g = d - m * l, p = y;
      break;
    case "left":
      d = f = e.coordinate, u = t + +!s * r, c = u - m * v, p = c - m * l, g = y;
      break;
    case "right":
      d = f = e.coordinate, u = t + +s * r, c = u + m * v, p = c + m * l, g = y;
      break;
    default:
      c = u = e.coordinate, f = n + +s * i, d = f + m * v, g = d + m * l, p = y;
      break;
  }
  return {
    line: {
      x1: c,
      y1: d,
      x2: u,
      y2: f
    },
    tick: {
      x: p,
      y: g
    }
  };
}
function g9(e, t) {
  switch (e) {
    case "left":
      return t ? "start" : "end";
    case "right":
      return t ? "end" : "start";
    default:
      return "middle";
  }
}
function v9(e, t) {
  switch (e) {
    case "left":
    case "right":
      return "middle";
    case "top":
      return t ? "start" : "end";
    default:
      return t ? "end" : "start";
  }
}
function y9(e) {
  var {
    option: t,
    tickProps: n,
    value: r
  } = e, i, o = ce(n.className, "recharts-cartesian-axis-tick-value");
  if (/* @__PURE__ */ _.isValidElement(t))
    i = /* @__PURE__ */ _.cloneElement(t, Nt(Nt({}, n), {}, {
      className: o
    }));
  else if (typeof t == "function")
    i = t(Nt(Nt({}, n), {}, {
      className: o
    }));
  else {
    var a = "recharts-cartesian-axis-tick-value";
    typeof t != "boolean" && (a = ce(a, t?.className)), i = /* @__PURE__ */ _.createElement(lf, Lo({}, n, {
      className: a
    }), r);
  }
  return i;
}
function b9(e) {
  var {
    ticks: t = [],
    tick: n,
    tickLine: r,
    stroke: i,
    tickFormatter: o,
    unit: a,
    padding: s,
    tickTextProps: l,
    orientation: c,
    mirror: u,
    x: d,
    y: f,
    width: p,
    height: g,
    tickSize: m,
    tickMargin: v,
    fontSize: y,
    letterSpacing: S,
    getTicksConfig: x,
    events: b
  } = e, w = ly(Nt(Nt({}, x), {}, {
    ticks: t
  }), y, S), E = g9(c, u), C = v9(c, u), A = Kr(x), k = ht(n, !1), R = Nt(Nt({}, A), {}, {
    fill: "none"
  }, ht(r, !1)), M = w.map((P, D) => {
    var {
      line: j,
      tick: N
    } = m9(P, d, f, p, g, c, m, u, v), $ = Nt(Nt(Nt(Nt({
      // @ts-expect-error textAnchor from axisProps is typed as `string` but Text wants type `TextAnchor`
      textAnchor: E,
      verticalAnchor: C
    }, A), {}, {
      stroke: "none",
      fill: i
    }, k), N), {}, {
      index: D,
      payload: P,
      visibleTicksCount: w.length,
      tickFormatter: o,
      padding: s
    }, l);
    return /* @__PURE__ */ _.createElement(tn, Lo({
      className: "recharts-cartesian-axis-tick",
      key: "tick-".concat(P.value, "-").concat(P.coordinate, "-").concat(P.tickCoord)
    }, kd(b, P, D)), r && // @ts-expect-error recharts scale is not compatible with SVG scale
    /* @__PURE__ */ _.createElement("line", Lo({}, R, j, {
      className: ce("recharts-cartesian-axis-tick-line", Do(r, "className"))
    })), n && /* @__PURE__ */ _.createElement(y9, {
      option: n,
      tickProps: $,
      value: "".concat(typeof o == "function" ? o(P.value, D) : P.value).concat(a || "")
    }));
  });
  return M.length > 0 ? /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-axis-ticks"
  }, M) : null;
}
var x9 = /* @__PURE__ */ nn((e, t) => {
  var {
    axisLine: n,
    width: r,
    height: i,
    className: o,
    hide: a,
    ticks: s
  } = e, l = km(e, s9), [c, u] = Rt(""), [d, f] = Rt(""), p = Ue([]);
  yE(t, () => ({
    getCalculatedWidth: () => {
      var m;
      return a9({
        ticks: p.current,
        label: (m = e.labelRef) === null || m === void 0 ? void 0 : m.current,
        labelGapWithTick: 5,
        tickSize: e.tickSize,
        tickMargin: e.tickMargin
      });
    }
  }));
  var g = pt((m) => {
    if (m) {
      var v = m.getElementsByClassName("recharts-cartesian-axis-tick-value");
      p.current = Array.from(v);
      var y = v[0];
      if (y) {
        var S = window.getComputedStyle(y), x = S.fontSize, b = S.letterSpacing;
        (x !== c || b !== d) && (u(x), f(b));
      }
    }
  }, [c, d]);
  return a || r != null && r <= 0 || i != null && i <= 0 ? null : /* @__PURE__ */ _.createElement(tn, {
    className: ce("recharts-cartesian-axis", o),
    ref: g
  }, /* @__PURE__ */ _.createElement(h9, {
    x: e.x,
    y: e.y,
    width: r,
    height: i,
    orientation: e.orientation,
    mirror: e.mirror,
    axisLine: n,
    otherSvgProps: Kr(e)
  }), /* @__PURE__ */ _.createElement(b9, {
    ticks: s,
    tick: e.tick,
    tickLine: e.tickLine,
    stroke: e.stroke,
    tickFormatter: e.tickFormatter,
    unit: e.unit,
    padding: e.padding,
    tickTextProps: e.tickTextProps,
    orientation: e.orientation,
    mirror: e.mirror,
    x: e.x,
    y: e.y,
    width: e.width,
    height: e.height,
    tickSize: e.tickSize,
    tickMargin: e.tickMargin,
    fontSize: c,
    letterSpacing: d,
    getTicksConfig: e,
    events: l
  }), /* @__PURE__ */ _.createElement(Pz, {
    x: e.x,
    y: e.y,
    width: e.width,
    height: e.height
  }, /* @__PURE__ */ _.createElement(Iz, {
    label: e.label
  }), e.children));
}), w9 = /* @__PURE__ */ _.memo(x9, (e, t) => {
  var {
    viewBox: n
  } = e, r = km(e, l9), {
    viewBox: i
  } = t, o = km(t, c9);
  return Ta(n, i) && Ta(r, o);
}), uy = /* @__PURE__ */ _.forwardRef((e, t) => {
  var n = rn(e, cy);
  return /* @__PURE__ */ _.createElement(w9, Lo({}, n, {
    ref: t
  }));
});
uy.displayName = "CartesianAxis";
var O9 = ["x1", "y1", "x2", "y2", "key"], S9 = ["offset"], E9 = ["xAxisId", "yAxisId"], _9 = ["xAxisId", "yAxisId"];
function Jw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function un(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jw(Object(n), !0).forEach(function(r) {
      P9(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function P9(e, t, n) {
  return (t = C9(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function C9(e) {
  var t = A9(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function A9(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Eo() {
  return Eo = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Eo.apply(null, arguments);
}
function Vu(e, t) {
  if (e == null) return {};
  var n, r, i = T9(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function T9(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var k9 = (e) => {
  var {
    fill: t
  } = e;
  if (!t || t === "none")
    return null;
  var {
    fillOpacity: n,
    x: r,
    y: i,
    width: o,
    height: a,
    ry: s
  } = e;
  return /* @__PURE__ */ _.createElement("rect", {
    x: r,
    y: i,
    ry: s,
    width: o,
    height: a,
    stroke: "none",
    fill: t,
    fillOpacity: n,
    className: "recharts-cartesian-grid-bg"
  });
};
function DA(e, t) {
  var n;
  if (/* @__PURE__ */ _.isValidElement(e))
    n = /* @__PURE__ */ _.cloneElement(e, t);
  else if (typeof e == "function")
    n = e(t);
  else {
    var {
      x1: r,
      y1: i,
      x2: o,
      y2: a,
      key: s
    } = t, l = Vu(t, O9), c = Kr(l), {
      offset: u
    } = c, d = Vu(c, S9);
    n = /* @__PURE__ */ _.createElement("line", Eo({}, d, {
      x1: r,
      y1: i,
      x2: o,
      y2: a,
      fill: "none",
      key: s
    }));
  }
  return n;
}
function M9(e) {
  var {
    x: t,
    width: n,
    horizontal: r = !0,
    horizontalPoints: i
  } = e;
  if (!r || !i || !i.length)
    return null;
  var {
    xAxisId: o,
    yAxisId: a
  } = e, s = Vu(e, E9), l = i.map((c, u) => {
    var d = un(un({}, s), {}, {
      x1: t,
      y1: c,
      x2: t + n,
      y2: c,
      key: "line-".concat(u),
      index: u
    });
    return DA(r, d);
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, l);
}
function j9(e) {
  var {
    y: t,
    height: n,
    vertical: r = !0,
    verticalPoints: i
  } = e;
  if (!r || !i || !i.length)
    return null;
  var {
    xAxisId: o,
    yAxisId: a
  } = e, s = Vu(e, _9), l = i.map((c, u) => {
    var d = un(un({}, s), {}, {
      x1: c,
      y1: t,
      x2: c,
      y2: t + n,
      key: "line-".concat(u),
      index: u
    });
    return DA(r, d);
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, l);
}
function N9(e) {
  var {
    horizontalFill: t,
    fillOpacity: n,
    x: r,
    y: i,
    width: o,
    height: a,
    horizontalPoints: s,
    horizontal: l = !0
  } = e;
  if (!l || !t || !t.length)
    return null;
  var c = s.map((d) => Math.round(d + i - i)).sort((d, f) => d - f);
  i !== c[0] && c.unshift(0);
  var u = c.map((d, f) => {
    var p = !c[f + 1], g = p ? i + a - d : c[f + 1] - d;
    if (g <= 0)
      return null;
    var m = f % t.length;
    return /* @__PURE__ */ _.createElement("rect", {
      key: "react-".concat(f),
      y: d,
      x: r,
      height: g,
      width: o,
      stroke: "none",
      fill: t[m],
      fillOpacity: n,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, u);
}
function D9(e) {
  var {
    vertical: t = !0,
    verticalFill: n,
    fillOpacity: r,
    x: i,
    y: o,
    width: a,
    height: s,
    verticalPoints: l
  } = e;
  if (!t || !n || !n.length)
    return null;
  var c = l.map((d) => Math.round(d + i - i)).sort((d, f) => d - f);
  i !== c[0] && c.unshift(0);
  var u = c.map((d, f) => {
    var p = !c[f + 1], g = p ? i + a - d : c[f + 1] - d;
    if (g <= 0)
      return null;
    var m = f % n.length;
    return /* @__PURE__ */ _.createElement("rect", {
      key: "react-".concat(f),
      x: d,
      y: o,
      width: g,
      height: s,
      stroke: "none",
      fill: n[m],
      fillOpacity: r,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, u);
}
var R9 = (e, t) => {
  var {
    xAxis: n,
    width: r,
    height: i,
    offset: o
  } = e;
  return T2(ly(un(un(un({}, cy), n), {}, {
    ticks: k2(n),
    viewBox: {
      x: 0,
      y: 0,
      width: r,
      height: i
    }
  })), o.left, o.left + o.width, t);
}, I9 = (e, t) => {
  var {
    yAxis: n,
    width: r,
    height: i,
    offset: o
  } = e;
  return T2(ly(un(un(un({}, cy), n), {}, {
    ticks: k2(n),
    viewBox: {
      x: 0,
      y: 0,
      width: r,
      height: i
    }
  })), o.top, o.top + o.height, t);
}, $9 = {
  horizontal: !0,
  vertical: !0,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: [],
  xAxisId: 0,
  yAxisId: 0
};
function cf(e) {
  var t = R2(), n = I2(), r = D2(), i = un(un({}, rn(e, $9)), {}, {
    x: me(e.x) ? e.x : r.left,
    y: me(e.y) ? e.y : r.top,
    width: me(e.width) ? e.width : r.width,
    height: me(e.height) ? e.height : r.height
  }), {
    xAxisId: o,
    yAxisId: a,
    x: s,
    y: l,
    width: c,
    height: u,
    syncWithTicks: d,
    horizontalValues: f,
    verticalValues: p
  } = i, g = Nn(), m = pe((k) => Y1(k, "xAxis", o, g)), v = pe((k) => Y1(k, "yAxis", a, g));
  if (!me(c) || c <= 0 || !me(u) || u <= 0 || !me(s) || s !== +s || !me(l) || l !== +l)
    return null;
  var y = i.verticalCoordinatesGenerator || R9, S = i.horizontalCoordinatesGenerator || I9, {
    horizontalPoints: x,
    verticalPoints: b
  } = i;
  if ((!x || !x.length) && typeof S == "function") {
    var w = f && f.length, E = S({
      yAxis: v ? un(un({}, v), {}, {
        ticks: w ? f : v.ticks
      }) : void 0,
      width: t,
      height: n,
      offset: r
    }, w ? !0 : d);
    js(Array.isArray(E), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof E, "]")), Array.isArray(E) && (x = E);
  }
  if ((!b || !b.length) && typeof y == "function") {
    var C = p && p.length, A = y({
      xAxis: m ? un(un({}, m), {}, {
        ticks: C ? p : m.ticks
      }) : void 0,
      width: t,
      height: n,
      offset: r
    }, C ? !0 : d);
    js(Array.isArray(A), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof A, "]")), Array.isArray(A) && (b = A);
  }
  return /* @__PURE__ */ _.createElement("g", {
    className: "recharts-cartesian-grid"
  }, /* @__PURE__ */ _.createElement(k9, {
    fill: i.fill,
    fillOpacity: i.fillOpacity,
    x: i.x,
    y: i.y,
    width: i.width,
    height: i.height,
    ry: i.ry
  }), /* @__PURE__ */ _.createElement(N9, Eo({}, i, {
    horizontalPoints: x
  })), /* @__PURE__ */ _.createElement(D9, Eo({}, i, {
    verticalPoints: b
  })), /* @__PURE__ */ _.createElement(M9, Eo({}, i, {
    offset: r,
    horizontalPoints: x,
    xAxis: m,
    yAxis: v
  })), /* @__PURE__ */ _.createElement(j9, Eo({}, i, {
    offset: r,
    verticalPoints: b,
    xAxis: m,
    yAxis: v
  })));
}
cf.displayName = "CartesianGrid";
var RA = (e, t, n, r) => Wi(e, "xAxis", t, r), IA = (e, t, n, r) => zi(e, "xAxis", t, r), $A = (e, t, n, r) => Wi(e, "yAxis", n, r), LA = (e, t, n, r) => zi(e, "yAxis", n, r), L9 = z([_e, RA, $A, IA, LA], (e, t, n, r, i) => Yi(e, "xAxis") ? Gs(t, r, !1) : Gs(n, i, !1)), F9 = (e, t, n, r, i) => i;
function B9(e) {
  return e.type === "line";
}
var z9 = z([tf, F9], (e, t) => e.filter(B9).find((n) => n.id === t)), W9 = z([_e, RA, $A, IA, LA, z9, L9, Xd], (e, t, n, r, i, o, a, s) => {
  var {
    chartData: l,
    dataStartIndex: c,
    dataEndIndex: u
  } = s;
  if (!(o == null || t == null || n == null || r == null || i == null || r.length === 0 || i.length === 0 || a == null)) {
    var {
      dataKey: d,
      data: f
    } = o, p;
    if (f != null && f.length > 0 ? p = f : p = l?.slice(c, u + 1), p != null)
      return uU({
        layout: e,
        xAxis: t,
        yAxis: n,
        xAxisTicks: r,
        yAxisTicks: i,
        dataKey: d,
        bandSize: a,
        displayedData: p
      });
  }
}), V9 = ["id"], U9 = ["type", "layout", "connectNulls", "needClip"], H9 = ["activeDot", "animateNewValues", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "hide", "isAnimationActive", "label", "legendType", "xAxisId", "yAxisId", "id"];
function Qw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qw(Object(n), !0).forEach(function(r) {
      K9(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function K9(e, t, n) {
  return (t = q9(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function q9(e) {
  var t = Y9(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Y9(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dy(e, t) {
  if (e == null) return {};
  var n, r, i = G9(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function G9(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Fo() {
  return Fo = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Fo.apply(null, arguments);
}
var X9 = (e) => {
  var {
    dataKey: t,
    name: n,
    stroke: r,
    legendType: i,
    hide: o
  } = e;
  return [{
    inactive: o,
    dataKey: t,
    type: i,
    color: r,
    value: La(n, t),
    payload: e
  }];
};
function Z9(e) {
  var {
    dataKey: t,
    data: n,
    stroke: r,
    strokeWidth: i,
    fill: o,
    name: a,
    hide: s,
    unit: l
  } = e;
  return {
    dataDefinedOnItem: n,
    positions: void 0,
    settings: {
      stroke: r,
      strokeWidth: i,
      fill: o,
      dataKey: t,
      nameKey: void 0,
      name: La(a, t),
      hide: s,
      type: e.tooltipType,
      color: e.stroke,
      unit: l
    }
  };
}
var FA = (e, t) => "".concat(t, "px ").concat(e - t, "px");
function J9(e, t) {
  for (var n = e.length % 2 !== 0 ? [...e, 0] : e, r = [], i = 0; i < t; ++i)
    r = [...r, ...n];
  return r;
}
var Q9 = (e, t, n) => {
  var r = n.reduce((d, f) => d + f);
  if (!r)
    return FA(t, e);
  for (var i = Math.floor(e / r), o = e % r, a = t - e, s = [], l = 0, c = 0; l < n.length; c += n[l], ++l)
    if (c + n[l] > o) {
      s = [...n.slice(0, l), o - c];
      break;
    }
  var u = s.length % 2 === 0 ? [0, a] : [a];
  return [...J9(n, i), ...s, ...u].map((d) => "".concat(d, "px")).join(", ");
};
function eU(e, t) {
  var n;
  if (/* @__PURE__ */ _.isValidElement(e))
    n = /* @__PURE__ */ _.cloneElement(e, t);
  else if (typeof e == "function")
    n = e(t);
  else {
    var r = ce("recharts-line-dot", typeof e != "boolean" ? e.className : "");
    n = /* @__PURE__ */ _.createElement(pA, Fo({}, t, {
      className: r
    }));
  }
  return n;
}
function tU(e, t) {
  return e == null ? !1 : t ? !0 : e.length === 1;
}
function nU(e) {
  var {
    clipPathId: t,
    points: n,
    props: r
  } = e, {
    dot: i,
    dataKey: o,
    needClip: a
  } = r;
  if (!tU(n, i))
    return null;
  var {
    id: s
  } = r, l = dy(r, V9), c = x_(i), u = Kr(l), d = ht(i, !0), f = n.map((g, m) => {
    var v = Fn(Fn(Fn({
      key: "dot-".concat(m),
      r: 3
    }, u), d), {}, {
      index: m,
      cx: g.x,
      cy: g.y,
      dataKey: o,
      value: g.value,
      payload: g.payload,
      points: n
    });
    return eU(i, v);
  }), p = {
    clipPath: a ? "url(#clipPath-".concat(c ? "" : "dots-").concat(t, ")") : void 0
  };
  return /* @__PURE__ */ _.createElement(tn, Fo({
    className: "recharts-line-dots",
    key: "dots"
  }, p), f);
}
function rU(e) {
  var {
    showLabels: t,
    children: n,
    points: r
  } = e, i = Ur(() => r?.map((o) => {
    var a = {
      x: o.x,
      y: o.y,
      width: 0,
      height: 0
    };
    return Fn(Fn({}, a), {}, {
      value: o.value,
      payload: o.payload,
      viewBox: a,
      /*
       * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?
       * Or should this just be the root chart viewBox?
       */
      parentViewBox: void 0,
      fill: void 0
    });
  }), [r]);
  return /* @__PURE__ */ _.createElement(dA, {
    value: t ? i : null
  }, n);
}
function eO(e) {
  var {
    clipPathId: t,
    pathRef: n,
    points: r,
    strokeDasharray: i,
    props: o
  } = e, {
    type: a,
    layout: s,
    connectNulls: l,
    needClip: c
  } = o, u = dy(o, U9), d = Fn(Fn({}, ht(u, !0)), {}, {
    fill: "none",
    className: "recharts-line-curve",
    clipPath: c ? "url(#clipPath-".concat(t, ")") : void 0,
    points: r,
    type: a,
    layout: s,
    connectNulls: l,
    strokeDasharray: i ?? o.strokeDasharray
  });
  return /* @__PURE__ */ _.createElement(_.Fragment, null, r?.length > 1 && /* @__PURE__ */ _.createElement(Fg, Fo({}, d, {
    pathRef: n
  })), /* @__PURE__ */ _.createElement(nU, {
    points: r,
    clipPathId: t,
    props: o
  }));
}
function iU(e) {
  try {
    return e && e.getTotalLength && e.getTotalLength() || 0;
  } catch {
    return 0;
  }
}
function oU(e) {
  var {
    clipPathId: t,
    props: n,
    pathRef: r,
    previousPointsRef: i,
    longestAnimatedLengthRef: o
  } = e, {
    points: a,
    strokeDasharray: s,
    isAnimationActive: l,
    animationBegin: c,
    animationDuration: u,
    animationEasing: d,
    animateNewValues: f,
    width: p,
    height: g,
    onAnimationEnd: m,
    onAnimationStart: v
  } = n, y = i.current, S = Ml(n, "recharts-line-"), [x, b] = Rt(!1), w = !x, E = pt(() => {
    typeof m == "function" && m(), b(!1);
  }, [m]), C = pt(() => {
    typeof v == "function" && v(), b(!0);
  }, [v]), A = iU(r.current), k = o.current;
  return /* @__PURE__ */ _.createElement(rU, {
    points: a,
    showLabels: w
  }, n.children, /* @__PURE__ */ _.createElement(kl, {
    animationId: S,
    begin: c,
    duration: u,
    isActive: l,
    easing: d,
    onAnimationEnd: E,
    onAnimationStart: C,
    key: S
  }, (R) => {
    var M = yt(k, A + k, R), P = Math.min(M, A), D;
    if (l)
      if (s) {
        var j = "".concat(s).split(/[,\s]+/gim).map((F) => parseFloat(F));
        D = Q9(P, A, j);
      } else
        D = FA(A, P);
    else
      D = s == null ? void 0 : String(s);
    if (y) {
      var N = y.length / a.length, $ = R === 1 ? a : a.map((F, q) => {
        var B = Math.floor(q * N);
        if (y[B]) {
          var L = y[B];
          return Fn(Fn({}, F), {}, {
            x: yt(L.x, F.x, R),
            y: yt(L.y, F.y, R)
          });
        }
        return f ? Fn(Fn({}, F), {}, {
          x: yt(p * 2, F.x, R),
          y: yt(g / 2, F.y, R)
        }) : Fn(Fn({}, F), {}, {
          x: F.x,
          y: F.y
        });
      });
      return i.current = $, /* @__PURE__ */ _.createElement(eO, {
        props: n,
        points: $,
        clipPathId: t,
        pathRef: r,
        strokeDasharray: D
      });
    }
    return R > 0 && A > 0 && (i.current = a, o.current = P), /* @__PURE__ */ _.createElement(eO, {
      props: n,
      points: a,
      clipPathId: t,
      pathRef: r,
      strokeDasharray: D
    });
  }), /* @__PURE__ */ _.createElement(qv, {
    label: n.label
  }));
}
function aU(e) {
  var {
    clipPathId: t,
    props: n
  } = e, r = Ue(null), i = Ue(0), o = Ue(null);
  return /* @__PURE__ */ _.createElement(oU, {
    props: n,
    clipPathId: t,
    previousPointsRef: r,
    longestAnimatedLengthRef: i,
    pathRef: o
  });
}
var sU = (e, t) => ({
  x: e.x,
  y: e.y,
  value: e.value,
  // @ts-expect-error getValueByDataKey does not validate the output type
  errorVal: tt(e.payload, t)
});
class lU extends lM {
  render() {
    var t, {
      hide: n,
      dot: r,
      points: i,
      className: o,
      xAxisId: a,
      yAxisId: s,
      top: l,
      left: c,
      width: u,
      height: d,
      id: f,
      needClip: p
    } = this.props;
    if (n)
      return null;
    var g = ce("recharts-line", o), m = f, {
      r: v = 3,
      strokeWidth: y = 2
    } = (t = ht(r, !1)) !== null && t !== void 0 ? t : {
      r: 3,
      strokeWidth: 2
    }, S = x_(r), x = v * 2 + y;
    return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(tn, {
      className: g
    }, p && /* @__PURE__ */ _.createElement("defs", null, /* @__PURE__ */ _.createElement(PA, {
      clipPathId: m,
      xAxisId: a,
      yAxisId: s
    }), !S && /* @__PURE__ */ _.createElement("clipPath", {
      id: "clipPath-dots-".concat(m)
    }, /* @__PURE__ */ _.createElement("rect", {
      x: c - x / 2,
      y: l - x / 2,
      width: u + x,
      height: d + x
    }))), /* @__PURE__ */ _.createElement(_A, {
      xAxisId: a,
      yAxisId: s,
      data: i,
      dataPointFormatter: sU,
      errorBarOffset: 0
    }, /* @__PURE__ */ _.createElement(aU, {
      props: this.props,
      clipPathId: m
    }))), /* @__PURE__ */ _.createElement(TV, {
      activeDot: this.props.activeDot,
      points: i,
      mainColor: this.props.stroke,
      itemDataKey: this.props.dataKey
    }));
  }
}
var BA = {
  activeDot: !0,
  animateNewValues: !0,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  connectNulls: !1,
  dot: !0,
  fill: "#fff",
  hide: !1,
  isAnimationActive: !Gi.isSsr,
  label: !1,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  xAxisId: 0,
  yAxisId: 0
};
function cU(e) {
  var t = rn(e, BA), {
    activeDot: n,
    animateNewValues: r,
    animationBegin: i,
    animationDuration: o,
    animationEasing: a,
    connectNulls: s,
    dot: l,
    hide: c,
    isAnimationActive: u,
    label: d,
    legendType: f,
    xAxisId: p,
    yAxisId: g,
    id: m
  } = t, v = dy(t, H9), {
    needClip: y
  } = ay(p, g), S = iy(), x = Vd(), b = Nn(), w = pe((R) => W9(R, p, g, b, m));
  if (x !== "horizontal" && x !== "vertical" || w == null || S == null)
    return null;
  var {
    height: E,
    width: C,
    x: A,
    y: k
  } = S;
  return /* @__PURE__ */ _.createElement(lU, Fo({}, v, {
    id: m,
    connectNulls: s,
    dot: l,
    activeDot: n,
    animateNewValues: r,
    animationBegin: i,
    animationDuration: o,
    animationEasing: a,
    isAnimationActive: u,
    hide: c,
    label: d,
    legendType: f,
    xAxisId: p,
    yAxisId: g,
    points: w,
    layout: x,
    height: E,
    width: C,
    left: A,
    top: k,
    needClip: y
  }));
}
function uU(e) {
  var {
    layout: t,
    xAxis: n,
    yAxis: r,
    xAxisTicks: i,
    yAxisTicks: o,
    dataKey: a,
    bandSize: s,
    displayedData: l
  } = e;
  return l.map((c, u) => {
    var d = tt(c, a);
    if (t === "horizontal") {
      var f = Mx({
        axis: n,
        ticks: i,
        bandSize: s,
        entry: c,
        index: u
      }), p = dt(d) ? null : r.scale(d);
      return {
        x: f,
        y: p,
        value: d,
        payload: c
      };
    }
    var g = dt(d) ? null : n.scale(d), m = Mx({
      axis: r,
      ticks: o,
      bandSize: s,
      entry: c,
      index: u
    });
    return g == null || m == null ? null : {
      x: g,
      y: m,
      value: d,
      payload: c
    };
  }).filter(Boolean);
}
function dU(e) {
  var t = rn(e, BA), n = Nn();
  return /* @__PURE__ */ _.createElement(ny, {
    id: t.id,
    type: "line"
  }, (r) => /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(xA, {
    legendPayload: X9(t)
  }), /* @__PURE__ */ _.createElement(ty, {
    fn: Z9,
    args: t
  }), /* @__PURE__ */ _.createElement(OA, {
    type: "line",
    id: r,
    data: t.data,
    xAxisId: t.xAxisId,
    yAxisId: t.yAxisId,
    zAxisId: 0,
    dataKey: t.dataKey,
    hide: t.hide,
    isPanorama: n
  }), /* @__PURE__ */ _.createElement(cU, Fo({}, t, {
    id: r
  }))));
}
var va = /* @__PURE__ */ _.memo(dU);
va.displayName = "Line";
var fU = ["dangerouslySetInnerHTML", "ticks"], pU = ["id"], hU = ["domain"], mU = ["domain"];
function Mm() {
  return Mm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Mm.apply(null, arguments);
}
function Uu(e, t) {
  if (e == null) return {};
  var n, r, i = gU(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function gU(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function vU(e) {
  var t = _t();
  return Le(() => (t(gV(e)), () => {
    t(vV(e));
  }), [e, t]), null;
}
var yU = (e) => {
  var {
    xAxisId: t,
    className: n
  } = e, r = pe($g), i = Nn(), o = "xAxis", a = pe((v) => Ha(v, o, t, i)), s = pe((v) => CC(v, o, t, i)), l = pe((v) => SC(v, t)), c = pe((v) => X6(v, t)), u = pe((v) => eC(v, t));
  if (l == null || c == null || u == null)
    return null;
  var {
    dangerouslySetInnerHTML: d,
    ticks: f
  } = e, p = Uu(e, fU), {
    id: g
  } = u, m = Uu(u, pU);
  return /* @__PURE__ */ _.createElement(uy, Mm({}, p, m, {
    scale: a,
    x: c.x,
    y: c.y,
    width: l.width,
    height: l.height,
    className: ce("recharts-".concat(o, " ").concat(o), n),
    viewBox: r,
    ticks: s
  }));
}, bU = {
  allowDataOverflow: Rn.allowDataOverflow,
  allowDecimals: Rn.allowDecimals,
  allowDuplicatedCategory: Rn.allowDuplicatedCategory,
  height: Rn.height,
  hide: !1,
  mirror: Rn.mirror,
  orientation: Rn.orientation,
  padding: Rn.padding,
  reversed: Rn.reversed,
  scale: Rn.scale,
  tickCount: Rn.tickCount,
  type: Rn.type,
  xAxisId: 0
}, xU = (e) => {
  var t, n, r, i, o, a = rn(e, bU);
  return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(vU, {
    interval: (t = a.interval) !== null && t !== void 0 ? t : "preserveEnd",
    id: a.xAxisId,
    scale: a.scale,
    type: a.type,
    padding: a.padding,
    allowDataOverflow: a.allowDataOverflow,
    domain: a.domain,
    dataKey: a.dataKey,
    allowDuplicatedCategory: a.allowDuplicatedCategory,
    allowDecimals: a.allowDecimals,
    tickCount: a.tickCount,
    includeHidden: (n = a.includeHidden) !== null && n !== void 0 ? n : !1,
    reversed: a.reversed,
    ticks: a.ticks,
    height: a.height,
    orientation: a.orientation,
    mirror: a.mirror,
    hide: a.hide,
    unit: a.unit,
    name: a.name,
    angle: (r = a.angle) !== null && r !== void 0 ? r : 0,
    minTickGap: (i = a.minTickGap) !== null && i !== void 0 ? i : 5,
    tick: (o = a.tick) !== null && o !== void 0 ? o : !0,
    tickFormatter: a.tickFormatter
  }), /* @__PURE__ */ _.createElement(yU, a));
}, wU = (e, t) => {
  var {
    domain: n
  } = e, r = Uu(e, hU), {
    domain: i
  } = t, o = Uu(t, mU);
  return Ta(r, o) ? Array.isArray(n) && n.length === 2 && Array.isArray(i) && i.length === 2 ? n[0] === i[0] && n[1] === i[1] : Ta({
    domain: n
  }, {
    domain: i
  }) : !1;
}, uf = /* @__PURE__ */ _.memo(xU, wU);
uf.displayName = "XAxis";
var OU = ["dangerouslySetInnerHTML", "ticks"], SU = ["id"], EU = ["domain"], _U = ["domain"];
function jm() {
  return jm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, jm.apply(null, arguments);
}
function Hu(e, t) {
  if (e == null) return {};
  var n, r, i = PU(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function PU(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function CU(e) {
  var t = _t();
  return Le(() => (t(yV(e)), () => {
    t(bV(e));
  }), [e, t]), null;
}
var AU = (e) => {
  var {
    yAxisId: t,
    className: n,
    width: r,
    label: i
  } = e, o = Ue(null), a = Ue(null), s = pe($g), l = Nn(), c = _t(), u = "yAxis", d = pe((w) => Ha(w, u, t, l)), f = pe((w) => EC(w, t)), p = pe((w) => J6(w, t)), g = pe((w) => CC(w, u, t, l)), m = pe((w) => tC(w, t));
  if (bE(() => {
    if (!(r !== "auto" || !f || Kv(i) || /* @__PURE__ */ bn(i) || m == null)) {
      var w = o.current;
      if (w) {
        var E = w.getCalculatedWidth();
        Math.round(f.width) !== Math.round(E) && c(xV({
          id: t,
          width: E
        }));
      }
    }
  }, [
    // The dependency on cartesianAxisRef.current is not needed because useLayoutEffect will run after every render.
    // The ref will be populated by then.
    // To re-run this effect when ticks change, we can depend on the ticks array from the store.
    g,
    f,
    c,
    i,
    t,
    r,
    m
  ]), f == null || p == null || m == null)
    return null;
  var {
    dangerouslySetInnerHTML: v,
    ticks: y
  } = e, S = Hu(e, OU), {
    id: x
  } = m, b = Hu(m, SU);
  return /* @__PURE__ */ _.createElement(uy, jm({}, S, b, {
    ref: o,
    labelRef: a,
    scale: d,
    x: p.x,
    y: p.y,
    tickTextProps: r === "auto" ? {
      width: void 0
    } : {
      width: r
    },
    width: f.width,
    height: f.height,
    className: ce("recharts-".concat(u, " ").concat(u), n),
    viewBox: s,
    ticks: g
  }));
}, TU = {
  allowDataOverflow: In.allowDataOverflow,
  allowDecimals: In.allowDecimals,
  allowDuplicatedCategory: In.allowDuplicatedCategory,
  hide: !1,
  mirror: In.mirror,
  orientation: In.orientation,
  padding: In.padding,
  reversed: In.reversed,
  scale: In.scale,
  tickCount: In.tickCount,
  type: In.type,
  width: In.width,
  yAxisId: 0
}, kU = (e) => {
  var t, n, r, i, o, a = rn(e, TU);
  return /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(CU, {
    interval: (t = a.interval) !== null && t !== void 0 ? t : "preserveEnd",
    id: a.yAxisId,
    scale: a.scale,
    type: a.type,
    domain: a.domain,
    allowDataOverflow: a.allowDataOverflow,
    dataKey: a.dataKey,
    allowDuplicatedCategory: a.allowDuplicatedCategory,
    allowDecimals: a.allowDecimals,
    tickCount: a.tickCount,
    padding: a.padding,
    includeHidden: (n = a.includeHidden) !== null && n !== void 0 ? n : !1,
    reversed: a.reversed,
    ticks: a.ticks,
    width: a.width,
    orientation: a.orientation,
    mirror: a.mirror,
    hide: a.hide,
    unit: a.unit,
    name: a.name,
    angle: (r = a.angle) !== null && r !== void 0 ? r : 0,
    minTickGap: (i = a.minTickGap) !== null && i !== void 0 ? i : 5,
    tick: (o = a.tick) !== null && o !== void 0 ? o : !0,
    tickFormatter: a.tickFormatter
  }), /* @__PURE__ */ _.createElement(AU, a));
}, MU = (e, t) => {
  var {
    domain: n
  } = e, r = Hu(e, EU), {
    domain: i
  } = t, o = Hu(t, _U);
  return Ta(r, o) ? Array.isArray(n) && n.length === 2 && Array.isArray(i) && i.length === 2 ? n[0] === i[0] && n[1] === i[1] : Ta({
    domain: n
  }, {
    domain: i
  }) : !1;
}, rl = /* @__PURE__ */ _.memo(kU, MU);
rl.displayName = "YAxis";
var Ec = { exports: {} }, ph = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tO;
function jU() {
  if (tO) return ph;
  tO = 1;
  var e = He;
  function t(l, c) {
    return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useSyncExternalStore, i = e.useRef, o = e.useEffect, a = e.useMemo, s = e.useDebugValue;
  return ph.useSyncExternalStoreWithSelector = function(l, c, u, d, f) {
    var p = i(null);
    if (p.current === null) {
      var g = { hasValue: !1, value: null };
      p.current = g;
    } else g = p.current;
    p = a(
      function() {
        function v(w) {
          if (!y) {
            if (y = !0, S = w, w = d(w), f !== void 0 && g.hasValue) {
              var E = g.value;
              if (f(E, w))
                return x = E;
            }
            return x = w;
          }
          if (E = x, n(S, w)) return E;
          var C = d(w);
          return f !== void 0 && f(E, C) ? (S = w, E) : (S = w, x = C);
        }
        var y = !1, S, x, b = u === void 0 ? null : u;
        return [
          function() {
            return v(c());
          },
          b === null ? void 0 : function() {
            return v(b());
          }
        ];
      },
      [c, u, d, f]
    );
    var m = r(l, p[0], p[1]);
    return o(
      function() {
        g.hasValue = !0, g.value = m;
      },
      [m]
    ), s(m), m;
  }, ph;
}
var hh = {};
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nO;
function NU() {
  return nO || (nO = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(l, c) {
      return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = He, n = typeof Object.is == "function" ? Object.is : e, r = t.useSyncExternalStore, i = t.useRef, o = t.useEffect, a = t.useMemo, s = t.useDebugValue;
    hh.useSyncExternalStoreWithSelector = function(l, c, u, d, f) {
      var p = i(null);
      if (p.current === null) {
        var g = { hasValue: !1, value: null };
        p.current = g;
      } else g = p.current;
      p = a(
        function() {
          function v(w) {
            if (!y) {
              if (y = !0, S = w, w = d(w), f !== void 0 && g.hasValue) {
                var E = g.value;
                if (f(E, w))
                  return x = E;
              }
              return x = w;
            }
            if (E = x, n(S, w))
              return E;
            var C = d(w);
            return f !== void 0 && f(E, C) ? (S = w, E) : (S = w, x = C);
          }
          var y = !1, S, x, b = u === void 0 ? null : u;
          return [
            function() {
              return v(c());
            },
            b === null ? void 0 : function() {
              return v(b());
            }
          ];
        },
        [c, u, d, f]
      );
      var m = r(l, p[0], p[1]);
      return o(
        function() {
          g.hasValue = !0, g.value = m;
        },
        [m]
      ), s(m), m;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), hh;
}
var rO;
function DU() {
  return rO || (rO = 1, process.env.NODE_ENV === "production" ? Ec.exports = jU() : Ec.exports = NU()), Ec.exports;
}
DU();
function RU(e) {
  e();
}
function IU() {
  let e = null, t = null;
  return {
    clear() {
      e = null, t = null;
    },
    notify() {
      RU(() => {
        let n = e;
        for (; n; )
          n.callback(), n = n.next;
      });
    },
    get() {
      const n = [];
      let r = e;
      for (; r; )
        n.push(r), r = r.next;
      return n;
    },
    subscribe(n) {
      let r = !0;
      const i = t = {
        callback: n,
        next: null,
        prev: t
      };
      return i.prev ? i.prev.next = i : e = i, function() {
        !r || e === null || (r = !1, i.next ? i.next.prev = i.prev : t = i.prev, i.prev ? i.prev.next = i.next : e = i.next);
      };
    }
  };
}
var iO = {
  notify() {
  },
  get: () => []
};
function $U(e, t) {
  let n, r = iO, i = 0, o = !1;
  function a(m) {
    u();
    const v = r.subscribe(m);
    let y = !1;
    return () => {
      y || (y = !0, v(), d());
    };
  }
  function s() {
    r.notify();
  }
  function l() {
    g.onStateChange && g.onStateChange();
  }
  function c() {
    return o;
  }
  function u() {
    i++, n || (n = e.subscribe(l), r = IU());
  }
  function d() {
    i--, n && i === 0 && (n(), n = void 0, r.clear(), r = iO);
  }
  function f() {
    o || (o = !0, u());
  }
  function p() {
    o && (o = !1, d());
  }
  const g = {
    addNestedSub: a,
    notifyNestedSubs: s,
    handleChangeWrapper: l,
    isSubscribed: c,
    trySubscribe: f,
    tryUnsubscribe: p,
    getListeners: () => r
  };
  return g;
}
var LU = () => typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", FU = /* @__PURE__ */ LU(), BU = () => typeof navigator < "u" && navigator.product === "ReactNative", zU = /* @__PURE__ */ BU(), WU = () => FU || zU ? _.useLayoutEffect : _.useEffect, VU = /* @__PURE__ */ WU(), UU = /* @__PURE__ */ Symbol.for("react-redux-context"), HU = typeof globalThis < "u" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function KU() {
  if (!_.createContext) return {};
  const e = HU[UU] ??= /* @__PURE__ */ new Map();
  let t = e.get(_.createContext);
  return t || (t = _.createContext(
    null
  ), process.env.NODE_ENV !== "production" && (t.displayName = "ReactRedux"), e.set(_.createContext, t)), t;
}
var qU = /* @__PURE__ */ KU();
function YU(e) {
  const { children: t, context: n, serverState: r, store: i } = e, o = _.useMemo(() => {
    const l = $U(i), c = {
      store: i,
      subscription: l,
      getServerState: r ? () => r : void 0
    };
    if (process.env.NODE_ENV === "production")
      return c;
    {
      const { identityFunctionCheck: u = "once", stabilityCheck: d = "once" } = e;
      return /* @__PURE__ */ Object.assign(c, {
        stabilityCheck: d,
        identityFunctionCheck: u
      });
    }
  }, [i, r]), a = _.useMemo(() => i.getState(), [i]);
  VU(() => {
    const { subscription: l } = o;
    return l.onStateChange = l.notifyNestedSubs, l.trySubscribe(), a !== i.getState() && l.notifyNestedSubs(), () => {
      l.tryUnsubscribe(), l.onStateChange = void 0;
    };
  }, [o, a]);
  const s = n || qU;
  return /* @__PURE__ */ _.createElement(s.Provider, { value: o }, t);
}
var GU = YU, XU = (e, t) => t, fy = z([XU, _e, ZP, Bt, WC, Pi, r8, Lt], l8), py = (e) => {
  var t = e.currentTarget.getBoundingClientRect(), n = t.width / e.currentTarget.offsetWidth, r = t.height / e.currentTarget.offsetHeight;
  return {
    /*
     * Here it's important to use:
     * - event.clientX and event.clientY to get the mouse position relative to the viewport, including scroll.
     * - pageX and pageY are not used because they are relative to the whole document, and ignore scroll.
     * - rect.left and rect.top are used to get the position of the chart relative to the viewport.
     * - offsetX and offsetY are not used because they are relative to the offset parent
     *  which may or may not be the same as the clientX and clientY, depending on the position of the chart in the DOM
     *  and surrounding element styles. CSS position: relative, absolute, fixed, will change the offset parent.
     * - scaleX and scaleY are necessary for when the chart element is scaled using CSS `transform: scale(N)`.
     */
    chartX: Math.round((e.clientX - t.left) / n),
    chartY: Math.round((e.clientY - t.top) / r)
  };
}, zA = cr("mouseClick"), WA = Al();
WA.startListening({
  actionCreator: zA,
  effect: (e, t) => {
    var n = e.payload, r = fy(t.getState(), py(n));
    r?.activeIndex != null && t.dispatch(d3({
      activeIndex: r.activeIndex,
      activeDataKey: void 0,
      activeCoordinate: r.activeCoordinate
    }));
  }
});
var Nm = cr("mouseMove"), VA = Al();
VA.startListening({
  actionCreator: Nm,
  effect: (e, t) => {
    var n = e.payload, r = t.getState(), i = Iv(r, r.tooltip.settings.shared), o = fy(r, py(n));
    i === "axis" && (o?.activeIndex != null ? t.dispatch(RC({
      activeIndex: o.activeIndex,
      activeDataKey: void 0,
      activeCoordinate: o.activeCoordinate
    })) : t.dispatch(DC()));
  }
});
var oO = {
  accessibilityLayer: !0,
  barCategoryGap: "10%",
  barGap: 4,
  barSize: void 0,
  className: void 0,
  maxBarSize: void 0,
  stackOffset: "none",
  syncId: void 0,
  syncMethod: "index"
}, UA = Gn({
  name: "rootProps",
  initialState: oO,
  reducers: {
    updateOptions: (e, t) => {
      var n;
      e.accessibilityLayer = t.payload.accessibilityLayer, e.barCategoryGap = t.payload.barCategoryGap, e.barGap = (n = t.payload.barGap) !== null && n !== void 0 ? n : oO.barGap, e.barSize = t.payload.barSize, e.maxBarSize = t.payload.maxBarSize, e.stackOffset = t.payload.stackOffset, e.syncId = t.payload.syncId, e.syncMethod = t.payload.syncMethod, e.className = t.payload.className;
    }
  }
}), ZU = UA.reducer, {
  updateOptions: JU
} = UA.actions, HA = Gn({
  name: "polarOptions",
  initialState: null,
  reducers: {
    updatePolarOptions: (e, t) => t.payload
  }
}), {
  updatePolarOptions: QU
} = HA.actions, eH = HA.reducer, KA = cr("keyDown"), qA = cr("focus"), hy = Al();
hy.startListening({
  actionCreator: KA,
  effect: (e, t) => {
    var n = t.getState(), r = n.rootProps.accessibilityLayer !== !1;
    if (r) {
      var {
        keyboardInteraction: i
      } = n.tooltip, o = e.payload;
      if (!(o !== "ArrowRight" && o !== "ArrowLeft" && o !== "Enter")) {
        var a = Number($v(i, qa(n))), s = Pi(n);
        if (o === "Enter") {
          var l = $u(n, "axis", "hover", String(i.index));
          t.dispatch(Em({
            active: !i.active,
            activeIndex: i.index,
            activeDataKey: i.dataKey,
            activeCoordinate: l
          }));
          return;
        }
        var c = n3(n), u = c === "left-to-right" ? 1 : -1, d = o === "ArrowRight" ? 1 : -1, f = a + d * u;
        if (!(s == null || f >= s.length || f < 0)) {
          var p = $u(n, "axis", "hover", String(f));
          t.dispatch(Em({
            active: !0,
            activeIndex: f.toString(),
            activeDataKey: void 0,
            activeCoordinate: p
          }));
        }
      }
    }
  }
});
hy.startListening({
  actionCreator: qA,
  effect: (e, t) => {
    var n = t.getState(), r = n.rootProps.accessibilityLayer !== !1;
    if (r) {
      var {
        keyboardInteraction: i
      } = n.tooltip;
      if (!i.active && i.index == null) {
        var o = "0", a = $u(n, "axis", "hover", String(o));
        t.dispatch(Em({
          activeDataKey: void 0,
          active: !0,
          activeIndex: o,
          activeCoordinate: a
        }));
      }
    }
  }
});
var nr = cr("externalEvent"), YA = Al();
YA.startListening({
  actionCreator: nr,
  effect: (e, t) => {
    if (e.payload.handler != null) {
      var n = t.getState(), r = {
        activeCoordinate: q3(n),
        activeDataKey: KC(n),
        activeIndex: Vi(n),
        activeLabel: HC(n),
        activeTooltipIndex: Vi(n),
        isTooltipActive: Y3(n)
      };
      e.payload.handler(r, e.payload.reactEvent);
    }
  }
});
var tH = z([Ka], (e) => e.tooltipItemPayloads), nH = z([tH, zl, (e, t, n) => t, (e, t, n) => n], (e, t, n, r) => {
  var i = e.find((s) => s.settings.dataKey === r);
  if (i != null) {
    var {
      positions: o
    } = i;
    if (o != null) {
      var a = t(o, n);
      return a;
    }
  }
}), GA = cr("touchMove"), XA = Al();
XA.startListening({
  actionCreator: GA,
  effect: (e, t) => {
    var n = e.payload, r = t.getState(), i = Iv(r, r.tooltip.settings.shared);
    if (i === "axis") {
      var o = fy(r, py({
        clientX: n.touches[0].clientX,
        clientY: n.touches[0].clientY,
        currentTarget: n.currentTarget
      }));
      o?.activeIndex != null && t.dispatch(RC({
        activeIndex: o.activeIndex,
        activeDataKey: void 0,
        activeCoordinate: o.activeCoordinate
      }));
    } else if (i === "item") {
      var a, s = n.touches[0], l = document.elementFromPoint(s.clientX, s.clientY);
      if (!l || !l.getAttribute)
        return;
      var c = l.getAttribute(j2), u = (a = l.getAttribute(N2)) !== null && a !== void 0 ? a : void 0, d = nH(t.getState(), c, u);
      t.dispatch(NC({
        activeDataKey: u,
        activeIndex: c,
        activeCoordinate: d
      }));
    }
  }
});
var rH = e2({
  brush: z7,
  cartesianAxis: wV,
  chartData: E8,
  errorBars: BV,
  graphicalItems: BW,
  layout: g5,
  legend: iL,
  options: b8,
  polarAxis: rW,
  polarOptions: eH,
  referenceElements: Y7,
  rootProps: ZU,
  tooltip: f3
}), iH = function(t) {
  return z$({
    reducer: rH,
    // redux-toolkit v1 types are unhappy with the preloadedState type. Remove the `as any` when bumping to v2
    preloadedState: t,
    // @ts-expect-error redux-toolkit v1 types are unhappy with the middleware array. Remove this comment when bumping to v2
    middleware: (n) => n({
      serializableCheck: !1
    }).concat([WA.middleware, VA.middleware, hy.middleware, YA.middleware, XA.middleware]),
    devTools: Gi.devToolsEnabled
  });
};
function ZA(e) {
  var {
    preloadedState: t,
    children: n,
    reduxStoreName: r
  } = e, i = Nn(), o = Ue(null);
  if (i)
    return n;
  o.current == null && (o.current = iH(t));
  var a = Mg;
  return /* @__PURE__ */ _.createElement(GU, {
    context: a,
    store: o.current
  }, n);
}
function JA(e) {
  var {
    layout: t,
    width: n,
    height: r,
    margin: i
  } = e, o = _t(), a = Nn();
  return Le(() => {
    a || (o(p5(t)), o(h5({
      width: n,
      height: r
    })), o(f5(i)));
  }, [o, a, t, n, r, i]), null;
}
function QA(e) {
  var t = _t();
  return Le(() => {
    t(JU(e));
  }, [t, e]), null;
}
var oH = ["children"];
function aH(e, t) {
  if (e == null) return {};
  var n, r, i = sH(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function sH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Ku() {
  return Ku = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ku.apply(null, arguments);
}
var lH = {
  width: "100%",
  height: "100%"
}, cH = /* @__PURE__ */ nn((e, t) => {
  var n = R2(), r = I2(), i = B2();
  if (!Ea(n) || !Ea(r))
    return null;
  var {
    children: o,
    otherAttributes: a,
    title: s,
    desc: l
  } = e, c, u;
  return typeof a.tabIndex == "number" ? c = a.tabIndex : c = i ? 0 : void 0, typeof a.role == "string" ? u = a.role : u = i ? "application" : void 0, /* @__PURE__ */ _.createElement(w_, Ku({}, a, {
    title: s,
    desc: l,
    role: u,
    tabIndex: c,
    width: n,
    height: r,
    style: lH,
    ref: t
  }), o);
}), uH = (e) => {
  var {
    children: t
  } = e, n = pe(Wd);
  if (!n)
    return null;
  var {
    width: r,
    height: i,
    y: o,
    x: a
  } = n;
  return /* @__PURE__ */ _.createElement(w_, {
    width: r,
    height: i,
    x: a,
    y: o
  }, t);
}, aO = /* @__PURE__ */ nn((e, t) => {
  var {
    children: n
  } = e, r = aH(e, oH), i = Nn();
  return i ? /* @__PURE__ */ _.createElement(uH, null, n) : /* @__PURE__ */ _.createElement(cH, Ku({
    ref: t
  }, r), n);
});
function dH() {
  var e = _t(), [t, n] = Rt(null), r = pe(H5);
  return Le(() => {
    if (t != null) {
      var i = t.getBoundingClientRect(), o = i.width / t.offsetWidth;
      qn(o) && o !== r && e(m5(o));
    }
  }, [t, e, r]), n;
}
function sO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sO(Object(n), !0).forEach(function(r) {
      pH(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pH(e, t, n) {
  return (t = hH(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function hH(e) {
  var t = mH(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function mH(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var gH = /* @__PURE__ */ nn((e, t) => {
  var {
    children: n,
    className: r,
    height: i,
    onClick: o,
    onContextMenu: a,
    onDoubleClick: s,
    onMouseDown: l,
    onMouseEnter: c,
    onMouseLeave: u,
    onMouseMove: d,
    onMouseUp: f,
    onTouchEnd: p,
    onTouchMove: g,
    onTouchStart: m,
    style: v,
    width: y
  } = e, S = _t(), [x, b] = Rt(null), [w, E] = Rt(null);
  N8();
  var C = dH(), A = pt((K) => {
    C(K), typeof t == "function" && t(K), b(K), E(K);
  }, [C, t, b, E]), k = pt((K) => {
    S(zA(K)), S(nr({
      handler: o,
      reactEvent: K
    }));
  }, [S, o]), R = pt((K) => {
    S(Nm(K)), S(nr({
      handler: c,
      reactEvent: K
    }));
  }, [S, c]), M = pt((K) => {
    S(DC()), S(nr({
      handler: u,
      reactEvent: K
    }));
  }, [S, u]), P = pt((K) => {
    S(Nm(K)), S(nr({
      handler: d,
      reactEvent: K
    }));
  }, [S, d]), D = pt(() => {
    S(qA());
  }, [S]), j = pt((K) => {
    S(KA(K.key));
  }, [S]), N = pt((K) => {
    S(nr({
      handler: a,
      reactEvent: K
    }));
  }, [S, a]), $ = pt((K) => {
    S(nr({
      handler: s,
      reactEvent: K
    }));
  }, [S, s]), F = pt((K) => {
    S(nr({
      handler: l,
      reactEvent: K
    }));
  }, [S, l]), q = pt((K) => {
    S(nr({
      handler: f,
      reactEvent: K
    }));
  }, [S, f]), B = pt((K) => {
    S(nr({
      handler: m,
      reactEvent: K
    }));
  }, [S, m]), L = pt((K) => {
    S(GA(K)), S(nr({
      handler: g,
      reactEvent: K
    }));
  }, [S, g]), Y = pt((K) => {
    S(nr({
      handler: p,
      reactEvent: K
    }));
  }, [S, p]);
  return /* @__PURE__ */ _.createElement(JC.Provider, {
    value: x
  }, /* @__PURE__ */ _.createElement(bR.Provider, {
    value: w
  }, /* @__PURE__ */ _.createElement("div", {
    className: ce("recharts-wrapper", r),
    style: fH({
      position: "relative",
      cursor: "default",
      width: y,
      height: i
    }, v),
    onClick: k,
    onContextMenu: N,
    onDoubleClick: $,
    onFocus: D,
    onKeyDown: j,
    onMouseDown: F,
    onMouseEnter: R,
    onMouseLeave: M,
    onMouseMove: P,
    onMouseUp: q,
    onTouchEnd: Y,
    onTouchMove: L,
    onTouchStart: B,
    ref: A
  }, n)));
}), vH = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function yH(e, t) {
  if (e == null) return {};
  var n, r, i = bH(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function bH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var eT = /* @__PURE__ */ nn((e, t) => {
  var {
    children: n,
    className: r,
    width: i,
    height: o,
    style: a,
    compact: s,
    title: l,
    desc: c
  } = e, u = yH(e, vH), d = Kr(u);
  return s ? /* @__PURE__ */ _.createElement(aO, {
    otherAttributes: d,
    title: l,
    desc: c
  }, n) : /* @__PURE__ */ _.createElement(gH, {
    className: r,
    style: a,
    width: i,
    height: o,
    onClick: e.onClick,
    onMouseLeave: e.onMouseLeave,
    onMouseEnter: e.onMouseEnter,
    onMouseMove: e.onMouseMove,
    onMouseDown: e.onMouseDown,
    onMouseUp: e.onMouseUp,
    onContextMenu: e.onContextMenu,
    onDoubleClick: e.onDoubleClick,
    onTouchStart: e.onTouchStart,
    onTouchMove: e.onTouchMove,
    onTouchEnd: e.onTouchEnd
  }, /* @__PURE__ */ _.createElement(aO, {
    otherAttributes: d,
    title: l,
    desc: c,
    ref: t
  }, /* @__PURE__ */ _.createElement(X7, null, n)));
}), xH = ["width", "height"];
function Dm() {
  return Dm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Dm.apply(null, arguments);
}
function wH(e, t) {
  if (e == null) return {};
  var n, r, i = OH(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function OH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var SH = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
}, EH = {
  accessibilityLayer: !0,
  layout: "horizontal",
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: SH,
  reverseStackOrder: !1,
  syncMethod: "index"
}, tT = /* @__PURE__ */ nn(function(t, n) {
  var r, i = rn(t.categoricalChartProps, EH), {
    width: o,
    height: a
  } = i, s = wH(i, xH);
  if (!Ea(o) || !Ea(a))
    return null;
  var {
    chartName: l,
    defaultTooltipEventType: c,
    validateTooltipEventTypes: u,
    tooltipPayloadSearcher: d,
    categoricalChartProps: f
  } = t, p = {
    chartName: l,
    defaultTooltipEventType: c,
    validateTooltipEventTypes: u,
    tooltipPayloadSearcher: d,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ _.createElement(ZA, {
    preloadedState: {
      options: p
    },
    reduxStoreName: (r = f.id) !== null && r !== void 0 ? r : l
  }, /* @__PURE__ */ _.createElement(kA, {
    chartData: f.data
  }), /* @__PURE__ */ _.createElement(JA, {
    width: o,
    height: a,
    layout: i.layout,
    margin: i.margin
  }), /* @__PURE__ */ _.createElement(QA, {
    accessibilityLayer: i.accessibilityLayer,
    barCategoryGap: i.barCategoryGap,
    maxBarSize: i.maxBarSize,
    stackOffset: i.stackOffset,
    barGap: i.barGap,
    barSize: i.barSize,
    syncId: i.syncId,
    syncMethod: i.syncMethod,
    className: i.className
  }), /* @__PURE__ */ _.createElement(eT, Dm({}, s, {
    width: o,
    height: a,
    ref: n
  })));
}), _H = ["axis"], nT = /* @__PURE__ */ nn((e, t) => /* @__PURE__ */ _.createElement(tT, {
  chartName: "LineChart",
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: _H,
  tooltipPayloadSearcher: Hv,
  categoricalChartProps: e,
  ref: t
})), PH = ["axis", "item"], CH = /* @__PURE__ */ nn((e, t) => /* @__PURE__ */ _.createElement(tT, {
  chartName: "BarChart",
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: PH,
  tooltipPayloadSearcher: Hv,
  categoricalChartProps: e,
  ref: t
}));
function AH(e) {
  var t = _t();
  return Le(() => {
    t(QU(e));
  }, [t, e]), null;
}
var TH = ["width", "height", "layout"];
function Rm() {
  return Rm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Rm.apply(null, arguments);
}
function kH(e, t) {
  if (e == null) return {};
  var n, r, i = MH(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
function MH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var jH = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
}, NH = {
  accessibilityLayer: !0,
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: jH,
  reverseStackOrder: !1,
  syncMethod: "index",
  layout: "radial"
}, DH = /* @__PURE__ */ nn(function(t, n) {
  var r, i = rn(t.categoricalChartProps, NH), {
    width: o,
    height: a,
    layout: s
  } = i, l = kH(i, TH);
  if (!Ea(o) || !Ea(a))
    return null;
  var {
    chartName: c,
    defaultTooltipEventType: u,
    validateTooltipEventTypes: d,
    tooltipPayloadSearcher: f
  } = t, p = {
    chartName: c,
    defaultTooltipEventType: u,
    validateTooltipEventTypes: d,
    tooltipPayloadSearcher: f,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ _.createElement(ZA, {
    preloadedState: {
      options: p
    },
    reduxStoreName: (r = i.id) !== null && r !== void 0 ? r : c
  }, /* @__PURE__ */ _.createElement(kA, {
    chartData: i.data
  }), /* @__PURE__ */ _.createElement(JA, {
    width: o,
    height: a,
    layout: s,
    margin: i.margin
  }), /* @__PURE__ */ _.createElement(QA, {
    accessibilityLayer: i.accessibilityLayer,
    barCategoryGap: i.barCategoryGap,
    maxBarSize: i.maxBarSize,
    stackOffset: i.stackOffset,
    barGap: i.barGap,
    barSize: i.barSize,
    syncId: i.syncId,
    syncMethod: i.syncMethod,
    className: i.className
  }), /* @__PURE__ */ _.createElement(AH, {
    cx: i.cx,
    cy: i.cy,
    startAngle: i.startAngle,
    endAngle: i.endAngle,
    innerRadius: i.innerRadius,
    outerRadius: i.outerRadius
  }), /* @__PURE__ */ _.createElement(eT, Rm({
    width: o,
    height: a
  }, l, {
    ref: n
  })));
}), RH = ["item"], IH = {
  layout: "centric",
  startAngle: 0,
  endAngle: 360,
  cx: "50%",
  cy: "50%",
  innerRadius: 0,
  outerRadius: "80%"
}, df = /* @__PURE__ */ nn((e, t) => {
  var n = rn(e, IH);
  return /* @__PURE__ */ _.createElement(DH, {
    chartName: "PieChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: RH,
    tooltipPayloadSearcher: Hv,
    categoricalChartProps: n,
    ref: t
  });
});
function Zee({ isStatic: e, data: t }) {
  const n = Number(t?.thisMonthMoveIns ?? t?.lastMonthMoveIns ?? 0), r = Number(
    t?.thisMonthMoveOuts ?? t?.lastMonthMoveOuts ?? 0
  ), i = Number(
    t?.moveInPercentChange ?? t?.moveInChange ?? 0
  ), o = Number(
    t?.moveOutPercentChange ?? t?.moveOutChange ?? 0
  ), a = ["#8B5CF6", "#EBE4F9"], s = [
    { name: "Move-ins", value: n, color: a[0] },
    { name: "Move-outs", value: r, color: a[1] }
  ];
  function l(c, u) {
    return ((Number(c) + Number(u)) / 2).toFixed(2) + "%";
  }
  return /* @__PURE__ */ O.jsx(
    Vo,
    {
      title: "Community",
      period: "This Month",
      icon: /* @__PURE__ */ O.jsx(bg, { className: "!text-[24px] text-[#329DFF]" }),
      className: `${e && "max-h-[184px]"} h-[184px] mb-4 break-inside-avoid`,
      children: /* @__PURE__ */ O.jsxs("div", { className: "flex", children: [
        /* @__PURE__ */ O.jsxs("div", { className: "w-[50%] flex flex-col gap-[28px]", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col gap-[8px]", children: [
            /* @__PURE__ */ O.jsx("div", { className: "!m-0 !text-[12px] !leading-[16px] !text-[#64748B]", children: "Move-in/Out Count" }),
            /* @__PURE__ */ O.jsx("div", { className: "!m-0 !text-[28px] !leading-[32px] !font-medium !text-[#8B5CF6]", children: n + r })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "!m-0 !text-[10px] !leading-[14px] !text-[#64748B] flex items-center gap-[4px]", children: [
            /* @__PURE__ */ O.jsx(
              p_,
              {
                value: l(i, o)
              }
            ),
            /* @__PURE__ */ O.jsx("div", { className: "whitespace-nowrap", children: "Compared to last month" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "w-[50%] h-[111px] flex justify-end", children: /* @__PURE__ */ O.jsx(Yo, { width: "75%", height: "100%", children: /* @__PURE__ */ O.jsxs(df, { children: [
          /* @__PURE__ */ O.jsxs(
            Vl,
            {
              data: s,
              innerRadius: 36,
              outerRadius: 52,
              paddingAngle: 2,
              dataKey: "value",
              children: [
                /* @__PURE__ */ O.jsx(zr, { fill: a[0] }),
                /* @__PURE__ */ O.jsx(zr, { fill: a[1] })
              ]
            }
          ),
          /* @__PURE__ */ O.jsx(qo, { content: /* @__PURE__ */ O.jsx(Sl, {}) })
        ] }) }) })
      ] })
    }
  );
}
function Ya(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : function(...r) {
    return e(...r) || t(...r);
  };
}
function rT(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Im(e, t) {
  return Im = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Im(e, t);
}
function iT(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Im(e, t);
}
const lO = {
  disabled: !1
};
var $H = process.env.NODE_ENV !== "production" ? h.oneOfType([h.number, h.shape({
  enter: h.number,
  exit: h.number,
  appear: h.number
}).isRequired]) : null;
process.env.NODE_ENV !== "production" && h.oneOfType([h.string, h.shape({
  enter: h.string,
  exit: h.string,
  active: h.string
}), h.shape({
  enter: h.string,
  enterDone: h.string,
  enterActive: h.string,
  exit: h.string,
  exitDone: h.string,
  exitActive: h.string
})]);
const qu = He.createContext(null);
var LH = function(t) {
  return t.scrollTop;
}, Ps = "unmounted", mo = "exited", go = "entering", ca = "entered", $m = "exiting", qr = /* @__PURE__ */ (function(e) {
  iT(t, e);
  function t(r, i) {
    var o;
    o = e.call(this, r, i) || this;
    var a = i, s = a && !a.isMounting ? r.enter : r.appear, l;
    return o.appearStatus = null, r.in ? s ? (l = mo, o.appearStatus = go) : l = ca : r.unmountOnExit || r.mountOnEnter ? l = Ps : l = mo, o.state = {
      status: l
    }, o.nextCallback = null, o;
  }
  t.getDerivedStateFromProps = function(i, o) {
    var a = i.in;
    return a && o.status === Ps ? {
      status: mo
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(i) {
    var o = null;
    if (i !== this.props) {
      var a = this.state.status;
      this.props.in ? a !== go && a !== ca && (o = go) : (a === go || a === ca) && (o = $m);
    }
    this.updateStatus(!1, o);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var i = this.props.timeout, o, a, s;
    return o = a = s = i, i != null && typeof i != "number" && (o = i.exit, a = i.enter, s = i.appear !== void 0 ? i.appear : a), {
      exit: o,
      enter: a,
      appear: s
    };
  }, n.updateStatus = function(i, o) {
    if (i === void 0 && (i = !1), o !== null)
      if (this.cancelNextCallback(), o === go) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var a = this.props.nodeRef ? this.props.nodeRef.current : Zl.findDOMNode(this);
          a && LH(a);
        }
        this.performEnter(i);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === mo && this.setState({
      status: Ps
    });
  }, n.performEnter = function(i) {
    var o = this, a = this.props.enter, s = this.context ? this.context.isMounting : i, l = this.props.nodeRef ? [s] : [Zl.findDOMNode(this), s], c = l[0], u = l[1], d = this.getTimeouts(), f = s ? d.appear : d.enter;
    if (!i && !a || lO.disabled) {
      this.safeSetState({
        status: ca
      }, function() {
        o.props.onEntered(c);
      });
      return;
    }
    this.props.onEnter(c, u), this.safeSetState({
      status: go
    }, function() {
      o.props.onEntering(c, u), o.onTransitionEnd(f, function() {
        o.safeSetState({
          status: ca
        }, function() {
          o.props.onEntered(c, u);
        });
      });
    });
  }, n.performExit = function() {
    var i = this, o = this.props.exit, a = this.getTimeouts(), s = this.props.nodeRef ? void 0 : Zl.findDOMNode(this);
    if (!o || lO.disabled) {
      this.safeSetState({
        status: mo
      }, function() {
        i.props.onExited(s);
      });
      return;
    }
    this.props.onExit(s), this.safeSetState({
      status: $m
    }, function() {
      i.props.onExiting(s), i.onTransitionEnd(a.exit, function() {
        i.safeSetState({
          status: mo
        }, function() {
          i.props.onExited(s);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(i, o) {
    o = this.setNextCallback(o), this.setState(i, o);
  }, n.setNextCallback = function(i) {
    var o = this, a = !0;
    return this.nextCallback = function(s) {
      a && (a = !1, o.nextCallback = null, i(s));
    }, this.nextCallback.cancel = function() {
      a = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(i, o) {
    this.setNextCallback(o);
    var a = this.props.nodeRef ? this.props.nodeRef.current : Zl.findDOMNode(this), s = i == null && !this.props.addEndListener;
    if (!a || s) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var l = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], c = l[0], u = l[1];
      this.props.addEndListener(c, u);
    }
    i != null && setTimeout(this.nextCallback, i);
  }, n.render = function() {
    var i = this.state.status;
    if (i === Ps)
      return null;
    var o = this.props, a = o.children;
    o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
    var s = rT(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ He.createElement(qu.Provider, {
        value: null
      }, typeof a == "function" ? a(i, s) : He.cloneElement(He.Children.only(a), s))
    );
  }, t;
})(He.Component);
qr.contextType = qu;
qr.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: h.shape({
    current: typeof Element > "u" ? h.any : function(e, t, n, r, i, o) {
      var a = e[t];
      return h.instanceOf(a && "ownerDocument" in a ? a.ownerDocument.defaultView.Element : Element)(e, t, n, r, i, o);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: h.oneOfType([h.func.isRequired, h.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: h.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: h.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: h.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: h.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: h.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: h.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function(t) {
    var n = $H;
    t.addEndListener || (n = n.isRequired);
    for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      i[o - 1] = arguments[o];
    return n.apply(void 0, [t].concat(i));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: h.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: h.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: h.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: h.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: h.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: h.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: h.func
} : {};
function ia() {
}
qr.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: ia,
  onEntering: ia,
  onEntered: ia,
  onExit: ia,
  onExiting: ia,
  onExited: ia
};
qr.UNMOUNTED = Ps;
qr.EXITED = mo;
qr.ENTERING = go;
qr.ENTERED = ca;
qr.EXITING = $m;
function FH(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function my(e, t) {
  var n = function(o) {
    return t && bn(o) ? t(o) : o;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && mE.map(e, function(i) {
    return i;
  }).forEach(function(i) {
    r[i.key] = n(i);
  }), r;
}
function BH(e, t) {
  e = e || {}, t = t || {};
  function n(u) {
    return u in t ? t[u] : e[u];
  }
  var r = /* @__PURE__ */ Object.create(null), i = [];
  for (var o in e)
    o in t ? i.length && (r[o] = i, i = []) : i.push(o);
  var a, s = {};
  for (var l in t) {
    if (r[l])
      for (a = 0; a < r[l].length; a++) {
        var c = r[l][a];
        s[r[l][a]] = n(c);
      }
    s[l] = n(l);
  }
  for (a = 0; a < i.length; a++)
    s[i[a]] = n(i[a]);
  return s;
}
function _o(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function zH(e, t) {
  return my(e.children, function(n) {
    return sr(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: _o(n, "appear", e),
      enter: _o(n, "enter", e),
      exit: _o(n, "exit", e)
    });
  });
}
function WH(e, t, n) {
  var r = my(e.children), i = BH(t, r);
  return Object.keys(i).forEach(function(o) {
    var a = i[o];
    if (bn(a)) {
      var s = o in t, l = o in r, c = t[o], u = bn(c) && !c.props.in;
      l && (!s || u) ? i[o] = sr(a, {
        onExited: n.bind(null, a),
        in: !0,
        exit: _o(a, "exit", e),
        enter: _o(a, "enter", e)
      }) : !l && s && !u ? i[o] = sr(a, {
        in: !1
      }) : l && s && bn(c) && (i[o] = sr(a, {
        onExited: n.bind(null, a),
        in: c.props.in,
        exit: _o(a, "exit", e),
        enter: _o(a, "enter", e)
      }));
    }
  }), i;
}
var VH = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, UH = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, gy = /* @__PURE__ */ (function(e) {
  iT(t, e);
  function t(r, i) {
    var o;
    o = e.call(this, r, i) || this;
    var a = o.handleExited.bind(FH(o));
    return o.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: a,
      firstRender: !0
    }, o;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(i, o) {
    var a = o.children, s = o.handleExited, l = o.firstRender;
    return {
      children: l ? zH(i, s) : WH(i, a, s),
      firstRender: !1
    };
  }, n.handleExited = function(i, o) {
    var a = my(this.props.children);
    i.key in a || (i.props.onExited && i.props.onExited(o), this.mounted && this.setState(function(s) {
      var l = ru({}, s.children);
      return delete l[i.key], {
        children: l
      };
    }));
  }, n.render = function() {
    var i = this.props, o = i.component, a = i.childFactory, s = rT(i, ["component", "childFactory"]), l = this.state.contextValue, c = VH(this.state.children).map(a);
    return delete s.appear, delete s.enter, delete s.exit, o === null ? /* @__PURE__ */ He.createElement(qu.Provider, {
      value: l
    }, c) : /* @__PURE__ */ He.createElement(qu.Provider, {
      value: l
    }, /* @__PURE__ */ He.createElement(o, s, c));
  }, t;
})(He.Component);
gy.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: h.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: h.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: h.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: h.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: h.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: h.func
} : {};
gy.defaultProps = UH;
const cO = {};
function oT(e, t) {
  const n = _.useRef(cO);
  return n.current === cO && (n.current = e(t)), n;
}
const HH = [];
function KH(e) {
  _.useEffect(e, HH);
}
class ff {
  static create() {
    return new ff();
  }
  currentId = null;
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
  clear = () => {
    this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
  };
  disposeEffect = () => this.clear;
}
function fa() {
  const e = oT(ff.create).current;
  return KH(e.disposeEffect), e;
}
function qH(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function YH(e, t, n, r, i) {
  const o = e[t], a = i || t;
  if (o == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  return typeof o == "function" && !qH(o) && (s = "Did you accidentally provide a plain function component instead?"), s !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element type that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const vy = Ya(h.elementType, YH), aT = (e) => e.scrollTop;
function Yu(e, t) {
  const {
    timeout: n,
    easing: r,
    style: i = {}
  } = e;
  return {
    duration: i.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
    easing: i.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
    delay: i.transitionDelay
  };
}
function GH(e) {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : Number.isFinite(e) ? e !== Math.floor(e) ? "float" : "number" : "Infinity";
    case "object":
      return e === null ? "null" : e.constructor.name;
    default:
      return t;
  }
}
function sT(e, t, n, r) {
  const i = e[t];
  if (i == null || !Number.isInteger(i)) {
    const o = GH(i);
    return new RangeError(`Invalid ${r} \`${t}\` of type \`${o}\` supplied to \`${n}\`, expected \`integer\`.`);
  }
  return null;
}
function lT(e, t, n, r) {
  return e[t] === void 0 ? null : sT(e, t, n, r);
}
function Lm() {
  return null;
}
lT.isRequired = sT;
Lm.isRequired = Lm;
const cT = process.env.NODE_ENV === "production" ? Lm : lT;
function XH(e) {
  return Mt("MuiPaper", e);
}
xt("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const ZH = (e) => {
  const {
    square: t,
    elevation: n,
    variant: r,
    classes: i
  } = e, o = {
    root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
  };
  return $t(o, XH, i);
}, JH = xe("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(hn(({
  theme: e
}) => ({
  backgroundColor: (e.vars || e).palette.background.paper,
  color: (e.vars || e).palette.text.primary,
  transition: e.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: e.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(e.vars || e).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), uT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiPaper"
  }), i = Td(), {
    className: o,
    component: a = "div",
    elevation: s = 1,
    square: l = !1,
    variant: c = "elevation",
    ...u
  } = r, d = {
    ...r,
    component: a,
    elevation: s,
    square: l,
    variant: c
  }, f = ZH(d);
  return process.env.NODE_ENV !== "production" && i.shadows[s] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${s}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${s}]\` is defined.`].join(`
`)), /* @__PURE__ */ O.jsx(JH, {
    as: a,
    ownerState: d,
    className: ce(f.root, o),
    ref: n,
    ...u,
    style: {
      ...c === "elevation" && {
        "--Paper-shadow": (i.vars || i).shadows[s],
        ...i.vars && {
          "--Paper-overlay": i.vars.overlays?.[s]
        },
        ...!i.vars && i.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${au("#fff", Wh(s))}, ${au("#fff", Wh(s))})`
        }
      },
      ...u.style
    }
  });
});
process.env.NODE_ENV !== "production" && (uT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: Ya(cT, (e) => {
    const {
      elevation: t,
      variant: n
    } = e;
    return t > 0 && n === "outlined" ? new Error(`MUI: Combining \`elevation={${t}}\` with \`variant="${n}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: h.bool,
  /**
   * @ignore
   */
  style: h.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: h.oneOfType([h.oneOf(["elevation", "outlined"]), h.string])
});
function Gu(e) {
  return typeof e == "string";
}
function dT(e, t, n) {
  return e === void 0 || Gu(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function fT(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function pT(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function uO(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function hT(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: o
  } = e;
  if (!t) {
    const p = ce(n?.className, o, i?.className, r?.className), g = {
      ...n?.style,
      ...i?.style,
      ...r?.style
    }, m = {
      ...n,
      ...i,
      ...r
    };
    return p.length > 0 && (m.className = p), Object.keys(g).length > 0 && (m.style = g), {
      props: m,
      internalRef: void 0
    };
  }
  const a = pT({
    ...i,
    ...r
  }), s = uO(r), l = uO(i), c = t(a), u = ce(c?.className, n?.className, o, i?.className, r?.className), d = {
    ...c?.style,
    ...n?.style,
    ...i?.style,
    ...r?.style
  }, f = {
    ...c,
    ...n,
    ...l,
    ...s
  };
  return u.length > 0 && (f.className = u), Object.keys(d).length > 0 && (f.style = d), {
    props: f,
    internalRef: c.ref
  };
}
function An(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: i,
    externalForwardedProps: o,
    internalForwardedProps: a,
    shouldForwardComponentProp: s = !1,
    ...l
  } = t, {
    component: c,
    slots: u = {
      [e]: void 0
    },
    slotProps: d = {
      [e]: void 0
    },
    ...f
  } = o, p = u[e] || r, g = fT(d[e], i), {
    props: {
      component: m,
      ...v
    },
    internalRef: y
  } = hT({
    className: n,
    ...l,
    externalForwardedProps: e === "root" ? f : void 0,
    externalSlotProps: g
  }), S = Kt(y, g?.ref, t.ref), x = e === "root" ? m || c : m, b = dT(p, {
    ...e === "root" && !c && !u[e] && a,
    ...e !== "root" && !u[e] && a,
    ...v,
    ...x && !s && {
      as: x
    },
    ...x && s && {
      component: x
    },
    ref: S
  }, i);
  return [p, b];
}
const Yr = h.oneOfType([h.func, h.object]);
function Xu(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
    process.env.NODE_ENV !== "production" && !/jsdom/.test(window.navigator.userAgent) && console.warn(["MUI: The `:focus-visible` pseudo class is not supported in this browser.", "Some components rely on this feature to work properly."].join(`
`));
  }
  return !1;
}
class Zu {
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new Zu();
  }
  static use() {
    const t = oT(Zu.create).current, [n, r] = _.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, _.useEffect(t.mountEffect, [n]), t;
  }
  constructor() {
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  mount() {
    return this.mounted || (this.mounted = eK(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  mountEffect = () => {
    this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
  };
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function QH() {
  return Zu.use();
}
function eK() {
  let e, t;
  const n = new Promise((r, i) => {
    e = r, t = i;
  });
  return n.resolve = e, n.reject = t, n;
}
function mT(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: i,
    rippleY: o,
    rippleSize: a,
    in: s,
    onExited: l,
    timeout: c
  } = e, [u, d] = _.useState(!1), f = ce(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), p = {
    width: a,
    height: a,
    top: -(a / 2) + o,
    left: -(a / 2) + i
  }, g = ce(n.child, u && n.childLeaving, r && n.childPulsate);
  return !s && !u && d(!0), _.useEffect(() => {
    if (!s && l != null) {
      const m = setTimeout(l, c);
      return () => {
        clearTimeout(m);
      };
    }
  }, [l, s, c]), /* @__PURE__ */ O.jsx("span", {
    className: f,
    style: p,
    children: /* @__PURE__ */ O.jsx("span", {
      className: g
    })
  });
}
process.env.NODE_ENV !== "production" && (mT.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object.isRequired,
  className: h.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: h.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: h.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: h.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: h.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: h.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: h.number,
  /**
   * exit delay
   */
  timeout: h.number.isRequired
});
const rr = xt("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Fm = 550, tK = 80, nK = fg`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, rK = fg`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, iK = fg`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, oK = xe("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), aK = xe(mT, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${rr.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${nK};
    animation-duration: ${Fm}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${rr.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${rr.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${rr.childLeaving} {
    opacity: 0;
    animation-name: ${rK};
    animation-duration: ${Fm}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${rr.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${iK};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, gT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: i = !1,
    classes: o = {},
    className: a,
    ...s
  } = r, [l, c] = _.useState([]), u = _.useRef(0), d = _.useRef(null);
  _.useEffect(() => {
    d.current && (d.current(), d.current = null);
  }, [l]);
  const f = _.useRef(!1), p = fa(), g = _.useRef(null), m = _.useRef(null), v = _.useCallback((b) => {
    const {
      pulsate: w,
      rippleX: E,
      rippleY: C,
      rippleSize: A,
      cb: k
    } = b;
    c((R) => [...R, /* @__PURE__ */ O.jsx(aK, {
      classes: {
        ripple: ce(o.ripple, rr.ripple),
        rippleVisible: ce(o.rippleVisible, rr.rippleVisible),
        ripplePulsate: ce(o.ripplePulsate, rr.ripplePulsate),
        child: ce(o.child, rr.child),
        childLeaving: ce(o.childLeaving, rr.childLeaving),
        childPulsate: ce(o.childPulsate, rr.childPulsate)
      },
      timeout: Fm,
      pulsate: w,
      rippleX: E,
      rippleY: C,
      rippleSize: A
    }, u.current)]), u.current += 1, d.current = k;
  }, [o]), y = _.useCallback((b = {}, w = {}, E = () => {
  }) => {
    const {
      pulsate: C = !1,
      center: A = i || w.pulsate,
      fakeElement: k = !1
      // For test purposes
    } = w;
    if (b?.type === "mousedown" && f.current) {
      f.current = !1;
      return;
    }
    b?.type === "touchstart" && (f.current = !0);
    const R = k ? null : m.current, M = R ? R.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let P, D, j;
    if (A || b === void 0 || b.clientX === 0 && b.clientY === 0 || !b.clientX && !b.touches)
      P = Math.round(M.width / 2), D = Math.round(M.height / 2);
    else {
      const {
        clientX: N,
        clientY: $
      } = b.touches && b.touches.length > 0 ? b.touches[0] : b;
      P = Math.round(N - M.left), D = Math.round($ - M.top);
    }
    if (A)
      j = Math.sqrt((2 * M.width ** 2 + M.height ** 2) / 3), j % 2 === 0 && (j += 1);
    else {
      const N = Math.max(Math.abs((R ? R.clientWidth : 0) - P), P) * 2 + 2, $ = Math.max(Math.abs((R ? R.clientHeight : 0) - D), D) * 2 + 2;
      j = Math.sqrt(N ** 2 + $ ** 2);
    }
    b?.touches ? g.current === null && (g.current = () => {
      v({
        pulsate: C,
        rippleX: P,
        rippleY: D,
        rippleSize: j,
        cb: E
      });
    }, p.start(tK, () => {
      g.current && (g.current(), g.current = null);
    })) : v({
      pulsate: C,
      rippleX: P,
      rippleY: D,
      rippleSize: j,
      cb: E
    });
  }, [i, v, p]), S = _.useCallback(() => {
    y({}, {
      pulsate: !0
    });
  }, [y]), x = _.useCallback((b, w) => {
    if (p.clear(), b?.type === "touchend" && g.current) {
      g.current(), g.current = null, p.start(0, () => {
        x(b, w);
      });
      return;
    }
    g.current = null, c((E) => E.length > 0 ? E.slice(1) : E), d.current = w;
  }, [p]);
  return _.useImperativeHandle(n, () => ({
    pulsate: S,
    start: y,
    stop: x
  }), [S, y, x]), /* @__PURE__ */ O.jsx(oK, {
    className: ce(rr.root, o.root, a),
    ref: m,
    ...s,
    children: /* @__PURE__ */ O.jsx(gy, {
      component: null,
      exit: !0,
      children: l
    })
  });
});
process.env.NODE_ENV !== "production" && (gT.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: h.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string
});
function sK(e) {
  return Mt("MuiButtonBase", e);
}
const lK = xt("MuiButtonBase", ["root", "disabled", "focusVisible"]), cK = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: i
  } = e, a = $t({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, sK, i);
  return n && r && (a.root += ` ${r}`), a;
}, uK = xe("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${lK.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), vT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: i,
    centerRipple: o = !1,
    children: a,
    className: s,
    component: l = "button",
    disabled: c = !1,
    disableRipple: u = !1,
    disableTouchRipple: d = !1,
    focusRipple: f = !1,
    focusVisibleClassName: p,
    LinkComponent: g = "a",
    onBlur: m,
    onClick: v,
    onContextMenu: y,
    onDragLeave: S,
    onFocus: x,
    onFocusVisible: b,
    onKeyDown: w,
    onKeyUp: E,
    onMouseDown: C,
    onMouseLeave: A,
    onMouseUp: k,
    onTouchEnd: R,
    onTouchMove: M,
    onTouchStart: P,
    tabIndex: D = 0,
    TouchRippleProps: j,
    touchRippleRef: N,
    type: $,
    ...F
  } = r, q = _.useRef(null), B = QH(), L = Kt(B.ref, N), [Y, K] = _.useState(!1);
  c && Y && K(!1), _.useImperativeHandle(i, () => ({
    focusVisible: () => {
      K(!0), q.current.focus();
    }
  }), []);
  const te = B.shouldMount && !u && !c;
  _.useEffect(() => {
    Y && f && !u && B.pulsate();
  }, [u, f, Y, B]);
  const J = Zr(B, "start", C, d), Q = Zr(B, "stop", y, d), ne = Zr(B, "stop", S, d), re = Zr(B, "stop", k, d), ie = Zr(B, "stop", (ue) => {
    Y && ue.preventDefault(), A && A(ue);
  }, d), U = Zr(B, "start", P, d), H = Zr(B, "stop", R, d), Z = Zr(B, "stop", M, d), T = Zr(B, "stop", (ue) => {
    Xu(ue.target) || K(!1), m && m(ue);
  }, !1), de = ci((ue) => {
    q.current || (q.current = ue.currentTarget), Xu(ue.target) && (K(!0), b && b(ue)), x && x(ue);
  }), ee = () => {
    const ue = q.current;
    return l && l !== "button" && !(ue.tagName === "A" && ue.href);
  }, he = ci((ue) => {
    f && !ue.repeat && Y && ue.key === " " && B.stop(ue, () => {
      B.start(ue);
    }), ue.target === ue.currentTarget && ee() && ue.key === " " && ue.preventDefault(), w && w(ue), ue.target === ue.currentTarget && ee() && ue.key === "Enter" && !c && (ue.preventDefault(), v && v(ue));
  }), be = ci((ue) => {
    f && ue.key === " " && Y && !ue.defaultPrevented && B.stop(ue, () => {
      B.pulsate(ue);
    }), E && E(ue), v && ue.target === ue.currentTarget && ee() && ue.key === " " && !ue.defaultPrevented && v(ue);
  });
  let Se = l;
  Se === "button" && (F.href || F.to) && (Se = g);
  const Ce = {};
  Se === "button" ? (Ce.type = $ === void 0 ? "button" : $, Ce.disabled = c) : (!F.href && !F.to && (Ce.role = "button"), c && (Ce["aria-disabled"] = c));
  const nt = Kt(n, q), Ke = {
    ...r,
    centerRipple: o,
    component: l,
    disabled: c,
    disableRipple: u,
    disableTouchRipple: d,
    focusRipple: f,
    tabIndex: D,
    focusVisible: Y
  }, Te = cK(Ke);
  return /* @__PURE__ */ O.jsxs(uK, {
    as: Se,
    className: ce(Te.root, s),
    ownerState: Ke,
    onBlur: T,
    onClick: v,
    onContextMenu: Q,
    onFocus: de,
    onKeyDown: he,
    onKeyUp: be,
    onMouseDown: J,
    onMouseLeave: ie,
    onMouseUp: re,
    onDragLeave: ne,
    onTouchEnd: H,
    onTouchMove: Z,
    onTouchStart: U,
    ref: nt,
    tabIndex: c ? -1 : D,
    type: $,
    ...Ce,
    ...F,
    children: [a, te ? /* @__PURE__ */ O.jsx(gT, {
      ref: L,
      center: o,
      ...j
    }) : null]
  });
});
function Zr(e, t, n, r = !1) {
  return ci((i) => (n && n(i), r || e[t](i), !0));
}
process.env.NODE_ENV !== "production" && (vT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: Yr,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: h.bool,
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: vy,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: h.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: h.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: h.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: h.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: h.string,
  /**
   * @ignore
   */
  href: h.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: h.elementType,
  /**
   * @ignore
   */
  onBlur: h.func,
  /**
   * @ignore
   */
  onClick: h.func,
  /**
   * @ignore
   */
  onContextMenu: h.func,
  /**
   * @ignore
   */
  onDragLeave: h.func,
  /**
   * @ignore
   */
  onFocus: h.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: h.func,
  /**
   * @ignore
   */
  onKeyDown: h.func,
  /**
   * @ignore
   */
  onKeyUp: h.func,
  /**
   * @ignore
   */
  onMouseDown: h.func,
  /**
   * @ignore
   */
  onMouseLeave: h.func,
  /**
   * @ignore
   */
  onMouseUp: h.func,
  /**
   * @ignore
   */
  onTouchEnd: h.func,
  /**
   * @ignore
   */
  onTouchMove: h.func,
  /**
   * @ignore
   */
  onTouchStart: h.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * @default 0
   */
  tabIndex: h.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: h.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: h.oneOfType([h.func, h.shape({
    current: h.shape({
      pulsate: h.func.isRequired,
      start: h.func.isRequired,
      stop: h.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: h.oneOfType([h.oneOf(["button", "reset", "submit"]), h.string])
});
function dK(e) {
  return typeof e.main == "string";
}
function fK(e, t = []) {
  if (!dK(e))
    return !1;
  for (const n of t)
    if (!e.hasOwnProperty(n) || typeof e[n] != "string")
      return !1;
  return !0;
}
function yy(e = []) {
  return ([, t]) => t && fK(t, e);
}
function yi(e, t, n, r, i) {
  if (process.env.NODE_ENV === "production")
    return null;
  const o = e[t], a = i || t;
  return o == null ? null : o && o.nodeType !== 1 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an HTMLElement.`) : null;
}
var kn = "top", dr = "bottom", fr = "right", Mn = "left", by = "auto", Hl = [kn, dr, fr, Mn], ka = "start", il = "end", pK = "clippingParents", yT = "viewport", us = "popper", hK = "reference", dO = /* @__PURE__ */ Hl.reduce(function(e, t) {
  return e.concat([t + "-" + ka, t + "-" + il]);
}, []), bT = /* @__PURE__ */ [].concat(Hl, [by]).reduce(function(e, t) {
  return e.concat([t, t + "-" + ka, t + "-" + il]);
}, []), mK = "beforeRead", gK = "read", vK = "afterRead", yK = "beforeMain", bK = "main", xK = "afterMain", wK = "beforeWrite", OK = "write", SK = "afterWrite", EK = [mK, gK, vK, yK, bK, xK, wK, OK, SK];
function Wr(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Yn(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Bo(e) {
  var t = Yn(e).Element;
  return e instanceof t || e instanceof Element;
}
function lr(e) {
  var t = Yn(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function xy(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Yn(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function _K(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, o = t.elements[n];
    !lr(o) || !Wr(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function(a) {
      var s = i[a];
      s === !1 ? o.removeAttribute(a) : o.setAttribute(a, s === !0 ? "" : s);
    }));
  });
}
function PK(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], o = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), s = a.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !lr(i) || !Wr(i) || (Object.assign(i.style, s), Object.keys(o).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const xT = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: _K,
  effect: PK,
  requires: ["computeStyles"]
};
function Rr(e) {
  return e.split("-")[0];
}
var jo = Math.max, Ju = Math.min, Ma = Math.round;
function Bm() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function wT() {
  return !/^((?!chrome|android).)*safari/i.test(Bm());
}
function ja(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, o = 1;
  t && lr(e) && (i = e.offsetWidth > 0 && Ma(r.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && Ma(r.height) / e.offsetHeight || 1);
  var a = Bo(e) ? Yn(e) : window, s = a.visualViewport, l = !wT() && n, c = (r.left + (l && s ? s.offsetLeft : 0)) / i, u = (r.top + (l && s ? s.offsetTop : 0)) / o, d = r.width / i, f = r.height / o;
  return {
    width: d,
    height: f,
    top: u,
    right: c + d,
    bottom: u + f,
    left: c,
    x: c,
    y: u
  };
}
function wy(e) {
  var t = ja(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function OT(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && xy(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function bi(e) {
  return Yn(e).getComputedStyle(e);
}
function CK(e) {
  return ["table", "td", "th"].indexOf(Wr(e)) >= 0;
}
function Qi(e) {
  return ((Bo(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function pf(e) {
  return Wr(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (xy(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Qi(e)
  );
}
function fO(e) {
  return !lr(e) || // https://github.com/popperjs/popper-core/issues/837
  bi(e).position === "fixed" ? null : e.offsetParent;
}
function AK(e) {
  var t = /firefox/i.test(Bm()), n = /Trident/i.test(Bm());
  if (n && lr(e)) {
    var r = bi(e);
    if (r.position === "fixed")
      return null;
  }
  var i = pf(e);
  for (xy(i) && (i = i.host); lr(i) && ["html", "body"].indexOf(Wr(i)) < 0; ) {
    var o = bi(i);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Kl(e) {
  for (var t = Yn(e), n = fO(e); n && CK(n) && bi(n).position === "static"; )
    n = fO(n);
  return n && (Wr(n) === "html" || Wr(n) === "body" && bi(n).position === "static") ? t : n || AK(e) || t;
}
function Oy(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Ds(e, t, n) {
  return jo(e, Ju(t, n));
}
function TK(e, t, n) {
  var r = Ds(e, t, n);
  return r > n ? n : r;
}
function ST() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function ET(e) {
  return Object.assign({}, ST(), e);
}
function _T(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var kK = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, ET(typeof t != "number" ? t : _T(t, Hl));
};
function MK(e) {
  var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, a = n.modifiersData.popperOffsets, s = Rr(n.placement), l = Oy(s), c = [Mn, fr].indexOf(s) >= 0, u = c ? "height" : "width";
  if (!(!o || !a)) {
    var d = kK(i.padding, n), f = wy(o), p = l === "y" ? kn : Mn, g = l === "y" ? dr : fr, m = n.rects.reference[u] + n.rects.reference[l] - a[l] - n.rects.popper[u], v = a[l] - n.rects.reference[l], y = Kl(o), S = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, x = m / 2 - v / 2, b = d[p], w = S - f[u] - d[g], E = S / 2 - f[u] / 2 + x, C = Ds(b, E, w), A = l;
    n.modifiersData[r] = (t = {}, t[A] = C, t.centerOffset = C - E, t);
  }
}
function jK(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || OT(t.elements.popper, i) && (t.elements.arrow = i));
}
const NK = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: MK,
  effect: jK,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Na(e) {
  return e.split("-")[1];
}
var DK = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function RK(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: Ma(n * i) / i || 0,
    y: Ma(r * i) / i || 0
  };
}
function pO(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, a = e.offsets, s = e.position, l = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, d = e.isFixed, f = a.x, p = f === void 0 ? 0 : f, g = a.y, m = g === void 0 ? 0 : g, v = typeof u == "function" ? u({
    x: p,
    y: m
  }) : {
    x: p,
    y: m
  };
  p = v.x, m = v.y;
  var y = a.hasOwnProperty("x"), S = a.hasOwnProperty("y"), x = Mn, b = kn, w = window;
  if (c) {
    var E = Kl(n), C = "clientHeight", A = "clientWidth";
    if (E === Yn(n) && (E = Qi(n), bi(E).position !== "static" && s === "absolute" && (C = "scrollHeight", A = "scrollWidth")), E = E, i === kn || (i === Mn || i === fr) && o === il) {
      b = dr;
      var k = d && E === w && w.visualViewport ? w.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        E[C]
      );
      m -= k - r.height, m *= l ? 1 : -1;
    }
    if (i === Mn || (i === kn || i === dr) && o === il) {
      x = fr;
      var R = d && E === w && w.visualViewport ? w.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        E[A]
      );
      p -= R - r.width, p *= l ? 1 : -1;
    }
  }
  var M = Object.assign({
    position: s
  }, c && DK), P = u === !0 ? RK({
    x: p,
    y: m
  }, Yn(n)) : {
    x: p,
    y: m
  };
  if (p = P.x, m = P.y, l) {
    var D;
    return Object.assign({}, M, (D = {}, D[b] = S ? "0" : "", D[x] = y ? "0" : "", D.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", D));
  }
  return Object.assign({}, M, (t = {}, t[b] = S ? m + "px" : "", t[x] = y ? p + "px" : "", t.transform = "", t));
}
function IK(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, o = n.adaptive, a = o === void 0 ? !0 : o, s = n.roundOffsets, l = s === void 0 ? !0 : s, c = {
    placement: Rr(t.placement),
    variation: Na(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, pO(Object.assign({}, c, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: a,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, pO(Object.assign({}, c, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const $K = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: IK,
  data: {}
};
var _c = {
  passive: !0
};
function LK(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, o = i === void 0 ? !0 : i, a = r.resize, s = a === void 0 ? !0 : a, l = Yn(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, _c);
  }), s && l.addEventListener("resize", n.update, _c), function() {
    o && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, _c);
    }), s && l.removeEventListener("resize", n.update, _c);
  };
}
const FK = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: LK,
  data: {}
};
var BK = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Qc(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return BK[t];
  });
}
var zK = {
  start: "end",
  end: "start"
};
function hO(e) {
  return e.replace(/start|end/g, function(t) {
    return zK[t];
  });
}
function Sy(e) {
  var t = Yn(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function Ey(e) {
  return ja(Qi(e)).left + Sy(e).scrollLeft;
}
function WK(e, t) {
  var n = Yn(e), r = Qi(e), i = n.visualViewport, o = r.clientWidth, a = r.clientHeight, s = 0, l = 0;
  if (i) {
    o = i.width, a = i.height;
    var c = wT();
    (c || !c && t === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: o,
    height: a,
    x: s + Ey(e),
    y: l
  };
}
function VK(e) {
  var t, n = Qi(e), r = Sy(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, o = jo(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = jo(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + Ey(e), l = -r.scrollTop;
  return bi(i || n).direction === "rtl" && (s += jo(n.clientWidth, i ? i.clientWidth : 0) - o), {
    width: o,
    height: a,
    x: s,
    y: l
  };
}
function _y(e) {
  var t = bi(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function PT(e) {
  return ["html", "body", "#document"].indexOf(Wr(e)) >= 0 ? e.ownerDocument.body : lr(e) && _y(e) ? e : PT(pf(e));
}
function Rs(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = PT(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Yn(r), a = i ? [o].concat(o.visualViewport || [], _y(r) ? r : []) : r, s = t.concat(a);
  return i ? s : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    s.concat(Rs(pf(a)))
  );
}
function zm(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function UK(e, t) {
  var n = ja(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function mO(e, t, n) {
  return t === yT ? zm(WK(e, n)) : Bo(t) ? UK(t, n) : zm(VK(Qi(e)));
}
function HK(e) {
  var t = Rs(pf(e)), n = ["absolute", "fixed"].indexOf(bi(e).position) >= 0, r = n && lr(e) ? Kl(e) : e;
  return Bo(r) ? t.filter(function(i) {
    return Bo(i) && OT(i, r) && Wr(i) !== "body";
  }) : [];
}
function KK(e, t, n, r) {
  var i = t === "clippingParents" ? HK(e) : [].concat(t), o = [].concat(i, [n]), a = o[0], s = o.reduce(function(l, c) {
    var u = mO(e, c, r);
    return l.top = jo(u.top, l.top), l.right = Ju(u.right, l.right), l.bottom = Ju(u.bottom, l.bottom), l.left = jo(u.left, l.left), l;
  }, mO(e, a, r));
  return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;
}
function CT(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? Rr(r) : null, o = r ? Na(r) : null, a = t.x + t.width / 2 - n.width / 2, s = t.y + t.height / 2 - n.height / 2, l;
  switch (i) {
    case kn:
      l = {
        x: a,
        y: t.y - n.height
      };
      break;
    case dr:
      l = {
        x: a,
        y: t.y + t.height
      };
      break;
    case fr:
      l = {
        x: t.x + t.width,
        y: s
      };
      break;
    case Mn:
      l = {
        x: t.x - n.width,
        y: s
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var c = i ? Oy(i) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (o) {
      case ka:
        l[c] = l[c] - (t[u] / 2 - n[u] / 2);
        break;
      case il:
        l[c] = l[c] + (t[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function ol(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, o = n.strategy, a = o === void 0 ? e.strategy : o, s = n.boundary, l = s === void 0 ? pK : s, c = n.rootBoundary, u = c === void 0 ? yT : c, d = n.elementContext, f = d === void 0 ? us : d, p = n.altBoundary, g = p === void 0 ? !1 : p, m = n.padding, v = m === void 0 ? 0 : m, y = ET(typeof v != "number" ? v : _T(v, Hl)), S = f === us ? hK : us, x = e.rects.popper, b = e.elements[g ? S : f], w = KK(Bo(b) ? b : b.contextElement || Qi(e.elements.popper), l, u, a), E = ja(e.elements.reference), C = CT({
    reference: E,
    element: x,
    placement: i
  }), A = zm(Object.assign({}, x, C)), k = f === us ? A : E, R = {
    top: w.top - k.top + y.top,
    bottom: k.bottom - w.bottom + y.bottom,
    left: w.left - k.left + y.left,
    right: k.right - w.right + y.right
  }, M = e.modifiersData.offset;
  if (f === us && M) {
    var P = M[i];
    Object.keys(R).forEach(function(D) {
      var j = [fr, dr].indexOf(D) >= 0 ? 1 : -1, N = [kn, dr].indexOf(D) >= 0 ? "y" : "x";
      R[D] += P[N] * j;
    });
  }
  return R;
}
function qK(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, o = n.rootBoundary, a = n.padding, s = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? bT : l, u = Na(r), d = u ? s ? dO : dO.filter(function(g) {
    return Na(g) === u;
  }) : Hl, f = d.filter(function(g) {
    return c.indexOf(g) >= 0;
  });
  f.length === 0 && (f = d);
  var p = f.reduce(function(g, m) {
    return g[m] = ol(e, {
      placement: m,
      boundary: i,
      rootBoundary: o,
      padding: a
    })[Rr(m)], g;
  }, {});
  return Object.keys(p).sort(function(g, m) {
    return p[g] - p[m];
  });
}
function YK(e) {
  if (Rr(e) === by)
    return [];
  var t = Qc(e);
  return [hO(e), t, hO(t)];
}
function GK(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, o = i === void 0 ? !0 : i, a = n.altAxis, s = a === void 0 ? !0 : a, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, g = p === void 0 ? !0 : p, m = n.allowedAutoPlacements, v = t.options.placement, y = Rr(v), S = y === v, x = l || (S || !g ? [Qc(v)] : YK(v)), b = [v].concat(x).reduce(function(J, Q) {
      return J.concat(Rr(Q) === by ? qK(t, {
        placement: Q,
        boundary: u,
        rootBoundary: d,
        padding: c,
        flipVariations: g,
        allowedAutoPlacements: m
      }) : Q);
    }, []), w = t.rects.reference, E = t.rects.popper, C = /* @__PURE__ */ new Map(), A = !0, k = b[0], R = 0; R < b.length; R++) {
      var M = b[R], P = Rr(M), D = Na(M) === ka, j = [kn, dr].indexOf(P) >= 0, N = j ? "width" : "height", $ = ol(t, {
        placement: M,
        boundary: u,
        rootBoundary: d,
        altBoundary: f,
        padding: c
      }), F = j ? D ? fr : Mn : D ? dr : kn;
      w[N] > E[N] && (F = Qc(F));
      var q = Qc(F), B = [];
      if (o && B.push($[P] <= 0), s && B.push($[F] <= 0, $[q] <= 0), B.every(function(J) {
        return J;
      })) {
        k = M, A = !1;
        break;
      }
      C.set(M, B);
    }
    if (A)
      for (var L = g ? 3 : 1, Y = function(Q) {
        var ne = b.find(function(re) {
          var ie = C.get(re);
          if (ie)
            return ie.slice(0, Q).every(function(U) {
              return U;
            });
        });
        if (ne)
          return k = ne, "break";
      }, K = L; K > 0; K--) {
        var te = Y(K);
        if (te === "break") break;
      }
    t.placement !== k && (t.modifiersData[r]._skip = !0, t.placement = k, t.reset = !0);
  }
}
const XK = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: GK,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function gO(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function vO(e) {
  return [kn, fr, dr, Mn].some(function(t) {
    return e[t] >= 0;
  });
}
function ZK(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, o = t.modifiersData.preventOverflow, a = ol(t, {
    elementContext: "reference"
  }), s = ol(t, {
    altBoundary: !0
  }), l = gO(a, r), c = gO(s, i, o), u = vO(l), d = vO(c);
  t.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
const JK = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: ZK
};
function QK(e, t, n) {
  var r = Rr(e), i = [Mn, kn].indexOf(r) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, a = o[0], s = o[1];
  return a = a || 0, s = (s || 0) * i, [Mn, fr].indexOf(r) >= 0 ? {
    x: s,
    y: a
  } : {
    x: a,
    y: s
  };
}
function eq(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, o = i === void 0 ? [0, 0] : i, a = bT.reduce(function(u, d) {
    return u[d] = QK(d, t.rects, o), u;
  }, {}), s = a[t.placement], l = s.x, c = s.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = a;
}
const tq = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: eq
};
function nq(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = CT({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const rq = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: nq,
  data: {}
};
function iq(e) {
  return e === "x" ? "y" : "x";
}
function oq(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, o = i === void 0 ? !0 : i, a = n.altAxis, s = a === void 0 ? !1 : a, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, f = n.tether, p = f === void 0 ? !0 : f, g = n.tetherOffset, m = g === void 0 ? 0 : g, v = ol(t, {
    boundary: l,
    rootBoundary: c,
    padding: d,
    altBoundary: u
  }), y = Rr(t.placement), S = Na(t.placement), x = !S, b = Oy(y), w = iq(b), E = t.modifiersData.popperOffsets, C = t.rects.reference, A = t.rects.popper, k = typeof m == "function" ? m(Object.assign({}, t.rects, {
    placement: t.placement
  })) : m, R = typeof k == "number" ? {
    mainAxis: k,
    altAxis: k
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, k), M = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, P = {
    x: 0,
    y: 0
  };
  if (E) {
    if (o) {
      var D, j = b === "y" ? kn : Mn, N = b === "y" ? dr : fr, $ = b === "y" ? "height" : "width", F = E[b], q = F + v[j], B = F - v[N], L = p ? -A[$] / 2 : 0, Y = S === ka ? C[$] : A[$], K = S === ka ? -A[$] : -C[$], te = t.elements.arrow, J = p && te ? wy(te) : {
        width: 0,
        height: 0
      }, Q = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : ST(), ne = Q[j], re = Q[N], ie = Ds(0, C[$], J[$]), U = x ? C[$] / 2 - L - ie - ne - R.mainAxis : Y - ie - ne - R.mainAxis, H = x ? -C[$] / 2 + L + ie + re + R.mainAxis : K + ie + re + R.mainAxis, Z = t.elements.arrow && Kl(t.elements.arrow), T = Z ? b === "y" ? Z.clientTop || 0 : Z.clientLeft || 0 : 0, de = (D = M?.[b]) != null ? D : 0, ee = F + U - de - T, he = F + H - de, be = Ds(p ? Ju(q, ee) : q, F, p ? jo(B, he) : B);
      E[b] = be, P[b] = be - F;
    }
    if (s) {
      var Se, Ce = b === "x" ? kn : Mn, nt = b === "x" ? dr : fr, Ke = E[w], Te = w === "y" ? "height" : "width", ue = Ke + v[Ce], jt = Ke - v[nt], at = [kn, Mn].indexOf(y) !== -1, on = (Se = M?.[w]) != null ? Se : 0, Zt = at ? ue : Ke - C[Te] - A[Te] - on + R.altAxis, an = at ? Ke + C[Te] + A[Te] - on - R.altAxis : jt, xn = p && at ? TK(Zt, Ke, an) : Ds(p ? Zt : ue, Ke, p ? an : jt);
      E[w] = xn, P[w] = xn - Ke;
    }
    t.modifiersData[r] = P;
  }
}
const aq = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: oq,
  requiresIfExists: ["offset"]
};
function sq(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function lq(e) {
  return e === Yn(e) || !lr(e) ? Sy(e) : sq(e);
}
function cq(e) {
  var t = e.getBoundingClientRect(), n = Ma(t.width) / e.offsetWidth || 1, r = Ma(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function uq(e, t, n) {
  n === void 0 && (n = !1);
  var r = lr(t), i = lr(t) && cq(t), o = Qi(t), a = ja(e, i, n), s = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((Wr(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  _y(o)) && (s = lq(t)), lr(t) ? (l = ja(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = Ey(o))), {
    x: a.left + s.scrollLeft - l.x,
    y: a.top + s.scrollTop - l.y,
    width: a.width,
    height: a.height
  };
}
function dq(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function i(o) {
    n.add(o.name);
    var a = [].concat(o.requires || [], o.requiresIfExists || []);
    a.forEach(function(s) {
      if (!n.has(s)) {
        var l = t.get(s);
        l && i(l);
      }
    }), r.push(o);
  }
  return e.forEach(function(o) {
    n.has(o.name) || i(o);
  }), r;
}
function fq(e) {
  var t = dq(e);
  return EK.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function pq(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function hq(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var yO = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function bO() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function mq(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, o = i === void 0 ? yO : i;
  return function(s, l, c) {
    c === void 0 && (c = o);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, yO, o),
      modifiersData: {},
      elements: {
        reference: s,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, p = {
      state: u,
      setOptions: function(y) {
        var S = typeof y == "function" ? y(u.options) : y;
        m(), u.options = Object.assign({}, o, u.options, S), u.scrollParents = {
          reference: Bo(s) ? Rs(s) : s.contextElement ? Rs(s.contextElement) : [],
          popper: Rs(l)
        };
        var x = fq(hq([].concat(r, u.options.modifiers)));
        return u.orderedModifiers = x.filter(function(b) {
          return b.enabled;
        }), g(), p.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var y = u.elements, S = y.reference, x = y.popper;
          if (bO(S, x)) {
            u.rects = {
              reference: uq(S, Kl(x), u.options.strategy === "fixed"),
              popper: wy(x)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(R) {
              return u.modifiersData[R.name] = Object.assign({}, R.data);
            });
            for (var b = 0; b < u.orderedModifiers.length; b++) {
              if (u.reset === !0) {
                u.reset = !1, b = -1;
                continue;
              }
              var w = u.orderedModifiers[b], E = w.fn, C = w.options, A = C === void 0 ? {} : C, k = w.name;
              typeof E == "function" && (u = E({
                state: u,
                options: A,
                name: k,
                instance: p
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: pq(function() {
        return new Promise(function(v) {
          p.forceUpdate(), v(u);
        });
      }),
      destroy: function() {
        m(), f = !0;
      }
    };
    if (!bO(s, l))
      return p;
    p.setOptions(c).then(function(v) {
      !f && c.onFirstUpdate && c.onFirstUpdate(v);
    });
    function g() {
      u.orderedModifiers.forEach(function(v) {
        var y = v.name, S = v.options, x = S === void 0 ? {} : S, b = v.effect;
        if (typeof b == "function") {
          var w = b({
            state: u,
            name: y,
            instance: p,
            options: x
          }), E = function() {
          };
          d.push(w || E);
        }
      });
    }
    function m() {
      d.forEach(function(v) {
        return v();
      }), d = [];
    }
    return p;
  };
}
var gq = [FK, rq, $K, xT, tq, XK, aq, NK, JK], AT = /* @__PURE__ */ mq({
  defaultModifiers: gq
});
function TT(e) {
  const {
    elementType: t,
    externalSlotProps: n,
    ownerState: r,
    skipResolvingSlotProps: i = !1,
    ...o
  } = e, a = i ? {} : fT(n, r), {
    props: s,
    internalRef: l
  } = hT({
    ...o,
    externalSlotProps: a
  }), c = Kt(l, a?.ref, e.additionalProps?.ref);
  return dT(t, {
    ...s,
    ref: c
  }, r);
}
function Ga(e) {
  return parseInt(_.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null;
}
function vq(e) {
  return typeof e == "function" ? e() : e;
}
const al = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    children: r,
    container: i,
    disablePortal: o = !1
  } = t, [a, s] = _.useState(null), l = Kt(/* @__PURE__ */ _.isValidElement(r) ? Ga(r) : null, n);
  if (Lr(() => {
    o || s(vq(i) || document.body);
  }, [i, o]), Lr(() => {
    if (a && !o)
      return n0(n, a), () => {
        n0(n, null);
      };
  }, [n, a, o]), o) {
    if (/* @__PURE__ */ _.isValidElement(r)) {
      const c = {
        ref: l
      };
      return /* @__PURE__ */ _.cloneElement(r, c);
    }
    return r;
  }
  return a && /* @__PURE__ */ cM.createPortal(r, a);
});
process.env.NODE_ENV !== "production" && (al.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * The children to render into the `container`.
   */
  children: h.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: h.oneOfType([yi, h.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: h.bool
});
process.env.NODE_ENV !== "production" && (al.propTypes = YE(al.propTypes));
function yq(e) {
  return Mt("MuiPopper", e);
}
xt("MuiPopper", ["root"]);
function bq(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function Qu(e) {
  return typeof e == "function" ? e() : e;
}
function hf(e) {
  return e.nodeType !== void 0;
}
function xq(e) {
  return !hf(e);
}
const wq = (e) => {
  const {
    classes: t
  } = e;
  return $t({
    root: ["root"]
  }, yq, t);
}, Oq = {}, Sq = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: i,
    direction: o,
    disablePortal: a,
    modifiers: s,
    open: l,
    placement: c,
    popperOptions: u,
    popperRef: d,
    slotProps: f = {},
    slots: p = {},
    TransitionProps: g,
    // @ts-ignore internal logic
    ownerState: m,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...v
  } = t, y = _.useRef(null), S = Kt(y, n), x = _.useRef(null), b = Kt(x, d), w = _.useRef(b);
  Lr(() => {
    w.current = b;
  }, [b]), _.useImperativeHandle(d, () => x.current, []);
  const E = bq(c, o), [C, A] = _.useState(E), [k, R] = _.useState(Qu(r));
  _.useEffect(() => {
    x.current && x.current.forceUpdate();
  }), _.useEffect(() => {
    r && R(Qu(r));
  }, [r]), Lr(() => {
    if (!k || !l)
      return;
    const N = (q) => {
      A(q.placement);
    };
    if (process.env.NODE_ENV !== "production" && k && hf(k) && k.nodeType === 1) {
      const q = k.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && q.top === 0 && q.left === 0 && q.right === 0 && q.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    let $ = [{
      name: "preventOverflow",
      options: {
        altBoundary: a
      }
    }, {
      name: "flip",
      options: {
        altBoundary: a
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: q
      }) => {
        N(q);
      }
    }];
    s != null && ($ = $.concat(s)), u && u.modifiers != null && ($ = $.concat(u.modifiers));
    const F = AT(k, y.current, {
      placement: E,
      ...u,
      modifiers: $
    });
    return w.current(F), () => {
      F.destroy(), w.current(null);
    };
  }, [k, a, s, l, u, E]);
  const M = {
    placement: C
  };
  g !== null && (M.TransitionProps = g);
  const P = wq(t), D = p.root ?? "div", j = TT({
    elementType: D,
    externalSlotProps: f.root,
    externalForwardedProps: v,
    additionalProps: {
      role: "tooltip",
      ref: S
    },
    ownerState: t,
    className: P.root
  });
  return /* @__PURE__ */ O.jsx(D, {
    ...j,
    children: typeof i == "function" ? i(M) : i
  });
}), kT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: i,
    container: o,
    direction: a = "ltr",
    disablePortal: s = !1,
    keepMounted: l = !1,
    modifiers: c,
    open: u,
    placement: d = "bottom",
    popperOptions: f = Oq,
    popperRef: p,
    style: g,
    transition: m = !1,
    slotProps: v = {},
    slots: y = {},
    ...S
  } = t, [x, b] = _.useState(!0), w = () => {
    b(!1);
  }, E = () => {
    b(!0);
  };
  if (!l && !u && (!m || x))
    return null;
  let C;
  if (o)
    C = o;
  else if (r) {
    const R = Qu(r);
    C = R && hf(R) ? Un(R).body : Un(null).body;
  }
  const A = !u && l && (!m || x) ? "none" : void 0, k = m ? {
    in: u,
    onEnter: w,
    onExited: E
  } : void 0;
  return /* @__PURE__ */ O.jsx(al, {
    disablePortal: s,
    container: C,
    children: /* @__PURE__ */ O.jsx(Sq, {
      anchorEl: r,
      direction: a,
      disablePortal: s,
      modifiers: c,
      ref: n,
      open: m ? !x : u,
      placement: d,
      popperOptions: f,
      popperRef: p,
      slotProps: v,
      slots: y,
      ...S,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: A,
        ...g
      },
      TransitionProps: k,
      children: i
    })
  });
});
process.env.NODE_ENV !== "production" && (kT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: Ya(h.oneOfType([yi, h.object, h.func]), (e) => {
    if (e.open) {
      const t = Qu(e.anchorEl);
      if (t && hf(t) && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else if (!t || typeof t.getBoundingClientRect != "function" || xq(t) && t.contextElement != null && t.contextElement.nodeType !== 1)
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: h.oneOfType([h.node, h.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: h.oneOfType([yi, h.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: h.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: h.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: h.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: h.arrayOf(h.shape({
    data: h.object,
    effect: h.func,
    enabled: h.bool,
    fn: h.func,
    name: h.any,
    options: h.object,
    phase: h.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: h.arrayOf(h.string),
    requiresIfExists: h.arrayOf(h.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: h.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: h.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: h.shape({
    modifiers: h.array,
    onFirstUpdate: h.func,
    placement: h.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: h.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: Yr,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: h.shape({
    root: h.oneOfType([h.func, h.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: h.shape({
    root: h.elementType
  }),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: h.bool
});
const Eq = xe(kT, {
  name: "MuiPopper",
  slot: "Root"
})({}), Py = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = mg(), i = qt({
    props: t,
    name: "MuiPopper"
  }), {
    anchorEl: o,
    component: a,
    components: s,
    componentsProps: l,
    container: c,
    disablePortal: u,
    keepMounted: d,
    modifiers: f,
    open: p,
    placement: g,
    popperOptions: m,
    popperRef: v,
    transition: y,
    slots: S,
    slotProps: x,
    ...b
  } = i, w = S?.root ?? s?.Root, E = {
    anchorEl: o,
    container: c,
    disablePortal: u,
    keepMounted: d,
    modifiers: f,
    open: p,
    placement: g,
    popperOptions: m,
    popperRef: v,
    transition: y,
    ...b
  };
  return /* @__PURE__ */ O.jsx(Eq, {
    as: a,
    direction: r ? "rtl" : "ltr",
    slots: {
      root: w
    },
    slotProps: x ?? l,
    ...E,
    ref: n
  });
});
process.env.NODE_ENV !== "production" && (Py.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: h.oneOfType([yi, h.object, h.func]),
  /**
   * Popper render function or node.
   */
  children: h.oneOfType([h.node, h.func]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: h.shape({
    Root: h.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: h.shape({
    root: h.oneOfType([h.func, h.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: h.oneOfType([yi, h.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: h.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: h.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: h.arrayOf(h.shape({
    data: h.object,
    effect: h.func,
    enabled: h.bool,
    fn: h.func,
    name: h.any,
    options: h.object,
    phase: h.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: h.arrayOf(h.string),
    requiresIfExists: h.arrayOf(h.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: h.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: h.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: h.shape({
    modifiers: h.array,
    onFirstUpdate: h.func,
    placement: h.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: h.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: Yr,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: h.shape({
    root: h.oneOfType([h.func, h.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: h.shape({
    root: h.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: h.bool
});
function Pc(e) {
  return parseInt(e, 10) || 0;
}
const _q = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function Pq(e) {
  for (const t in e)
    return !1;
  return !0;
}
function xO(e) {
  return Pq(e) || e.outerHeightStyle === 0 && !e.overflowing;
}
const MT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    onChange: r,
    maxRows: i,
    minRows: o = 1,
    style: a,
    value: s,
    ...l
  } = t, {
    current: c
  } = _.useRef(s != null), u = _.useRef(null), d = Kt(n, u), f = _.useRef(null), p = _.useRef(null), g = _.useCallback(() => {
    const x = u.current, b = p.current;
    if (!x || !b)
      return;
    const E = pi(x).getComputedStyle(x);
    if (E.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    b.style.width = E.width, b.value = x.value || t.placeholder || "x", b.value.slice(-1) === `
` && (b.value += " ");
    const C = E.boxSizing, A = Pc(E.paddingBottom) + Pc(E.paddingTop), k = Pc(E.borderBottomWidth) + Pc(E.borderTopWidth), R = b.scrollHeight;
    b.value = "x";
    const M = b.scrollHeight;
    let P = R;
    o && (P = Math.max(Number(o) * M, P)), i && (P = Math.min(Number(i) * M, P)), P = Math.max(P, M);
    const D = P + (C === "border-box" ? A + k : 0), j = Math.abs(P - R) <= 1;
    return {
      outerHeightStyle: D,
      overflowing: j
    };
  }, [i, o, t.placeholder]), m = ci(() => {
    const x = u.current, b = g();
    if (!x || !b || xO(b))
      return !1;
    const w = b.outerHeightStyle;
    return f.current != null && f.current !== w;
  }), v = _.useCallback(() => {
    const x = u.current, b = g();
    if (!x || !b || xO(b))
      return;
    const w = b.outerHeightStyle;
    f.current !== w && (f.current = w, x.style.height = `${w}px`), x.style.overflow = b.overflowing ? "hidden" : "";
  }, [g]), y = _.useRef(-1);
  Lr(() => {
    const x = i_(v), b = u?.current;
    if (!b)
      return;
    const w = pi(b);
    w.addEventListener("resize", x);
    let E;
    return typeof ResizeObserver < "u" && (E = new ResizeObserver(() => {
      m() && (E.unobserve(b), cancelAnimationFrame(y.current), v(), y.current = requestAnimationFrame(() => {
        E.observe(b);
      }));
    }), E.observe(b)), () => {
      x.clear(), cancelAnimationFrame(y.current), w.removeEventListener("resize", x), E && E.disconnect();
    };
  }, [g, v, m]), Lr(() => {
    v();
  });
  const S = (x) => {
    c || v();
    const b = x.target, w = b.value.length, E = b.value.endsWith(`
`), C = b.selectionStart === w;
    E && C && b.setSelectionRange(w, w), r && r(x);
  };
  return /* @__PURE__ */ O.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ O.jsx("textarea", {
      value: s,
      onChange: S,
      ref: d,
      rows: o,
      style: a,
      ...l
    }), /* @__PURE__ */ O.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: p,
      tabIndex: -1,
      style: {
        ..._q.shadow,
        ...a,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
process.env.NODE_ENV !== "production" && (MT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  className: h.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: h.oneOfType([h.number, h.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: h.oneOfType([h.number, h.string]),
  /**
   * @ignore
   */
  onChange: h.func,
  /**
   * @ignore
   */
  placeholder: h.string,
  /**
   * @ignore
   */
  style: h.object,
  /**
   * @ignore
   */
  value: h.oneOfType([h.arrayOf(h.string), h.number, h.string])
});
function Cy({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, i) => (r[i] = e[i], n && typeof e[i] > "u" && (r[i] = n[i]), r), {});
}
const mf = /* @__PURE__ */ _.createContext(void 0);
process.env.NODE_ENV !== "production" && (mf.displayName = "FormControlContext");
function Ay() {
  return _.useContext(mf);
}
function wO(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function ed(e, t = !1) {
  return e && (wO(e.value) && e.value !== "" || t && wO(e.defaultValue) && e.defaultValue !== "");
}
function Cq(e) {
  return e.startAdornment;
}
function Aq(e) {
  return Mt("MuiInputBase", e);
}
const Da = xt("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var OO;
const gf = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${It(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, vf = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, Tq = (e) => {
  const {
    classes: t,
    color: n,
    disabled: r,
    error: i,
    endAdornment: o,
    focused: a,
    formControl: s,
    fullWidth: l,
    hiddenLabel: c,
    multiline: u,
    readOnly: d,
    size: f,
    startAdornment: p,
    type: g
  } = e, m = {
    root: ["root", `color${It(n)}`, r && "disabled", i && "error", l && "fullWidth", a && "focused", s && "formControl", f && f !== "medium" && `size${It(f)}`, u && "multiline", p && "adornedStart", o && "adornedEnd", c && "hiddenLabel", d && "readOnly"],
    input: ["input", r && "disabled", g === "search" && "inputTypeSearch", u && "inputMultiline", f === "small" && "inputSizeSmall", c && "inputHiddenLabel", p && "inputAdornedStart", o && "inputAdornedEnd", d && "readOnly"]
  };
  return $t(m, Aq, t);
}, yf = xe("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: gf
})(hn(({
  theme: e
}) => ({
  ...e.typography.body1,
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Da.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: n
    }) => t.multiline && n === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), bf = xe("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: vf
})(hn(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = {
    color: "currentColor",
    ...e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }, r = {
    opacity: "0 !important"
  }, i = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": n,
    "&::-moz-placeholder": n,
    // Firefox 19+
    "&::-ms-input-placeholder": n,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Da.formControl} &`]: {
      "&::-webkit-input-placeholder": r,
      "&::-moz-placeholder": r,
      // Firefox 19+
      "&::-ms-input-placeholder": r,
      // Edge
      "&:focus::-webkit-input-placeholder": i,
      "&:focus::-moz-placeholder": i,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": i
      // Edge
    },
    [`&.${Da.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: o
      }) => !o.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: o
      }) => o.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), SO = ND({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), xf = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": i,
    autoComplete: o,
    autoFocus: a,
    className: s,
    color: l,
    components: c = {},
    componentsProps: u = {},
    defaultValue: d,
    disabled: f,
    disableInjectingGlobalStyles: p,
    endAdornment: g,
    error: m,
    fullWidth: v = !1,
    id: y,
    inputComponent: S = "input",
    inputProps: x = {},
    inputRef: b,
    margin: w,
    maxRows: E,
    minRows: C,
    multiline: A = !1,
    name: k,
    onBlur: R,
    onChange: M,
    onClick: P,
    onFocus: D,
    onKeyDown: j,
    onKeyUp: N,
    placeholder: $,
    readOnly: F,
    renderSuffix: q,
    rows: B,
    size: L,
    slotProps: Y = {},
    slots: K = {},
    startAdornment: te,
    type: J = "text",
    value: Q,
    ...ne
  } = r, re = x.value != null ? x.value : Q, {
    current: ie
  } = _.useRef(re != null), U = _.useRef(), H = _.useCallback((ge) => {
    process.env.NODE_ENV !== "production" && ge && ge.nodeName !== "INPUT" && !ge.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), Z = Kt(U, b, x.ref, H), [T, de] = _.useState(!1), ee = Ay();
  process.env.NODE_ENV !== "production" && _.useEffect(() => {
    if (ee)
      return ee.registerEffect();
  }, [ee]);
  const he = Cy({
    props: r,
    muiFormControl: ee,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  he.focused = ee ? ee.focused : T, _.useEffect(() => {
    !ee && f && T && (de(!1), R && R());
  }, [ee, f, T, R]);
  const be = ee && ee.onFilled, Se = ee && ee.onEmpty, Ce = _.useCallback((ge) => {
    ed(ge) ? be && be() : Se && Se();
  }, [be, Se]);
  Lr(() => {
    ie && Ce({
      value: re
    });
  }, [re, Ce, ie]);
  const nt = (ge) => {
    D && D(ge), x.onFocus && x.onFocus(ge), ee && ee.onFocus ? ee.onFocus(ge) : de(!0);
  }, Ke = (ge) => {
    R && R(ge), x.onBlur && x.onBlur(ge), ee && ee.onBlur ? ee.onBlur(ge) : de(!1);
  }, Te = (ge, ...sn) => {
    if (!ie) {
      const Wt = ge.target || U.current;
      if (Wt == null)
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : $r(1));
      Ce({
        value: Wt.value
      });
    }
    x.onChange && x.onChange(ge, ...sn), M && M(ge, ...sn);
  };
  _.useEffect(() => {
    Ce(U.current);
  }, []);
  const ue = (ge) => {
    U.current && ge.currentTarget === ge.target && U.current.focus(), P && P(ge);
  };
  let jt = S, at = x;
  A && jt === "input" && (B ? (process.env.NODE_ENV !== "production" && (C || E) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), at = {
    type: void 0,
    minRows: B,
    maxRows: B,
    ...at
  }) : at = {
    type: void 0,
    maxRows: E,
    minRows: C,
    ...at
  }, jt = MT);
  const on = (ge) => {
    Ce(ge.animationName === "mui-auto-fill-cancel" ? U.current : {
      value: "x"
    });
  };
  _.useEffect(() => {
    ee && ee.setAdornedStart(!!te);
  }, [ee, te]);
  const Zt = {
    ...r,
    color: he.color || "primary",
    disabled: he.disabled,
    endAdornment: g,
    error: he.error,
    focused: he.focused,
    formControl: ee,
    fullWidth: v,
    hiddenLabel: he.hiddenLabel,
    multiline: A,
    size: he.size,
    startAdornment: te,
    type: J
  }, an = Tq(Zt), xn = K.root || c.Root || yf, zt = Y.root || u.root || {}, wn = K.input || c.Input || bf;
  return at = {
    ...at,
    ...Y.input ?? u.input
  }, /* @__PURE__ */ O.jsxs(_.Fragment, {
    children: [!p && typeof SO == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (OO || (OO = /* @__PURE__ */ O.jsx(SO, {}))), /* @__PURE__ */ O.jsxs(xn, {
      ...zt,
      ref: n,
      onClick: ue,
      ...ne,
      ...!Gu(xn) && {
        ownerState: {
          ...Zt,
          ...zt.ownerState
        }
      },
      className: ce(an.root, zt.className, s, F && "MuiInputBase-readOnly"),
      children: [te, /* @__PURE__ */ O.jsx(mf.Provider, {
        value: null,
        children: /* @__PURE__ */ O.jsx(wn, {
          "aria-invalid": he.error,
          "aria-describedby": i,
          autoComplete: o,
          autoFocus: a,
          defaultValue: d,
          disabled: he.disabled,
          id: y,
          onAnimationStart: on,
          name: k,
          placeholder: $,
          readOnly: F,
          required: he.required,
          rows: B,
          value: re,
          onKeyDown: j,
          onKeyUp: N,
          type: J,
          ...at,
          ...!Gu(wn) && {
            as: jt,
            ownerState: {
              ...Zt,
              ...at.ownerState
            }
          },
          ref: Z,
          className: ce(an.input, at.className, F && "MuiInputBase-readOnly"),
          onBlur: Ke,
          onChange: Te,
          onFocus: nt
        })
      }), g, q ? q({
        ...he,
        startAdornment: te
      }) : null]
    })]
  });
});
process.env.NODE_ENV !== "production" && (xf.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * @ignore
   */
  "aria-describedby": h.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: h.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: h.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: h.oneOfType([h.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), h.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: h.shape({
    Input: h.elementType,
    Root: h.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: h.shape({
    input: h.object,
    root: h.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: h.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: h.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: h.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: h.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: h.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: h.bool,
  /**
   * The id of the `input` element.
   */
  id: h.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: vy,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: h.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Yr,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: h.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: h.oneOfType([h.number, h.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: h.oneOfType([h.number, h.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: h.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: h.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: h.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: h.func,
  /**
   * @ignore
   */
  onClick: h.func,
  /**
   * @ignore
   */
  onFocus: h.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: h.func,
  /**
   * @ignore
   */
  onKeyDown: h.func,
  /**
   * @ignore
   */
  onKeyUp: h.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: h.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: h.bool,
  /**
   * @ignore
   */
  renderSuffix: h.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: h.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: h.oneOfType([h.number, h.string]),
  /**
   * The size of the component.
   */
  size: h.oneOfType([h.oneOf(["medium", "small"]), h.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: h.shape({
    input: h.object,
    root: h.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: h.shape({
    input: h.elementType,
    root: h.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: h.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: h.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: h.any
});
function kq(e) {
  return Mt("MuiInput", e);
}
const ds = {
  ...Da,
  ...xt("MuiInput", ["root", "underline", "input"])
};
function Mq(e) {
  return Mt("MuiOutlinedInput", e);
}
const _r = {
  ...Da,
  ...xt("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function jq(e) {
  return Mt("MuiFilledInput", e);
}
const so = {
  ...Da,
  ...xt("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, Nq = wl(/* @__PURE__ */ O.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
function Dq(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function jT(e, t, n, r, i) {
  const o = e[t], a = i || t;
  if (o == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  const l = o.type;
  return typeof l == "function" && !Dq(l) && (s = "Did you accidentally use a plain function component for an element instead?"), s !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const Xa = Ya(h.element, jT);
Xa.isRequired = Ya(h.element.isRequired, jT);
const Rq = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, NT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = Td(), i = {
    enter: r.transitions.duration.enteringScreen,
    exit: r.transitions.duration.leavingScreen
  }, {
    addEndListener: o,
    appear: a = !0,
    children: s,
    easing: l,
    in: c,
    onEnter: u,
    onEntered: d,
    onEntering: f,
    onExit: p,
    onExited: g,
    onExiting: m,
    style: v,
    timeout: y = i,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: S = qr,
    ...x
  } = t, b = _.useRef(null), w = Kt(b, Ga(s), n), E = (j) => (N) => {
    if (j) {
      const $ = b.current;
      N === void 0 ? j($) : j($, N);
    }
  }, C = E(f), A = E((j, N) => {
    aT(j);
    const $ = Yu({
      style: v,
      timeout: y,
      easing: l
    }, {
      mode: "enter"
    });
    j.style.webkitTransition = r.transitions.create("opacity", $), j.style.transition = r.transitions.create("opacity", $), u && u(j, N);
  }), k = E(d), R = E(m), M = E((j) => {
    const N = Yu({
      style: v,
      timeout: y,
      easing: l
    }, {
      mode: "exit"
    });
    j.style.webkitTransition = r.transitions.create("opacity", N), j.style.transition = r.transitions.create("opacity", N), p && p(j);
  }), P = E(g), D = (j) => {
    o && o(b.current, j);
  };
  return /* @__PURE__ */ O.jsx(S, {
    appear: a,
    in: c,
    nodeRef: b,
    onEnter: A,
    onEntered: k,
    onEntering: C,
    onExit: M,
    onExited: P,
    onExiting: R,
    addEndListener: D,
    timeout: y,
    ...x,
    children: (j, {
      ownerState: N,
      ...$
    }) => /* @__PURE__ */ _.cloneElement(s, {
      style: {
        opacity: 0,
        visibility: j === "exited" && !c ? "hidden" : void 0,
        ...Rq[j],
        ...v,
        ...s.props.style
      },
      ref: w,
      ...$
    })
  });
});
process.env.NODE_ENV !== "production" && (NT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: h.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: h.bool,
  /**
   * A single child content element.
   */
  children: Xa.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: h.oneOfType([h.shape({
    enter: h.string,
    exit: h.string
  }), h.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: h.bool,
  /**
   * @ignore
   */
  onEnter: h.func,
  /**
   * @ignore
   */
  onEntered: h.func,
  /**
   * @ignore
   */
  onEntering: h.func,
  /**
   * @ignore
   */
  onExit: h.func,
  /**
   * @ignore
   */
  onExited: h.func,
  /**
   * @ignore
   */
  onExiting: h.func,
  /**
   * @ignore
   */
  style: h.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: h.oneOfType([h.number, h.shape({
    appear: h.number,
    enter: h.number,
    exit: h.number
  })])
});
function Iq(e) {
  return Mt("MuiBackdrop", e);
}
xt("MuiBackdrop", ["root", "invisible"]);
const $q = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return $t({
    root: ["root", n && "invisible"]
  }, Iq, t);
}, Lq = xe("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), DT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: i,
    className: o,
    component: a = "div",
    invisible: s = !1,
    open: l,
    components: c = {},
    componentsProps: u = {},
    slotProps: d = {},
    slots: f = {},
    TransitionComponent: p,
    transitionDuration: g,
    ...m
  } = r, v = {
    ...r,
    component: a,
    invisible: s
  }, y = $q(v), S = {
    transition: p,
    root: c.Root,
    ...f
  }, x = {
    ...u,
    ...d
  }, b = {
    component: a,
    slots: S,
    slotProps: x
  }, [w, E] = An("root", {
    elementType: Lq,
    externalForwardedProps: b,
    className: ce(y.root, o),
    ownerState: v
  }), [C, A] = An("transition", {
    elementType: NT,
    externalForwardedProps: b,
    ownerState: v
  });
  return /* @__PURE__ */ O.jsx(C, {
    in: l,
    timeout: g,
    ...m,
    ...A,
    children: /* @__PURE__ */ O.jsx(w, {
      "aria-hidden": !0,
      ...E,
      classes: y,
      ref: n,
      children: i
    })
  });
});
process.env.NODE_ENV !== "production" && (DT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: h.shape({
    Root: h.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: h.shape({
    root: h.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: h.bool,
  /**
   * If `true`, the component is shown.
   */
  open: h.bool.isRequired,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: h.shape({
    root: h.oneOfType([h.func, h.object]),
    transition: h.oneOfType([h.func, h.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: h.shape({
    root: h.elementType,
    transition: h.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   * @deprecated Use `slots.transition` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  TransitionComponent: h.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: h.oneOfType([h.number, h.shape({
    appear: h.number,
    enter: h.number,
    exit: h.number
  })])
});
function RT(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function Fq(e) {
  const t = Un(e);
  return t.body === e ? pi(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function Is(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function EO(e) {
  return parseInt(pi(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function Bq(e) {
  const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return n || r;
}
function _O(e, t, n, r, i) {
  const o = [t, n, ...r];
  [].forEach.call(e.children, (a) => {
    const s = !o.includes(a), l = !Bq(a);
    s && l && Is(a, i);
  });
}
function mh(e, t) {
  let n = -1;
  return e.some((r, i) => t(r) ? (n = i, !0) : !1), n;
}
function zq(e, t) {
  const n = [], r = e.container;
  if (!t.disableScrollLock) {
    if (Fq(r)) {
      const a = RT(pi(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${EO(r) + a}px`;
      const s = Un(r).querySelectorAll(".mui-fixed");
      [].forEach.call(s, (l) => {
        n.push({
          value: l.style.paddingRight,
          property: "padding-right",
          el: l
        }), l.style.paddingRight = `${EO(l) + a}px`;
      });
    }
    let o;
    if (r.parentNode instanceof DocumentFragment)
      o = Un(r).body;
    else {
      const a = r.parentElement, s = pi(r);
      o = a?.nodeName === "HTML" && s.getComputedStyle(a).overflowY === "scroll" ? a : r;
    }
    n.push({
      value: o.style.overflow,
      property: "overflow",
      el: o
    }, {
      value: o.style.overflowX,
      property: "overflow-x",
      el: o
    }, {
      value: o.style.overflowY,
      property: "overflow-y",
      el: o
    }), o.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: o,
      el: a,
      property: s
    }) => {
      o ? a.style.setProperty(s, o) : a.style.removeProperty(s);
    });
  };
}
function Wq(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class Vq {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1)
      return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && Is(t.modalRef, !1);
    const i = Wq(n);
    _O(n, t.mount, t.modalRef, i, !0);
    const o = mh(this.containers, (a) => a.container === n);
    return o !== -1 ? (this.containers[o].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: i
    }), r);
  }
  mount(t, n) {
    const r = mh(this.containers, (o) => o.modals.includes(t)), i = this.containers[r];
    i.restore || (i.restore = zq(i, n));
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1)
      return r;
    const i = mh(this.containers, (a) => a.modals.includes(t)), o = this.containers[i];
    if (o.modals.splice(o.modals.indexOf(t), 1), this.modals.splice(r, 1), o.modals.length === 0)
      o.restore && o.restore(), t.modalRef && Is(t.modalRef, n), _O(o.container, t.mount, t.modalRef, o.hiddenSiblings, !1), this.containers.splice(i, 1);
    else {
      const a = o.modals[o.modals.length - 1];
      a.modalRef && Is(a.modalRef, !1);
    }
    return r;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const Uq = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function Hq(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function Kq(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function qq(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || Kq(e));
}
function Yq(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(Uq)).forEach((r, i) => {
    const o = Hq(r);
    o === -1 || !qq(r) || (o === 0 ? t.push(r) : n.push({
      documentOrder: i,
      tabIndex: o,
      node: r
    }));
  }), n.sort((r, i) => r.tabIndex === i.tabIndex ? r.documentOrder - i.documentOrder : r.tabIndex - i.tabIndex).map((r) => r.node).concat(t);
}
function Gq() {
  return !0;
}
function td(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: i = !1,
    getTabbable: o = Yq,
    isEnabled: a = Gq,
    open: s
  } = e, l = _.useRef(!1), c = _.useRef(null), u = _.useRef(null), d = _.useRef(null), f = _.useRef(null), p = _.useRef(!1), g = _.useRef(null), m = Kt(Ga(t), g), v = _.useRef(null);
  _.useEffect(() => {
    !s || !g.current || (p.current = !n);
  }, [n, s]), _.useEffect(() => {
    if (!s || !g.current)
      return;
    const x = Un(g.current);
    return g.current.contains(x.activeElement) || (g.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), g.current.setAttribute("tabIndex", "-1")), p.current && g.current.focus()), () => {
      i || (d.current && d.current.focus && (l.current = !0, d.current.focus()), d.current = null);
    };
  }, [s]), _.useEffect(() => {
    if (!s || !g.current)
      return;
    const x = Un(g.current), b = (C) => {
      v.current = C, !(r || !a() || C.key !== "Tab") && x.activeElement === g.current && C.shiftKey && (l.current = !0, u.current && u.current.focus());
    }, w = () => {
      const C = g.current;
      if (C === null)
        return;
      if (!x.hasFocus() || !a() || l.current) {
        l.current = !1;
        return;
      }
      if (C.contains(x.activeElement) || r && x.activeElement !== c.current && x.activeElement !== u.current)
        return;
      if (x.activeElement !== f.current)
        f.current = null;
      else if (f.current !== null)
        return;
      if (!p.current)
        return;
      let A = [];
      if ((x.activeElement === c.current || x.activeElement === u.current) && (A = o(g.current)), A.length > 0) {
        const k = !!(v.current?.shiftKey && v.current?.key === "Tab"), R = A[0], M = A[A.length - 1];
        typeof R != "string" && typeof M != "string" && (k ? M.focus() : R.focus());
      } else
        C.focus();
    };
    x.addEventListener("focusin", w), x.addEventListener("keydown", b, !0);
    const E = setInterval(() => {
      x.activeElement && x.activeElement.tagName === "BODY" && w();
    }, 50);
    return () => {
      clearInterval(E), x.removeEventListener("focusin", w), x.removeEventListener("keydown", b, !0);
    };
  }, [n, r, i, a, s, o]);
  const y = (x) => {
    d.current === null && (d.current = x.relatedTarget), p.current = !0, f.current = x.target;
    const b = t.props.onFocus;
    b && b(x);
  }, S = (x) => {
    d.current === null && (d.current = x.relatedTarget), p.current = !0;
  };
  return /* @__PURE__ */ O.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ O.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: S,
      ref: c,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ _.cloneElement(t, {
      ref: m,
      onFocus: y
    }), /* @__PURE__ */ O.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: S,
      ref: u,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && (td.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * A single child content element.
   */
  children: Xa,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: h.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: h.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: h.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: h.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: h.func,
  /**
   * If `true`, focus is locked.
   */
  open: h.bool.isRequired
});
process.env.NODE_ENV !== "production" && (td.propTypes = YE(td.propTypes));
function Xq(e) {
  return typeof e == "function" ? e() : e;
}
function Zq(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const PO = () => {
}, Cc = new Vq();
function Jq(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: r = !1,
    closeAfterTransition: i = !1,
    onTransitionEnter: o,
    onTransitionExited: a,
    children: s,
    onClose: l,
    open: c,
    rootRef: u
  } = e, d = _.useRef({}), f = _.useRef(null), p = _.useRef(null), g = Kt(p, u), [m, v] = _.useState(!c), y = Zq(s);
  let S = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (S = !1);
  const x = () => Un(f.current), b = () => (d.current.modalRef = p.current, d.current.mount = f.current, d.current), w = () => {
    Cc.mount(b(), {
      disableScrollLock: r
    }), p.current && (p.current.scrollTop = 0);
  }, E = ci(() => {
    const N = Xq(t) || x().body;
    Cc.add(b(), N), p.current && w();
  }), C = () => Cc.isTopModal(b()), A = ci((N) => {
    f.current = N, N && (c && C() ? w() : p.current && Is(p.current, S));
  }), k = _.useCallback(() => {
    Cc.remove(b(), S);
  }, [S]);
  _.useEffect(() => () => {
    k();
  }, [k]), _.useEffect(() => {
    c ? E() : (!y || !i) && k();
  }, [c, k, y, i, E]);
  const R = (N) => ($) => {
    N.onKeyDown?.($), !($.key !== "Escape" || $.which === 229 || // Wait until IME is settled.
    !C()) && (n || ($.stopPropagation(), l && l($, "escapeKeyDown")));
  }, M = (N) => ($) => {
    N.onClick?.($), $.target === $.currentTarget && l && l($, "backdropClick");
  };
  return {
    getRootProps: (N = {}) => {
      const $ = pT(e);
      delete $.onTransitionEnter, delete $.onTransitionExited;
      const F = {
        ...$,
        ...N
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...F,
        onKeyDown: R(F),
        ref: g
      };
    },
    getBackdropProps: (N = {}) => {
      const $ = N;
      return {
        "aria-hidden": !0,
        ...$,
        onClick: M($),
        open: c
      };
    },
    getTransitionProps: () => {
      const N = () => {
        v(!1), o && o();
      }, $ = () => {
        v(!0), a && a(), i && k();
      };
      return {
        onEnter: ub(N, s?.props.onEnter ?? PO),
        onExited: ub($, s?.props.onExited ?? PO)
      };
    },
    rootRef: g,
    portalRef: A,
    isTopModal: C,
    exited: m,
    hasTransition: y
  };
}
function Qq(e) {
  return Mt("MuiModal", e);
}
xt("MuiModal", ["root", "hidden", "backdrop"]);
const eY = (e) => {
  const {
    open: t,
    exited: n,
    classes: r
  } = e;
  return $t({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, Qq, r);
}, tY = xe("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(hn(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), nY = xe(DT, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
}), IT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: i = nY,
    BackdropProps: o,
    classes: a,
    className: s,
    closeAfterTransition: l = !1,
    children: c,
    container: u,
    component: d,
    components: f = {},
    componentsProps: p = {},
    disableAutoFocus: g = !1,
    disableEnforceFocus: m = !1,
    disableEscapeKeyDown: v = !1,
    disablePortal: y = !1,
    disableRestoreFocus: S = !1,
    disableScrollLock: x = !1,
    hideBackdrop: b = !1,
    keepMounted: w = !1,
    onClose: E,
    onTransitionEnter: C,
    onTransitionExited: A,
    open: k,
    slotProps: R = {},
    slots: M = {},
    // eslint-disable-next-line react/prop-types
    theme: P,
    ...D
  } = r, j = {
    ...r,
    closeAfterTransition: l,
    disableAutoFocus: g,
    disableEnforceFocus: m,
    disableEscapeKeyDown: v,
    disablePortal: y,
    disableRestoreFocus: S,
    disableScrollLock: x,
    hideBackdrop: b,
    keepMounted: w
  }, {
    getRootProps: N,
    getBackdropProps: $,
    getTransitionProps: F,
    portalRef: q,
    isTopModal: B,
    exited: L,
    hasTransition: Y
  } = Jq({
    ...j,
    rootRef: n
  }), K = {
    ...j,
    exited: L
  }, te = eY(K), J = {};
  if (c.props.tabIndex === void 0 && (J.tabIndex = "-1"), Y) {
    const {
      onEnter: H,
      onExited: Z
    } = F();
    J.onEnter = H, J.onExited = Z;
  }
  const Q = {
    slots: {
      root: f.Root,
      backdrop: f.Backdrop,
      ...M
    },
    slotProps: {
      ...p,
      ...R
    }
  }, [ne, re] = An("root", {
    ref: n,
    elementType: tY,
    externalForwardedProps: {
      ...Q,
      ...D,
      component: d
    },
    getSlotProps: N,
    ownerState: K,
    className: ce(s, te?.root, !K.open && K.exited && te?.hidden)
  }), [ie, U] = An("backdrop", {
    ref: o?.ref,
    elementType: i,
    externalForwardedProps: Q,
    shouldForwardComponentProp: !0,
    additionalProps: o,
    getSlotProps: (H) => $({
      ...H,
      onClick: (Z) => {
        H?.onClick && H.onClick(Z);
      }
    }),
    className: ce(o?.className, te?.backdrop),
    ownerState: K
  });
  return !w && !k && (!Y || L) ? null : /* @__PURE__ */ O.jsx(al, {
    ref: q,
    container: u,
    disablePortal: y,
    children: /* @__PURE__ */ O.jsxs(ne, {
      ...re,
      children: [!b && i ? /* @__PURE__ */ O.jsx(ie, {
        ...U
      }) : null, /* @__PURE__ */ O.jsx(td, {
        disableEnforceFocus: m,
        disableAutoFocus: g,
        disableRestoreFocus: S,
        isEnabled: B,
        open: k,
        children: /* @__PURE__ */ _.cloneElement(c, J)
      })]
    })
  });
});
process.env.NODE_ENV !== "production" && (IT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: h.elementType,
  /**
   * Props applied to the [`Backdrop`](https://mui.com/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: h.object,
  /**
   * A single child content element.
   */
  children: Xa.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: h.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: h.shape({
    Backdrop: h.elementType,
    Root: h.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: h.shape({
    backdrop: h.oneOfType([h.func, h.object]),
    root: h.oneOfType([h.func, h.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: h.oneOfType([yi, h.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: h.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: h.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: h.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: h.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: h.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: h.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: h.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: h.bool,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: h.func,
  /**
   * A function called when a transition enters.
   */
  onTransitionEnter: h.func,
  /**
   * A function called when a transition has exited.
   */
  onTransitionExited: h.func,
  /**
   * If `true`, the component is shown.
   */
  open: h.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: h.shape({
    backdrop: h.oneOfType([h.func, h.object]),
    root: h.oneOfType([h.func, h.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: h.shape({
    backdrop: h.elementType,
    root: h.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object])
});
const CO = xt("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), rY = (e) => {
  const {
    classes: t,
    disableUnderline: n,
    startAdornment: r,
    endAdornment: i,
    size: o,
    hiddenLabel: a,
    multiline: s
  } = e, l = {
    root: ["root", !n && "underline", r && "adornedStart", i && "adornedEnd", o === "small" && `size${It(o)}`, a && "hiddenLabel", s && "multiline"],
    input: ["input"]
  }, c = $t(l, jq, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...c
  };
}, iY = xe(yf, {
  shouldForwardProp: (e) => Hr(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...gf(e, t), !n.disableUnderline && t.underline];
  }
})(hn(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", i = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", o = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : i,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      }
    },
    [`&.${so.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
    },
    [`&.${so.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : o
    },
    variants: [{
      props: ({
        ownerState: a
      }) => !a.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${so.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${so.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${so.disabled}, .${so.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
        },
        [`&.${so.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(yy()).map(([a]) => ({
      props: {
        disableUnderline: !1,
        color: a
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[a]?.main}`
        }
      }
    })), {
      props: ({
        ownerState: a
      }) => a.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: a,
        size: s
      }) => a.multiline && s === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel && a.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), oY = xe(bf, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: vf
})(hn(({
  theme: e
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), Ty = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiFilledInput"
  }), {
    disableUnderline: i = !1,
    components: o = {},
    componentsProps: a,
    fullWidth: s = !1,
    hiddenLabel: l,
    // declare here to prevent spreading to DOM
    inputComponent: c = "input",
    multiline: u = !1,
    slotProps: d,
    slots: f = {},
    type: p = "text",
    ...g
  } = r, m = {
    ...r,
    disableUnderline: i,
    fullWidth: s,
    inputComponent: c,
    multiline: u,
    type: p
  }, v = rY(r), y = {
    root: {
      ownerState: m
    },
    input: {
      ownerState: m
    }
  }, S = d ?? a ? fn(y, d ?? a) : y, x = f.root ?? o.Root ?? iY, b = f.input ?? o.Input ?? oY;
  return /* @__PURE__ */ O.jsx(xf, {
    slots: {
      root: x,
      input: b
    },
    slotProps: S,
    fullWidth: s,
    inputComponent: c,
    multiline: u,
    ref: n,
    type: p,
    ...g,
    classes: v
  });
});
process.env.NODE_ENV !== "production" && (Ty.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: h.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: h.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: h.oneOfType([h.oneOf(["primary", "secondary"]), h.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: h.shape({
    Input: h.elementType,
    Root: h.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: h.shape({
    input: h.object,
    root: h.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: h.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: h.bool,
  /**
   * If `true`, the input will not have an underline.
   * @default false
   */
  disableUnderline: h.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: h.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: h.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: h.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: h.bool,
  /**
   * The id of the `input` element.
   */
  id: h.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: h.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: h.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Yr,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: h.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: h.oneOfType([h.number, h.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: h.oneOfType([h.number, h.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: h.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: h.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: h.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: h.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: h.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: h.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: h.oneOfType([h.number, h.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: h.shape({
    input: h.object,
    root: h.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: h.shape({
    input: h.elementType,
    root: h.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: h.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: h.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: h.any
});
Ty.muiName = "Input";
function aY(e) {
  return Mt("MuiFormControl", e);
}
xt("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const sY = (e) => {
  const {
    classes: t,
    margin: n,
    fullWidth: r
  } = e, i = {
    root: ["root", n !== "none" && `margin${It(n)}`, r && "fullWidth"]
  };
  return $t(i, aY, t);
}, lY = xe("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`margin${It(n.margin)}`], n.fullWidth && t.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), $T = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiFormControl"
  }), {
    children: i,
    className: o,
    color: a = "primary",
    component: s = "div",
    disabled: l = !1,
    error: c = !1,
    focused: u,
    fullWidth: d = !1,
    hiddenLabel: f = !1,
    margin: p = "none",
    required: g = !1,
    size: m = "medium",
    variant: v = "outlined",
    ...y
  } = r, S = {
    ...r,
    color: a,
    component: s,
    disabled: l,
    error: c,
    fullWidth: d,
    hiddenLabel: f,
    margin: p,
    required: g,
    size: m,
    variant: v
  }, x = sY(S), [b, w] = _.useState(() => {
    let $ = !1;
    return i && _.Children.forEach(i, (F) => {
      if (!$f(F, ["Input", "Select"]))
        return;
      const q = $f(F, ["Select"]) ? F.props.input : F;
      q && Cq(q.props) && ($ = !0);
    }), $;
  }), [E, C] = _.useState(() => {
    let $ = !1;
    return i && _.Children.forEach(i, (F) => {
      $f(F, ["Input", "Select"]) && (ed(F.props, !0) || ed(F.props.inputProps, !0)) && ($ = !0);
    }), $;
  }), [A, k] = _.useState(!1);
  l && A && k(!1);
  const R = u !== void 0 && !l ? u : A;
  let M;
  const P = _.useRef(!1);
  process.env.NODE_ENV !== "production" && (M = () => (P.current && console.error(["MUI: There are multiple `InputBase` components inside a FormControl.", "This creates visual inconsistencies, only use one `InputBase`."].join(`
`)), P.current = !0, () => {
    P.current = !1;
  }));
  const D = _.useCallback(() => {
    C(!0);
  }, []), j = _.useCallback(() => {
    C(!1);
  }, []), N = _.useMemo(() => ({
    adornedStart: b,
    setAdornedStart: w,
    color: a,
    disabled: l,
    error: c,
    filled: E,
    focused: R,
    fullWidth: d,
    hiddenLabel: f,
    size: m,
    onBlur: () => {
      k(!1);
    },
    onFocus: () => {
      k(!0);
    },
    onEmpty: j,
    onFilled: D,
    registerEffect: M,
    required: g,
    variant: v
  }), [b, a, l, c, E, R, d, f, M, j, D, g, m, v]);
  return /* @__PURE__ */ O.jsx(mf.Provider, {
    value: N,
    children: /* @__PURE__ */ O.jsx(lY, {
      as: s,
      ownerState: S,
      className: ce(x.root, o),
      ref: n,
      ...y,
      children: i
    })
  });
});
process.env.NODE_ENV !== "production" && ($T.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: h.oneOfType([h.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), h.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   * @default false
   */
  disabled: h.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: h.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: h.bool,
  /**
   * If `true`, the component will take up the full width of its container.
   * @default false
   */
  fullWidth: h.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: h.bool,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: h.oneOf(["dense", "none", "normal"]),
  /**
   * If `true`, the label will indicate that the `input` is required.
   * @default false
   */
  required: h.bool,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: h.oneOfType([h.oneOf(["medium", "small"]), h.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: h.oneOf(["filled", "outlined", "standard"])
});
function Wm(e) {
  return `scale(${e}, ${e ** 2})`;
}
const cY = {
  entering: {
    opacity: 1,
    transform: Wm(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, gh = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), sl = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    addEndListener: r,
    appear: i = !0,
    children: o,
    easing: a,
    in: s,
    onEnter: l,
    onEntered: c,
    onEntering: u,
    onExit: d,
    onExited: f,
    onExiting: p,
    style: g,
    timeout: m = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: v = qr,
    ...y
  } = t, S = fa(), x = _.useRef(), b = Td(), w = _.useRef(null), E = Kt(w, Ga(o), n), C = (N) => ($) => {
    if (N) {
      const F = w.current;
      $ === void 0 ? N(F) : N(F, $);
    }
  }, A = C(u), k = C((N, $) => {
    aT(N);
    const {
      duration: F,
      delay: q,
      easing: B
    } = Yu({
      style: g,
      timeout: m,
      easing: a
    }, {
      mode: "enter"
    });
    let L;
    m === "auto" ? (L = b.transitions.getAutoHeightDuration(N.clientHeight), x.current = L) : L = F, N.style.transition = [b.transitions.create("opacity", {
      duration: L,
      delay: q
    }), b.transitions.create("transform", {
      duration: gh ? L : L * 0.666,
      delay: q,
      easing: B
    })].join(","), l && l(N, $);
  }), R = C(c), M = C(p), P = C((N) => {
    const {
      duration: $,
      delay: F,
      easing: q
    } = Yu({
      style: g,
      timeout: m,
      easing: a
    }, {
      mode: "exit"
    });
    let B;
    m === "auto" ? (B = b.transitions.getAutoHeightDuration(N.clientHeight), x.current = B) : B = $, N.style.transition = [b.transitions.create("opacity", {
      duration: B,
      delay: F
    }), b.transitions.create("transform", {
      duration: gh ? B : B * 0.666,
      delay: gh ? F : F || B * 0.333,
      easing: q
    })].join(","), N.style.opacity = 0, N.style.transform = Wm(0.75), d && d(N);
  }), D = C(f), j = (N) => {
    m === "auto" && S.start(x.current || 0, N), r && r(w.current, N);
  };
  return /* @__PURE__ */ O.jsx(v, {
    appear: i,
    in: s,
    nodeRef: w,
    onEnter: k,
    onEntered: R,
    onEntering: A,
    onExit: P,
    onExited: D,
    onExiting: M,
    addEndListener: j,
    timeout: m === "auto" ? null : m,
    ...y,
    children: (N, {
      ownerState: $,
      ...F
    }) => /* @__PURE__ */ _.cloneElement(o, {
      style: {
        opacity: 0,
        transform: Wm(0.75),
        visibility: N === "exited" && !s ? "hidden" : void 0,
        ...cY[N],
        ...g,
        ...o.props.style
      },
      ref: E,
      ...F
    })
  });
});
process.env.NODE_ENV !== "production" && (sl.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: h.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: h.bool,
  /**
   * A single child content element.
   */
  children: Xa.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: h.oneOfType([h.shape({
    enter: h.string,
    exit: h.string
  }), h.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: h.bool,
  /**
   * @ignore
   */
  onEnter: h.func,
  /**
   * @ignore
   */
  onEntered: h.func,
  /**
   * @ignore
   */
  onEntering: h.func,
  /**
   * @ignore
   */
  onExit: h.func,
  /**
   * @ignore
   */
  onExited: h.func,
  /**
   * @ignore
   */
  onExiting: h.func,
  /**
   * @ignore
   */
  style: h.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: h.oneOfType([h.oneOf(["auto"]), h.number, h.shape({
    appear: h.number,
    enter: h.number,
    exit: h.number
  })])
});
sl && (sl.muiSupportAuto = !0);
const uY = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, i = $t({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, kq, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...i
  };
}, dY = xe(yf, {
  shouldForwardProp: (e) => Hr(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...gf(e, t), !n.disableUnderline && t.underline];
  }
})(hn(({
  theme: e
}) => {
  let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (n = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: r
      }) => r.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: r
      }) => !r.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${ds.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${ds.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${ds.disabled}, .${ds.error}):before`]: {
          borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${n}`
          }
        },
        [`&.${ds.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(yy()).map(([r]) => ({
      props: {
        color: r,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[r].main}`
        }
      }
    }))]
  };
})), fY = xe(bf, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: vf
})({}), ky = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: i = !1,
    components: o = {},
    componentsProps: a,
    fullWidth: s = !1,
    inputComponent: l = "input",
    multiline: c = !1,
    slotProps: u,
    slots: d = {},
    type: f = "text",
    ...p
  } = r, g = uY(r), v = {
    root: {
      ownerState: {
        disableUnderline: i
      }
    }
  }, y = u ?? a ? fn(u ?? a, v) : v, S = d.root ?? o.Root ?? dY, x = d.input ?? o.Input ?? fY;
  return /* @__PURE__ */ O.jsx(xf, {
    slots: {
      root: S,
      input: x
    },
    slotProps: y,
    fullWidth: s,
    inputComponent: l,
    multiline: c,
    ref: n,
    type: f,
    ...p,
    classes: g
  });
});
process.env.NODE_ENV !== "production" && (ky.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: h.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: h.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: h.oneOfType([h.oneOf(["primary", "secondary"]), h.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: h.shape({
    Input: h.elementType,
    Root: h.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: h.shape({
    input: h.object,
    root: h.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: h.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: h.bool,
  /**
   * If `true`, the `input` will not have an underline.
   * @default false
   */
  disableUnderline: h.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: h.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: h.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: h.bool,
  /**
   * The id of the `input` element.
   */
  id: h.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: h.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: h.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Yr,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: h.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: h.oneOfType([h.number, h.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: h.oneOfType([h.number, h.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: h.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: h.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: h.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: h.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: h.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: h.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: h.oneOfType([h.number, h.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: h.shape({
    input: h.object,
    root: h.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: h.shape({
    input: h.elementType,
    root: h.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: h.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: h.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: h.any
});
ky.muiName = "Input";
const nd = /* @__PURE__ */ _.createContext({});
process.env.NODE_ENV !== "production" && (nd.displayName = "ListContext");
function pY(e) {
  return Mt("MuiList", e);
}
xt("MuiList", ["root", "padding", "dense", "subheader"]);
const hY = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: r,
    subheader: i
  } = e;
  return $t({
    root: ["root", !n && "padding", r && "dense", i && "subheader"]
  }, pY, t);
}, mY = xe("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: e
    }) => !e.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: e
    }) => e.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), LT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiList"
  }), {
    children: i,
    className: o,
    component: a = "ul",
    dense: s = !1,
    disablePadding: l = !1,
    subheader: c,
    ...u
  } = r, d = _.useMemo(() => ({
    dense: s
  }), [s]), f = {
    ...r,
    component: a,
    dense: s,
    disablePadding: l
  }, p = hY(f);
  return /* @__PURE__ */ O.jsx(nd.Provider, {
    value: d,
    children: /* @__PURE__ */ O.jsxs(mY, {
      as: a,
      className: ce(p.root, o),
      ref: n,
      ownerState: f,
      ...u,
      children: [c, i]
    })
  });
});
process.env.NODE_ENV !== "production" && (LT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: h.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: h.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: h.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object])
});
const AO = xt("MuiListItemIcon", ["root", "alignItemsFlexStart"]), TO = xt("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
function vh(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function kO(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function FT(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
}
function fs(e, t, n, r, i, o) {
  let a = !1, s = i(e, t, t ? n : !1);
  for (; s; ) {
    if (s === e.firstChild) {
      if (a)
        return !1;
      a = !0;
    }
    const l = r ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
    if (!s.hasAttribute("tabindex") || !FT(s, o) || l)
      s = i(e, s, n);
    else
      return s.focus(), !0;
  }
  return !1;
}
const BT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: r,
    autoFocus: i = !1,
    autoFocusItem: o = !1,
    children: a,
    className: s,
    disabledItemsFocusable: l = !1,
    disableListWrap: c = !1,
    onKeyDown: u,
    variant: d = "selectedMenu",
    ...f
  } = t, p = _.useRef(null), g = _.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  Lr(() => {
    i && p.current.focus();
  }, [i]), _.useImperativeHandle(r, () => ({
    adjustStyleForScrollbar: (x, {
      direction: b
    }) => {
      const w = !p.current.style.width;
      if (x.clientHeight < p.current.clientHeight && w) {
        const E = `${RT(pi(x))}px`;
        p.current.style[b === "rtl" ? "paddingLeft" : "paddingRight"] = E, p.current.style.width = `calc(100% + ${E})`;
      }
      return p.current;
    }
  }), []);
  const m = (x) => {
    const b = p.current, w = x.key;
    if (x.ctrlKey || x.metaKey || x.altKey) {
      u && u(x);
      return;
    }
    const C = Un(b).activeElement;
    if (w === "ArrowDown")
      x.preventDefault(), fs(b, C, c, l, vh);
    else if (w === "ArrowUp")
      x.preventDefault(), fs(b, C, c, l, kO);
    else if (w === "Home")
      x.preventDefault(), fs(b, null, c, l, vh);
    else if (w === "End")
      x.preventDefault(), fs(b, null, c, l, kO);
    else if (w.length === 1) {
      const A = g.current, k = w.toLowerCase(), R = performance.now();
      A.keys.length > 0 && (R - A.lastTime > 500 ? (A.keys = [], A.repeating = !0, A.previousKeyMatched = !0) : A.repeating && k !== A.keys[0] && (A.repeating = !1)), A.lastTime = R, A.keys.push(k);
      const M = C && !A.repeating && FT(C, A);
      A.previousKeyMatched && (M || fs(b, C, !1, l, vh, A)) ? x.preventDefault() : A.previousKeyMatched = !1;
    }
    u && u(x);
  }, v = Kt(p, n);
  let y = -1;
  _.Children.forEach(a, (x, b) => {
    if (!/* @__PURE__ */ _.isValidElement(x)) {
      y === b && (y += 1, y >= a.length && (y = -1));
      return;
    }
    process.env.NODE_ENV !== "production" && Fi.isFragment(x) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), x.props.disabled || (d === "selectedMenu" && x.props.selected || y === -1) && (y = b), y === b && (x.props.disabled || x.props.muiSkipListHighlight || x.type.muiSkipListHighlight) && (y += 1, y >= a.length && (y = -1));
  });
  const S = _.Children.map(a, (x, b) => {
    if (b === y) {
      const w = {};
      return o && (w.autoFocus = !0), x.props.tabIndex === void 0 && d === "selectedMenu" && (w.tabIndex = 0), /* @__PURE__ */ _.cloneElement(x, w);
    }
    return x;
  });
  return /* @__PURE__ */ O.jsx(LT, {
    role: "menu",
    ref: v,
    className: s,
    onKeyDown: m,
    tabIndex: i ? 0 : -1,
    ...f,
    children: S
  });
});
process.env.NODE_ENV !== "production" && (BT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: h.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: h.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: h.node,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: h.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: h.bool,
  /**
   * @ignore
   */
  onKeyDown: h.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: h.oneOf(["menu", "selectedMenu"])
});
function gY(e) {
  return Mt("MuiPopover", e);
}
xt("MuiPopover", ["root", "paper"]);
function MO(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function jO(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function NO(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function Cs(e) {
  return typeof e == "function" ? e() : e;
}
const vY = (e) => {
  const {
    classes: t
  } = e;
  return $t({
    root: ["root"],
    paper: ["paper"]
  }, gY, t);
}, yY = xe(IT, {
  name: "MuiPopover",
  slot: "Root"
})({}), zT = xe(uT, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), WT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiPopover"
  }), {
    action: i,
    anchorEl: o,
    anchorOrigin: a = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: s,
    anchorReference: l = "anchorEl",
    children: c,
    className: u,
    container: d,
    elevation: f = 8,
    marginThreshold: p = 16,
    open: g,
    PaperProps: m = {},
    // TODO: remove in v7
    slots: v = {},
    slotProps: y = {},
    transformOrigin: S = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: x,
    // TODO: remove in v7
    transitionDuration: b = "auto",
    TransitionProps: w = {},
    // TODO: remove in v7
    disableScrollLock: E = !1,
    ...C
  } = r, A = _.useRef(), k = {
    ...r,
    anchorOrigin: a,
    anchorReference: l,
    elevation: f,
    marginThreshold: p,
    transformOrigin: S,
    TransitionComponent: x,
    transitionDuration: b,
    TransitionProps: w
  }, R = vY(k), M = _.useCallback(() => {
    if (l === "anchorPosition")
      return process.env.NODE_ENV !== "production" && (s || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.')), s;
    const H = Cs(o), Z = H && H.nodeType === 1 ? H : Un(A.current).body, T = Z.getBoundingClientRect();
    if (process.env.NODE_ENV !== "production") {
      const de = Z.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && de.top === 0 && de.left === 0 && de.right === 0 && de.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: T.top + MO(T, a.vertical),
      left: T.left + jO(T, a.horizontal)
    };
  }, [o, a.horizontal, a.vertical, s, l]), P = _.useCallback((H) => ({
    vertical: MO(H, S.vertical),
    horizontal: jO(H, S.horizontal)
  }), [S.horizontal, S.vertical]), D = _.useCallback((H) => {
    const Z = {
      width: H.offsetWidth,
      height: H.offsetHeight
    }, T = P(Z);
    if (l === "none")
      return {
        top: null,
        left: null,
        transformOrigin: NO(T)
      };
    const de = M();
    let ee = de.top - T.vertical, he = de.left - T.horizontal;
    const be = ee + Z.height, Se = he + Z.width, Ce = pi(Cs(o)), nt = Ce.innerHeight - p, Ke = Ce.innerWidth - p;
    if (p !== null && ee < p) {
      const Te = ee - p;
      ee -= Te, T.vertical += Te;
    } else if (p !== null && be > nt) {
      const Te = be - nt;
      ee -= Te, T.vertical += Te;
    }
    if (process.env.NODE_ENV !== "production" && Z.height > nt && Z.height && nt && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${Z.height - nt}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), p !== null && he < p) {
      const Te = he - p;
      he -= Te, T.horizontal += Te;
    } else if (Se > Ke) {
      const Te = Se - Ke;
      he -= Te, T.horizontal += Te;
    }
    return {
      top: `${Math.round(ee)}px`,
      left: `${Math.round(he)}px`,
      transformOrigin: NO(T)
    };
  }, [o, l, M, P, p]), [j, N] = _.useState(g), $ = _.useCallback(() => {
    const H = A.current;
    if (!H)
      return;
    const Z = D(H);
    Z.top !== null && H.style.setProperty("top", Z.top), Z.left !== null && (H.style.left = Z.left), H.style.transformOrigin = Z.transformOrigin, N(!0);
  }, [D]);
  _.useEffect(() => (E && window.addEventListener("scroll", $), () => window.removeEventListener("scroll", $)), [o, E, $]);
  const F = () => {
    $();
  }, q = () => {
    N(!1);
  };
  _.useEffect(() => {
    g && $();
  }), _.useImperativeHandle(i, () => g ? {
    updatePosition: () => {
      $();
    }
  } : null, [g, $]), _.useEffect(() => {
    if (!g)
      return;
    const H = i_(() => {
      $();
    }), Z = pi(Cs(o));
    return Z.addEventListener("resize", H), () => {
      H.clear(), Z.removeEventListener("resize", H);
    };
  }, [o, g, $]);
  let B = b;
  const L = {
    slots: {
      transition: x,
      ...v
    },
    slotProps: {
      transition: w,
      paper: m,
      ...y
    }
  }, [Y, K] = An("transition", {
    elementType: sl,
    externalForwardedProps: L,
    ownerState: k,
    getSlotProps: (H) => ({
      ...H,
      onEntering: (Z, T) => {
        H.onEntering?.(Z, T), F();
      },
      onExited: (Z) => {
        H.onExited?.(Z), q();
      }
    }),
    additionalProps: {
      appear: !0,
      in: g
    }
  });
  b === "auto" && !Y.muiSupportAuto && (B = void 0);
  const te = d || (o ? Un(Cs(o)).body : void 0), [J, {
    slots: Q,
    slotProps: ne,
    ...re
  }] = An("root", {
    ref: n,
    elementType: yY,
    externalForwardedProps: {
      ...L,
      ...C
    },
    shouldForwardComponentProp: !0,
    additionalProps: {
      slots: {
        backdrop: v.backdrop
      },
      slotProps: {
        backdrop: LD(typeof y.backdrop == "function" ? y.backdrop(k) : y.backdrop, {
          invisible: !0
        })
      },
      container: te,
      open: g
    },
    ownerState: k,
    className: ce(R.root, u)
  }), [ie, U] = An("paper", {
    ref: A,
    className: R.paper,
    elementType: zT,
    externalForwardedProps: L,
    shouldForwardComponentProp: !0,
    additionalProps: {
      elevation: f,
      style: j ? void 0 : {
        opacity: 0
      }
    },
    ownerState: k
  });
  return /* @__PURE__ */ O.jsx(J, {
    ...re,
    ...!Gu(J) && {
      slots: Q,
      slotProps: ne,
      disableScrollLock: E
    },
    children: /* @__PURE__ */ O.jsx(Y, {
      ...K,
      timeout: B,
      children: /* @__PURE__ */ O.jsx(ie, {
        ...U,
        children: c
      })
    })
  });
});
process.env.NODE_ENV !== "production" && (WT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: Yr,
  /**
   * An HTML element, [PopoverVirtualElement](https://mui.com/material-ui/react-popover/#virtual-element),
   * or a function that returns either.
   * It's used to set the position of the popover.
   */
  anchorEl: Ya(h.oneOfType([yi, h.func]), (e) => {
    if (e.open && (!e.anchorReference || e.anchorReference === "anchorEl")) {
      const t = Cs(e.anchorEl);
      if (t && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element or PopoverVirtualElement instance but it's \`${t}\` instead.`].join(`
`));
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: h.shape({
    horizontal: h.oneOfType([h.oneOf(["center", "left", "right"]), h.number]).isRequired,
    vertical: h.oneOfType([h.oneOf(["bottom", "center", "top"]), h.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: h.shape({
    left: h.number.isRequired,
    top: h.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: h.oneOf(["anchorEl", "anchorPosition", "none"]),
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: h.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  BackdropProps: h.object,
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: h.oneOfType([yi, h.func]),
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: h.bool,
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: cT,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * If null, the popover will not be constrained by the window.
   * @default 16
   */
  marginThreshold: h.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: h.func,
  /**
   * If `true`, the component is shown.
   */
  open: h.bool.isRequired,
  /**
   * Props applied to the [`Paper`](https://mui.com/material-ui/api/paper/) element.
   *
   * This prop is an alias for `slotProps.paper` and will be overridden by it if both are used.
   * @deprecated Use `slotProps.paper` instead.
   *
   * @default {}
   */
  PaperProps: h.shape({
    component: vy
  }),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: h.shape({
    backdrop: h.oneOfType([h.func, h.object]),
    paper: h.oneOfType([h.func, h.object]),
    root: h.oneOfType([h.func, h.object]),
    transition: h.oneOfType([h.func, h.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: h.shape({
    backdrop: h.elementType,
    paper: h.elementType,
    root: h.elementType,
    transition: h.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: h.shape({
    horizontal: h.oneOfType([h.oneOf(["center", "left", "right"]), h.number]).isRequired,
    vertical: h.oneOfType([h.oneOf(["bottom", "center", "top"]), h.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @deprecated use the `slots.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default Grow
   */
  TransitionComponent: h.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: h.oneOfType([h.oneOf(["auto"]), h.number, h.shape({
    appear: h.number,
    enter: h.number,
    exit: h.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  TransitionProps: h.object
});
function bY(e) {
  return Mt("MuiMenu", e);
}
xt("MuiMenu", ["root", "paper", "list"]);
const xY = {
  vertical: "top",
  horizontal: "right"
}, wY = {
  vertical: "top",
  horizontal: "left"
}, OY = (e) => {
  const {
    classes: t
  } = e;
  return $t({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, bY, t);
}, SY = xe(WT, {
  shouldForwardProp: (e) => Hr(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root"
})({}), EY = xe(zT, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), _Y = xe(BT, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), VT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: i = !0,
    children: o,
    className: a,
    disableAutoFocusItem: s = !1,
    MenuListProps: l = {},
    onClose: c,
    open: u,
    PaperProps: d = {},
    PopoverClasses: f,
    transitionDuration: p = "auto",
    TransitionProps: {
      onEntering: g,
      ...m
    } = {},
    variant: v = "selectedMenu",
    slots: y = {},
    slotProps: S = {},
    ...x
  } = r, b = mg(), w = {
    ...r,
    autoFocus: i,
    disableAutoFocusItem: s,
    MenuListProps: l,
    onEntering: g,
    PaperProps: d,
    transitionDuration: p,
    TransitionProps: m,
    variant: v
  }, E = OY(w), C = i && !s && u, A = _.useRef(null), k = (B, L) => {
    A.current && A.current.adjustStyleForScrollbar(B, {
      direction: b ? "rtl" : "ltr"
    }), g && g(B, L);
  }, R = (B) => {
    B.key === "Tab" && (B.preventDefault(), c && c(B, "tabKeyDown"));
  };
  let M = -1;
  _.Children.map(o, (B, L) => {
    /* @__PURE__ */ _.isValidElement(B) && (process.env.NODE_ENV !== "production" && Fi.isFragment(B) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), B.props.disabled || (v === "selectedMenu" && B.props.selected || M === -1) && (M = L));
  });
  const P = {
    slots: y,
    slotProps: {
      list: l,
      transition: m,
      paper: d,
      ...S
    }
  }, D = TT({
    elementType: y.root,
    externalSlotProps: S.root,
    ownerState: w,
    className: [E.root, a]
  }), [j, N] = An("paper", {
    className: E.paper,
    elementType: EY,
    externalForwardedProps: P,
    shouldForwardComponentProp: !0,
    ownerState: w
  }), [$, F] = An("list", {
    className: ce(E.list, l.className),
    elementType: _Y,
    shouldForwardComponentProp: !0,
    externalForwardedProps: P,
    getSlotProps: (B) => ({
      ...B,
      onKeyDown: (L) => {
        R(L), B.onKeyDown?.(L);
      }
    }),
    ownerState: w
  }), q = typeof P.slotProps.transition == "function" ? P.slotProps.transition(w) : P.slotProps.transition;
  return /* @__PURE__ */ O.jsx(SY, {
    onClose: c,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: b ? "right" : "left"
    },
    transformOrigin: b ? xY : wY,
    slots: {
      root: y.root,
      paper: j,
      backdrop: y.backdrop,
      ...y.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: y.transition
      }
    },
    slotProps: {
      root: D,
      paper: N,
      backdrop: typeof S.backdrop == "function" ? S.backdrop(w) : S.backdrop,
      transition: {
        ...q,
        onEntering: (...B) => {
          k(...B), q?.onEntering?.(...B);
        }
      }
    },
    open: u,
    ref: n,
    transitionDuration: p,
    ownerState: w,
    ...x,
    classes: f,
    children: /* @__PURE__ */ O.jsx($, {
      actions: A,
      autoFocus: i && (M === -1 || s),
      autoFocusItem: C,
      variant: v,
      ...F,
      children: o
    })
  });
});
process.env.NODE_ENV !== "production" && (VT.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: h.oneOfType([yi, h.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: h.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: h.bool,
  /**
   * Props applied to the [`MenuList`](https://mui.com/material-ui/api/menu-list/) element.
   * @deprecated use the `slotProps.list` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  MenuListProps: h.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: h.func,
  /**
   * If `true`, the component is shown.
   */
  open: h.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: h.object,
  /**
   * `classes` prop applied to the [`Popover`](https://mui.com/material-ui/api/popover/) element.
   */
  PopoverClasses: h.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: h.shape({
    backdrop: h.oneOfType([h.func, h.object]),
    list: h.oneOfType([h.func, h.object]),
    paper: h.oneOfType([h.func, h.object]),
    root: h.oneOfType([h.func, h.object]),
    transition: h.oneOfType([h.func, h.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: h.shape({
    backdrop: h.elementType,
    list: h.elementType,
    paper: h.elementType,
    root: h.elementType,
    transition: h.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: h.oneOfType([h.oneOf(["auto"]), h.number, h.shape({
    appear: h.number,
    enter: h.number,
    exit: h.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  TransitionProps: h.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: h.oneOf(["menu", "selectedMenu"])
});
function PY(e) {
  return Mt("MuiMenuItem", e);
}
const ps = xt("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), CY = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, AY = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: r,
    disableGutters: i,
    selected: o,
    classes: a
  } = e, l = $t({
    root: ["root", n && "dense", t && "disabled", !i && "gutters", r && "divider", o && "selected"]
  }, PY, a);
  return {
    ...a,
    ...l
  };
}, TY = xe(vT, {
  shouldForwardProp: (e) => Hr(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: CY
})(hn(({
  theme: e
}) => ({
  ...e.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${ps.selected}`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
    [`&.${ps.focusVisible}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
    }
  },
  [`&.${ps.selected}:hover`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
    }
  },
  [`&.${ps.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${ps.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${CO.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${CO.inset}`]: {
    marginLeft: 52
  },
  [`& .${TO.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${TO.inset}`]: {
    paddingLeft: 36
  },
  [`& .${AO.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.dense,
    style: {
      [e.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...e.typography.body2,
      [`& .${AO.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
}))), Vm = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: i = !1,
    component: o = "li",
    dense: a = !1,
    divider: s = !1,
    disableGutters: l = !1,
    focusVisibleClassName: c,
    role: u = "menuitem",
    tabIndex: d,
    className: f,
    ...p
  } = r, g = _.useContext(nd), m = _.useMemo(() => ({
    dense: a || g.dense || !1,
    disableGutters: l
  }), [g.dense, a, l]), v = _.useRef(null);
  Lr(() => {
    i && (v.current ? v.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [i]);
  const y = {
    ...r,
    dense: m.dense,
    divider: s,
    disableGutters: l
  }, S = AY(r), x = Kt(v, n);
  let b;
  return r.disabled || (b = d !== void 0 ? d : -1), /* @__PURE__ */ O.jsx(nd.Provider, {
    value: m,
    children: /* @__PURE__ */ O.jsx(TY, {
      ref: x,
      role: u,
      tabIndex: b,
      component: o,
      focusVisibleClassName: ce(S.focusVisible, c),
      className: ce(S.root, f),
      ...p,
      ownerState: y,
      classes: S
    })
  });
});
process.env.NODE_ENV !== "production" && (Vm.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   */
  autoFocus: h.bool,
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: h.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent Menu component.
   * @default false
   */
  dense: h.bool,
  /**
   * @ignore
   */
  disabled: h.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: h.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the menu item.
   * @default false
   */
  divider: h.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: h.string,
  /**
   * @ignore
   */
  role: h.string,
  /**
   * If `true`, the component is selected.
   * @default false
   */
  selected: h.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * @default 0
   */
  tabIndex: h.number
});
function kY(e) {
  return Mt("MuiNativeSelect", e);
}
const My = xt("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), MY = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: o,
    error: a
  } = e, s = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${It(n)}`, o && "iconOpen", r && "disabled"]
  };
  return $t(s, kY, t);
}, UT = xe("select", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${My.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (e.vars || e).shape.borderRadius,
      "&:focus": {
        borderRadius: (e.vars || e).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), jY = xe(UT, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: Hr,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${My.multiple}`]: t.multiple
    }];
  }
})({}), HT = xe("svg", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (e.vars || e).palette.action.active,
  [`&.${My.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), NY = xe(HT, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${It(n.variant)}`], n.open && t.iconOpen];
  }
})({}), KT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    className: r,
    disabled: i,
    error: o,
    IconComponent: a,
    inputRef: s,
    variant: l = "standard",
    ...c
  } = t, u = {
    ...t,
    disabled: i,
    variant: l,
    error: o
  }, d = MY(u);
  return /* @__PURE__ */ O.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ O.jsx(jY, {
      ownerState: u,
      className: ce(d.select, r),
      disabled: i,
      ref: s || n,
      ...c
    }), t.multiple ? null : /* @__PURE__ */ O.jsx(NY, {
      as: a,
      ownerState: u,
      className: d.icon
    })]
  });
});
process.env.NODE_ENV !== "production" && (KT.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * The CSS class name of the select element.
   */
  className: h.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: h.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: h.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: h.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: Yr,
  /**
   * @ignore
   */
  multiple: h.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: h.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: h.func,
  /**
   * The input value.
   */
  value: h.any,
  /**
   * The variant to use.
   */
  variant: h.oneOf(["standard", "outlined", "filled"])
});
var DO;
const DY = xe("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Hr
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), RY = xe("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Hr
})(hn(({
  theme: e
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: e.transitions.create("width", {
        duration: 150,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: e.transitions.create("max-width", {
        duration: 50,
        easing: e.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: e.transitions.create("max-width", {
        duration: 100,
        easing: e.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function qT(e) {
  const {
    children: t,
    classes: n,
    className: r,
    label: i,
    notched: o,
    ...a
  } = e, s = i != null && i !== "", l = {
    ...e,
    notched: o,
    withLabel: s
  };
  return /* @__PURE__ */ O.jsx(DY, {
    "aria-hidden": !0,
    className: r,
    ownerState: l,
    ...a,
    children: /* @__PURE__ */ O.jsx(RY, {
      ownerState: l,
      children: s ? /* @__PURE__ */ O.jsx("span", {
        children: i
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        DO || (DO = /* @__PURE__ */ O.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      )
    })
  });
}
process.env.NODE_ENV !== "production" && (qT.propTypes = {
  /**
   * The content of the component.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The label.
   */
  label: h.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: h.bool.isRequired,
  /**
   * @ignore
   */
  style: h.object
});
const IY = (e) => {
  const {
    classes: t
  } = e, r = $t({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, Mq, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...r
  };
}, $Y = xe(yf, {
  shouldForwardProp: (e) => Hr(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: gf
})(hn(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${_r.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${_r.notchedOutline}`]: {
        borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
      }
    },
    [`&.${_r.focused} .${_r.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(e.palette).filter(yy()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        [`&.${_r.focused} .${_r.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[n].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${_r.error} .${_r.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main
        },
        [`&.${_r.disabled} .${_r.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => n.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: n,
        size: r
      }) => n.multiline && r === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), LY = xe(qT, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(hn(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
  };
})), FY = xe(bf, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: vf
})(hn(({
  theme: e
}) => ({
  padding: "16.5px 14px",
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), jy = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: i = {},
    fullWidth: o = !1,
    inputComponent: a = "input",
    label: s,
    multiline: l = !1,
    notched: c,
    slots: u = {},
    slotProps: d = {},
    type: f = "text",
    ...p
  } = r, g = IY(r), m = Ay(), v = Cy({
    props: r,
    muiFormControl: m,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), y = {
    ...r,
    color: v.color || "primary",
    disabled: v.disabled,
    error: v.error,
    focused: v.focused,
    formControl: m,
    fullWidth: o,
    hiddenLabel: v.hiddenLabel,
    multiline: l,
    size: v.size,
    type: f
  }, S = u.root ?? i.Root ?? $Y, x = u.input ?? i.Input ?? FY, [b, w] = An("notchedOutline", {
    elementType: LY,
    className: g.notchedOutline,
    shouldForwardComponentProp: !0,
    ownerState: y,
    externalForwardedProps: {
      slots: u,
      slotProps: d
    },
    additionalProps: {
      label: s != null && s !== "" && v.required ? /* @__PURE__ */ O.jsxs(_.Fragment, {
        children: [s, "", "*"]
      }) : s
    }
  });
  return /* @__PURE__ */ O.jsx(xf, {
    slots: {
      root: S,
      input: x
    },
    slotProps: d,
    renderSuffix: (E) => /* @__PURE__ */ O.jsx(b, {
      ...w,
      notched: typeof c < "u" ? c : !!(E.startAdornment || E.filled || E.focused)
    }),
    fullWidth: o,
    inputComponent: a,
    multiline: l,
    ref: n,
    type: f,
    ...p,
    classes: {
      ...g,
      notchedOutline: null
    }
  });
});
process.env.NODE_ENV !== "production" && (jy.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: h.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: h.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: h.oneOfType([h.oneOf(["primary", "secondary"]), h.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: h.shape({
    Input: h.elementType,
    Root: h.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: h.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: h.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: h.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: h.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: h.bool,
  /**
   * The id of the `input` element.
   */
  id: h.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: h.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: h.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Yr,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: h.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: h.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: h.oneOfType([h.number, h.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: h.oneOfType([h.number, h.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: h.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: h.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: h.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: h.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: h.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: h.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: h.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: h.oneOfType([h.number, h.string]),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: h.shape({
    input: h.object,
    notchedOutline: h.oneOfType([h.func, h.object]),
    root: h.object
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: h.shape({
    input: h.elementType,
    notchedOutline: h.elementType,
    root: h.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: h.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types).
   * @default 'text'
   */
  type: h.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: h.any
});
jy.muiName = "Input";
function YT(e) {
  return Mt("MuiSelect", e);
}
const hs = xt("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var RO;
const BY = xe(UT, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${hs.select}`]: t.select
      },
      {
        [`&.${hs.select}`]: t[n.variant]
      },
      {
        [`&.${hs.error}`]: t.error
      },
      {
        [`&.${hs.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${hs.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), zY = xe(HT, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${It(n.variant)}`], n.open && t.iconOpen];
  }
})({}), WY = xe("input", {
  shouldForwardProp: (e) => r_(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function IO(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function VY(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const UY = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: o,
    error: a
  } = e, s = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${It(n)}`, o && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return $t(s, YT, t);
}, GT = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const {
    "aria-describedby": r,
    "aria-label": i,
    autoFocus: o,
    autoWidth: a,
    children: s,
    className: l,
    defaultOpen: c,
    defaultValue: u,
    disabled: d,
    displayEmpty: f,
    error: p = !1,
    IconComponent: g,
    inputRef: m,
    labelId: v,
    MenuProps: y = {},
    multiple: S,
    name: x,
    onBlur: b,
    onChange: w,
    onClose: E,
    onFocus: C,
    onOpen: A,
    open: k,
    readOnly: R,
    renderValue: M,
    required: P,
    SelectDisplayProps: D = {},
    tabIndex: j,
    // catching `type` from Input which makes no sense for SelectInput
    type: N,
    value: $,
    variant: F = "standard",
    ...q
  } = t, [B, L] = Vh({
    controlled: $,
    default: u,
    name: "Select"
  }), [Y, K] = Vh({
    controlled: k,
    default: c,
    name: "Select"
  }), te = _.useRef(null), J = _.useRef(null), [Q, ne] = _.useState(null), {
    current: re
  } = _.useRef(k != null), [ie, U] = _.useState(), H = Kt(n, m), Z = _.useCallback((G) => {
    J.current = G, G && ne(G);
  }, []), T = Q?.parentNode;
  _.useImperativeHandle(H, () => ({
    focus: () => {
      J.current.focus();
    },
    node: te.current,
    value: B
  }), [B]), _.useEffect(() => {
    c && Y && Q && !re && (U(a ? null : T.clientWidth), J.current.focus());
  }, [Q, a]), _.useEffect(() => {
    o && J.current.focus();
  }, [o]), _.useEffect(() => {
    if (!v)
      return;
    const G = Un(J.current).getElementById(v);
    if (G) {
      const se = () => {
        getSelection().isCollapsed && J.current.focus();
      };
      return G.addEventListener("click", se), () => {
        G.removeEventListener("click", se);
      };
    }
  }, [v]);
  const de = (G, se) => {
    G ? A && A(se) : E && E(se), re || (U(a ? null : T.clientWidth), K(G));
  }, ee = (G) => {
    G.button === 0 && (G.preventDefault(), J.current.focus(), de(!0, G));
  }, he = (G) => {
    de(!1, G);
  }, be = _.Children.toArray(s), Se = (G) => {
    const se = be.find((fe) => fe.props.value === G.target.value);
    se !== void 0 && (L(se.props.value), w && w(G, se));
  }, Ce = (G) => (se) => {
    let fe;
    if (se.currentTarget.hasAttribute("tabindex")) {
      if (S) {
        fe = Array.isArray(B) ? B.slice() : [];
        const Xe = B.indexOf(G.props.value);
        Xe === -1 ? fe.push(G.props.value) : fe.splice(Xe, 1);
      } else
        fe = G.props.value;
      if (G.props.onClick && G.props.onClick(se), B !== fe && (L(fe), w)) {
        const Xe = se.nativeEvent || se, st = new Xe.constructor(Xe.type, Xe);
        Object.defineProperty(st, "target", {
          writable: !0,
          value: {
            value: fe,
            name: x
          }
        }), w(st, G);
      }
      S || de(!1, se);
    }
  }, nt = (G) => {
    R || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(G.key) && (G.preventDefault(), de(!0, G));
  }, Ke = Q !== null && Y, Te = (G) => {
    !Ke && b && (Object.defineProperty(G, "target", {
      writable: !0,
      value: {
        value: B,
        name: x
      }
    }), b(G));
  };
  delete q["aria-invalid"];
  let ue, jt;
  const at = [];
  let on = !1, Zt = !1;
  (ed({
    value: B
  }) || f) && (M ? ue = M(B) : on = !0);
  const an = be.map((G) => {
    if (!/* @__PURE__ */ _.isValidElement(G))
      return null;
    process.env.NODE_ENV !== "production" && Fi.isFragment(G) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let se;
    if (S) {
      if (!Array.isArray(B))
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : $r(2));
      se = B.some((fe) => IO(fe, G.props.value)), se && on && at.push(G.props.children);
    } else
      se = IO(B, G.props.value), se && on && (jt = G.props.children);
    return se && (Zt = !0), /* @__PURE__ */ _.cloneElement(G, {
      "aria-selected": se ? "true" : "false",
      onClick: Ce(G),
      onKeyUp: (fe) => {
        fe.key === " " && fe.preventDefault(), G.props.onKeyUp && G.props.onKeyUp(fe);
      },
      role: "option",
      selected: se,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": G.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  process.env.NODE_ENV !== "production" && _.useEffect(() => {
    if (!Zt && !S && B !== "") {
      const G = be.map((se) => se.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${B}\` for the select ${x ? `(name="${x}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${G.filter((se) => se != null).map((se) => `\`${se}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [Zt, be, S, x, B]), on && (S ? at.length === 0 ? ue = null : ue = at.reduce((G, se, fe) => (G.push(se), fe < at.length - 1 && G.push(", "), G), []) : ue = jt);
  let xn = ie;
  !a && re && Q && (xn = T.clientWidth);
  let zt;
  typeof j < "u" ? zt = j : zt = d ? null : 0;
  const wn = D.id || (x ? `mui-component-select-${x}` : void 0), ge = {
    ...t,
    variant: F,
    value: B,
    open: Ke,
    error: p
  }, sn = UY(ge), Wt = {
    ...y.PaperProps,
    ...typeof y.slotProps?.paper == "function" ? y.slotProps.paper(ge) : y.slotProps?.paper
  }, W = {
    ...y.MenuListProps,
    ...typeof y.slotProps?.list == "function" ? y.slotProps.list(ge) : y.slotProps?.list
  }, ae = GE();
  return /* @__PURE__ */ O.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ O.jsx(BY, {
      as: "div",
      ref: Z,
      tabIndex: zt,
      role: "combobox",
      "aria-controls": Ke ? ae : void 0,
      "aria-disabled": d ? "true" : void 0,
      "aria-expanded": Ke ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": i,
      "aria-labelledby": [v, wn].filter(Boolean).join(" ") || void 0,
      "aria-describedby": r,
      "aria-required": P ? "true" : void 0,
      "aria-invalid": p ? "true" : void 0,
      onKeyDown: nt,
      onMouseDown: d || R ? null : ee,
      onBlur: Te,
      onFocus: C,
      ...D,
      ownerState: ge,
      className: ce(D.className, sn.select, l),
      id: wn,
      children: VY(ue) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        RO || (RO = /* @__PURE__ */ O.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : ue
    }), /* @__PURE__ */ O.jsx(WY, {
      "aria-invalid": p,
      value: Array.isArray(B) ? B.join(",") : B,
      name: x,
      ref: te,
      "aria-hidden": !0,
      onChange: Se,
      tabIndex: -1,
      disabled: d,
      className: sn.nativeInput,
      autoFocus: o,
      required: P,
      ...q,
      ownerState: ge
    }), /* @__PURE__ */ O.jsx(zY, {
      as: g,
      className: sn.icon,
      ownerState: ge
    }), /* @__PURE__ */ O.jsx(VT, {
      id: `menu-${x || ""}`,
      anchorEl: T,
      open: Ke,
      onClose: he,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...y,
      slotProps: {
        ...y.slotProps,
        list: {
          "aria-labelledby": v,
          role: "listbox",
          "aria-multiselectable": S ? "true" : void 0,
          disableListWrap: !0,
          id: ae,
          ...W
        },
        paper: {
          ...Wt,
          style: {
            minWidth: xn,
            ...Wt != null ? Wt.style : null
          }
        }
      },
      children: an
    })]
  });
});
process.env.NODE_ENV !== "production" && (GT.propTypes = {
  /**
   * @ignore
   */
  "aria-describedby": h.string,
  /**
   * @ignore
   */
  "aria-label": h.string,
  /**
   * @ignore
   */
  autoFocus: h.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: h.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * The CSS class name of the select element.
   */
  className: h.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: h.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: h.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: h.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: h.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: h.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: h.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: Yr,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: h.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: h.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: h.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: h.string,
  /**
   * @ignore
   */
  onBlur: h.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: h.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: h.func,
  /**
   * @ignore
   */
  onFocus: h.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: h.func,
  /**
   * If `true`, the component is shown.
   */
  open: h.bool,
  /**
   * @ignore
   */
  readOnly: h.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: h.func,
  /**
   * If `true`, the component is required.
   */
  required: h.bool,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: h.object,
  /**
   * @ignore
   */
  tabIndex: h.oneOfType([h.number, h.string]),
  /**
   * @ignore
   */
  type: h.any,
  /**
   * The input value.
   */
  value: h.any,
  /**
   * The variant to use.
   */
  variant: h.oneOf(["standard", "outlined", "filled"])
});
const HY = (e) => {
  const {
    classes: t
  } = e, r = $t({
    root: ["root"]
  }, YT, t);
  return {
    ...t,
    ...r
  };
}, Ny = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (e) => Hr(e) && e !== "variant"
}, KY = xe(ky, Ny)(""), qY = xe(jy, Ny)(""), YY = xe(Ty, Ny)(""), Dy = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: i = !1,
    children: o,
    classes: a = {},
    className: s,
    defaultOpen: l = !1,
    displayEmpty: c = !1,
    IconComponent: u = Nq,
    id: d,
    input: f,
    inputProps: p,
    label: g,
    labelId: m,
    MenuProps: v,
    multiple: y = !1,
    native: S = !1,
    onClose: x,
    onOpen: b,
    open: w,
    renderValue: E,
    SelectDisplayProps: C,
    variant: A = "outlined",
    ...k
  } = r, R = S ? KT : GT, M = Ay(), P = Cy({
    props: r,
    muiFormControl: M,
    states: ["variant", "error"]
  }), D = P.variant || A, j = {
    ...r,
    variant: D,
    classes: a
  }, N = HY(j), {
    root: $,
    ...F
  } = N, q = f || {
    standard: /* @__PURE__ */ O.jsx(KY, {
      ownerState: j
    }),
    outlined: /* @__PURE__ */ O.jsx(qY, {
      label: g,
      ownerState: j
    }),
    filled: /* @__PURE__ */ O.jsx(YY, {
      ownerState: j
    })
  }[D], B = Kt(n, Ga(q));
  return /* @__PURE__ */ O.jsx(_.Fragment, {
    children: /* @__PURE__ */ _.cloneElement(q, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: R,
      inputProps: {
        children: o,
        error: P.error,
        IconComponent: u,
        variant: D,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: y,
        ...S ? {
          id: d
        } : {
          autoWidth: i,
          defaultOpen: l,
          displayEmpty: c,
          labelId: m,
          MenuProps: v,
          onClose: x,
          onOpen: b,
          open: w,
          renderValue: E,
          SelectDisplayProps: {
            id: d,
            ...C
          }
        },
        ...p,
        classes: p ? fn(F, p.classes) : F,
        ...f ? f.props.inputProps : {}
      },
      ...(y && S || c) && D === "outlined" ? {
        notched: !0
      } : {},
      ref: B,
      className: ce(q.props.className, s, N.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!f && {
        variant: D
      },
      ...k
    })
  });
});
process.env.NODE_ENV !== "production" && (Dy.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: h.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: h.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: h.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: h.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   *  When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: h.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: h.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: h.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: h.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: h.object,
  /**
   * See [OutlinedInput#label](https://mui.com/material-ui/api/outlined-input/#props)
   */
  label: h.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: h.string,
  /**
   * Props applied to the [`Menu`](https://mui.com/material-ui/api/menu/) element.
   */
  MenuProps: h.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: h.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: h.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<Value>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: h.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapses).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: h.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: h.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: h.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: h.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: h.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: h.oneOfType([h.oneOf([""]), h.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: h.oneOf(["filled", "outlined", "standard"])
});
Dy.muiName = "Select";
function GY(e) {
  return Mt("MuiTooltip", e);
}
const vt = xt("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function XY(e) {
  return Math.round(e * 1e5) / 1e5;
}
const ZY = (e) => {
  const {
    classes: t,
    disableInteractive: n,
    arrow: r,
    touch: i,
    placement: o
  } = e, a = {
    popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
    tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${It(o.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return $t(a, GY, t);
}, JY = xe(Py, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose];
  }
})(hn(({
  theme: e
}) => ({
  zIndex: (e.vars || e).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open: t
    }) => !t,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${vt.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${vt.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${vt.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${vt.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${vt.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${vt.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${vt.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${vt.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
}))), QY = xe("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${It(n.placement.split("-")[0])}`]];
  }
})(hn(({
  theme: e
}) => ({
  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : e.alpha(e.palette.grey[700], 0.92),
  borderRadius: (e.vars || e).shape.borderRadius,
  color: (e.vars || e).palette.common.white,
  fontFamily: e.typography.fontFamily,
  padding: "4px 8px",
  fontSize: e.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: e.typography.fontWeightMedium,
  [`.${vt.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${vt.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${vt.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${vt.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      padding: "8px 16px",
      fontSize: e.typography.pxToRem(14),
      lineHeight: `${XY(16 / 14)}em`,
      fontWeight: e.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl,
    style: {
      [`.${vt.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${vt.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl && t.touch,
    style: {
      [`.${vt.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${vt.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl,
    style: {
      [`.${vt.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${vt.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl && t.touch,
    style: {
      [`.${vt.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${vt.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${vt.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${vt.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
}))), eG = xe("span", {
  name: "MuiTooltip",
  slot: "Arrow"
})(hn(({
  theme: e
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: e.vars ? e.vars.palette.Tooltip.bg : e.alpha(e.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let Ac = !1;
const $O = new ff();
let ms = {
  x: 0,
  y: 0
};
function Tc(e, t) {
  return (n, ...r) => {
    t && t(n, ...r), e(n, ...r);
  };
}
const Um = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = qt({
    props: t,
    name: "MuiTooltip"
  }), {
    arrow: i = !1,
    children: o,
    classes: a,
    components: s = {},
    componentsProps: l = {},
    describeChild: c = !1,
    disableFocusListener: u = !1,
    disableHoverListener: d = !1,
    disableInteractive: f = !1,
    disableTouchListener: p = !1,
    enterDelay: g = 100,
    enterNextDelay: m = 0,
    enterTouchDelay: v = 700,
    followCursor: y = !1,
    id: S,
    leaveDelay: x = 0,
    leaveTouchDelay: b = 1500,
    onClose: w,
    onOpen: E,
    open: C,
    placement: A = "bottom",
    PopperComponent: k,
    PopperProps: R = {},
    slotProps: M = {},
    slots: P = {},
    title: D,
    TransitionComponent: j,
    TransitionProps: N,
    ...$
  } = r, F = /* @__PURE__ */ _.isValidElement(o) ? o : /* @__PURE__ */ O.jsx("span", {
    children: o
  }), q = Td(), B = mg(), [L, Y] = _.useState(), [K, te] = _.useState(null), J = _.useRef(!1), Q = f || y, ne = fa(), re = fa(), ie = fa(), U = fa(), [H, Z] = Vh({
    controlled: C,
    default: !1,
    name: "Tooltip",
    state: "open"
  });
  let T = H;
  if (process.env.NODE_ENV !== "production") {
    const {
      current: ve
    } = _.useRef(C !== void 0);
    _.useEffect(() => {
      L && L.disabled && !ve && D !== "" && L.tagName.toLowerCase() === "button" && console.warn(["MUI: You are providing a disabled `button` child to the Tooltip component.", "A disabled element does not fire events.", "Tooltip needs to listen to the child element's events to display the title.", "", "Add a simple wrapper element, such as a `span`."].join(`
`));
    }, [D, L, ve]);
  }
  const de = GE(S), ee = _.useRef(), he = ci(() => {
    ee.current !== void 0 && (document.body.style.WebkitUserSelect = ee.current, ee.current = void 0), U.clear();
  });
  _.useEffect(() => he, [he]);
  const be = (ve) => {
    $O.clear(), Ac = !0, Z(!0), E && !T && E(ve);
  }, Se = ci(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (ve) => {
      $O.start(800 + x, () => {
        Ac = !1;
      }), Z(!1), w && T && w(ve), ne.start(q.transitions.duration.shortest, () => {
        J.current = !1;
      });
    }
  ), Ce = (ve) => {
    J.current && ve.type !== "touchstart" || (L && L.removeAttribute("title"), re.clear(), ie.clear(), g || Ac && m ? re.start(Ac ? m : g, () => {
      be(ve);
    }) : be(ve));
  }, nt = (ve) => {
    re.clear(), ie.start(x, () => {
      Se(ve);
    });
  }, [, Ke] = _.useState(!1), Te = (ve) => {
    Xu(ve.target) || (Ke(!1), nt(ve));
  }, ue = (ve) => {
    L || Y(ve.currentTarget), Xu(ve.target) && (Ke(!0), Ce(ve));
  }, jt = (ve) => {
    J.current = !0;
    const mn = F.props;
    mn.onTouchStart && mn.onTouchStart(ve);
  }, at = (ve) => {
    jt(ve), ie.clear(), ne.clear(), he(), ee.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", U.start(v, () => {
      document.body.style.WebkitUserSelect = ee.current, Ce(ve);
    });
  }, on = (ve) => {
    F.props.onTouchEnd && F.props.onTouchEnd(ve), he(), ie.start(b, () => {
      Se(ve);
    });
  };
  _.useEffect(() => {
    if (!T)
      return;
    function ve(mn) {
      mn.key === "Escape" && Se(mn);
    }
    return document.addEventListener("keydown", ve), () => {
      document.removeEventListener("keydown", ve);
    };
  }, [Se, T]);
  const Zt = Kt(Ga(F), Y, n);
  !D && D !== 0 && (T = !1);
  const an = _.useRef(), xn = (ve) => {
    const mn = F.props;
    mn.onMouseMove && mn.onMouseMove(ve), ms = {
      x: ve.clientX,
      y: ve.clientY
    }, an.current && an.current.update();
  }, zt = {}, wn = typeof D == "string";
  c ? (zt.title = !T && wn && !d ? D : null, zt["aria-describedby"] = T ? de : null) : (zt["aria-label"] = wn ? D : null, zt["aria-labelledby"] = T && !wn ? de : null);
  const ge = {
    ...zt,
    ...$,
    ...F.props,
    className: ce($.className, F.props.className),
    onTouchStart: jt,
    ref: Zt,
    ...y ? {
      onMouseMove: xn
    } : {}
  };
  process.env.NODE_ENV !== "production" && (ge["data-mui-internal-clone-element"] = !0, _.useEffect(() => {
    L && !L.getAttribute("data-mui-internal-clone-element") && console.error(["MUI: The `children` component of the Tooltip is not forwarding its props correctly.", "Please make sure that props are spread on the same element that the ref is applied to."].join(`
`));
  }, [L]));
  const sn = {};
  p || (ge.onTouchStart = at, ge.onTouchEnd = on), d || (ge.onMouseOver = Tc(Ce, ge.onMouseOver), ge.onMouseLeave = Tc(nt, ge.onMouseLeave), Q || (sn.onMouseOver = Ce, sn.onMouseLeave = nt)), u || (ge.onFocus = Tc(ue, ge.onFocus), ge.onBlur = Tc(Te, ge.onBlur), Q || (sn.onFocus = ue, sn.onBlur = Te)), process.env.NODE_ENV !== "production" && F.props.title && console.error(["MUI: You have provided a `title` prop to the child of <Tooltip />.", `Remove this title prop \`${F.props.title}\` or the Tooltip component.`].join(`
`));
  const Wt = {
    ...r,
    isRtl: B,
    arrow: i,
    disableInteractive: Q,
    placement: A,
    PopperComponentProp: k,
    touch: J.current
  }, W = typeof M.popper == "function" ? M.popper(Wt) : M.popper, ae = _.useMemo(() => {
    let ve = [{
      name: "arrow",
      enabled: !!K,
      options: {
        element: K,
        padding: 4
      }
    }];
    return R.popperOptions?.modifiers && (ve = ve.concat(R.popperOptions.modifiers)), W?.popperOptions?.modifiers && (ve = ve.concat(W.popperOptions.modifiers)), {
      ...R.popperOptions,
      ...W?.popperOptions,
      modifiers: ve
    };
  }, [K, R.popperOptions, W?.popperOptions]), G = ZY(Wt), se = typeof M.transition == "function" ? M.transition(Wt) : M.transition, fe = {
    slots: {
      popper: s.Popper,
      transition: s.Transition ?? j,
      tooltip: s.Tooltip,
      arrow: s.Arrow,
      ...P
    },
    slotProps: {
      arrow: M.arrow ?? l.arrow,
      popper: {
        ...R,
        ...W ?? l.popper
      },
      // resolvedPopperProps can be spread because it's already an object
      tooltip: M.tooltip ?? l.tooltip,
      transition: {
        ...N,
        ...se ?? l.transition
      }
    }
  }, [Xe, st] = An("popper", {
    elementType: JY,
    externalForwardedProps: fe,
    ownerState: Wt,
    className: ce(G.popper, R?.className)
  }), [Xn, Ci] = An("transition", {
    elementType: sl,
    externalForwardedProps: fe,
    ownerState: Wt
  }), [Zn, ro] = An("tooltip", {
    elementType: QY,
    className: G.tooltip,
    externalForwardedProps: fe,
    ownerState: Wt
  }), [Gr, Sr] = An("arrow", {
    elementType: eG,
    className: G.arrow,
    externalForwardedProps: fe,
    ownerState: Wt,
    ref: te
  });
  return /* @__PURE__ */ O.jsxs(_.Fragment, {
    children: [/* @__PURE__ */ _.cloneElement(F, ge), /* @__PURE__ */ O.jsx(Xe, {
      as: k ?? Py,
      placement: A,
      anchorEl: y ? {
        getBoundingClientRect: () => ({
          top: ms.y,
          left: ms.x,
          right: ms.x,
          bottom: ms.y,
          width: 0,
          height: 0
        })
      } : L,
      popperRef: an,
      open: L ? T : !1,
      id: de,
      transition: !0,
      ...sn,
      ...st,
      popperOptions: ae,
      children: ({
        TransitionProps: ve
      }) => /* @__PURE__ */ O.jsx(Xn, {
        timeout: q.transitions.duration.shorter,
        ...ve,
        ...Ci,
        children: /* @__PURE__ */ O.jsxs(Zn, {
          ...ro,
          children: [D, i ? /* @__PURE__ */ O.jsx(Gr, {
            ...Sr
          }) : null]
        })
      })
    })]
  });
});
process.env.NODE_ENV !== "production" && (Um.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, adds an arrow to the tooltip.
   * @default false
   */
  arrow: h.bool,
  /**
   * Tooltip reference element.
   */
  children: Xa.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: h.object,
  /**
   * @ignore
   */
  className: h.string,
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: h.shape({
    Arrow: h.elementType,
    Popper: h.elementType,
    Tooltip: h.elementType,
    Transition: h.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: h.shape({
    arrow: h.object,
    popper: h.object,
    tooltip: h.object,
    transition: h.object
  }),
  /**
   * Set to `true` if the `title` acts as an accessible description.
   * By default the `title` acts as an accessible label for the child.
   * @default false
   */
  describeChild: h.bool,
  /**
   * Do not respond to focus-visible events.
   * @default false
   */
  disableFocusListener: h.bool,
  /**
   * Do not respond to hover events.
   * @default false
   */
  disableHoverListener: h.bool,
  /**
   * Makes a tooltip not interactive, i.e. it will close when the user
   * hovers over the tooltip before the `leaveDelay` is expired.
   * @default false
   */
  disableInteractive: h.bool,
  /**
   * Do not respond to long press touch events.
   * @default false
   */
  disableTouchListener: h.bool,
  /**
   * The number of milliseconds to wait before showing the tooltip.
   * This prop won't impact the enter touch delay (`enterTouchDelay`).
   * @default 100
   */
  enterDelay: h.number,
  /**
   * The number of milliseconds to wait before showing the tooltip when one was already recently opened.
   * @default 0
   */
  enterNextDelay: h.number,
  /**
   * The number of milliseconds a user must touch the element before showing the tooltip.
   * @default 700
   */
  enterTouchDelay: h.number,
  /**
   * If `true`, the tooltip follow the cursor over the wrapped element.
   * @default false
   */
  followCursor: h.bool,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: h.string,
  /**
   * The number of milliseconds to wait before hiding the tooltip.
   * This prop won't impact the leave touch delay (`leaveTouchDelay`).
   * @default 0
   */
  leaveDelay: h.number,
  /**
   * The number of milliseconds after the user stops touching an element before hiding the tooltip.
   * @default 1500
   */
  leaveTouchDelay: h.number,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onClose: h.func,
  /**
   * Callback fired when the component requests to be open.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onOpen: h.func,
  /**
   * If `true`, the component is shown.
   */
  open: h.bool,
  /**
   * Tooltip placement.
   * @default 'bottom'
   */
  placement: h.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * The component used for the popper.
   * @deprecated use the `slots.popper` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  PopperComponent: h.elementType,
  /**
   * Props applied to the [`Popper`](https://mui.com/material-ui/api/popper/) element.
   * @deprecated use the `slotProps.popper` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  PopperProps: h.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: h.shape({
    arrow: h.oneOfType([h.func, h.object]),
    popper: h.oneOfType([h.func, h.object]),
    tooltip: h.oneOfType([h.func, h.object]),
    transition: h.oneOfType([h.func, h.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: h.shape({
    arrow: h.elementType,
    popper: h.elementType,
    tooltip: h.elementType,
    transition: h.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: h.oneOfType([h.arrayOf(h.oneOfType([h.func, h.object, h.bool])), h.func, h.object]),
  /**
   * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.
   */
  title: h.node,
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @deprecated use the `slots.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  TransitionComponent: h.elementType,
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  TransitionProps: h.object
});
function tG(e) {
  return Ge({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Box_List" }, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M6.562,8.062h-2a1.5,1.5,0,0,1-1.5-1.5v-2a1.5,1.5,0,0,1,1.5-1.5h2a1.5,1.5,0,0,1,1.5,1.5v2A1.5,1.5,0,0,1,6.562,8.062Zm-2-4a.5.5,0,0,0-.5.5v2a.5.5,0,0,0,.5.5h2a.5.5,0,0,0,.5-.5v-2a.5.5,0,0,0-.5-.5Z" }, child: [] }, { tag: "path", attr: { d: "M6.562,20.938h-2a1.5,1.5,0,0,1-1.5-1.5v-2a1.5,1.5,0,0,1,1.5-1.5h2a1.5,1.5,0,0,1,1.5,1.5v2A1.5,1.5,0,0,1,6.562,20.938Zm-2-4a.5.5,0,0,0-.5.5v2a.5.5,0,0,0,.5.5h2a.5.5,0,0,0,.5-.5v-2a.5.5,0,0,0-.5-.5Z" }, child: [] }, { tag: "path", attr: { d: "M6.562,14.5h-2a1.5,1.5,0,0,1-1.5-1.5V11a1.5,1.5,0,0,1,1.5-1.5h2a1.5,1.5,0,0,1,1.5,1.5v2A1.5,1.5,0,0,1,6.562,14.5Zm-2-4a.5.5,0,0,0-.5.5v2a.5.5,0,0,0,.5.5h2a.5.5,0,0,0,.5-.5V11a.5.5,0,0,0-.5-.5Z" }, child: [] }, { tag: "path", attr: { d: "M20.438,6.062h-9a.5.5,0,0,1,0-1h9a.5.5,0,0,1,0,1Z" }, child: [] }, { tag: "path", attr: { d: "M20.438,12.5h-9a.5.5,0,0,1,0-1h9a.5.5,0,0,1,0,1Z" }, child: [] }, { tag: "path", attr: { d: "M20.438,18.935h-9a.5.5,0,1,1,0-1h9a.5.5,0,0,1,0,1Z" }, child: [] }] }] }] })(e);
}
function nG(e) {
  return Ge({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Export" }, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M5.552,20.968a2.577,2.577,0,0,1-2.5-2.73c-.012-2.153,0-4.306,0-6.459a.5.5,0,0,1,1,0c0,2.2-.032,4.4,0,6.6.016,1.107.848,1.589,1.838,1.589H18.353A1.546,1.546,0,0,0,19.825,19a3.023,3.023,0,0,0,.1-1.061V11.779h0a.5.5,0,0,1,1,0c0,2.224.085,4.465,0,6.687a2.567,2.567,0,0,1-2.67,2.5Z" }, child: [] }, { tag: "path", attr: { d: "M12.337,3.176a.455.455,0,0,0-.311-.138c-.015,0-.028,0-.043-.006s-.027,0-.041.006a.457.457,0,0,0-.312.138L7.961,6.845a.5.5,0,0,0,.707.707l2.816-2.815V15.479a.5.5,0,0,0,1,0V4.737L15.3,7.552a.5.5,0,0,0,.707-.707Z" }, child: [] }] }] }] })(e);
}
function rG(e) {
  return Ge({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Warning" }, child: [{ tag: "g", attr: {}, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M12.5,8.752a.5.5,0,0,0-1,0h0v6a.5.5,0,0,0,1,0Z" }, child: [] }, { tag: "circle", attr: { cx: "11.999", cy: "16.736", r: "0.5" }, child: [] }] }, { tag: "path", attr: { d: "M18.642,20.934H5.385A2.5,2.5,0,0,1,3.163,17.29L9.792,4.421a2.5,2.5,0,0,1,4.444,0L20.865,17.29a2.5,2.5,0,0,1-2.223,3.644ZM12.014,4.065a1.478,1.478,0,0,0-1.334.814L4.052,17.748a1.5,1.5,0,0,0,1.333,2.186H18.642a1.5,1.5,0,0,0,1.334-2.186L13.348,4.879A1.478,1.478,0,0,0,12.014,4.065Z" }, child: [] }] }] }] })(e);
}
const iG = ou(Dy)(() => ({
  width: "fit-content",
  maxWidth: "100px",
  height: "28px",
  padding: "0 6px",
  display: "flex",
  fontSize: "12px",
  alignItems: "center",
  "& .MuiSelect-select": { padding: 0 },
  // Normal border
  "& .MuiOutlinedInput-notchedOutline": {
    borderColor: "#C6C6C6",
    transition: "all 0.2s ease"
  },
  // Hover state
  "&:hover .MuiOutlinedInput-notchedOutline": {
    borderColor: "#B084CC"
  },
  // Focus state (main customization)
  "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
    borderColor: "#884EA7 !important",
    boxShadow: "0 0 0 3px rgba(136, 78, 167, 0.2)"
  }
}));
function XT({
  widgetId: e,
  options: t = [],
  defaultValue: n = "all",
  onFilterChange: r = () => {
  },
  onExport: i = () => {
  }
}) {
  const o = sessionStorage.getItem(`${e}_community_id`), [a, s] = Rt(o || n), l = (u) => {
    const d = u.target.value;
    s(d), d === "all" ? sessionStorage.removeItem(`${e}_community_id`) : sessionStorage.setItem(`${e}_community_id`, d), r(d, e);
  }, c = () => {
    sessionStorage.setItem(`${e}_export`, "true"), i(e);
  };
  return /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-2", children: [
    /* @__PURE__ */ O.jsx(Um, { title: "Select a community", children: /* @__PURE__ */ O.jsx($T, { size: "small", children: /* @__PURE__ */ O.jsxs(iG, { value: a, onChange: l, children: [
      /* @__PURE__ */ O.jsx(Vm, { value: "all", sx: { fontWeight: 600 }, children: "All" }),
      t?.map((u) => /* @__PURE__ */ O.jsx(Vm, { value: u.id, children: u.name }, u.id))
    ] }) }) }),
    /* @__PURE__ */ O.jsx(Um, { title: "Export CSV for this widget", children: /* @__PURE__ */ O.jsx(
      "button",
      {
        onClick: c,
        className: "px-3 py-2 bg-[#FBF5FF] rounded cursor-pointer",
        children: /* @__PURE__ */ O.jsx(nG, { className: "stroke-[#884EA7] stroke-[1.4]" })
      }
    ) })
  ] });
}
function Jee({ isStatic: e, data: t }) {
  const n = ["#8B5CF6", "#22C55E", "#3B82F6", "#F59E0B"], r = [
    {
      name: "Notice",
      value: Number(t?.total_notices || 0),
      color: n[0]
    },
    { name: "Post", value: Number(t?.total_topics || 0), color: n[1] },
    { name: "Poll", value: Number(t?.total_polls || 0), color: n[2] },
    {
      name: "Survey",
      value: Number(t?.total_surveys || 0),
      color: n[3]
    }
  ];
  return /* @__PURE__ */ O.jsx(
    Vo,
    {
      title: "Engagement",
      period: "This Month",
      icon: /* @__PURE__ */ O.jsx(l_, { className: "!text-[24px] text-[#DBB467]" }),
      className: `${e && "max-h-[303px]"} h-[303px]`,
      actionButtons: /* @__PURE__ */ O.jsx(
        XT,
        {
          widgetId: "engagement",
          options: t?.communities,
          onFilterChange: (i, o) => console.log(i, o),
          onExport: (i) => console.log("Export triggered for", i)
        }
      ),
      children: /* @__PURE__ */ O.jsx("div", { className: "w-full h-[235px]", children: /* @__PURE__ */ O.jsx(Yo, { width: "100%", height: "100%", children: /* @__PURE__ */ O.jsxs(
        CH,
        {
          data: r,
          layout: "vertical",
          margin: { top: 4, right: 8, left: 0, bottom: 0 },
          children: [
            /* @__PURE__ */ O.jsx(
              cf,
              {
                stroke: "#e5e7eb",
                strokeDasharray: "3 3",
                horizontal: !1
              }
            ),
            /* @__PURE__ */ O.jsx(
              rl,
              {
                type: "category",
                dataKey: "name",
                width: 40,
                axisLine: !1,
                tickLine: !1,
                tick: {
                  fontSize: 10,
                  lineHeight: 14,
                  fill: "#121212",
                  fontWeight: 400
                }
              }
            ),
            /* @__PURE__ */ O.jsx(
              uf,
              {
                type: "number",
                axisLine: !1,
                tickLine: !1,
                tick: {
                  fontSize: 10,
                  lineHeight: 14,
                  fill: "#64748B",
                  fontWeight: 400
                }
              }
            ),
            /* @__PURE__ */ O.jsx(
              qo,
              {
                content: /* @__PURE__ */ O.jsx(Sl, {}),
                cursor: { fill: "transparent" }
              }
            ),
            /* @__PURE__ */ O.jsx(AA, { dataKey: "value", barSize: 40, isAnimationActive: !1, children: r.map((i, o) => /* @__PURE__ */ O.jsx(zr, { fill: n[o] }, i.name)) })
          ]
        }
      ) }) })
    }
  );
}
function Qee({ isStatic: e, data: t }) {
  const n = Number(t?.totalBookings || 0), r = Number(t?.averageUtilizationPercentage || 0), i = Ur(() => {
    if (!t?.graph) return [];
    const { labels: s = [], bookings: l = [], utilization: c = [] } = t.graph;
    return s.map((u, d) => ({
      time: u,
      bookings: l[d] || 0,
      utilization: c[d] || 0
    }));
  }, [t]), o = (s) => ["12 AM", "6 AM", "12 PM", "6 PM", "11 PM"].includes(s) ? s : "", a = i.length ? i : Array.from({ length: 24 }, (s, l) => ({
    time: `${l % 12 || 12} ${l >= 12 ? "PM" : "AM"}`,
    bookings: 0,
    utilization: 0
  }));
  return /* @__PURE__ */ O.jsxs(
    Vo,
    {
      title: "Facilities",
      period: "Today",
      icon: /* @__PURE__ */ O.jsx(s_, { className: "!text-[24px] text-[#8B5CF6]" }),
      className: `${e && "max-h-[305px]"} h-[305px] mb-4 break-inside-avoid`,
      children: [
        /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-2 gap-[24px] mb-[16px]", children: [
          /* @__PURE__ */ O.jsxs("div", { children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] text-[#64748B]", children: "Bookings" }),
            /* @__PURE__ */ O.jsx("div", { className: "!text-[24px] font-medium text-[#8B5CF6]", children: n })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] text-[#64748B]", children: "Utilisation Rate" }),
            /* @__PURE__ */ O.jsxs("div", { className: "!text-[24px] font-medium text-[#329DFF]", children: [
              r.toFixed(2),
              "%"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "w-full h-[170px]", children: /* @__PURE__ */ O.jsx(Yo, { width: "100%", height: "100%", children: /* @__PURE__ */ O.jsxs(
          nT,
          {
            data: a,
            margin: { top: 5, right: -30, left: -35, bottom: 0 },
            children: [
              /* @__PURE__ */ O.jsx(cf, { strokeDasharray: "3 3", stroke: "#EBEBEB" }),
              /* @__PURE__ */ O.jsx(
                uf,
                {
                  dataKey: "time",
                  interval: 0,
                  tickFormatter: o,
                  tick: {
                    fontSize: 10,
                    fill: "#121212",
                    fontWeight: 400
                  },
                  axisLine: !1,
                  tickLine: !1,
                  minTickGap: 0
                }
              ),
              /* @__PURE__ */ O.jsx(
                rl,
                {
                  yAxisId: "left",
                  tick: { fontSize: 10, fill: "#64748B" },
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ O.jsx(
                rl,
                {
                  yAxisId: "right",
                  orientation: "right",
                  domain: [0, 100],
                  ticks: [0, 20, 40, 60, 80, 100],
                  tickFormatter: (s) => `${s}%`,
                  tick: { fontSize: 10, fill: "#64748B" },
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ O.jsx(qo, { content: /* @__PURE__ */ O.jsx(Sl, {}) }),
              /* @__PURE__ */ O.jsx(
                va,
                {
                  yAxisId: "left",
                  type: "monotone",
                  dataKey: "bookings",
                  name: "Bookings",
                  stroke: "#8B5CF6",
                  strokeWidth: 2,
                  dot: !1
                }
              ),
              /* @__PURE__ */ O.jsx(
                va,
                {
                  yAxisId: "right",
                  type: "monotone",
                  dataKey: "utilization",
                  name: "Utilization Rate",
                  stroke: "#329DFF",
                  strokeWidth: 2,
                  dot: !1,
                  strokeDasharray: "2 4"
                }
              )
            ]
          }
        ) }) })
      ]
    }
  );
}
function ete({ data: e }) {
  const t = e?.incomeSummary || {}, n = e?.expenditureSummary || {}, r = ["AED", "USD", "EUR"], i = ["Rs", "INR", ""];
  function o(s) {
    if (s == null || isNaN(s)) return "0";
    const l = Number(s), c = Math.abs(l), u = l < 0 ? "-" : "";
    return c >= 1e9 ? u + (c / 1e9).toFixed(c % 1e9 === 0 ? 0 : 2) + "B" : c >= 1e6 ? u + (c / 1e6).toFixed(c % 1e6 === 0 ? 0 : 2) + "M" : c >= 1e3 ? u + (c / 1e3).toFixed(c % 1e3 === 0 ? 0 : 2) + "K" : u + c.toFixed(c % 1 === 0 ? 0 : 2);
  }
  function a(s, l) {
    return l ? i.includes(l) ? `${l} ${o(s)}` : r.includes(l) ? `${o(s)} ${l}` : `${o(s)} ${l}` : o(s);
  }
  return /* @__PURE__ */ O.jsx(
    Vo,
    {
      title: "Income",
      period: "This Month",
      icon: /* @__PURE__ */ O.jsx(a0, { className: "!text-[24px] text-green-600" }),
      className: "!gap-[16px] break-inside-avoid h-[232px] overflow-hidden",
      actionButtons: /* @__PURE__ */ O.jsx(
        XT,
        {
          widgetId: "finance_summary",
          options: e?.communities,
          onFilterChange: (s, l) => console.log(s, l),
          onExport: (s) => console.log("Export triggered for", s)
        }
      ),
      children: /* @__PURE__ */ O.jsxs("div", { children: [
        /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-4 !text-[12px] text-[#64748B] mb-2", children: [
          /* @__PURE__ */ O.jsx("div", { children: "Opening" }),
          /* @__PURE__ */ O.jsx("div", { children: "Income" }),
          /* @__PURE__ */ O.jsx("div", { children: "Collection" }),
          /* @__PURE__ */ O.jsx("div", { children: "Closing" })
        ] }),
        /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-4 !text-[12px] font-medium text-[#121212] mb-2", children: [
          /* @__PURE__ */ O.jsx("div", { children: a(t.opening_balance, t?.currency_type) }),
          /* @__PURE__ */ O.jsx("div", { children: a(t.income, t?.currency_type) }),
          /* @__PURE__ */ O.jsx("div", { children: a(t.collection, t?.currency_type) }),
          /* @__PURE__ */ O.jsx("div", { children: a(t.closing_balance, t?.currency_type) })
        ] }),
        /* @__PURE__ */ O.jsx("hr", { className: "my-4 border-t border-dashed border-gray-300" }),
        /* @__PURE__ */ O.jsx("div", { className: "flex items-center justify-between", children: /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[12px]", children: [
          /* @__PURE__ */ O.jsx(a0, { className: "!text-[24px] text-red-600" }),
          /* @__PURE__ */ O.jsx("div", { className: "!my-0 !font-medium !text-[16px] !leading-[20px] !text-[#121212]", children: "Expenditure" })
        ] }) }),
        /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-4 !text-[12px] text-[#64748B] mt-4 mb-2", children: [
          /* @__PURE__ */ O.jsx("div", { children: "Opening" }),
          /* @__PURE__ */ O.jsx("div", { children: "Expenditure" }),
          /* @__PURE__ */ O.jsx("div", { children: "Payment" }),
          /* @__PURE__ */ O.jsx("div", { children: "Outstanding" })
        ] }),
        /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-4 !text-[12px] font-medium text-[#121212]", children: [
          /* @__PURE__ */ O.jsx("div", { children: a(
            n.opening_balance,
            n?.currency_type
          ) }),
          /* @__PURE__ */ O.jsx("div", { children: a(n.expenditure, n?.currency_type) }),
          /* @__PURE__ */ O.jsx("div", { children: a(n.payment, n?.currency_type) }),
          /* @__PURE__ */ O.jsx("div", { children: a(n.outstanding, n?.currency_type) })
        ] })
      ] })
    }
  );
}
var oG = "tippy-box", ZT = "tippy-content", aG = "tippy-backdrop", JT = "tippy-arrow", QT = "tippy-svg-arrow", vo = {
  passive: !0,
  capture: !0
}, ek = function() {
  return document.body;
};
function sG(e, t) {
  return {}.hasOwnProperty.call(e, t);
}
function yh(e, t, n) {
  if (Array.isArray(e)) {
    var r = e[t];
    return r ?? (Array.isArray(n) ? n[t] : n);
  }
  return e;
}
function Ry(e, t) {
  var n = {}.toString.call(e);
  return n.indexOf("[object") === 0 && n.indexOf(t + "]") > -1;
}
function tk(e, t) {
  return typeof e == "function" ? e.apply(void 0, t) : e;
}
function LO(e, t) {
  if (t === 0)
    return e;
  var n;
  return function(r) {
    clearTimeout(n), n = setTimeout(function() {
      e(r);
    }, t);
  };
}
function lG(e, t) {
  var n = Object.assign({}, e);
  return t.forEach(function(r) {
    delete n[r];
  }), n;
}
function cG(e) {
  return e.split(/\s+/).filter(Boolean);
}
function ua(e) {
  return [].concat(e);
}
function FO(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function uG(e) {
  return e.filter(function(t, n) {
    return e.indexOf(t) === n;
  });
}
function dG(e) {
  return e.split("-")[0];
}
function rd(e) {
  return [].slice.call(e);
}
function BO(e) {
  return Object.keys(e).reduce(function(t, n) {
    return e[n] !== void 0 && (t[n] = e[n]), t;
  }, {});
}
function $s() {
  return document.createElement("div");
}
function ll(e) {
  return ["Element", "Fragment"].some(function(t) {
    return Ry(e, t);
  });
}
function fG(e) {
  return Ry(e, "NodeList");
}
function pG(e) {
  return Ry(e, "MouseEvent");
}
function hG(e) {
  return !!(e && e._tippy && e._tippy.reference === e);
}
function mG(e) {
  return ll(e) ? [e] : fG(e) ? rd(e) : Array.isArray(e) ? e : rd(document.querySelectorAll(e));
}
function bh(e, t) {
  e.forEach(function(n) {
    n && (n.style.transitionDuration = t + "ms");
  });
}
function zO(e, t) {
  e.forEach(function(n) {
    n && n.setAttribute("data-state", t);
  });
}
function gG(e) {
  var t, n = ua(e), r = n[0];
  return r != null && (t = r.ownerDocument) != null && t.body ? r.ownerDocument : document;
}
function vG(e, t) {
  var n = t.clientX, r = t.clientY;
  return e.every(function(i) {
    var o = i.popperRect, a = i.popperState, s = i.props, l = s.interactiveBorder, c = dG(a.placement), u = a.modifiersData.offset;
    if (!u)
      return !0;
    var d = c === "bottom" ? u.top.y : 0, f = c === "top" ? u.bottom.y : 0, p = c === "right" ? u.left.x : 0, g = c === "left" ? u.right.x : 0, m = o.top - r + d > l, v = r - o.bottom - f > l, y = o.left - n + p > l, S = n - o.right - g > l;
    return m || v || y || S;
  });
}
function xh(e, t, n) {
  var r = t + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    e[r](i, n);
  });
}
function WO(e, t) {
  for (var n = t; n; ) {
    var r;
    if (e.contains(n))
      return !0;
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var Mr = {
  isTouch: !1
}, VO = 0;
function yG() {
  Mr.isTouch || (Mr.isTouch = !0, window.performance && document.addEventListener("mousemove", nk));
}
function nk() {
  var e = performance.now();
  e - VO < 20 && (Mr.isTouch = !1, document.removeEventListener("mousemove", nk)), VO = e;
}
function bG() {
  var e = document.activeElement;
  if (hG(e)) {
    var t = e._tippy;
    e.blur && !t.state.isVisible && e.blur();
  }
}
function xG() {
  document.addEventListener("touchstart", yG, vo), window.addEventListener("blur", bG);
}
var wG = typeof window < "u" && typeof document < "u", OG = wG ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function oa(e) {
  var t = e === "destroy" ? "n already-" : " ";
  return [e + "() was called on a" + t + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function UO(e) {
  var t = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return e.replace(t, " ").replace(n, "").trim();
}
function SG(e) {
  return UO(`
  %ctippy.js

  %c` + UO(e) + `

  %c This is a development-only message. It will be removed in production.
  `);
}
function rk(e) {
  return [
    SG(e),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var cl;
process.env.NODE_ENV !== "production" && EG();
function EG() {
  cl = /* @__PURE__ */ new Set();
}
function ti(e, t) {
  if (e && !cl.has(t)) {
    var n;
    cl.add(t), (n = console).warn.apply(n, rk(t));
  }
}
function Hm(e, t) {
  if (e && !cl.has(t)) {
    var n;
    cl.add(t), (n = console).error.apply(n, rk(t));
  }
}
function _G(e) {
  var t = !e, n = Object.prototype.toString.call(e) === "[object Object]" && !e.addEventListener;
  Hm(t, ["tippy() was passed", "`" + String(e) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), Hm(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var ik = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, PG = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, Wn = Object.assign({
  appendTo: ek,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, ik, PG), CG = Object.keys(Wn), AG = function(t) {
  process.env.NODE_ENV !== "production" && ak(t, []);
  var n = Object.keys(t);
  n.forEach(function(r) {
    Wn[r] = t[r];
  });
};
function ok(e) {
  var t = e.plugins || [], n = t.reduce(function(r, i) {
    var o = i.name, a = i.defaultValue;
    if (o) {
      var s;
      r[o] = e[o] !== void 0 ? e[o] : (s = Wn[o]) != null ? s : a;
    }
    return r;
  }, {});
  return Object.assign({}, e, n);
}
function TG(e, t) {
  var n = t ? Object.keys(ok(Object.assign({}, Wn, {
    plugins: t
  }))) : CG, r = n.reduce(function(i, o) {
    var a = (e.getAttribute("data-tippy-" + o) || "").trim();
    if (!a)
      return i;
    if (o === "content")
      i[o] = a;
    else
      try {
        i[o] = JSON.parse(a);
      } catch {
        i[o] = a;
      }
    return i;
  }, {});
  return r;
}
function HO(e, t) {
  var n = Object.assign({}, t, {
    content: tk(t.content, [e])
  }, t.ignoreAttributes ? {} : TG(e, t.plugins));
  return n.aria = Object.assign({}, Wn.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? t.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? t.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function ak(e, t) {
  e === void 0 && (e = {}), t === void 0 && (t = []);
  var n = Object.keys(e);
  n.forEach(function(r) {
    var i = lG(Wn, Object.keys(ik)), o = !sG(i, r);
    o && (o = t.filter(function(a) {
      return a.name === r;
    }).length === 0), ti(o, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var kG = function() {
  return "innerHTML";
};
function Km(e, t) {
  e[kG()] = t;
}
function KO(e) {
  var t = $s();
  return e === !0 ? t.className = JT : (t.className = QT, ll(e) ? t.appendChild(e) : Km(t, e)), t;
}
function qO(e, t) {
  ll(t.content) ? (Km(e, ""), e.appendChild(t.content)) : typeof t.content != "function" && (t.allowHTML ? Km(e, t.content) : e.textContent = t.content);
}
function qm(e) {
  var t = e.firstElementChild, n = rd(t.children);
  return {
    box: t,
    content: n.find(function(r) {
      return r.classList.contains(ZT);
    }),
    arrow: n.find(function(r) {
      return r.classList.contains(JT) || r.classList.contains(QT);
    }),
    backdrop: n.find(function(r) {
      return r.classList.contains(aG);
    })
  };
}
function sk(e) {
  var t = $s(), n = $s();
  n.className = oG, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var r = $s();
  r.className = ZT, r.setAttribute("data-state", "hidden"), qO(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props);
  function i(o, a) {
    var s = qm(t), l = s.box, c = s.content, u = s.arrow;
    a.theme ? l.setAttribute("data-theme", a.theme) : l.removeAttribute("data-theme"), typeof a.animation == "string" ? l.setAttribute("data-animation", a.animation) : l.removeAttribute("data-animation"), a.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof a.maxWidth == "number" ? a.maxWidth + "px" : a.maxWidth, a.role ? l.setAttribute("role", a.role) : l.removeAttribute("role"), (o.content !== a.content || o.allowHTML !== a.allowHTML) && qO(c, e.props), a.arrow ? u ? o.arrow !== a.arrow && (l.removeChild(u), l.appendChild(KO(a.arrow))) : l.appendChild(KO(a.arrow)) : u && l.removeChild(u);
  }
  return {
    popper: t,
    onUpdate: i
  };
}
sk.$$tippy = !0;
var MG = 1, kc = [], wh = [];
function jG(e, t) {
  var n = HO(e, Object.assign({}, Wn, ok(BO(t)))), r, i, o, a = !1, s = !1, l = !1, c = !1, u, d, f, p = [], g = LO(ee, n.interactiveDebounce), m, v = MG++, y = null, S = uG(n.plugins), x = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: v,
    reference: e,
    popper: $s(),
    popperInstance: y,
    props: n,
    state: x,
    plugins: S,
    // methods
    clearDelayTimeouts: Zt,
    setProps: an,
    setContent: xn,
    show: zt,
    hide: wn,
    hideWithInteractivity: ge,
    enable: at,
    disable: on,
    unmount: sn,
    destroy: Wt
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && Hm(!0, "render() function has not been supplied."), b;
  var w = n.render(b), E = w.popper, C = w.onUpdate;
  E.setAttribute("data-tippy-root", ""), E.id = "tippy-" + b.id, b.popper = E, e._tippy = b, E._tippy = b;
  var A = S.map(function(W) {
    return W.fn(b);
  }), k = e.hasAttribute("aria-expanded");
  return Z(), L(), F(), q("onCreate", [b]), n.showOnCreate && ue(), E.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), E.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && j().addEventListener("mousemove", g);
  }), b;
  function R() {
    var W = b.props.touch;
    return Array.isArray(W) ? W : [W, 0];
  }
  function M() {
    return R()[0] === "hold";
  }
  function P() {
    var W;
    return !!((W = b.props.render) != null && W.$$tippy);
  }
  function D() {
    return m || e;
  }
  function j() {
    var W = D().parentNode;
    return W ? gG(W) : document;
  }
  function N() {
    return qm(E);
  }
  function $(W) {
    return b.state.isMounted && !b.state.isVisible || Mr.isTouch || u && u.type === "focus" ? 0 : yh(b.props.delay, W ? 0 : 1, Wn.delay);
  }
  function F(W) {
    W === void 0 && (W = !1), E.style.pointerEvents = b.props.interactive && !W ? "" : "none", E.style.zIndex = "" + b.props.zIndex;
  }
  function q(W, ae, G) {
    if (G === void 0 && (G = !0), A.forEach(function(fe) {
      fe[W] && fe[W].apply(fe, ae);
    }), G) {
      var se;
      (se = b.props)[W].apply(se, ae);
    }
  }
  function B() {
    var W = b.props.aria;
    if (W.content) {
      var ae = "aria-" + W.content, G = E.id, se = ua(b.props.triggerTarget || e);
      se.forEach(function(fe) {
        var Xe = fe.getAttribute(ae);
        if (b.state.isVisible)
          fe.setAttribute(ae, Xe ? Xe + " " + G : G);
        else {
          var st = Xe && Xe.replace(G, "").trim();
          st ? fe.setAttribute(ae, st) : fe.removeAttribute(ae);
        }
      });
    }
  }
  function L() {
    if (!(k || !b.props.aria.expanded)) {
      var W = ua(b.props.triggerTarget || e);
      W.forEach(function(ae) {
        b.props.interactive ? ae.setAttribute("aria-expanded", b.state.isVisible && ae === D() ? "true" : "false") : ae.removeAttribute("aria-expanded");
      });
    }
  }
  function Y() {
    j().removeEventListener("mousemove", g), kc = kc.filter(function(W) {
      return W !== g;
    });
  }
  function K(W) {
    if (!(Mr.isTouch && (l || W.type === "mousedown"))) {
      var ae = W.composedPath && W.composedPath()[0] || W.target;
      if (!(b.props.interactive && WO(E, ae))) {
        if (ua(b.props.triggerTarget || e).some(function(G) {
          return WO(G, ae);
        })) {
          if (Mr.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          q("onClickOutside", [b, W]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), s = !0, setTimeout(function() {
          s = !1;
        }), b.state.isMounted || ne());
      }
    }
  }
  function te() {
    l = !0;
  }
  function J() {
    l = !1;
  }
  function Q() {
    var W = j();
    W.addEventListener("mousedown", K, !0), W.addEventListener("touchend", K, vo), W.addEventListener("touchstart", J, vo), W.addEventListener("touchmove", te, vo);
  }
  function ne() {
    var W = j();
    W.removeEventListener("mousedown", K, !0), W.removeEventListener("touchend", K, vo), W.removeEventListener("touchstart", J, vo), W.removeEventListener("touchmove", te, vo);
  }
  function re(W, ae) {
    U(W, function() {
      !b.state.isVisible && E.parentNode && E.parentNode.contains(E) && ae();
    });
  }
  function ie(W, ae) {
    U(W, ae);
  }
  function U(W, ae) {
    var G = N().box;
    function se(fe) {
      fe.target === G && (xh(G, "remove", se), ae());
    }
    if (W === 0)
      return ae();
    xh(G, "remove", d), xh(G, "add", se), d = se;
  }
  function H(W, ae, G) {
    G === void 0 && (G = !1);
    var se = ua(b.props.triggerTarget || e);
    se.forEach(function(fe) {
      fe.addEventListener(W, ae, G), p.push({
        node: fe,
        eventType: W,
        handler: ae,
        options: G
      });
    });
  }
  function Z() {
    M() && (H("touchstart", de, {
      passive: !0
    }), H("touchend", he, {
      passive: !0
    })), cG(b.props.trigger).forEach(function(W) {
      if (W !== "manual")
        switch (H(W, de), W) {
          case "mouseenter":
            H("mouseleave", he);
            break;
          case "focus":
            H(OG ? "focusout" : "blur", be);
            break;
          case "focusin":
            H("focusout", be);
            break;
        }
    });
  }
  function T() {
    p.forEach(function(W) {
      var ae = W.node, G = W.eventType, se = W.handler, fe = W.options;
      ae.removeEventListener(G, se, fe);
    }), p = [];
  }
  function de(W) {
    var ae, G = !1;
    if (!(!b.state.isEnabled || Se(W) || s)) {
      var se = ((ae = u) == null ? void 0 : ae.type) === "focus";
      u = W, m = W.currentTarget, L(), !b.state.isVisible && pG(W) && kc.forEach(function(fe) {
        return fe(W);
      }), W.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || a) && b.props.hideOnClick !== !1 && b.state.isVisible ? G = !0 : ue(W), W.type === "click" && (a = !G), G && !se && jt(W);
    }
  }
  function ee(W) {
    var ae = W.target, G = D().contains(ae) || E.contains(ae);
    if (!(W.type === "mousemove" && G)) {
      var se = Te().concat(E).map(function(fe) {
        var Xe, st = fe._tippy, Xn = (Xe = st.popperInstance) == null ? void 0 : Xe.state;
        return Xn ? {
          popperRect: fe.getBoundingClientRect(),
          popperState: Xn,
          props: n
        } : null;
      }).filter(Boolean);
      vG(se, W) && (Y(), jt(W));
    }
  }
  function he(W) {
    var ae = Se(W) || b.props.trigger.indexOf("click") >= 0 && a;
    if (!ae) {
      if (b.props.interactive) {
        b.hideWithInteractivity(W);
        return;
      }
      jt(W);
    }
  }
  function be(W) {
    b.props.trigger.indexOf("focusin") < 0 && W.target !== D() || b.props.interactive && W.relatedTarget && E.contains(W.relatedTarget) || jt(W);
  }
  function Se(W) {
    return Mr.isTouch ? M() !== W.type.indexOf("touch") >= 0 : !1;
  }
  function Ce() {
    nt();
    var W = b.props, ae = W.popperOptions, G = W.placement, se = W.offset, fe = W.getReferenceClientRect, Xe = W.moveTransition, st = P() ? qm(E).arrow : null, Xn = fe ? {
      getBoundingClientRect: fe,
      contextElement: fe.contextElement || D()
    } : e, Ci = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Gr) {
        var Sr = Gr.state;
        if (P()) {
          var ve = N(), mn = ve.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Xo) {
            Xo === "placement" ? mn.setAttribute("data-placement", Sr.placement) : Sr.attributes.popper["data-popper-" + Xo] ? mn.setAttribute("data-" + Xo, "") : mn.removeAttribute("data-" + Xo);
          }), Sr.attributes.popper = {};
        }
      }
    }, Zn = [{
      name: "offset",
      options: {
        offset: se
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !Xe
      }
    }, Ci];
    P() && st && Zn.push({
      name: "arrow",
      options: {
        element: st,
        padding: 3
      }
    }), Zn.push.apply(Zn, ae?.modifiers || []), b.popperInstance = AT(Xn, E, Object.assign({}, ae, {
      placement: G,
      onFirstUpdate: f,
      modifiers: Zn
    }));
  }
  function nt() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function Ke() {
    var W = b.props.appendTo, ae, G = D();
    b.props.interactive && W === ek || W === "parent" ? ae = G.parentNode : ae = tk(W, [G]), ae.contains(E) || ae.appendChild(E), b.state.isMounted = !0, Ce(), process.env.NODE_ENV !== "production" && ti(b.props.interactive && W === Wn.appendTo && G.nextElementSibling !== E, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function Te() {
    return rd(E.querySelectorAll("[data-tippy-root]"));
  }
  function ue(W) {
    b.clearDelayTimeouts(), W && q("onTrigger", [b, W]), Q();
    var ae = $(!0), G = R(), se = G[0], fe = G[1];
    Mr.isTouch && se === "hold" && fe && (ae = fe), ae ? r = setTimeout(function() {
      b.show();
    }, ae) : b.show();
  }
  function jt(W) {
    if (b.clearDelayTimeouts(), q("onUntrigger", [b, W]), !b.state.isVisible) {
      ne();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(W.type) >= 0 && a)) {
      var ae = $(!1);
      ae ? i = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, ae) : o = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function at() {
    b.state.isEnabled = !0;
  }
  function on() {
    b.hide(), b.state.isEnabled = !1;
  }
  function Zt() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(o);
  }
  function an(W) {
    if (process.env.NODE_ENV !== "production" && ti(b.state.isDestroyed, oa("setProps")), !b.state.isDestroyed) {
      q("onBeforeUpdate", [b, W]), T();
      var ae = b.props, G = HO(e, Object.assign({}, ae, BO(W), {
        ignoreAttributes: !0
      }));
      b.props = G, Z(), ae.interactiveDebounce !== G.interactiveDebounce && (Y(), g = LO(ee, G.interactiveDebounce)), ae.triggerTarget && !G.triggerTarget ? ua(ae.triggerTarget).forEach(function(se) {
        se.removeAttribute("aria-expanded");
      }) : G.triggerTarget && e.removeAttribute("aria-expanded"), L(), F(), C && C(ae, G), b.popperInstance && (Ce(), Te().forEach(function(se) {
        requestAnimationFrame(se._tippy.popperInstance.forceUpdate);
      })), q("onAfterUpdate", [b, W]);
    }
  }
  function xn(W) {
    b.setProps({
      content: W
    });
  }
  function zt() {
    process.env.NODE_ENV !== "production" && ti(b.state.isDestroyed, oa("show"));
    var W = b.state.isVisible, ae = b.state.isDestroyed, G = !b.state.isEnabled, se = Mr.isTouch && !b.props.touch, fe = yh(b.props.duration, 0, Wn.duration);
    if (!(W || ae || G || se) && !D().hasAttribute("disabled") && (q("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, P() && (E.style.visibility = "visible"), F(), Q(), b.state.isMounted || (E.style.transition = "none"), P()) {
        var Xe = N(), st = Xe.box, Xn = Xe.content;
        bh([st, Xn], 0);
      }
      f = function() {
        var Zn;
        if (!(!b.state.isVisible || c)) {
          if (c = !0, E.offsetHeight, E.style.transition = b.props.moveTransition, P() && b.props.animation) {
            var ro = N(), Gr = ro.box, Sr = ro.content;
            bh([Gr, Sr], fe), zO([Gr, Sr], "visible");
          }
          B(), L(), FO(wh, b), (Zn = b.popperInstance) == null || Zn.forceUpdate(), q("onMount", [b]), b.props.animation && P() && ie(fe, function() {
            b.state.isShown = !0, q("onShown", [b]);
          });
        }
      }, Ke();
    }
  }
  function wn() {
    process.env.NODE_ENV !== "production" && ti(b.state.isDestroyed, oa("hide"));
    var W = !b.state.isVisible, ae = b.state.isDestroyed, G = !b.state.isEnabled, se = yh(b.props.duration, 1, Wn.duration);
    if (!(W || ae || G) && (q("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, c = !1, a = !1, P() && (E.style.visibility = "hidden"), Y(), ne(), F(!0), P()) {
        var fe = N(), Xe = fe.box, st = fe.content;
        b.props.animation && (bh([Xe, st], se), zO([Xe, st], "hidden"));
      }
      B(), L(), b.props.animation ? P() && re(se, b.unmount) : b.unmount();
    }
  }
  function ge(W) {
    process.env.NODE_ENV !== "production" && ti(b.state.isDestroyed, oa("hideWithInteractivity")), j().addEventListener("mousemove", g), FO(kc, g), g(W);
  }
  function sn() {
    process.env.NODE_ENV !== "production" && ti(b.state.isDestroyed, oa("unmount")), b.state.isVisible && b.hide(), b.state.isMounted && (nt(), Te().forEach(function(W) {
      W._tippy.unmount();
    }), E.parentNode && E.parentNode.removeChild(E), wh = wh.filter(function(W) {
      return W !== b;
    }), b.state.isMounted = !1, q("onHidden", [b]));
  }
  function Wt() {
    process.env.NODE_ENV !== "production" && ti(b.state.isDestroyed, oa("destroy")), !b.state.isDestroyed && (b.clearDelayTimeouts(), b.unmount(), T(), delete e._tippy, b.state.isDestroyed = !0, q("onDestroy", [b]));
  }
}
function ql(e, t) {
  t === void 0 && (t = {});
  var n = Wn.plugins.concat(t.plugins || []);
  process.env.NODE_ENV !== "production" && (_G(e), ak(t, n)), xG();
  var r = Object.assign({}, t, {
    plugins: n
  }), i = mG(e);
  if (process.env.NODE_ENV !== "production") {
    var o = ll(r.content), a = i.length > 1;
    ti(o && a, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var s = i.reduce(function(l, c) {
    var u = c && jG(c, r);
    return u && l.push(u), l;
  }, []);
  return ll(e) ? s[0] : s;
}
ql.defaultProps = Wn;
ql.setDefaultProps = AG;
ql.currentInput = Mr;
Object.assign({}, xT, {
  effect: function(t) {
    var n = t.state, r = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  }
});
ql.setDefaultProps({
  render: sk
});
function lk(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var ck = typeof window < "u" && typeof document < "u";
function Ym(e, t) {
  e && (typeof e == "function" && e(t), {}.hasOwnProperty.call(e, "current") && (e.current = t));
}
function YO() {
  return ck && document.createElement("div");
}
function NG(e) {
  var t = {
    "data-placement": e.placement
  };
  return e.referenceHidden && (t["data-reference-hidden"] = ""), e.escaped && (t["data-escaped"] = ""), t;
}
function uk(e, t) {
  if (e === t)
    return !0;
  if (typeof e == "object" && e != null && typeof t == "object" && t != null) {
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (var n in e)
      if (t.hasOwnProperty(n)) {
        if (!uk(e[n], t[n]))
          return !1;
      } else
        return !1;
    return !0;
  } else
    return !1;
}
function DG(e) {
  var t = [];
  return e.forEach(function(n) {
    t.find(function(r) {
      return uk(n, r);
    }) || t.push(n);
  }), t;
}
function RG(e, t) {
  var n, r;
  return Object.assign({}, t, {
    popperOptions: Object.assign({}, e.popperOptions, t.popperOptions, {
      modifiers: DG([].concat(((n = e.popperOptions) == null ? void 0 : n.modifiers) || [], ((r = t.popperOptions) == null ? void 0 : r.modifiers) || []))
    })
  });
}
var Oh = ck ? bE : Le;
function IG(e) {
  var t = Ue();
  return t.current || (t.current = typeof e == "function" ? e() : e), t.current;
}
function GO(e, t, n) {
  n.split(/\s+/).forEach(function(r) {
    r && e.classList[t](r);
  });
}
var $G = {
  name: "className",
  defaultValue: "",
  fn: function(t) {
    var n = t.popper.firstElementChild, r = function() {
      var s;
      return !!((s = t.props.render) != null && s.$$tippy);
    };
    function i() {
      if (t.props.className && !r()) {
        process.env.NODE_ENV !== "production" && console.warn(["@tippyjs/react: Cannot use `className` prop in conjunction with", "`render` prop. Place the className on the element you are", "rendering."].join(" "));
        return;
      }
      GO(n, "add", t.props.className);
    }
    function o() {
      r() && GO(n, "remove", t.props.className);
    }
    return {
      onCreate: i,
      onBeforeUpdate: o,
      onAfterUpdate: i
    };
  }
};
function LG(e) {
  function t(n) {
    var r = n.children, i = n.content, o = n.visible, a = n.singleton, s = n.render, l = n.reference, c = n.disabled, u = c === void 0 ? !1 : c, d = n.ignoreAttributes, f = d === void 0 ? !0 : d;
    n.__source, n.__self;
    var p = lk(n, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]), g = o !== void 0, m = a !== void 0, v = Rt(!1), y = v[0], S = v[1], x = Rt({}), b = x[0], w = x[1], E = Rt(), C = E[0], A = E[1], k = IG(function() {
      return {
        container: YO(),
        renders: 1
      };
    }), R = Object.assign({
      ignoreAttributes: f
    }, p, {
      content: k.container
    });
    g && (process.env.NODE_ENV !== "production" && ["trigger", "hideOnClick", "showOnCreate"].forEach(function(j) {
      R[j] !== void 0 && console.warn(["@tippyjs/react: Cannot specify `" + j + "` prop in", "controlled mode (`visible` prop)"].join(" "));
    }), R.trigger = "manual", R.hideOnClick = !1), m && (u = !0);
    var M = R, P = R.plugins || [];
    s && (M = Object.assign({}, R, {
      plugins: m && a.data != null ? [].concat(P, [{
        fn: function() {
          return {
            onTrigger: function($, F) {
              var q = a.data.children.find(function(B) {
                var L = B.instance;
                return L.reference === F.currentTarget;
              });
              $.state.$$activeSingletonInstance = q.instance, A(q.content);
            }
          };
        }
      }]) : P,
      render: function() {
        return {
          popper: k.container
        };
      }
    }));
    var D = [l].concat(r ? [r.type] : []);
    return Oh(function() {
      var j = l;
      l && l.hasOwnProperty("current") && (j = l.current);
      var N = e(j || k.ref || YO(), Object.assign({}, M, {
        plugins: [$G].concat(R.plugins || [])
      }));
      return k.instance = N, u && N.disable(), o && N.show(), m && a.hook({
        instance: N,
        content: i,
        props: M,
        setSingletonContent: A
      }), S(!0), function() {
        N.destroy(), a?.cleanup(N);
      };
    }, D), Oh(function() {
      var j;
      if (k.renders === 1) {
        k.renders++;
        return;
      }
      var N = k.instance;
      N.setProps(RG(N.props, M)), (j = N.popperInstance) == null || j.forceUpdate(), u ? N.disable() : N.enable(), g && (o ? N.show() : N.hide()), m && a.hook({
        instance: N,
        content: i,
        props: M,
        setSingletonContent: A
      });
    }), Oh(function() {
      var j;
      if (s) {
        var N = k.instance;
        N.setProps({
          popperOptions: Object.assign({}, N.props.popperOptions, {
            modifiers: [].concat((((j = N.props.popperOptions) == null ? void 0 : j.modifiers) || []).filter(function($) {
              var F = $.name;
              return F !== "$$tippyReact";
            }), [{
              name: "$$tippyReact",
              enabled: !0,
              phase: "beforeWrite",
              requires: ["computeStyles"],
              fn: function(F) {
                var q, B = F.state, L = (q = B.modifiersData) == null ? void 0 : q.hide;
                (b.placement !== B.placement || b.referenceHidden !== L?.isReferenceHidden || b.escaped !== L?.hasPopperEscaped) && w({
                  placement: B.placement,
                  referenceHidden: L?.isReferenceHidden,
                  escaped: L?.hasPopperEscaped
                }), B.attributes.popper = {};
              }
            }])
          })
        });
      }
    }, [b.placement, b.referenceHidden, b.escaped].concat(D)), /* @__PURE__ */ He.createElement(He.Fragment, null, r ? /* @__PURE__ */ sr(r, {
      ref: function(N) {
        k.ref = N, Ym(r.ref, N);
      }
    }) : null, y && /* @__PURE__ */ xE(s ? s(NG(b), C, k.instance) : i, k.container));
  }
  return t;
}
var FG = (function(e, t) {
  return /* @__PURE__ */ nn(function(r, i) {
    var o = r.children, a = lk(r, ["children"]);
    return (
      // If I spread them separately here, Babel adds the _extends ponyfill for
      // some reason
      /* @__PURE__ */ He.createElement(e, Object.assign({}, t, a), o ? /* @__PURE__ */ sr(o, {
        ref: function(l) {
          Ym(i, l), Ym(o.ref, l);
        }
      }) : null)
    );
  });
}), BG = /* @__PURE__ */ FG(/* @__PURE__ */ LG(ql));
function zG(e) {
  const t = e >= 12 ? "PM" : "AM";
  let n = e % 12;
  return n === 0 && (n = 12), `${n} ${t}`;
}
function WG(e = []) {
  return Array.from({ length: 24 }, (t, n) => {
    const r = e.find((i) => i.hour === n) || {};
    return {
      hour: n,
      time: zG(n),
      walkins: r.walkins ?? 0,
      checkins: r.preApproved ?? 0,
      staffAttendance: r.staffAttendance ?? 0
    };
  });
}
const aa = {
  walkins: "#1FA05B",
  preApproved: "#E7A015",
  staffAttendance: "#329DFF"
};
function VG({ type: e, data: t, children: n }) {
  if (!e || !t) return n;
  const r = {
    activeWalkins: [
      ["Currently Inside", t.visitor_in],
      // ["Currently Out", data.visitor_out],
      ["Total Visited Today", t.total_pass]
    ],
    preApprovedCheckins: [
      ["Currently Inside", t.currently_inside],
      ["Total Visited Today", t.expected_pass_scanned],
      ["No show", t.expected_pass_not_scanned],
      ["Total Scheduled", t.total_expected_pass]
    ],
    staffAttendance: [
      ["Currently Inside", t.total_in_now],
      ["Absent Today", t.absent_staff],
      ["Total Visited Today", t.total_in_today],
      ["Total Staff", t.total_staff]
    ]
  }, i = {
    activeWalkins: "Active Walk-ins",
    preApprovedCheckins: "Pre-approved Check-ins",
    staffAttendance: "Staff Attendance"
  }, o = {
    activeWalkins: "text-[#1FA05B]",
    preApprovedCheckins: "text-[#E7A015]",
    staffAttendance: "text-[#329DFF]"
  }, a = /* @__PURE__ */ O.jsx(
    Vo,
    {
      title: i[e],
      period: "Today",
      icon: /* @__PURE__ */ O.jsx(xg, { className: `${o[e]} !text-[24px]` }),
      className: "!gap-0 min-w-[353px] bg-white shadow-xl rounded-lg border border-gray-200",
      children: /* @__PURE__ */ O.jsx("div", { className: "flex flex-col gap-[8px] mt-[12px] pt-[12px] border-t border-dashed border-[#EBEBEB]", children: r[e].map(([s, l]) => /* @__PURE__ */ O.jsxs(
        "div",
        {
          className: "flex justify-between text-[14px] text-[#64748B]",
          children: [
            /* @__PURE__ */ O.jsx("div", { children: s }),
            /* @__PURE__ */ O.jsx("div", { className: "font-semibold text-gray-800", children: l ?? 0 })
          ]
        },
        s
      )) })
    }
  );
  return /* @__PURE__ */ O.jsx(
    BG,
    {
      content: a,
      placement: "bottom-start",
      interactive: !0,
      delay: [100, 0],
      offset: [0, 8],
      appendTo: document.body,
      theme: "light-border",
      maxWidth: "none",
      children: n
    }
  );
}
function tte({ isStatic: e, data: t }) {
  const n = t?.summary?.activeWalkins || {}, r = t?.summary?.preApprovedCheckins || {}, i = t?.summary?.staffAttendance || {}, o = WG(t?.chart || []), a = Math.max(
    ...o.flatMap((c) => [c.walkins, c.checkins, c.staffAttendance])
  ), s = a > 0 ? a : 5, l = [0, Math.ceil(s / 2), s];
  return /* @__PURE__ */ O.jsx(
    Vo,
    {
      title: "Gate Updates",
      period: "Today",
      icon: /* @__PURE__ */ O.jsx(xg, { className: "!text-[24px] text-[#37CC6D]" }),
      className: `${e ? "max-h-[303px]" : ""} h-[251px] mb-4 break-inside-avoid`,
      children: /* @__PURE__ */ O.jsxs("div", { children: [
        /* @__PURE__ */ O.jsx("div", { className: "grid grid-cols-3 gap-[24px] mb-[16px]", children: [
          {
            key: "activeWalkins",
            data: n,
            color: aa.walkins,
            label: "Active Walk-ins"
          },
          {
            key: "staffAttendance",
            data: i,
            color: aa.staffAttendance,
            label: "Staff Checked-in"
          },
          {
            key: "preApprovedCheckins",
            data: r,
            color: aa.preApproved,
            label: "Pre-approved"
          }
        ].map((c) => /* @__PURE__ */ O.jsx(VG, { type: c.key, data: c.data, children: /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col gap-[8px] cursor-pointer", children: [
          /* @__PURE__ */ O.jsx("div", { className: "text-[10px] text-[#64748B] whitespace-nowrap", children: c.label }),
          /* @__PURE__ */ O.jsxs(
            "div",
            {
              className: "text-[28px] font-medium flex items-center",
              style: { color: c.color },
              children: [
                c.key === "activeWalkins" ? c.data?.visitor_in ?? 0 : c.key === "preApprovedCheckins" ? c.data?.currently_inside ?? 0 : c.data?.total_in_now ?? 0,
                /* @__PURE__ */ O.jsxs("div", { className: "text-[20px] text-[#64748B] ml-1", children: [
                  "/",
                  c.key === "activeWalkins" ? c.data?.total_pass ?? 0 : c.key === "preApprovedCheckins" ? c.data?.total_expected_pass ?? 0 : c.data?.total_staff ?? 0
                ] })
              ]
            }
          )
        ] }) }, c.key)) }),
        /* @__PURE__ */ O.jsx("div", { className: "w-full h-[105px]", children: /* @__PURE__ */ O.jsx(Yo, { width: "100%", height: "100%", children: /* @__PURE__ */ O.jsxs(
          nT,
          {
            data: o,
            margin: { top: 5, right: 0, left: -40, bottom: 0 },
            children: [
              /* @__PURE__ */ O.jsx(cf, { strokeDasharray: "3 3", stroke: "#EBEBEB" }),
              /* @__PURE__ */ O.jsx(
                uf,
                {
                  dataKey: "time",
                  tickFormatter: (c, u) => u % 4 === 0 ? c : "",
                  tick: { fontSize: 10, fill: "#121212", fontWeight: 400 },
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ O.jsx(
                rl,
                {
                  tick: { fontSize: 10, fill: "#64748B", fontWeight: 400 },
                  ticks: l,
                  domain: [0, s],
                  allowDecimals: !1,
                  axisLine: !1,
                  tickLine: !1
                }
              ),
              /* @__PURE__ */ O.jsx(qo, { content: /* @__PURE__ */ O.jsx(Sl, {}) }),
              /* @__PURE__ */ O.jsx(
                va,
                {
                  type: "monotone",
                  dataKey: "walkins",
                  stroke: aa.walkins,
                  strokeWidth: 2,
                  dot: !1,
                  name: "Active Walk-ins"
                }
              ),
              /* @__PURE__ */ O.jsx(
                va,
                {
                  type: "monotone",
                  dataKey: "checkins",
                  stroke: aa.preApproved,
                  strokeWidth: 2,
                  strokeDasharray: "5 5",
                  dot: !1,
                  name: "Pre-approved"
                }
              ),
              /* @__PURE__ */ O.jsx(
                va,
                {
                  type: "monotone",
                  dataKey: "staffAttendance",
                  stroke: aa.staffAttendance,
                  strokeWidth: 2,
                  dot: !1,
                  name: "Staff Attendance"
                }
              )
            ]
          }
        ) }) })
      ] })
    }
  );
}
function nte({ isStatic: e, data: t }) {
  const n = ["#1FA05B", "#E7A015", "#FA7E28", "#EF4444", "#CBD5E1"], r = [
    { name: "L1 Level", value: Number(t?.total_L1 || 0), color: n[0] },
    { name: "L2 Level", value: Number(t?.total_L2 || 0), color: n[1] },
    { name: "L3 Level", value: Number(t?.total_L3 || 0), color: n[2] },
    {
      name: "No Level",
      value: Number(t?.total_NoLevel || 0),
      color: n[3]
    }
  ];
  r.reduce((o, a) => o + a.value, 0);
  const i = r;
  return /* @__PURE__ */ O.jsx(
    Vo,
    {
      title: "Helpdesk",
      period: "As of Today",
      icon: /* @__PURE__ */ O.jsx(nR, { className: "!text-[24px] text-[#FA7E28]" }),
      className: `${e && "max-h-[186px]"} h-[186px] mb-4 break-inside-avoid`,
      children: /* @__PURE__ */ O.jsxs("div", { className: "flex gap-[12px] h-fit", children: [
        /* @__PURE__ */ O.jsxs("div", { className: "w-[50%] flex flex-col gap-[28px]", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col gap-[8px]", children: [
            /* @__PURE__ */ O.jsx("div", { className: "!m-0 !text-[12px] !leading-[16px] !text-[#64748B]", children: "Un-resolved Complaints" }),
            /* @__PURE__ */ O.jsx("div", { className: "!m-0 !text-[28px] !leading-[32px] !font-medium text-[#FA7E28]", children: t?.total_open_complaints ?? 0 })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "!m-0 !text-[10px] !leading-[14px] !text-[#64748B] flex items-center gap-[4px]", children: [
            /* @__PURE__ */ O.jsx(p_, { value: t?.percent_change }),
            /* @__PURE__ */ O.jsx("div", { className: "whitespace-nowrap", children: "Compared to yesterday" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "w-[50%] h-[110px] flex justify-end", children: /* @__PURE__ */ O.jsx(Yo, { width: "75%", height: "100%", children: /* @__PURE__ */ O.jsxs(df, { children: [
          /* @__PURE__ */ O.jsx(
            Vl,
            {
              data: i,
              innerRadius: 36,
              outerRadius: 52,
              paddingAngle: 2,
              dataKey: "value",
              children: i.map((o, a) => /* @__PURE__ */ O.jsx(zr, { fill: n[a] || "#CBD5E1" }, o.name))
            }
          ),
          /* @__PURE__ */ O.jsx(qo, { content: /* @__PURE__ */ O.jsx(Sl, {}) })
        ] }) }) })
      ] })
    }
  );
}
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function Yl(e) {
  return e + 0.5 | 0;
}
const ji = (e, t, n) => Math.max(Math.min(e, n), t);
function As(e) {
  return ji(Yl(e * 2.55), 0, 255);
}
function Li(e) {
  return ji(Yl(e * 255), 0, 255);
}
function ni(e) {
  return ji(Yl(e / 2.55) / 100, 0, 1);
}
function XO(e) {
  return ji(Yl(e * 100), 0, 100);
}
const tr = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Gm = [..."0123456789ABCDEF"], UG = (e) => Gm[e & 15], HG = (e) => Gm[(e & 240) >> 4] + Gm[e & 15], Mc = (e) => (e & 240) >> 4 === (e & 15), KG = (e) => Mc(e.r) && Mc(e.g) && Mc(e.b) && Mc(e.a);
function qG(e) {
  var t = e.length, n;
  return e[0] === "#" && (t === 4 || t === 5 ? n = {
    r: 255 & tr[e[1]] * 17,
    g: 255 & tr[e[2]] * 17,
    b: 255 & tr[e[3]] * 17,
    a: t === 5 ? tr[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (n = {
    r: tr[e[1]] << 4 | tr[e[2]],
    g: tr[e[3]] << 4 | tr[e[4]],
    b: tr[e[5]] << 4 | tr[e[6]],
    a: t === 9 ? tr[e[7]] << 4 | tr[e[8]] : 255
  })), n;
}
const YG = (e, t) => e < 255 ? t(e) : "";
function GG(e) {
  var t = KG(e) ? UG : HG;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + YG(e.a, t) : void 0;
}
const XG = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function dk(e, t, n) {
  const r = t * Math.min(n, 1 - n), i = (o, a = (o + e / 30) % 12) => n - r * Math.max(Math.min(a - 3, 9 - a, 1), -1);
  return [i(0), i(8), i(4)];
}
function ZG(e, t, n) {
  const r = (i, o = (i + e / 60) % 6) => n - n * t * Math.max(Math.min(o, 4 - o, 1), 0);
  return [r(5), r(3), r(1)];
}
function JG(e, t, n) {
  const r = dk(e, 1, 0.5);
  let i;
  for (t + n > 1 && (i = 1 / (t + n), t *= i, n *= i), i = 0; i < 3; i++)
    r[i] *= 1 - t - n, r[i] += t;
  return r;
}
function QG(e, t, n, r, i) {
  return e === i ? (t - n) / r + (t < n ? 6 : 0) : t === i ? (n - e) / r + 2 : (e - t) / r + 4;
}
function Iy(e) {
  const n = e.r / 255, r = e.g / 255, i = e.b / 255, o = Math.max(n, r, i), a = Math.min(n, r, i), s = (o + a) / 2;
  let l, c, u;
  return o !== a && (u = o - a, c = s > 0.5 ? u / (2 - o - a) : u / (o + a), l = QG(n, r, i, u, o), l = l * 60 + 0.5), [l | 0, c || 0, s];
}
function $y(e, t, n, r) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(Li);
}
function Ly(e, t, n) {
  return $y(dk, e, t, n);
}
function eX(e, t, n) {
  return $y(JG, e, t, n);
}
function tX(e, t, n) {
  return $y(ZG, e, t, n);
}
function fk(e) {
  return (e % 360 + 360) % 360;
}
function nX(e) {
  const t = XG.exec(e);
  let n = 255, r;
  if (!t)
    return;
  t[5] !== r && (n = t[6] ? As(+t[5]) : Li(+t[5]));
  const i = fk(+t[2]), o = +t[3] / 100, a = +t[4] / 100;
  return t[1] === "hwb" ? r = eX(i, o, a) : t[1] === "hsv" ? r = tX(i, o, a) : r = Ly(i, o, a), {
    r: r[0],
    g: r[1],
    b: r[2],
    a: n
  };
}
function rX(e, t) {
  var n = Iy(e);
  n[0] = fk(n[0] + t), n = Ly(n), e.r = n[0], e.g = n[1], e.b = n[2];
}
function iX(e) {
  if (!e)
    return;
  const t = Iy(e), n = t[0], r = XO(t[1]), i = XO(t[2]);
  return e.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${ni(e.a)})` : `hsl(${n}, ${r}%, ${i}%)`;
}
const ZO = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, JO = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function oX() {
  const e = {}, t = Object.keys(JO), n = Object.keys(ZO);
  let r, i, o, a, s;
  for (r = 0; r < t.length; r++) {
    for (a = s = t[r], i = 0; i < n.length; i++)
      o = n[i], s = s.replace(o, ZO[o]);
    o = parseInt(JO[a], 16), e[s] = [o >> 16 & 255, o >> 8 & 255, o & 255];
  }
  return e;
}
let jc;
function aX(e) {
  jc || (jc = oX(), jc.transparent = [0, 0, 0, 0]);
  const t = jc[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const sX = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function lX(e) {
  const t = sX.exec(e);
  let n = 255, r, i, o;
  if (t) {
    if (t[7] !== r) {
      const a = +t[7];
      n = t[8] ? As(a) : ji(a * 255, 0, 255);
    }
    return r = +t[1], i = +t[3], o = +t[5], r = 255 & (t[2] ? As(r) : ji(r, 0, 255)), i = 255 & (t[4] ? As(i) : ji(i, 0, 255)), o = 255 & (t[6] ? As(o) : ji(o, 0, 255)), {
      r,
      g: i,
      b: o,
      a: n
    };
  }
}
function cX(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${ni(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const Sh = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, sa = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function uX(e, t, n) {
  const r = sa(ni(e.r)), i = sa(ni(e.g)), o = sa(ni(e.b));
  return {
    r: Li(Sh(r + n * (sa(ni(t.r)) - r))),
    g: Li(Sh(i + n * (sa(ni(t.g)) - i))),
    b: Li(Sh(o + n * (sa(ni(t.b)) - o))),
    a: e.a + n * (t.a - e.a)
  };
}
function Nc(e, t, n) {
  if (e) {
    let r = Iy(e);
    r[t] = Math.max(0, Math.min(r[t] + r[t] * n, t === 0 ? 360 : 1)), r = Ly(r), e.r = r[0], e.g = r[1], e.b = r[2];
  }
}
function pk(e, t) {
  return e && Object.assign(t || {}, e);
}
function QO(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Li(e[3]))) : (t = pk(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Li(t.a)), t;
}
function dX(e) {
  return e.charAt(0) === "r" ? lX(e) : nX(e);
}
class ul {
  constructor(t) {
    if (t instanceof ul)
      return t;
    const n = typeof t;
    let r;
    n === "object" ? r = QO(t) : n === "string" && (r = qG(t) || aX(t) || dX(t)), this._rgb = r, this._valid = !!r;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = pk(this._rgb);
    return t && (t.a = ni(t.a)), t;
  }
  set rgb(t) {
    this._rgb = QO(t);
  }
  rgbString() {
    return this._valid ? cX(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? GG(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? iX(this._rgb) : void 0;
  }
  mix(t, n) {
    if (t) {
      const r = this.rgb, i = t.rgb;
      let o;
      const a = n === o ? 0.5 : n, s = 2 * a - 1, l = r.a - i.a, c = ((s * l === -1 ? s : (s + l) / (1 + s * l)) + 1) / 2;
      o = 1 - c, r.r = 255 & c * r.r + o * i.r + 0.5, r.g = 255 & c * r.g + o * i.g + 0.5, r.b = 255 & c * r.b + o * i.b + 0.5, r.a = a * r.a + (1 - a) * i.a, this.rgb = r;
    }
    return this;
  }
  interpolate(t, n) {
    return t && (this._rgb = uX(this._rgb, t._rgb, n)), this;
  }
  clone() {
    return new ul(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = Li(t), this;
  }
  clearer(t) {
    const n = this._rgb;
    return n.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, n = Yl(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = n, this;
  }
  opaquer(t) {
    const n = this._rgb;
    return n.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return Nc(this._rgb, 2, t), this;
  }
  darken(t) {
    return Nc(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return Nc(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return Nc(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return rX(this._rgb, t), this;
  }
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function Jr() {
}
const fX = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function Fe(e) {
  return e == null;
}
function Ut(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function Pe(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function pr(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function Pr(e, t) {
  return pr(e) ? e : t;
}
function we(e, t) {
  return typeof e > "u" ? t : e;
}
const pX = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, hk = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function rt(e, t, n) {
  if (e && typeof e.call == "function")
    return e.apply(n, t);
}
function We(e, t, n, r) {
  let i, o, a;
  if (Ut(e))
    for (o = e.length, i = 0; i < o; i++)
      t.call(n, e[i], i);
  else if (Pe(e))
    for (a = Object.keys(e), o = a.length, i = 0; i < o; i++)
      t.call(n, e[a[i]], a[i]);
}
function id(e, t) {
  let n, r, i, o;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (n = 0, r = e.length; n < r; ++n)
    if (i = e[n], o = t[n], i.datasetIndex !== o.datasetIndex || i.index !== o.index)
      return !1;
  return !0;
}
function od(e) {
  if (Ut(e))
    return e.map(od);
  if (Pe(e)) {
    const t = /* @__PURE__ */ Object.create(null), n = Object.keys(e), r = n.length;
    let i = 0;
    for (; i < r; ++i)
      t[n[i]] = od(e[n[i]]);
    return t;
  }
  return e;
}
function mk(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function hX(e, t, n, r) {
  if (!mk(e))
    return;
  const i = t[e], o = n[e];
  Pe(i) && Pe(o) ? dl(i, o, r) : t[e] = od(o);
}
function dl(e, t, n) {
  const r = Ut(t) ? t : [
    t
  ], i = r.length;
  if (!Pe(e))
    return e;
  n = n || {};
  const o = n.merger || hX;
  let a;
  for (let s = 0; s < i; ++s) {
    if (a = r[s], !Pe(a))
      continue;
    const l = Object.keys(a);
    for (let c = 0, u = l.length; c < u; ++c)
      o(l[c], e, a, n);
  }
  return e;
}
function Ls(e, t) {
  return dl(e, t, {
    merger: mX
  });
}
function mX(e, t, n) {
  if (!mk(e))
    return;
  const r = t[e], i = n[e];
  Pe(r) && Pe(i) ? Ls(r, i) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = od(i));
}
const eS = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function gX(e) {
  const t = e.split("."), n = [];
  let r = "";
  for (const i of t)
    r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = "");
  return n;
}
function vX(e) {
  const t = gX(e);
  return (n) => {
    for (const r of t) {
      if (r === "")
        break;
      n = n && n[r];
    }
    return n;
  };
}
function zo(e, t) {
  return (eS[t] || (eS[t] = vX(t)))(e);
}
function Fy(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const fl = (e) => typeof e < "u", Ki = (e) => typeof e == "function", tS = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
};
function yX(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const Je = Math.PI, bt = 2 * Je, bX = bt + Je, ad = Number.POSITIVE_INFINITY, xX = Je / 180, Dt = Je / 2, lo = Je / 4, nS = Je * 2 / 3, gk = Math.log10, Ir = Math.sign;
function Fs(e, t, n) {
  return Math.abs(e - t) < n;
}
function rS(e) {
  const t = Math.round(e);
  e = Fs(e, t, e / 1e3) ? t : e;
  const n = Math.pow(10, Math.floor(gk(e))), r = e / n;
  return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n;
}
function wX(e) {
  const t = [], n = Math.sqrt(e);
  let r;
  for (r = 1; r < n; r++)
    e % r === 0 && (t.push(r), t.push(e / r));
  return n === (n | 0) && t.push(n), t.sort((i, o) => i - o).pop(), t;
}
function OX(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function pl(e) {
  return !OX(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function SX(e, t) {
  const n = Math.round(e);
  return n - t <= e && n + t >= e;
}
function EX(e, t, n) {
  let r, i, o;
  for (r = 0, i = e.length; r < i; r++)
    o = e[r][n], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));
}
function li(e) {
  return e * (Je / 180);
}
function _X(e) {
  return e * (180 / Je);
}
function iS(e) {
  if (!pr(e))
    return;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n++;
  return n;
}
function vk(e, t) {
  const n = t.x - e.x, r = t.y - e.y, i = Math.sqrt(n * n + r * r);
  let o = Math.atan2(r, n);
  return o < -0.5 * Je && (o += bt), {
    angle: o,
    distance: i
  };
}
function Xm(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function PX(e, t) {
  return (e - t + bX) % bt - Je;
}
function vr(e) {
  return (e % bt + bt) % bt;
}
function hl(e, t, n, r) {
  const i = vr(e), o = vr(t), a = vr(n), s = vr(o - i), l = vr(a - i), c = vr(i - o), u = vr(i - a);
  return i === o || i === a || r && o === a || s > l && c < u;
}
function dn(e, t, n) {
  return Math.max(t, Math.min(n, e));
}
function CX(e) {
  return dn(e, -32768, 32767);
}
function Ni(e, t, n, r = 1e-6) {
  return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r;
}
function By(e, t, n) {
  n = n || ((a) => e[a] < t);
  let r = e.length - 1, i = 0, o;
  for (; r - i > 1; )
    o = i + r >> 1, n(o) ? i = o : r = o;
  return {
    lo: i,
    hi: r
  };
}
const Po = (e, t, n, r) => By(e, n, r ? (i) => {
  const o = e[i][t];
  return o < n || o === n && e[i + 1][t] === n;
} : (i) => e[i][t] < n), AX = (e, t, n) => By(e, n, (r) => e[r][t] >= n);
function TX(e, t, n) {
  let r = 0, i = e.length;
  for (; r < i && e[r] < t; )
    r++;
  for (; i > r && e[i - 1] > n; )
    i--;
  return r > 0 || i < e.length ? e.slice(r, i) : e;
}
const yk = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function kX(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), yk.forEach((n) => {
    const r = "_onData" + Fy(n), i = e[n];
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      value(...o) {
        const a = i.apply(this, o);
        return e._chartjs.listeners.forEach((s) => {
          typeof s[r] == "function" && s[r](...o);
        }), a;
      }
    });
  });
}
function oS(e, t) {
  const n = e._chartjs;
  if (!n)
    return;
  const r = n.listeners, i = r.indexOf(t);
  i !== -1 && r.splice(i, 1), !(r.length > 0) && (yk.forEach((o) => {
    delete e[o];
  }), delete e._chartjs);
}
function bk(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const xk = (function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
})();
function wk(e, t) {
  let n = [], r = !1;
  return function(...i) {
    n = i, r || (r = !0, xk.call(window, () => {
      r = !1, e.apply(t, n);
    }));
  };
}
function MX(e, t) {
  let n;
  return function(...r) {
    return t ? (clearTimeout(n), n = setTimeout(e, t, r)) : e.apply(this, r), t;
  };
}
const Ok = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", $n = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2, jX = (e, t, n, r) => e === (r ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t;
function NX(e, t, n) {
  const r = t.length;
  let i = 0, o = r;
  if (e._sorted) {
    const { iScale: a, vScale: s, _parsed: l } = e, c = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, u = a.axis, { min: d, max: f, minDefined: p, maxDefined: g } = a.getUserBounds();
    if (p) {
      if (i = Math.min(
        // @ts-expect-error Need to type _parsed
        Po(l, u, d).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? r : Po(t, u, a.getPixelForValue(d)).lo
      ), c) {
        const m = l.slice(0, i + 1).reverse().findIndex((v) => !Fe(v[s.axis]));
        i -= Math.max(0, m);
      }
      i = dn(i, 0, r - 1);
    }
    if (g) {
      let m = Math.max(
        // @ts-expect-error Need to type _parsed
        Po(l, a.axis, f, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? 0 : Po(t, u, a.getPixelForValue(f), !0).hi + 1
      );
      if (c) {
        const v = l.slice(m - 1).findIndex((y) => !Fe(y[s.axis]));
        m += Math.max(0, v);
      }
      o = dn(m, i, r) - i;
    } else
      o = r - i;
  }
  return {
    start: i,
    count: o
  };
}
function DX(e) {
  const { xScale: t, yScale: n, _scaleRanges: r } = e, i = {
    xmin: t.min,
    xmax: t.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!r)
    return e._scaleRanges = i, !0;
  const o = r.xmin !== t.min || r.xmax !== t.max || r.ymin !== n.min || r.ymax !== n.max;
  return Object.assign(r, i), o;
}
const Dc = (e) => e === 0 || e === 1, aS = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * bt / n)), sS = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * bt / n) + 1, Bs = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * Dt) + 1,
  easeOutSine: (e) => Math.sin(e * Dt),
  easeInOutSine: (e) => -0.5 * (Math.cos(Je * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => Dc(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => Dc(e) ? e : aS(e, 0.075, 0.3),
  easeOutElastic: (e) => Dc(e) ? e : sS(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return Dc(e) ? e : e < 0.5 ? 0.5 * aS(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * sS(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - Bs.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? Bs.easeInBounce(e * 2) * 0.5 : Bs.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function zy(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function lS(e) {
  return zy(e) ? e : new ul(e);
}
function Eh(e) {
  return zy(e) ? e : new ul(e).saturate(0.5).darken(0.1).hexString();
}
const RX = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], IX = [
  "color",
  "borderColor",
  "backgroundColor"
];
function $X(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: IX
    },
    numbers: {
      type: "number",
      properties: RX
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function LX(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const cS = /* @__PURE__ */ new Map();
function FX(e, t) {
  t = t || {};
  const n = e + JSON.stringify(t);
  let r = cS.get(n);
  return r || (r = new Intl.NumberFormat(e, t), cS.set(n, r)), r;
}
function Wy(e, t, n) {
  return FX(t, n).format(e);
}
const BX = {
  values(e) {
    return Ut(e) ? e : "" + e;
  },
  numeric(e, t, n) {
    if (e === 0)
      return "0";
    const r = this.chart.options.locale;
    let i, o = e;
    if (n.length > 1) {
      const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (c < 1e-4 || c > 1e15) && (i = "scientific"), o = zX(e, n);
    }
    const a = gk(Math.abs(o)), s = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = {
      notation: i,
      minimumFractionDigits: s,
      maximumFractionDigits: s
    };
    return Object.assign(l, this.options.ticks.format), Wy(e, r, l);
  }
};
function zX(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n;
}
var Sk = {
  formatters: BX
};
function WX(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Sk.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const Wo = /* @__PURE__ */ Object.create(null), Zm = /* @__PURE__ */ Object.create(null);
function zs(e, t) {
  if (!t)
    return e;
  const n = t.split(".");
  for (let r = 0, i = n.length; r < i; ++r) {
    const o = n[r];
    e = e[o] || (e[o] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function _h(e, t, n) {
  return typeof t == "string" ? dl(zs(e, t), n) : dl(zs(e, ""), t);
}
class VX {
  constructor(t, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (r) => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (r, i) => Eh(i.backgroundColor), this.hoverBorderColor = (r, i) => Eh(i.borderColor), this.hoverColor = (r, i) => Eh(i.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(n);
  }
  set(t, n) {
    return _h(this, t, n);
  }
  get(t) {
    return zs(this, t);
  }
  describe(t, n) {
    return _h(Zm, t, n);
  }
  override(t, n) {
    return _h(Wo, t, n);
  }
  route(t, n, r, i) {
    const o = zs(this, t), a = zs(this, r), s = "_" + n;
    Object.defineProperties(o, {
      [s]: {
        value: o[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const l = this[s], c = a[i];
          return Pe(l) ? Object.assign({}, c, l) : we(l, c);
        },
        set(l) {
          this[s] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((n) => n(this));
  }
}
var St = /* @__PURE__ */ new VX({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  $X,
  LX,
  WX
]);
function UX(e) {
  return !e || Fe(e.size) || Fe(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function uS(e, t, n, r, i) {
  let o = t[i];
  return o || (o = t[i] = e.measureText(i).width, n.push(i)), o > r && (r = o), r;
}
function co(e, t, n) {
  const r = e.currentDevicePixelRatio, i = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((t - i) * r) / r + i;
}
function dS(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function Jm(e, t, n, r) {
  Ek(e, t, n, r, null);
}
function Ek(e, t, n, r, i) {
  let o, a, s, l, c, u, d, f;
  const p = t.pointStyle, g = t.rotation, m = t.radius;
  let v = (g || 0) * xX;
  if (p && typeof p == "object" && (o = p.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(n, r), e.rotate(v), e.drawImage(p, -p.width / 2, -p.height / 2, p.width, p.height), e.restore();
    return;
  }
  if (!(isNaN(m) || m <= 0)) {
    switch (e.beginPath(), p) {
      // Default includes circle
      default:
        i ? e.ellipse(n, r, i / 2, m, 0, 0, bt) : e.arc(n, r, m, 0, bt), e.closePath();
        break;
      case "triangle":
        u = i ? i / 2 : m, e.moveTo(n + Math.sin(v) * u, r - Math.cos(v) * m), v += nS, e.lineTo(n + Math.sin(v) * u, r - Math.cos(v) * m), v += nS, e.lineTo(n + Math.sin(v) * u, r - Math.cos(v) * m), e.closePath();
        break;
      case "rectRounded":
        c = m * 0.516, l = m - c, a = Math.cos(v + lo) * l, d = Math.cos(v + lo) * (i ? i / 2 - c : l), s = Math.sin(v + lo) * l, f = Math.sin(v + lo) * (i ? i / 2 - c : l), e.arc(n - d, r - s, c, v - Je, v - Dt), e.arc(n + f, r - a, c, v - Dt, v), e.arc(n + d, r + s, c, v, v + Dt), e.arc(n - f, r + a, c, v + Dt, v + Je), e.closePath();
        break;
      case "rect":
        if (!g) {
          l = Math.SQRT1_2 * m, u = i ? i / 2 : l, e.rect(n - u, r - l, 2 * u, 2 * l);
          break;
        }
        v += lo;
      /* falls through */
      case "rectRot":
        d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, f = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + f, r - a), e.lineTo(n + d, r + s), e.lineTo(n - f, r + a), e.closePath();
        break;
      case "crossRot":
        v += lo;
      /* falls through */
      case "cross":
        d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, f = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + f, r - a), e.lineTo(n - f, r + a);
        break;
      case "star":
        d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, f = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + f, r - a), e.lineTo(n - f, r + a), v += lo, d = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, s = Math.sin(v) * m, f = Math.sin(v) * (i ? i / 2 : m), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + f, r - a), e.lineTo(n - f, r + a);
        break;
      case "line":
        a = i ? i / 2 : Math.cos(v) * m, s = Math.sin(v) * m, e.moveTo(n - a, r - s), e.lineTo(n + a, r + s);
        break;
      case "dash":
        e.moveTo(n, r), e.lineTo(n + Math.cos(v) * (i ? i / 2 : m), r + Math.sin(v) * m);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function ml(e, t, n) {
  return n = n || 0.5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n;
}
function Vy(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function Uy(e) {
  e.restore();
}
function HX(e, t, n, r, i) {
  if (!t)
    return e.lineTo(n.x, n.y);
  if (i === "middle") {
    const o = (t.x + n.x) / 2;
    e.lineTo(o, t.y), e.lineTo(o, n.y);
  } else i === "after" != !!r ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
  e.lineTo(n.x, n.y);
}
function KX(e, t, n, r) {
  if (!t)
    return e.lineTo(n.x, n.y);
  e.bezierCurveTo(r ? t.cp1x : t.cp2x, r ? t.cp1y : t.cp2y, r ? n.cp2x : n.cp1x, r ? n.cp2y : n.cp1y, n.x, n.y);
}
function qX(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), Fe(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function YX(e, t, n, r, i) {
  if (i.strikethrough || i.underline) {
    const o = e.measureText(r), a = t - o.actualBoundingBoxLeft, s = t + o.actualBoundingBoxRight, l = n - o.actualBoundingBoxAscent, c = n + o.actualBoundingBoxDescent, u = i.strikethrough ? (l + c) / 2 : c;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = i.decorationWidth || 2, e.moveTo(a, u), e.lineTo(s, u), e.stroke();
  }
}
function GX(e, t) {
  const n = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n;
}
function sd(e, t, n, r, i, o = {}) {
  const a = Ut(t) ? t : [
    t
  ], s = o.strokeWidth > 0 && o.strokeColor !== "";
  let l, c;
  for (e.save(), e.font = i.string, qX(e, o), l = 0; l < a.length; ++l)
    c = a[l], o.backdrop && GX(e, o.backdrop), s && (o.strokeColor && (e.strokeStyle = o.strokeColor), Fe(o.strokeWidth) || (e.lineWidth = o.strokeWidth), e.strokeText(c, n, r, o.maxWidth)), e.fillText(c, n, r, o.maxWidth), YX(e, n, r, c, o), r += Number(i.lineHeight);
  e.restore();
}
function ld(e, t) {
  const { x: n, y: r, w: i, h: o, radius: a } = t;
  e.arc(n + a.topLeft, r + a.topLeft, a.topLeft, 1.5 * Je, Je, !0), e.lineTo(n, r + o - a.bottomLeft), e.arc(n + a.bottomLeft, r + o - a.bottomLeft, a.bottomLeft, Je, Dt, !0), e.lineTo(n + i - a.bottomRight, r + o), e.arc(n + i - a.bottomRight, r + o - a.bottomRight, a.bottomRight, Dt, 0, !0), e.lineTo(n + i, r + a.topRight), e.arc(n + i - a.topRight, r + a.topRight, a.topRight, 0, -Dt, !0), e.lineTo(n + a.topLeft, r);
}
const XX = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, ZX = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function JX(e, t) {
  const n = ("" + e).match(XX);
  if (!n || n[1] === "normal")
    return t * 1.2;
  switch (e = +n[2], n[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const QX = (e) => +e || 0;
function Hy(e, t) {
  const n = {}, r = Pe(t), i = r ? Object.keys(t) : t, o = Pe(e) ? r ? (a) => we(e[a], e[t[a]]) : (a) => e[a] : () => e;
  for (const a of i)
    n[a] = QX(o(a));
  return n;
}
function _k(e) {
  return Hy(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function ya(e) {
  return Hy(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function br(e) {
  const t = _k(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function Tn(e, t) {
  e = e || {}, t = t || St.font;
  let n = we(e.size, t.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let r = we(e.style, t.style);
  r && !("" + r).match(ZX) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0);
  const i = {
    family: we(e.family, t.family),
    lineHeight: JX(we(e.lineHeight, t.lineHeight), n),
    size: n,
    style: r,
    weight: we(e.weight, t.weight),
    string: ""
  };
  return i.string = UX(i), i;
}
function Rc(e, t, n, r) {
  let i, o, a;
  for (i = 0, o = e.length; i < o; ++i)
    if (a = e[i], a !== void 0 && a !== void 0)
      return a;
}
function eZ(e, t, n) {
  const { min: r, max: i } = e, o = hk(t, (i - r) / 2), a = (s, l) => n && s === 0 ? 0 : s + l;
  return {
    min: a(r, -Math.abs(o)),
    max: a(i, o)
  };
}
function Go(e, t) {
  return Object.assign(Object.create(e), t);
}
function Ky(e, t = [
  ""
], n, r, i = () => e[0]) {
  const o = n || e;
  typeof r > "u" && (r = Tk("_fallback", e));
  const a = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: o,
    _fallback: r,
    _getTarget: i,
    override: (s) => Ky([
      s,
      ...e
    ], t, o, r)
  };
  return new Proxy(a, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(s, l) {
      return delete s[l], delete s._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(s, l) {
      return Ck(s, l, () => lZ(l, t, e, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(s, l) {
      return Reflect.getOwnPropertyDescriptor(s._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(s, l) {
      return pS(s).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(s) {
      return pS(s);
    },
    /**
    * A trap for setting property values.
    */
    set(s, l, c) {
      const u = s._storage || (s._storage = i());
      return s[l] = u[l] = c, delete s._keys, !0;
    }
  });
}
function Ra(e, t, n, r) {
  const i = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Pk(e, r),
    setContext: (o) => Ra(e, o, n, r),
    override: (o) => Ra(e.override(o), t, n, r)
  };
  return new Proxy(i, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(o, a) {
      return delete o[a], delete e[a], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(o, a, s) {
      return Ck(o, a, () => nZ(o, a, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(o, a) {
      return o._descriptors.allKeys ? Reflect.has(e, a) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, a);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(o, a) {
      return Reflect.has(e, a);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(o, a, s) {
      return e[a] = s, delete o[a], !0;
    }
  });
}
function Pk(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = t.scriptable, _indexable: r = t.indexable, _allKeys: i = t.allKeys } = e;
  return {
    allKeys: i,
    scriptable: n,
    indexable: r,
    isScriptable: Ki(n) ? n : () => n,
    isIndexable: Ki(r) ? r : () => r
  };
}
const tZ = (e, t) => e ? e + Fy(t) : t, qy = (e, t) => Pe(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function Ck(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const r = n();
  return e[t] = r, r;
}
function nZ(e, t, n) {
  const { _proxy: r, _context: i, _subProxy: o, _descriptors: a } = e;
  let s = r[t];
  return Ki(s) && a.isScriptable(t) && (s = rZ(t, s, e, n)), Ut(s) && s.length && (s = iZ(t, s, e, a.isIndexable)), qy(t, s) && (s = Ra(s, i, o && o[t], a)), s;
}
function rZ(e, t, n, r) {
  const { _proxy: i, _context: o, _subProxy: a, _stack: s } = n;
  if (s.has(e))
    throw new Error("Recursion detected: " + Array.from(s).join("->") + "->" + e);
  s.add(e);
  let l = t(o, a || r);
  return s.delete(e), qy(e, l) && (l = Yy(i._scopes, i, e, l)), l;
}
function iZ(e, t, n, r) {
  const { _proxy: i, _context: o, _subProxy: a, _descriptors: s } = n;
  if (typeof o.index < "u" && r(e))
    return t[o.index % t.length];
  if (Pe(t[0])) {
    const l = t, c = i._scopes.filter((u) => u !== l);
    t = [];
    for (const u of l) {
      const d = Yy(c, i, e, u);
      t.push(Ra(d, o, a && a[e], s));
    }
  }
  return t;
}
function Ak(e, t, n) {
  return Ki(e) ? e(t, n) : e;
}
const oZ = (e, t) => e === !0 ? t : typeof e == "string" ? zo(t, e) : void 0;
function aZ(e, t, n, r, i) {
  for (const o of t) {
    const a = oZ(n, o);
    if (a) {
      e.add(a);
      const s = Ak(a._fallback, n, i);
      if (typeof s < "u" && s !== n && s !== r)
        return s;
    } else if (a === !1 && typeof r < "u" && n !== r)
      return null;
  }
  return !1;
}
function Yy(e, t, n, r) {
  const i = t._rootScopes, o = Ak(t._fallback, n, r), a = [
    ...e,
    ...i
  ], s = /* @__PURE__ */ new Set();
  s.add(r);
  let l = fS(s, a, n, o || n, r);
  return l === null || typeof o < "u" && o !== n && (l = fS(s, a, o, l, r), l === null) ? !1 : Ky(Array.from(s), [
    ""
  ], i, o, () => sZ(t, n, r));
}
function fS(e, t, n, r, i) {
  for (; n; )
    n = aZ(e, t, n, r, i);
  return n;
}
function sZ(e, t, n) {
  const r = e._getTarget();
  t in r || (r[t] = {});
  const i = r[t];
  return Ut(i) && Pe(n) ? n : i || {};
}
function lZ(e, t, n, r) {
  let i;
  for (const o of t)
    if (i = Tk(tZ(o, e), n), typeof i < "u")
      return qy(e, i) ? Yy(n, r, e, i) : i;
}
function Tk(e, t) {
  for (const n of t) {
    if (!n)
      continue;
    const r = n[e];
    if (typeof r < "u")
      return r;
  }
}
function pS(e) {
  let t = e._keys;
  return t || (t = e._keys = cZ(e._scopes)), t;
}
function cZ(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const r of Object.keys(n).filter((i) => !i.startsWith("_")))
      t.add(r);
  return Array.from(t);
}
const uZ = Number.EPSILON || 1e-14, Ia = (e, t) => t < e.length && !e[t].skip && e[t], kk = (e) => e === "x" ? "y" : "x";
function dZ(e, t, n, r) {
  const i = e.skip ? t : e, o = t, a = n.skip ? t : n, s = Xm(o, i), l = Xm(a, o);
  let c = s / (s + l), u = l / (s + l);
  c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
  const d = r * c, f = r * u;
  return {
    previous: {
      x: o.x - d * (a.x - i.x),
      y: o.y - d * (a.y - i.y)
    },
    next: {
      x: o.x + f * (a.x - i.x),
      y: o.y + f * (a.y - i.y)
    }
  };
}
function fZ(e, t, n) {
  const r = e.length;
  let i, o, a, s, l, c = Ia(e, 0);
  for (let u = 0; u < r - 1; ++u)
    if (l = c, c = Ia(e, u + 1), !(!l || !c)) {
      if (Fs(t[u], 0, uZ)) {
        n[u] = n[u + 1] = 0;
        continue;
      }
      i = n[u] / t[u], o = n[u + 1] / t[u], s = Math.pow(i, 2) + Math.pow(o, 2), !(s <= 9) && (a = 3 / Math.sqrt(s), n[u] = i * a * t[u], n[u + 1] = o * a * t[u]);
    }
}
function pZ(e, t, n = "x") {
  const r = kk(n), i = e.length;
  let o, a, s, l = Ia(e, 0);
  for (let c = 0; c < i; ++c) {
    if (a = s, s = l, l = Ia(e, c + 1), !s)
      continue;
    const u = s[n], d = s[r];
    a && (o = (u - a[n]) / 3, s[`cp1${n}`] = u - o, s[`cp1${r}`] = d - o * t[c]), l && (o = (l[n] - u) / 3, s[`cp2${n}`] = u + o, s[`cp2${r}`] = d + o * t[c]);
  }
}
function hZ(e, t = "x") {
  const n = kk(t), r = e.length, i = Array(r).fill(0), o = Array(r);
  let a, s, l, c = Ia(e, 0);
  for (a = 0; a < r; ++a)
    if (s = l, l = c, c = Ia(e, a + 1), !!l) {
      if (c) {
        const u = c[t] - l[t];
        i[a] = u !== 0 ? (c[n] - l[n]) / u : 0;
      }
      o[a] = s ? c ? Ir(i[a - 1]) !== Ir(i[a]) ? 0 : (i[a - 1] + i[a]) / 2 : i[a - 1] : i[a];
    }
  fZ(e, i, o), pZ(e, o, t);
}
function Ic(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
function mZ(e, t) {
  let n, r, i, o, a, s = ml(e[0], t);
  for (n = 0, r = e.length; n < r; ++n)
    a = o, o = s, s = n < r - 1 && ml(e[n + 1], t), o && (i = e[n], a && (i.cp1x = Ic(i.cp1x, t.left, t.right), i.cp1y = Ic(i.cp1y, t.top, t.bottom)), s && (i.cp2x = Ic(i.cp2x, t.left, t.right), i.cp2y = Ic(i.cp2y, t.top, t.bottom)));
}
function gZ(e, t, n, r, i) {
  let o, a, s, l;
  if (t.spanGaps && (e = e.filter((c) => !c.skip)), t.cubicInterpolationMode === "monotone")
    hZ(e, i);
  else {
    let c = r ? e[e.length - 1] : e[0];
    for (o = 0, a = e.length; o < a; ++o)
      s = e[o], l = dZ(c, s, e[Math.min(o + 1, a - (r ? 0 : 1)) % a], t.tension), s.cp1x = l.previous.x, s.cp1y = l.previous.y, s.cp2x = l.next.x, s.cp2y = l.next.y, c = s;
  }
  t.capBezierPoints && mZ(e, n);
}
function Gy() {
  return typeof window < "u" && typeof document < "u";
}
function Xy(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function cd(e, t, n) {
  let r;
  return typeof e == "string" ? (r = parseInt(e, 10), e.indexOf("%") !== -1 && (r = r / 100 * t.parentNode[n])) : r = e, r;
}
const wf = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function vZ(e, t) {
  return wf(e).getPropertyValue(t);
}
const yZ = [
  "top",
  "right",
  "bottom",
  "left"
];
function No(e, t, n) {
  const r = {};
  n = n ? "-" + n : "";
  for (let i = 0; i < 4; i++) {
    const o = yZ[i];
    r[o] = parseFloat(e[t + "-" + o + n]) || 0;
  }
  return r.width = r.left + r.right, r.height = r.top + r.bottom, r;
}
const bZ = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function xZ(e, t) {
  const n = e.touches, r = n && n.length ? n[0] : e, { offsetX: i, offsetY: o } = r;
  let a = !1, s, l;
  if (bZ(i, o, e.target))
    s = i, l = o;
  else {
    const c = t.getBoundingClientRect();
    s = r.clientX - c.left, l = r.clientY - c.top, a = !0;
  }
  return {
    x: s,
    y: l,
    box: a
  };
}
function yo(e, t) {
  if ("native" in e)
    return e;
  const { canvas: n, currentDevicePixelRatio: r } = t, i = wf(n), o = i.boxSizing === "border-box", a = No(i, "padding"), s = No(i, "border", "width"), { x: l, y: c, box: u } = xZ(e, n), d = a.left + (u && s.left), f = a.top + (u && s.top);
  let { width: p, height: g } = t;
  return o && (p -= a.width + s.width, g -= a.height + s.height), {
    x: Math.round((l - d) / p * n.width / r),
    y: Math.round((c - f) / g * n.height / r)
  };
}
function wZ(e, t, n) {
  let r, i;
  if (t === void 0 || n === void 0) {
    const o = e && Xy(e);
    if (!o)
      t = e.clientWidth, n = e.clientHeight;
    else {
      const a = o.getBoundingClientRect(), s = wf(o), l = No(s, "border", "width"), c = No(s, "padding");
      t = a.width - c.width - l.width, n = a.height - c.height - l.height, r = cd(s.maxWidth, o, "clientWidth"), i = cd(s.maxHeight, o, "clientHeight");
    }
  }
  return {
    width: t,
    height: n,
    maxWidth: r || ad,
    maxHeight: i || ad
  };
}
const $c = (e) => Math.round(e * 10) / 10;
function OZ(e, t, n, r) {
  const i = wf(e), o = No(i, "margin"), a = cd(i.maxWidth, e, "clientWidth") || ad, s = cd(i.maxHeight, e, "clientHeight") || ad, l = wZ(e, t, n);
  let { width: c, height: u } = l;
  if (i.boxSizing === "content-box") {
    const f = No(i, "border", "width"), p = No(i, "padding");
    c -= p.width + f.width, u -= p.height + f.height;
  }
  return c = Math.max(0, c - o.width), u = Math.max(0, r ? c / r : u - o.height), c = $c(Math.min(c, a, l.maxWidth)), u = $c(Math.min(u, s, l.maxHeight)), c && !u && (u = $c(c / 2)), (t !== void 0 || n !== void 0) && r && l.height && u > l.height && (u = l.height, c = $c(Math.floor(u * r))), {
    width: c,
    height: u
  };
}
function hS(e, t, n) {
  const r = t || 1, i = Math.floor(e.height * r), o = Math.floor(e.width * r);
  e.height = Math.floor(e.height), e.width = Math.floor(e.width);
  const a = e.canvas;
  return a.style && (n || !a.style.height && !a.style.width) && (a.style.height = `${e.height}px`, a.style.width = `${e.width}px`), e.currentDevicePixelRatio !== r || a.height !== i || a.width !== o ? (e.currentDevicePixelRatio = r, a.height = i, a.width = o, e.ctx.setTransform(r, 0, 0, r, 0, 0), !0) : !1;
}
const SZ = (function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    Gy() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
})();
function mS(e, t) {
  const n = vZ(e, t), r = n && n.match(/^(\d+)(\.\d+)?px$/);
  return r ? +r[1] : void 0;
}
function bo(e, t, n, r) {
  return {
    x: e.x + n * (t.x - e.x),
    y: e.y + n * (t.y - e.y)
  };
}
function EZ(e, t, n, r) {
  return {
    x: e.x + n * (t.x - e.x),
    y: r === "middle" ? n < 0.5 ? e.y : t.y : r === "after" ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y
  };
}
function _Z(e, t, n, r) {
  const i = {
    x: e.cp2x,
    y: e.cp2y
  }, o = {
    x: t.cp1x,
    y: t.cp1y
  }, a = bo(e, i, n), s = bo(i, o, n), l = bo(o, t, n), c = bo(a, s, n), u = bo(s, l, n);
  return bo(c, u, n);
}
const PZ = function(e, t) {
  return {
    x(n) {
      return e + e + t - n;
    },
    setWidth(n) {
      t = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, r) {
      return n - r;
    },
    leftForLtr(n, r) {
      return n - r;
    }
  };
}, CZ = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function ba(e, t, n) {
  return e ? PZ(t, n) : CZ();
}
function Mk(e, t) {
  let n, r;
  (t === "ltr" || t === "rtl") && (n = e.canvas.style, r = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", t, "important"), e.prevTextDirection = r);
}
function jk(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function Nk(e) {
  return e === "angle" ? {
    between: hl,
    compare: PX,
    normalize: vr
  } : {
    between: Ni,
    compare: (t, n) => t - n,
    normalize: (t) => t
  };
}
function gS({ start: e, end: t, count: n, loop: r, style: i }) {
  return {
    start: e % n,
    end: t % n,
    loop: r && (t - e + 1) % n === 0,
    style: i
  };
}
function AZ(e, t, n) {
  const { property: r, start: i, end: o } = n, { between: a, normalize: s } = Nk(r), l = t.length;
  let { start: c, end: u, loop: d } = e, f, p;
  if (d) {
    for (c += l, u += l, f = 0, p = l; f < p && a(s(t[c % l][r]), i, o); ++f)
      c--, u--;
    c %= l, u %= l;
  }
  return u < c && (u += l), {
    start: c,
    end: u,
    loop: d,
    style: e.style
  };
}
function TZ(e, t, n) {
  if (!n)
    return [
      e
    ];
  const { property: r, start: i, end: o } = n, a = t.length, { compare: s, between: l, normalize: c } = Nk(r), { start: u, end: d, loop: f, style: p } = AZ(e, t, n), g = [];
  let m = !1, v = null, y, S, x;
  const b = () => l(i, x, y) && s(i, x) !== 0, w = () => s(o, y) === 0 || l(o, x, y), E = () => m || b(), C = () => !m || w();
  for (let A = u, k = u; A <= d; ++A)
    S = t[A % a], !S.skip && (y = c(S[r]), y !== x && (m = l(y, i, o), v === null && E() && (v = s(y, i) === 0 ? A : k), v !== null && C() && (g.push(gS({
      start: v,
      end: A,
      loop: f,
      count: a,
      style: p
    })), v = null), k = A, x = y));
  return v !== null && g.push(gS({
    start: v,
    end: d,
    loop: f,
    count: a,
    style: p
  })), g;
}
function kZ(e, t) {
  const n = [], r = e.segments;
  for (let i = 0; i < r.length; i++) {
    const o = TZ(r[i], e.points, t);
    o.length && n.push(...o);
  }
  return n;
}
function MZ(e, t, n, r) {
  let i = 0, o = t - 1;
  if (n && !r)
    for (; i < t && !e[i].skip; )
      i++;
  for (; i < t && e[i].skip; )
    i++;
  for (i %= t, n && (o += i); o > i && e[o % t].skip; )
    o--;
  return o %= t, {
    start: i,
    end: o
  };
}
function jZ(e, t, n, r) {
  const i = e.length, o = [];
  let a = t, s = e[t], l;
  for (l = t + 1; l <= n; ++l) {
    const c = e[l % i];
    c.skip || c.stop ? s.skip || (r = !1, o.push({
      start: t % i,
      end: (l - 1) % i,
      loop: r
    }), t = a = c.stop ? l : null) : (a = l, s.skip && (t = l)), s = c;
  }
  return a !== null && o.push({
    start: t % i,
    end: a % i,
    loop: r
  }), o;
}
function NZ(e, t) {
  const n = e.points, r = e.options.spanGaps, i = n.length;
  if (!i)
    return [];
  const o = !!e._loop, { start: a, end: s } = MZ(n, i, o, r);
  if (r === !0)
    return vS(e, [
      {
        start: a,
        end: s,
        loop: o
      }
    ], n, t);
  const l = s < a ? s + i : s, c = !!e._fullLoop && a === 0 && s === i - 1;
  return vS(e, jZ(n, a, l, c), n, t);
}
function vS(e, t, n, r) {
  return !r || !r.setContext || !n ? t : DZ(e, t, n, r);
}
function DZ(e, t, n, r) {
  const i = e._chart.getContext(), o = yS(e.options), { _datasetIndex: a, options: { spanGaps: s } } = e, l = n.length, c = [];
  let u = o, d = t[0].start, f = d;
  function p(g, m, v, y) {
    const S = s ? -1 : 1;
    if (g !== m) {
      for (g += l; n[g % l].skip; )
        g -= S;
      for (; n[m % l].skip; )
        m += S;
      g % l !== m % l && (c.push({
        start: g % l,
        end: m % l,
        loop: v,
        style: y
      }), u = y, d = m % l);
    }
  }
  for (const g of t) {
    d = s ? d : g.start;
    let m = n[d % l], v;
    for (f = d + 1; f <= g.end; f++) {
      const y = n[f % l];
      v = yS(r.setContext(Go(i, {
        type: "segment",
        p0: m,
        p1: y,
        p0DataIndex: (f - 1) % l,
        p1DataIndex: f % l,
        datasetIndex: a
      }))), RZ(v, u) && p(d, f - 1, g.loop, u), m = y, u = v;
    }
    d < f - 1 && p(d, f - 1, g.loop, u);
  }
  return c;
}
function yS(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function RZ(e, t) {
  if (!t)
    return !1;
  const n = [], r = function(i, o) {
    return zy(o) ? (n.includes(o) || n.push(o), n.indexOf(o)) : o;
  };
  return JSON.stringify(e, r) !== JSON.stringify(t, r);
}
function Lc(e, t, n) {
  return e.options.clip ? e[n] : t[n];
}
function IZ(e, t) {
  const { xScale: n, yScale: r } = e;
  return n && r ? {
    left: Lc(n, t, "left"),
    right: Lc(n, t, "right"),
    top: Lc(r, t, "top"),
    bottom: Lc(r, t, "bottom")
  } : t;
}
function $Z(e, t) {
  const n = t._clip;
  if (n.disabled)
    return !1;
  const r = IZ(t, e.chartArea);
  return {
    left: n.left === !1 ? 0 : r.left - (n.left === !0 ? 0 : n.left),
    right: n.right === !1 ? e.width : r.right + (n.right === !0 ? 0 : n.right),
    top: n.top === !1 ? 0 : r.top - (n.top === !0 ? 0 : n.top),
    bottom: n.bottom === !1 ? e.height : r.bottom + (n.bottom === !0 ? 0 : n.bottom)
  };
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class LZ {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, n, r, i) {
    const o = n.listeners[i], a = n.duration;
    o.forEach((s) => s({
      chart: t,
      initial: n.initial,
      numSteps: a,
      currentStep: Math.min(r - n.start, a)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = xk.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let n = 0;
    this._charts.forEach((r, i) => {
      if (!r.running || !r.items.length)
        return;
      const o = r.items;
      let a = o.length - 1, s = !1, l;
      for (; a >= 0; --a)
        l = o[a], l._active ? (l._total > r.duration && (r.duration = l._total), l.tick(t), s = !0) : (o[a] = o[o.length - 1], o.pop());
      s && (i.draw(), this._notify(i, r, t, "progress")), o.length || (r.running = !1, this._notify(i, r, t, "complete"), r.initial = !1), n += o.length;
    }), this._lastDate = t, n === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const n = this._charts;
    let r = n.get(t);
    return r || (r = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(t, r)), r;
  }
  listen(t, n, r) {
    this._getAnims(t).listeners[n].push(r);
  }
  add(t, n) {
    !n || !n.length || this._getAnims(t).items.push(...n);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const n = this._charts.get(t);
    n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const n = this._charts.get(t);
    return !(!n || !n.running || !n.items.length);
  }
  stop(t) {
    const n = this._charts.get(t);
    if (!n || !n.items.length)
      return;
    const r = n.items;
    let i = r.length - 1;
    for (; i >= 0; --i)
      r[i].cancel();
    n.items = [], this._notify(t, n, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var Qr = /* @__PURE__ */ new LZ();
const bS = "transparent", FZ = {
  boolean(e, t, n) {
    return n > 0.5 ? t : e;
  },
  color(e, t, n) {
    const r = lS(e || bS), i = r.valid && lS(t || bS);
    return i && i.valid ? i.mix(r, n).hexString() : t;
  },
  number(e, t, n) {
    return e + (t - e) * n;
  }
};
class BZ {
  constructor(t, n, r, i) {
    const o = n[r];
    i = Rc([
      t.to,
      i,
      o,
      t.from
    ]);
    const a = Rc([
      t.from,
      o,
      i
    ]);
    this._active = !0, this._fn = t.fn || FZ[t.type || typeof a], this._easing = Bs[t.easing] || Bs.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = n, this._prop = r, this._from = a, this._to = i, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, n, r) {
    if (this._active) {
      this._notify(!1);
      const i = this._target[this._prop], o = r - this._start, a = this._duration - o;
      this._start = r, this._duration = Math.floor(Math.max(a, t.duration)), this._total += o, this._loop = !!t.loop, this._to = Rc([
        t.to,
        n,
        i,
        t.from
      ]), this._from = Rc([
        t.from,
        i,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const n = t - this._start, r = this._duration, i = this._prop, o = this._from, a = this._loop, s = this._to;
    let l;
    if (this._active = o !== s && (a || n < r), !this._active) {
      this._target[i] = s, this._notify(!0);
      return;
    }
    if (n < 0) {
      this._target[i] = o;
      return;
    }
    l = n / r % 2, l = a && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(o, s, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((n, r) => {
      t.push({
        res: n,
        rej: r
      });
    });
  }
  _notify(t) {
    const n = t ? "res" : "rej", r = this._promises || [];
    for (let i = 0; i < r.length; i++)
      r[i][n]();
  }
}
class Dk {
  constructor(t, n) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(t) {
    if (!Pe(t))
      return;
    const n = Object.keys(St.animation), r = this._properties;
    Object.getOwnPropertyNames(t).forEach((i) => {
      const o = t[i];
      if (!Pe(o))
        return;
      const a = {};
      for (const s of n)
        a[s] = o[s];
      (Ut(o.properties) && o.properties || [
        i
      ]).forEach((s) => {
        (s === i || !r.has(s)) && r.set(s, a);
      });
    });
  }
  _animateOptions(t, n) {
    const r = n.options, i = WZ(t, r);
    if (!i)
      return [];
    const o = this._createAnimations(i, r);
    return r.$shared && zZ(t.options.$animations, r).then(() => {
      t.options = r;
    }, () => {
    }), o;
  }
  _createAnimations(t, n) {
    const r = this._properties, i = [], o = t.$animations || (t.$animations = {}), a = Object.keys(n), s = Date.now();
    let l;
    for (l = a.length - 1; l >= 0; --l) {
      const c = a[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        i.push(...this._animateOptions(t, n));
        continue;
      }
      const u = n[c];
      let d = o[c];
      const f = r.get(c);
      if (d)
        if (f && d.active()) {
          d.update(f, u, s);
          continue;
        } else
          d.cancel();
      if (!f || !f.duration) {
        t[c] = u;
        continue;
      }
      o[c] = d = new BZ(f, t, c, u), i.push(d);
    }
    return i;
  }
  update(t, n) {
    if (this._properties.size === 0) {
      Object.assign(t, n);
      return;
    }
    const r = this._createAnimations(t, n);
    if (r.length)
      return Qr.add(this._chart, r), !0;
  }
}
function zZ(e, t) {
  const n = [], r = Object.keys(t);
  for (let i = 0; i < r.length; i++) {
    const o = e[r[i]];
    o && o.active() && n.push(o.wait());
  }
  return Promise.all(n);
}
function WZ(e, t) {
  if (!t)
    return;
  let n = e.options;
  if (!n) {
    e.options = t;
    return;
  }
  return n.$shared && (e.options = n = Object.assign({}, n, {
    $shared: !1,
    $animations: {}
  })), n;
}
function xS(e, t) {
  const n = e && e.options || {}, r = n.reverse, i = n.min === void 0 ? t : 0, o = n.max === void 0 ? t : 0;
  return {
    start: r ? o : i,
    end: r ? i : o
  };
}
function VZ(e, t, n) {
  if (n === !1)
    return !1;
  const r = xS(e, n), i = xS(t, n);
  return {
    top: i.end,
    right: r.end,
    bottom: i.start,
    left: r.start
  };
}
function UZ(e) {
  let t, n, r, i;
  return Pe(e) ? (t = e.top, n = e.right, r = e.bottom, i = e.left) : t = n = r = i = e, {
    top: t,
    right: n,
    bottom: r,
    left: i,
    disabled: e === !1
  };
}
function Rk(e, t) {
  const n = [], r = e._getSortedDatasetMetas(t);
  let i, o;
  for (i = 0, o = r.length; i < o; ++i)
    n.push(r[i].index);
  return n;
}
function wS(e, t, n, r = {}) {
  const i = e.keys, o = r.mode === "single";
  let a, s, l, c;
  if (t === null)
    return;
  let u = !1;
  for (a = 0, s = i.length; a < s; ++a) {
    if (l = +i[a], l === n) {
      if (u = !0, r.all)
        continue;
      break;
    }
    c = e.values[l], pr(c) && (o || t === 0 || Ir(t) === Ir(c)) && (t += c);
  }
  return !u && !r.all ? 0 : t;
}
function HZ(e, t) {
  const { iScale: n, vScale: r } = t, i = n.axis === "x" ? "x" : "y", o = r.axis === "x" ? "x" : "y", a = Object.keys(e), s = new Array(a.length);
  let l, c, u;
  for (l = 0, c = a.length; l < c; ++l)
    u = a[l], s[l] = {
      [i]: u,
      [o]: e[u]
    };
  return s;
}
function Ph(e, t) {
  const n = e && e.options.stacked;
  return n || n === void 0 && t.stack !== void 0;
}
function KZ(e, t, n) {
  return `${e.id}.${t.id}.${n.stack || n.type}`;
}
function qZ(e) {
  const { min: t, max: n, minDefined: r, maxDefined: i } = e.getUserBounds();
  return {
    min: r ? t : Number.NEGATIVE_INFINITY,
    max: i ? n : Number.POSITIVE_INFINITY
  };
}
function YZ(e, t, n) {
  const r = e[t] || (e[t] = {});
  return r[n] || (r[n] = {});
}
function OS(e, t, n, r) {
  for (const i of t.getMatchingVisibleMetas(r).reverse()) {
    const o = e[i.index];
    if (n && o > 0 || !n && o < 0)
      return i.index;
  }
  return null;
}
function SS(e, t) {
  const { chart: n, _cachedMeta: r } = e, i = n._stacks || (n._stacks = {}), { iScale: o, vScale: a, index: s } = r, l = o.axis, c = a.axis, u = KZ(o, a, r), d = t.length;
  let f;
  for (let p = 0; p < d; ++p) {
    const g = t[p], { [l]: m, [c]: v } = g, y = g._stacks || (g._stacks = {});
    f = y[c] = YZ(i, u, m), f[s] = v, f._top = OS(f, a, !0, r.type), f._bottom = OS(f, a, !1, r.type);
    const S = f._visualValues || (f._visualValues = {});
    S[s] = v;
  }
}
function Ch(e, t) {
  const n = e.scales;
  return Object.keys(n).filter((r) => n[r].axis === t).shift();
}
function GZ(e, t) {
  return Go(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function XZ(e, t, n) {
  return Go(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: t,
    mode: "default",
    type: "data"
  });
}
function gs(e, t) {
  const n = e.controller.index, r = e.vScale && e.vScale.axis;
  if (r) {
    t = t || e._parsed;
    for (const i of t) {
      const o = i._stacks;
      if (!o || o[r] === void 0 || o[r][n] === void 0)
        return;
      delete o[r][n], o[r]._visualValues !== void 0 && o[r]._visualValues[n] !== void 0 && delete o[r]._visualValues[n];
    }
  }
}
const Ah = (e) => e === "reset" || e === "none", ES = (e, t) => t ? e : Object.assign({}, e), ZZ = (e, t, n) => e && !t.hidden && t._stacked && {
  keys: Rk(n, !0),
  values: null
};
class Of {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(t, n) {
    this.chart = t, this._ctx = t.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = Ph(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && gs(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, n = this._cachedMeta, r = this.getDataset(), i = (d, f, p, g) => d === "x" ? f : d === "r" ? g : p, o = n.xAxisID = we(r.xAxisID, Ch(t, "x")), a = n.yAxisID = we(r.yAxisID, Ch(t, "y")), s = n.rAxisID = we(r.rAxisID, Ch(t, "r")), l = n.indexAxis, c = n.iAxisID = i(l, o, a, s), u = n.vAxisID = i(l, a, o, s);
    n.xScale = this.getScaleForId(o), n.yScale = this.getScaleForId(a), n.rScale = this.getScaleForId(s), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const n = this._cachedMeta;
    return t === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && oS(this._data, this), t._stacked && gs(t);
  }
  _dataCheck() {
    const t = this.getDataset(), n = t.data || (t.data = []), r = this._data;
    if (Pe(n)) {
      const i = this._cachedMeta;
      this._data = HZ(n, i);
    } else if (r !== n) {
      if (r) {
        oS(r, this);
        const i = this._cachedMeta;
        gs(i), i._parsed = [];
      }
      n && Object.isExtensible(n) && kX(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const n = this._cachedMeta, r = this.getDataset();
    let i = !1;
    this._dataCheck();
    const o = n._stacked;
    n._stacked = Ph(n.vScale, n), n.stack !== r.stack && (i = !0, gs(n), n.stack = r.stack), this._resyncElements(t), (i || o !== n._stacked) && (SS(this, n._parsed), n._stacked = Ph(n.vScale, n));
  }
  configure() {
    const t = this.chart.config, n = t.datasetScopeKeys(this._type), r = t.getOptionScopes(this.getDataset(), n, !0);
    this.options = t.createResolver(r, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, n) {
    const { _cachedMeta: r, _data: i } = this, { iScale: o, _stacked: a } = r, s = o.axis;
    let l = t === 0 && n === i.length ? !0 : r._sorted, c = t > 0 && r._parsed[t - 1], u, d, f;
    if (this._parsing === !1)
      r._parsed = i, r._sorted = !0, f = i;
    else {
      Ut(i[t]) ? f = this.parseArrayData(r, i, t, n) : Pe(i[t]) ? f = this.parseObjectData(r, i, t, n) : f = this.parsePrimitiveData(r, i, t, n);
      const p = () => d[s] === null || c && d[s] < c[s];
      for (u = 0; u < n; ++u)
        r._parsed[u + t] = d = f[u], l && (p() && (l = !1), c = d);
      r._sorted = l;
    }
    a && SS(this, f);
  }
  parsePrimitiveData(t, n, r, i) {
    const { iScale: o, vScale: a } = t, s = o.axis, l = a.axis, c = o.getLabels(), u = o === a, d = new Array(i);
    let f, p, g;
    for (f = 0, p = i; f < p; ++f)
      g = f + r, d[f] = {
        [s]: u || o.parse(c[g], g),
        [l]: a.parse(n[g], g)
      };
    return d;
  }
  parseArrayData(t, n, r, i) {
    const { xScale: o, yScale: a } = t, s = new Array(i);
    let l, c, u, d;
    for (l = 0, c = i; l < c; ++l)
      u = l + r, d = n[u], s[l] = {
        x: o.parse(d[0], u),
        y: a.parse(d[1], u)
      };
    return s;
  }
  parseObjectData(t, n, r, i) {
    const { xScale: o, yScale: a } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(i);
    let u, d, f, p;
    for (u = 0, d = i; u < d; ++u)
      f = u + r, p = n[f], c[u] = {
        x: o.parse(zo(p, s), f),
        y: a.parse(zo(p, l), f)
      };
    return c;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, n, r) {
    const i = this.chart, o = this._cachedMeta, a = n[t.axis], s = {
      keys: Rk(i, !0),
      values: n._stacks[t.axis]._visualValues
    };
    return wS(s, a, o.index, {
      mode: r
    });
  }
  updateRangeFromParsed(t, n, r, i) {
    const o = r[n.axis];
    let a = o === null ? NaN : o;
    const s = i && r._stacks[n.axis];
    i && s && (i.values = s, a = wS(i, o, this._cachedMeta.index)), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a);
  }
  getMinMax(t, n) {
    const r = this._cachedMeta, i = r._parsed, o = r._sorted && t === r.iScale, a = i.length, s = this._getOtherScale(t), l = ZZ(n, r, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: d } = qZ(s);
    let f, p;
    function g() {
      p = i[f];
      const m = p[s.axis];
      return !pr(p[t.axis]) || u > m || d < m;
    }
    for (f = 0; f < a && !(!g() && (this.updateRangeFromParsed(c, t, p, l), o)); ++f)
      ;
    if (o) {
      for (f = a - 1; f >= 0; --f)
        if (!g()) {
          this.updateRangeFromParsed(c, t, p, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(t) {
    const n = this._cachedMeta._parsed, r = [];
    let i, o, a;
    for (i = 0, o = n.length; i < o; ++i)
      a = n[i][t.axis], pr(a) && r.push(a);
    return r;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, r = n.iScale, i = n.vScale, o = this.getParsed(t);
    return {
      label: r ? "" + r.getLabelForValue(o[r.axis]) : "",
      value: i ? "" + i.getLabelForValue(o[i.axis]) : ""
    };
  }
  _update(t) {
    const n = this._cachedMeta;
    this.update(t || "default"), n._clip = UZ(we(this.options.clip, VZ(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, n = this.chart, r = this._cachedMeta, i = r.data || [], o = n.chartArea, a = [], s = this._drawStart || 0, l = this._drawCount || i.length - s, c = this.options.drawActiveElementsOnTop;
    let u;
    for (r.dataset && r.dataset.draw(t, o, s, l), u = s; u < s + l; ++u) {
      const d = i[u];
      d.hidden || (d.active && c ? a.push(d) : d.draw(t, o));
    }
    for (u = 0; u < a.length; ++u)
      a[u].draw(t, o);
  }
  getStyle(t, n) {
    const r = n ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(t || 0, r);
  }
  getContext(t, n, r) {
    const i = this.getDataset();
    let o;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const a = this._cachedMeta.data[t];
      o = a.$context || (a.$context = XZ(this.getContext(), t, a)), o.parsed = this.getParsed(t), o.raw = i.data[t], o.index = o.dataIndex = t;
    } else
      o = this.$context || (this.$context = GZ(this.chart.getContext(), this.index)), o.dataset = i, o.index = o.datasetIndex = this.index;
    return o.active = !!n, o.mode = r, o;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, t);
  }
  _resolveElementOptions(t, n = "default", r) {
    const i = n === "active", o = this._cachedDataOpts, a = t + "-" + n, s = o[a], l = this.enableOptionSharing && fl(r);
    if (s)
      return ES(s, l);
    const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, t), d = i ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], f = c.getOptionScopes(this.getDataset(), u), p = Object.keys(St.elements[t]), g = () => this.getContext(r, i, n), m = c.resolveNamedOptions(f, p, g, d);
    return m.$shared && (m.$shared = l, o[a] = Object.freeze(ES(m, l))), m;
  }
  _resolveAnimations(t, n, r) {
    const i = this.chart, o = this._cachedDataOpts, a = `animation-${n}`, s = o[a];
    if (s)
      return s;
    let l;
    if (i.options.animation !== !1) {
      const u = this.chart.config, d = u.datasetAnimationScopeKeys(this._type, n), f = u.getOptionScopes(this.getDataset(), d);
      l = u.createResolver(f, this.getContext(t, r, n));
    }
    const c = new Dk(i, l && l.animations);
    return l && l._cacheable && (o[a] = Object.freeze(c)), c;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, n) {
    return !n || Ah(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, n) {
    const r = this.resolveDataElementOptions(t, n), i = this._sharedOptions, o = this.getSharedOptions(r), a = this.includeOptions(n, o) || o !== i;
    return this.updateSharedOptions(o, n, r), {
      sharedOptions: o,
      includeOptions: a
    };
  }
  updateElement(t, n, r, i) {
    Ah(i) ? Object.assign(t, r) : this._resolveAnimations(n, i).update(t, r);
  }
  updateSharedOptions(t, n, r) {
    t && !Ah(n) && this._resolveAnimations(void 0, n).update(t, r);
  }
  _setStyle(t, n, r, i) {
    t.active = i;
    const o = this.getStyle(n, i);
    this._resolveAnimations(n, r, i).update(t, {
      options: !i && this.getSharedOptions(o) || o
    });
  }
  removeHoverStyle(t, n, r) {
    this._setStyle(t, r, "active", !1);
  }
  setHoverStyle(t, n, r) {
    this._setStyle(t, r, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const n = this._data, r = this._cachedMeta.data;
    for (const [s, l, c] of this._syncList)
      this[s](l, c);
    this._syncList = [];
    const i = r.length, o = n.length, a = Math.min(o, i);
    a && this.parse(0, a), o > i ? this._insertElements(i, o - i, t) : o < i && this._removeElements(o, i - o);
  }
  _insertElements(t, n, r = !0) {
    const i = this._cachedMeta, o = i.data, a = t + n;
    let s;
    const l = (c) => {
      for (c.length += n, s = c.length - 1; s >= a; s--)
        c[s] = c[s - n];
    };
    for (l(o), s = t; s < a; ++s)
      o[s] = new this.dataElementType();
    this._parsing && l(i._parsed), this.parse(t, n), r && this.updateElements(o, t, n, "reset");
  }
  updateElements(t, n, r, i) {
  }
  _removeElements(t, n) {
    const r = this._cachedMeta;
    if (this._parsing) {
      const i = r._parsed.splice(t, n);
      r._stacked && gs(r, i);
    }
    r.data.splice(t, n);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [n, r, i] = t;
      this[n](r, i);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, n) {
    n && this._sync([
      "_removeElements",
      t,
      n
    ]);
    const r = arguments.length - 2;
    r && this._sync([
      "_insertElements",
      t,
      r
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
function JZ(e, t) {
  if (!e._cache.$bar) {
    const n = e.getMatchingVisibleMetas(t);
    let r = [];
    for (let i = 0, o = n.length; i < o; i++)
      r = r.concat(n[i].controller.getAllParsedValues(e));
    e._cache.$bar = bk(r.sort((i, o) => i - o));
  }
  return e._cache.$bar;
}
function QZ(e) {
  const t = e.iScale, n = JZ(t, e.type);
  let r = t._length, i, o, a, s;
  const l = () => {
    a === 32767 || a === -32768 || (fl(s) && (r = Math.min(r, Math.abs(a - s) || r)), s = a);
  };
  for (i = 0, o = n.length; i < o; ++i)
    a = t.getPixelForValue(n[i]), l();
  for (s = void 0, i = 0, o = t.ticks.length; i < o; ++i)
    a = t.getPixelForTick(i), l();
  return r;
}
function eJ(e, t, n, r) {
  const i = n.barThickness;
  let o, a;
  return Fe(i) ? (o = t.min * n.categoryPercentage, a = n.barPercentage) : (o = i * r, a = 1), {
    chunk: o / r,
    ratio: a,
    start: t.pixels[e] - o / 2
  };
}
function tJ(e, t, n, r) {
  const i = t.pixels, o = i[e];
  let a = e > 0 ? i[e - 1] : null, s = e < i.length - 1 ? i[e + 1] : null;
  const l = n.categoryPercentage;
  a === null && (a = o - (s === null ? t.end - t.start : s - o)), s === null && (s = o + o - a);
  const c = o - (o - Math.min(a, s)) / 2 * l;
  return {
    chunk: Math.abs(s - a) / 2 * l / r,
    ratio: n.barPercentage,
    start: c
  };
}
function nJ(e, t, n, r) {
  const i = n.parse(e[0], r), o = n.parse(e[1], r), a = Math.min(i, o), s = Math.max(i, o);
  let l = a, c = s;
  Math.abs(a) > Math.abs(s) && (l = s, c = a), t[n.axis] = c, t._custom = {
    barStart: l,
    barEnd: c,
    start: i,
    end: o,
    min: a,
    max: s
  };
}
function Ik(e, t, n, r) {
  return Ut(e) ? nJ(e, t, n, r) : t[n.axis] = n.parse(e, r), t;
}
function _S(e, t, n, r) {
  const i = e.iScale, o = e.vScale, a = i.getLabels(), s = i === o, l = [];
  let c, u, d, f;
  for (c = n, u = n + r; c < u; ++c)
    f = t[c], d = {}, d[i.axis] = s || i.parse(a[c], c), l.push(Ik(f, d, o, c));
  return l;
}
function Th(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function rJ(e, t, n) {
  return e !== 0 ? Ir(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1);
}
function iJ(e) {
  let t, n, r, i, o;
  return e.horizontal ? (t = e.base > e.x, n = "left", r = "right") : (t = e.base < e.y, n = "bottom", r = "top"), t ? (i = "end", o = "start") : (i = "start", o = "end"), {
    start: n,
    end: r,
    reverse: t,
    top: i,
    bottom: o
  };
}
function oJ(e, t, n, r) {
  let i = t.borderSkipped;
  const o = {};
  if (!i) {
    e.borderSkipped = o;
    return;
  }
  if (i === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: a, end: s, reverse: l, top: c, bottom: u } = iJ(e);
  i === "middle" && n && (e.enableBorderRadius = !0, (n._top || 0) === r ? i = c : (n._bottom || 0) === r ? i = u : (o[PS(u, a, s, l)] = !0, i = c)), o[PS(i, a, s, l)] = !0, e.borderSkipped = o;
}
function PS(e, t, n, r) {
  return r ? (e = aJ(e, t, n), e = CS(e, n, t)) : e = CS(e, t, n), e;
}
function aJ(e, t, n) {
  return e === t ? n : e === n ? t : e;
}
function CS(e, t, n) {
  return e === "start" ? t : e === "end" ? n : e;
}
function sJ(e, { inflateAmount: t }, n) {
  e.inflateAmount = t === "auto" ? n === 1 ? 0.33 : 0 : t;
}
class lJ extends Of {
  static id = "bar";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  parsePrimitiveData(t, n, r, i) {
    return _S(t, n, r, i);
  }
  parseArrayData(t, n, r, i) {
    return _S(t, n, r, i);
  }
  parseObjectData(t, n, r, i) {
    const { iScale: o, vScale: a } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, c = o.axis === "x" ? s : l, u = a.axis === "x" ? s : l, d = [];
    let f, p, g, m;
    for (f = r, p = r + i; f < p; ++f)
      m = n[f], g = {}, g[o.axis] = o.parse(zo(m, c), f), d.push(Ik(zo(m, u), g, a, f));
    return d;
  }
  updateRangeFromParsed(t, n, r, i) {
    super.updateRangeFromParsed(t, n, r, i);
    const o = r._custom;
    o && n === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, { iScale: r, vScale: i } = n, o = this.getParsed(t), a = o._custom, s = Th(a) ? "[" + a.start + ", " + a.end + "]" : "" + i.getLabelForValue(o[i.axis]);
    return {
      label: "" + r.getLabelForValue(o[r.axis]),
      value: s
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const n = this._cachedMeta;
    this.updateElements(n.data, 0, n.data.length, t);
  }
  updateElements(t, n, r, i) {
    const o = i === "reset", { index: a, _cachedMeta: { vScale: s } } = this, l = s.getBasePixel(), c = s.isHorizontal(), u = this._getRuler(), { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, i);
    for (let p = n; p < n + r; p++) {
      const g = this.getParsed(p), m = o || Fe(g[s.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(p), v = this._calculateBarIndexPixels(p, u), y = (g._stacks || {})[s.axis], S = {
        horizontal: c,
        base: m.base,
        enableBorderRadius: !y || Th(g._custom) || a === y._top || a === y._bottom,
        x: c ? m.head : v.center,
        y: c ? v.center : m.head,
        height: c ? v.size : Math.abs(m.size),
        width: c ? Math.abs(m.size) : v.size
      };
      f && (S.options = d || this.resolveDataElementOptions(p, t[p].active ? "active" : i));
      const x = S.options || t[p].options;
      oJ(S, x, y, a), sJ(S, x, u.ratio), this.updateElement(t[p], p, S, i);
    }
  }
  _getStacks(t, n) {
    const { iScale: r } = this._cachedMeta, i = r.getMatchingVisibleMetas(this._type).filter((u) => u.controller.options.grouped), o = r.options.stacked, a = [], s = this._cachedMeta.controller.getParsed(n), l = s && s[r.axis], c = (u) => {
      const d = u._parsed.find((p) => p[r.axis] === l), f = d && d[u.vScale.axis];
      if (Fe(f) || isNaN(f))
        return !0;
    };
    for (const u of i)
      if (!(n !== void 0 && c(u)) && ((o === !1 || a.indexOf(u.stack) === -1 || o === void 0 && u.stack === void 0) && a.push(u.stack), u.index === t))
        break;
    return a.length || a.push(void 0), a;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales, n = this.chart.options.indexAxis;
    return Object.keys(t).filter((r) => t[r].axis === n).shift();
  }
  _getAxis() {
    const t = {}, n = this.getFirstScaleIdForIndexAxis();
    for (const r of this.chart.data.datasets)
      t[we(this.chart.options.indexAxis === "x" ? r.xAxisID : r.yAxisID, n)] = !0;
    return Object.keys(t);
  }
  _getStackIndex(t, n, r) {
    const i = this._getStacks(t, r), o = n !== void 0 ? i.indexOf(n) : -1;
    return o === -1 ? i.length - 1 : o;
  }
  _getRuler() {
    const t = this.options, n = this._cachedMeta, r = n.iScale, i = [];
    let o, a;
    for (o = 0, a = n.data.length; o < a; ++o)
      i.push(r.getPixelForValue(this.getParsed(o)[r.axis], o));
    const s = t.barThickness;
    return {
      min: s || QZ(n),
      pixels: i,
      start: r._startPixel,
      end: r._endPixel,
      stackCount: this._getStackCount(),
      scale: r,
      grouped: t.grouped,
      ratio: s ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: n, _stacked: r, index: i }, options: { base: o, minBarLength: a } } = this, s = o || 0, l = this.getParsed(t), c = l._custom, u = Th(c);
    let d = l[n.axis], f = 0, p = r ? this.applyStack(n, l, r) : d, g, m;
    p !== d && (f = p - d, p = d), u && (d = c.barStart, p = c.barEnd - c.barStart, d !== 0 && Ir(d) !== Ir(c.barEnd) && (f = 0), f += d);
    const v = !Fe(o) && !u ? o : f;
    let y = n.getPixelForValue(v);
    if (this.chart.getDataVisibility(t) ? g = n.getPixelForValue(f + p) : g = y, m = g - y, Math.abs(m) < a) {
      m = rJ(m, n, s) * a, d === s && (y -= m / 2);
      const S = n.getPixelForDecimal(0), x = n.getPixelForDecimal(1), b = Math.min(S, x), w = Math.max(S, x);
      y = Math.max(Math.min(y, w), b), g = y + m, r && !u && (l._stacks[n.axis]._visualValues[i] = n.getValueForPixel(g) - n.getValueForPixel(y));
    }
    if (y === n.getPixelForValue(s)) {
      const S = Ir(m) * n.getLineWidthForValue(s) / 2;
      y += S, m -= S;
    }
    return {
      size: m,
      base: y,
      head: g,
      center: g + m / 2
    };
  }
  _calculateBarIndexPixels(t, n) {
    const r = n.scale, i = this.options, o = i.skipNull, a = we(i.maxBarThickness, 1 / 0);
    let s, l;
    const c = this._getAxisCount();
    if (n.grouped) {
      const u = o ? this._getStackCount(t) : n.stackCount, d = i.barThickness === "flex" ? tJ(t, n, i, u * c) : eJ(t, n, i, u * c), f = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, p = this._getAxis().indexOf(we(f, this.getFirstScaleIdForIndexAxis())), g = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0) + p;
      s = d.start + d.chunk * g + d.chunk / 2, l = Math.min(a, d.chunk * d.ratio);
    } else
      s = r.getPixelForValue(this.getParsed(t)[r.axis], t), l = Math.min(a, n.min * n.ratio);
    return {
      base: s - l / 2,
      head: s + l / 2,
      center: s,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, n = t.vScale, r = t.data, i = r.length;
    let o = 0;
    for (; o < i; ++o)
      this.getParsed(o)[n.axis] !== null && !r[o].hidden && r[o].draw(this._ctx);
  }
}
function cJ(e, t, n) {
  let r = 1, i = 1, o = 0, a = 0;
  if (t < bt) {
    const s = e, l = s + t, c = Math.cos(s), u = Math.sin(s), d = Math.cos(l), f = Math.sin(l), p = (x, b, w) => hl(x, s, l, !0) ? 1 : Math.max(b, b * n, w, w * n), g = (x, b, w) => hl(x, s, l, !0) ? -1 : Math.min(b, b * n, w, w * n), m = p(0, c, d), v = p(Dt, u, f), y = g(Je, c, d), S = g(Je + Dt, u, f);
    r = (m - y) / 2, i = (v - S) / 2, o = -(m + y) / 2, a = -(v + S) / 2;
  }
  return {
    ratioX: r,
    ratioY: i,
    offsetX: o,
    offsetY: a
  };
}
class uJ extends Of {
  static id = "doughnut";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (t) => t !== "spacing",
    _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const n = t.data;
            if (n.labels.length && n.datasets.length) {
              const { labels: { pointStyle: r, color: i } } = t.legend.options;
              return n.labels.map((o, a) => {
                const l = t.getDatasetMeta(0).controller.getStyle(a);
                return {
                  text: o,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: i,
                  lineWidth: l.borderWidth,
                  pointStyle: r,
                  hidden: !t.getDataVisibility(a),
                  index: a
                };
              });
            }
            return [];
          }
        },
        onClick(t, n, r) {
          r.chart.toggleDataVisibility(n.index), r.chart.update();
        }
      }
    }
  };
  constructor(t, n) {
    super(t, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, n) {
    const r = this.getDataset().data, i = this._cachedMeta;
    if (this._parsing === !1)
      i._parsed = r;
    else {
      let o = (l) => +r[l];
      if (Pe(r[t])) {
        const { key: l = "value" } = this._parsing;
        o = (c) => +zo(r[c], l);
      }
      let a, s;
      for (a = t, s = t + n; a < s; ++a)
        i._parsed[a] = o(a);
    }
  }
  _getRotation() {
    return li(this.options.rotation - 90);
  }
  _getCircumference() {
    return li(this.options.circumference);
  }
  _getRotationExtents() {
    let t = bt, n = -bt;
    for (let r = 0; r < this.chart.data.datasets.length; ++r)
      if (this.chart.isDatasetVisible(r) && this.chart.getDatasetMeta(r).type === this._type) {
        const i = this.chart.getDatasetMeta(r).controller, o = i._getRotation(), a = i._getCircumference();
        t = Math.min(t, o), n = Math.max(n, o + a);
      }
    return {
      rotation: t,
      circumference: n - t
    };
  }
  update(t) {
    const n = this.chart, { chartArea: r } = n, i = this._cachedMeta, o = i.data, a = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, s = Math.max((Math.min(r.width, r.height) - a) / 2, 0), l = Math.min(pX(this.options.cutout, s), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: f, ratioY: p, offsetX: g, offsetY: m } = cJ(d, u, l), v = (r.width - a) / f, y = (r.height - a) / p, S = Math.max(Math.min(v, y) / 2, 0), x = hk(this.options.radius, S), b = Math.max(x * l, 0), w = (x - b) / this._getVisibleDatasetWeightTotal();
    this.offsetX = g * x, this.offsetY = m * x, i.total = this.calculateTotal(), this.outerRadius = x - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * c, 0), this.updateElements(o, 0, o.length, t);
  }
  _circumference(t, n) {
    const r = this.options, i = this._cachedMeta, o = this._getCircumference();
    return n && r.animation.animateRotate || !this.chart.getDataVisibility(t) || i._parsed[t] === null || i.data[t].hidden ? 0 : this.calculateCircumference(i._parsed[t] * o / bt);
  }
  updateElements(t, n, r, i) {
    const o = i === "reset", a = this.chart, s = a.chartArea, c = a.options.animation, u = (s.left + s.right) / 2, d = (s.top + s.bottom) / 2, f = o && c.animateScale, p = f ? 0 : this.innerRadius, g = f ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: v } = this._getSharedOptions(n, i);
    let y = this._getRotation(), S;
    for (S = 0; S < n; ++S)
      y += this._circumference(S, o);
    for (S = n; S < n + r; ++S) {
      const x = this._circumference(S, o), b = t[S], w = {
        x: u + this.offsetX,
        y: d + this.offsetY,
        startAngle: y,
        endAngle: y + x,
        circumference: x,
        outerRadius: g,
        innerRadius: p
      };
      v && (w.options = m || this.resolveDataElementOptions(S, b.active ? "active" : i)), y += x, this.updateElement(b, S, w, i);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, n = t.data;
    let r = 0, i;
    for (i = 0; i < n.length; i++) {
      const o = t._parsed[i];
      o !== null && !isNaN(o) && this.chart.getDataVisibility(i) && !n[i].hidden && (r += Math.abs(o));
    }
    return r;
  }
  calculateCircumference(t) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(t) ? bt * (Math.abs(t) / n) : 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, r = this.chart, i = r.data.labels || [], o = Wy(n._parsed[t], r.options.locale);
    return {
      label: i[t] || "",
      value: o
    };
  }
  getMaxBorderWidth(t) {
    let n = 0;
    const r = this.chart;
    let i, o, a, s, l;
    if (!t) {
      for (i = 0, o = r.data.datasets.length; i < o; ++i)
        if (r.isDatasetVisible(i)) {
          a = r.getDatasetMeta(i), t = a.data, s = a.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (i = 0, o = t.length; i < o; ++i)
      l = s.resolveDataElementOptions(i), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(t) {
    let n = 0;
    for (let r = 0, i = t.length; r < i; ++r) {
      const o = this.resolveDataElementOptions(r);
      n = Math.max(n, o.offset || 0, o.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(t) {
    let n = 0;
    for (let r = 0; r < t; ++r)
      this.chart.isDatasetVisible(r) && (n += this._getRingWeight(r));
    return n;
  }
  _getRingWeight(t) {
    return Math.max(we(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
class dJ extends Of {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const n = this._cachedMeta, { dataset: r, data: i = [], _dataset: o } = n, a = this.chart._animationsDisabled;
    let { start: s, count: l } = NX(n, i, a);
    this._drawStart = s, this._drawCount = l, DX(n) && (s = 0, l = i.length), r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!o._decimated, r.points = i;
    const c = this.resolveDatasetElementOptions(t);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(r, void 0, {
      animated: !a,
      options: c
    }, t), this.updateElements(i, s, l, t);
  }
  updateElements(t, n, r, i) {
    const o = i === "reset", { iScale: a, vScale: s, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, i), f = a.axis, p = s.axis, { spanGaps: g, segment: m } = this.options, v = pl(g) ? g : Number.POSITIVE_INFINITY, y = this.chart._animationsDisabled || o || i === "none", S = n + r, x = t.length;
    let b = n > 0 && this.getParsed(n - 1);
    for (let w = 0; w < x; ++w) {
      const E = t[w], C = y ? E : {};
      if (w < n || w >= S) {
        C.skip = !0;
        continue;
      }
      const A = this.getParsed(w), k = Fe(A[p]), R = C[f] = a.getPixelForValue(A[f], w), M = C[p] = o || k ? s.getBasePixel() : s.getPixelForValue(l ? this.applyStack(s, A, l) : A[p], w);
      C.skip = isNaN(R) || isNaN(M) || k, C.stop = w > 0 && Math.abs(A[f] - b[f]) > v, m && (C.parsed = A, C.raw = c.data[w]), d && (C.options = u || this.resolveDataElementOptions(w, E.active ? "active" : i)), y || this.updateElement(E, w, C, i), b = A;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, n = t.dataset, r = n.options && n.options.borderWidth || 0, i = t.data || [];
    if (!i.length)
      return r;
    const o = i[0].size(this.resolveDataElementOptions(0)), a = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
    return Math.max(r, o, a) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
function uo() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Zy {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(Zy.prototype, t);
  }
  options;
  constructor(t) {
    this.options = t || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return uo();
  }
  parse() {
    return uo();
  }
  format() {
    return uo();
  }
  add() {
    return uo();
  }
  diff() {
    return uo();
  }
  startOf() {
    return uo();
  }
  endOf() {
    return uo();
  }
}
var fJ = {
  _date: Zy
};
function pJ(e, t, n, r) {
  const { controller: i, data: o, _sorted: a } = e, s = i._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (s && t === s.axis && t !== "r" && a && o.length) {
    const c = s._reversePixels ? AX : Po;
    if (r) {
      if (i._sharedOptions) {
        const u = o[0], d = typeof u.getRange == "function" && u.getRange(t);
        if (d) {
          const f = c(o, t, n - d), p = c(o, t, n + d);
          return {
            lo: f.lo,
            hi: p.hi
          };
        }
      }
    } else {
      const u = c(o, t, n);
      if (l) {
        const { vScale: d } = i._cachedMeta, { _parsed: f } = e, p = f.slice(0, u.lo + 1).reverse().findIndex((m) => !Fe(m[d.axis]));
        u.lo -= Math.max(0, p);
        const g = f.slice(u.hi).findIndex((m) => !Fe(m[d.axis]));
        u.hi += Math.max(0, g);
      }
      return u;
    }
  }
  return {
    lo: 0,
    hi: o.length - 1
  };
}
function Sf(e, t, n, r, i) {
  const o = e.getSortedVisibleDatasetMetas(), a = n[t];
  for (let s = 0, l = o.length; s < l; ++s) {
    const { index: c, data: u } = o[s], { lo: d, hi: f } = pJ(o[s], t, a, i);
    for (let p = d; p <= f; ++p) {
      const g = u[p];
      g.skip || r(g, c, p);
    }
  }
}
function hJ(e) {
  const t = e.indexOf("x") !== -1, n = e.indexOf("y") !== -1;
  return function(r, i) {
    const o = t ? Math.abs(r.x - i.x) : 0, a = n ? Math.abs(r.y - i.y) : 0;
    return Math.sqrt(Math.pow(o, 2) + Math.pow(a, 2));
  };
}
function kh(e, t, n, r, i) {
  const o = [];
  return !i && !e.isPointInArea(t) || Sf(e, n, t, function(s, l, c) {
    !i && !ml(s, e.chartArea, 0) || s.inRange(t.x, t.y, r) && o.push({
      element: s,
      datasetIndex: l,
      index: c
    });
  }, !0), o;
}
function mJ(e, t, n, r) {
  let i = [];
  function o(a, s, l) {
    const { startAngle: c, endAngle: u } = a.getProps([
      "startAngle",
      "endAngle"
    ], r), { angle: d } = vk(a, {
      x: t.x,
      y: t.y
    });
    hl(d, c, u) && i.push({
      element: a,
      datasetIndex: s,
      index: l
    });
  }
  return Sf(e, n, t, o), i;
}
function gJ(e, t, n, r, i, o) {
  let a = [];
  const s = hJ(n);
  let l = Number.POSITIVE_INFINITY;
  function c(u, d, f) {
    const p = u.inRange(t.x, t.y, i);
    if (r && !p)
      return;
    const g = u.getCenterPoint(i);
    if (!(!!o || e.isPointInArea(g)) && !p)
      return;
    const v = s(t, g);
    v < l ? (a = [
      {
        element: u,
        datasetIndex: d,
        index: f
      }
    ], l = v) : v === l && a.push({
      element: u,
      datasetIndex: d,
      index: f
    });
  }
  return Sf(e, n, t, c), a;
}
function Mh(e, t, n, r, i, o) {
  return !o && !e.isPointInArea(t) ? [] : n === "r" && !r ? mJ(e, t, n, i) : gJ(e, t, n, r, i, o);
}
function AS(e, t, n, r, i) {
  const o = [], a = n === "x" ? "inXRange" : "inYRange";
  let s = !1;
  return Sf(e, n, t, (l, c, u) => {
    l[a] && l[a](t[n], i) && (o.push({
      element: l,
      datasetIndex: c,
      index: u
    }), s = s || l.inRange(t.x, t.y, i));
  }), r && !s ? [] : o;
}
var vJ = {
  modes: {
    index(e, t, n, r) {
      const i = yo(t, e), o = n.axis || "x", a = n.includeInvisible || !1, s = n.intersect ? kh(e, i, o, r, a) : Mh(e, i, o, !1, r, a), l = [];
      return s.length ? (e.getSortedVisibleDatasetMetas().forEach((c) => {
        const u = s[0].index, d = c.data[u];
        d && !d.skip && l.push({
          element: d,
          datasetIndex: c.index,
          index: u
        });
      }), l) : [];
    },
    dataset(e, t, n, r) {
      const i = yo(t, e), o = n.axis || "xy", a = n.includeInvisible || !1;
      let s = n.intersect ? kh(e, i, o, r, a) : Mh(e, i, o, !1, r, a);
      if (s.length > 0) {
        const l = s[0].datasetIndex, c = e.getDatasetMeta(l).data;
        s = [];
        for (let u = 0; u < c.length; ++u)
          s.push({
            element: c[u],
            datasetIndex: l,
            index: u
          });
      }
      return s;
    },
    point(e, t, n, r) {
      const i = yo(t, e), o = n.axis || "xy", a = n.includeInvisible || !1;
      return kh(e, i, o, r, a);
    },
    nearest(e, t, n, r) {
      const i = yo(t, e), o = n.axis || "xy", a = n.includeInvisible || !1;
      return Mh(e, i, o, n.intersect, r, a);
    },
    x(e, t, n, r) {
      const i = yo(t, e);
      return AS(e, i, "x", n.intersect, r);
    },
    y(e, t, n, r) {
      const i = yo(t, e);
      return AS(e, i, "y", n.intersect, r);
    }
  }
};
const $k = [
  "left",
  "top",
  "right",
  "bottom"
];
function vs(e, t) {
  return e.filter((n) => n.pos === t);
}
function TS(e, t) {
  return e.filter((n) => $k.indexOf(n.pos) === -1 && n.box.axis === t);
}
function ys(e, t) {
  return e.sort((n, r) => {
    const i = t ? r : n, o = t ? n : r;
    return i.weight === o.weight ? i.index - o.index : i.weight - o.weight;
  });
}
function yJ(e) {
  const t = [];
  let n, r, i, o, a, s;
  for (n = 0, r = (e || []).length; n < r; ++n)
    i = e[n], { position: o, options: { stack: a, stackWeight: s = 1 } } = i, t.push({
      index: n,
      box: i,
      pos: o,
      horizontal: i.isHorizontal(),
      weight: i.weight,
      stack: a && o + a,
      stackWeight: s
    });
  return t;
}
function bJ(e) {
  const t = {};
  for (const n of e) {
    const { stack: r, pos: i, stackWeight: o } = n;
    if (!r || !$k.includes(i))
      continue;
    const a = t[r] || (t[r] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    a.count++, a.weight += o;
  }
  return t;
}
function xJ(e, t) {
  const n = bJ(e), { vBoxMaxWidth: r, hBoxMaxHeight: i } = t;
  let o, a, s;
  for (o = 0, a = e.length; o < a; ++o) {
    s = e[o];
    const { fullSize: l } = s.box, c = n[s.stack], u = c && s.stackWeight / c.weight;
    s.horizontal ? (s.width = u ? u * r : l && t.availableWidth, s.height = i) : (s.width = r, s.height = u ? u * i : l && t.availableHeight);
  }
  return n;
}
function wJ(e) {
  const t = yJ(e), n = ys(t.filter((c) => c.box.fullSize), !0), r = ys(vs(t, "left"), !0), i = ys(vs(t, "right")), o = ys(vs(t, "top"), !0), a = ys(vs(t, "bottom")), s = TS(t, "x"), l = TS(t, "y");
  return {
    fullSize: n,
    leftAndTop: r.concat(o),
    rightAndBottom: i.concat(l).concat(a).concat(s),
    chartArea: vs(t, "chartArea"),
    vertical: r.concat(i).concat(l),
    horizontal: o.concat(a).concat(s)
  };
}
function kS(e, t, n, r) {
  return Math.max(e[n], t[n]) + Math.max(e[r], t[r]);
}
function Lk(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function OJ(e, t, n, r) {
  const { pos: i, box: o } = n, a = e.maxPadding;
  if (!Pe(i)) {
    n.size && (e[i] -= n.size);
    const d = r[n.stack] || {
      size: 0,
      count: 1
    };
    d.size = Math.max(d.size, n.horizontal ? o.height : o.width), n.size = d.size / d.count, e[i] += n.size;
  }
  o.getPadding && Lk(a, o.getPadding());
  const s = Math.max(0, t.outerWidth - kS(a, e, "left", "right")), l = Math.max(0, t.outerHeight - kS(a, e, "top", "bottom")), c = s !== e.w, u = l !== e.h;
  return e.w = s, e.h = l, n.horizontal ? {
    same: c,
    other: u
  } : {
    same: u,
    other: c
  };
}
function SJ(e) {
  const t = e.maxPadding;
  function n(r) {
    const i = Math.max(t[r] - e[r], 0);
    return e[r] += i, i;
  }
  e.y += n("top"), e.x += n("left"), n("right"), n("bottom");
}
function EJ(e, t) {
  const n = t.maxPadding;
  function r(i) {
    const o = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return i.forEach((a) => {
      o[a] = Math.max(t[a], n[a]);
    }), o;
  }
  return r(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Ts(e, t, n, r) {
  const i = [];
  let o, a, s, l, c, u;
  for (o = 0, a = e.length, c = 0; o < a; ++o) {
    s = e[o], l = s.box, l.update(s.width || t.w, s.height || t.h, EJ(s.horizontal, t));
    const { same: d, other: f } = OJ(t, n, s, r);
    c |= d && i.length, u = u || f, l.fullSize || i.push(s);
  }
  return c && Ts(i, t, n, r) || u;
}
function Fc(e, t, n, r, i) {
  e.top = n, e.left = t, e.right = t + r, e.bottom = n + i, e.width = r, e.height = i;
}
function MS(e, t, n, r) {
  const i = n.padding;
  let { x: o, y: a } = t;
  for (const s of e) {
    const l = s.box, c = r[s.stack] || {
      placed: 0,
      weight: 1
    }, u = s.stackWeight / c.weight || 1;
    if (s.horizontal) {
      const d = t.w * u, f = c.size || l.height;
      fl(c.start) && (a = c.start), l.fullSize ? Fc(l, i.left, a, n.outerWidth - i.right - i.left, f) : Fc(l, t.left + c.placed, a, d, f), c.start = a, c.placed += d, a = l.bottom;
    } else {
      const d = t.h * u, f = c.size || l.width;
      fl(c.start) && (o = c.start), l.fullSize ? Fc(l, o, i.top, f, n.outerHeight - i.bottom - i.top) : Fc(l, o, t.top + c.placed, f, d), c.start = o, c.placed += d, o = l.right;
    }
  }
  t.x = o, t.y = a;
}
var Di = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            t.draw(n);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const n = e.boxes ? e.boxes.indexOf(t) : -1;
    n !== -1 && e.boxes.splice(n, 1);
  },
  configure(e, t, n) {
    t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight;
  },
  update(e, t, n, r) {
    if (!e)
      return;
    const i = br(e.options.layout.padding), o = Math.max(t - i.width, 0), a = Math.max(n - i.height, 0), s = wJ(e.boxes), l = s.vertical, c = s.horizontal;
    We(e.boxes, (m) => {
      typeof m.beforeLayout == "function" && m.beforeLayout();
    });
    const u = l.reduce((m, v) => v.box.options && v.box.options.display === !1 ? m : m + 1, 0) || 1, d = Object.freeze({
      outerWidth: t,
      outerHeight: n,
      padding: i,
      availableWidth: o,
      availableHeight: a,
      vBoxMaxWidth: o / 2 / u,
      hBoxMaxHeight: a / 2
    }), f = Object.assign({}, i);
    Lk(f, br(r));
    const p = Object.assign({
      maxPadding: f,
      w: o,
      h: a,
      x: i.left,
      y: i.top
    }, i), g = xJ(l.concat(c), d);
    Ts(s.fullSize, p, d, g), Ts(l, p, d, g), Ts(c, p, d, g) && Ts(l, p, d, g), SJ(p), MS(s.leftAndTop, p, d, g), p.x += p.w, p.y += p.h, MS(s.rightAndBottom, p, d, g), e.chartArea = {
      left: p.left,
      top: p.top,
      right: p.left + p.w,
      bottom: p.top + p.h,
      height: p.h,
      width: p.w
    }, We(s.chartArea, (m) => {
      const v = m.box;
      Object.assign(v, e.chartArea), v.update(p.w, p.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class Fk {
  acquireContext(t, n) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, n, r) {
  }
  removeEventListener(t, n, r) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, n, r, i) {
    return n = Math.max(0, n || t.width), r = r || t.height, {
      width: n,
      height: Math.max(0, i ? Math.floor(n / i) : r)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class _J extends Fk {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const eu = "$chartjs", PJ = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, jS = (e) => e === null || e === "";
function CJ(e, t) {
  const n = e.style, r = e.getAttribute("height"), i = e.getAttribute("width");
  if (e[eu] = {
    initial: {
      height: r,
      width: i,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", jS(i)) {
    const o = mS(e, "width");
    o !== void 0 && (e.width = o);
  }
  if (jS(r))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const o = mS(e, "height");
      o !== void 0 && (e.height = o);
    }
  return e;
}
const Bk = SZ ? {
  passive: !0
} : !1;
function AJ(e, t, n) {
  e && e.addEventListener(t, n, Bk);
}
function TJ(e, t, n) {
  e && e.canvas && e.canvas.removeEventListener(t, n, Bk);
}
function kJ(e, t) {
  const n = PJ[e.type] || e.type, { x: r, y: i } = yo(e, t);
  return {
    type: n,
    chart: t,
    native: e,
    x: r !== void 0 ? r : null,
    y: i !== void 0 ? i : null
  };
}
function ud(e, t) {
  for (const n of e)
    if (n === t || n.contains(t))
      return !0;
}
function MJ(e, t, n) {
  const r = e.canvas, i = new MutationObserver((o) => {
    let a = !1;
    for (const s of o)
      a = a || ud(s.addedNodes, r), a = a && !ud(s.removedNodes, r);
    a && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
function jJ(e, t, n) {
  const r = e.canvas, i = new MutationObserver((o) => {
    let a = !1;
    for (const s of o)
      a = a || ud(s.removedNodes, r), a = a && !ud(s.addedNodes, r);
    a && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
const gl = /* @__PURE__ */ new Map();
let NS = 0;
function zk() {
  const e = window.devicePixelRatio;
  e !== NS && (NS = e, gl.forEach((t, n) => {
    n.currentDevicePixelRatio !== e && t();
  }));
}
function NJ(e, t) {
  gl.size || window.addEventListener("resize", zk), gl.set(e, t);
}
function DJ(e) {
  gl.delete(e), gl.size || window.removeEventListener("resize", zk);
}
function RJ(e, t, n) {
  const r = e.canvas, i = r && Xy(r);
  if (!i)
    return;
  const o = wk((s, l) => {
    const c = i.clientWidth;
    n(s, l), c < i.clientWidth && n();
  }, window), a = new ResizeObserver((s) => {
    const l = s[0], c = l.contentRect.width, u = l.contentRect.height;
    c === 0 && u === 0 || o(c, u);
  });
  return a.observe(i), NJ(e, o), a;
}
function jh(e, t, n) {
  n && n.disconnect(), t === "resize" && DJ(e);
}
function IJ(e, t, n) {
  const r = e.canvas, i = wk((o) => {
    e.ctx !== null && n(kJ(o, e));
  }, e);
  return AJ(r, t, i), i;
}
class $J extends Fk {
  acquireContext(t, n) {
    const r = t && t.getContext && t.getContext("2d");
    return r && r.canvas === t ? (CJ(t, n), r) : null;
  }
  releaseContext(t) {
    const n = t.canvas;
    if (!n[eu])
      return !1;
    const r = n[eu].initial;
    [
      "height",
      "width"
    ].forEach((o) => {
      const a = r[o];
      Fe(a) ? n.removeAttribute(o) : n.setAttribute(o, a);
    });
    const i = r.style || {};
    return Object.keys(i).forEach((o) => {
      n.style[o] = i[o];
    }), n.width = n.width, delete n[eu], !0;
  }
  addEventListener(t, n, r) {
    this.removeEventListener(t, n);
    const i = t.$proxies || (t.$proxies = {}), a = {
      attach: MJ,
      detach: jJ,
      resize: RJ
    }[n] || IJ;
    i[n] = a(t, n, r);
  }
  removeEventListener(t, n) {
    const r = t.$proxies || (t.$proxies = {}), i = r[n];
    if (!i)
      return;
    ({
      attach: jh,
      detach: jh,
      resize: jh
    }[n] || TJ)(t, n, i), r[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, n, r, i) {
    return OZ(t, n, r, i);
  }
  isAttached(t) {
    const n = t && Xy(t);
    return !!(n && n.isConnected);
  }
}
function LJ(e) {
  return !Gy() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? _J : $J;
}
let eo = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(t) {
    const { x: n, y: r } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: r
    };
  }
  hasValue() {
    return pl(this.x) && pl(this.y);
  }
  getProps(t, n) {
    const r = this.$animations;
    if (!n || !r)
      return this;
    const i = {};
    return t.forEach((o) => {
      i[o] = r[o] && r[o].active() ? r[o]._to : this[o];
    }), i;
  }
};
function FJ(e, t) {
  const n = e.options.ticks, r = BJ(e), i = Math.min(n.maxTicksLimit || r, r), o = n.major.enabled ? WJ(t) : [], a = o.length, s = o[0], l = o[a - 1], c = [];
  if (a > i)
    return VJ(t, c, o, a / i), c;
  const u = zJ(o, t, i);
  if (a > 0) {
    let d, f;
    const p = a > 1 ? Math.round((l - s) / (a - 1)) : null;
    for (Bc(t, c, u, Fe(p) ? 0 : s - p, s), d = 0, f = a - 1; d < f; d++)
      Bc(t, c, u, o[d], o[d + 1]);
    return Bc(t, c, u, l, Fe(p) ? t.length : l + p), c;
  }
  return Bc(t, c, u), c;
}
function BJ(e) {
  const t = e.options.offset, n = e._tickSize(), r = e._length / n + (t ? 0 : 1), i = e._maxLength / n;
  return Math.floor(Math.min(r, i));
}
function zJ(e, t, n) {
  const r = UJ(e), i = t.length / n;
  if (!r)
    return Math.max(i, 1);
  const o = wX(r);
  for (let a = 0, s = o.length - 1; a < s; a++) {
    const l = o[a];
    if (l > i)
      return l;
  }
  return Math.max(i, 1);
}
function WJ(e) {
  const t = [];
  let n, r;
  for (n = 0, r = e.length; n < r; n++)
    e[n].major && t.push(n);
  return t;
}
function VJ(e, t, n, r) {
  let i = 0, o = n[0], a;
  for (r = Math.ceil(r), a = 0; a < e.length; a++)
    a === o && (t.push(e[a]), i++, o = n[i * r]);
}
function Bc(e, t, n, r, i) {
  const o = we(r, 0), a = Math.min(we(i, e.length), e.length);
  let s = 0, l, c, u;
  for (n = Math.ceil(n), i && (l = i - r, n = l / Math.floor(l / n)), u = o; u < 0; )
    s++, u = Math.round(o + s * n);
  for (c = Math.max(o, 0); c < a; c++)
    c === u && (t.push(e[c]), s++, u = Math.round(o + s * n));
}
function UJ(e) {
  const t = e.length;
  let n, r;
  if (t < 2)
    return !1;
  for (r = e[0], n = 1; n < t; ++n)
    if (e[n] - e[n - 1] !== r)
      return !1;
  return r;
}
const HJ = (e) => e === "left" ? "right" : e === "right" ? "left" : e, DS = (e, t, n) => t === "top" || t === "left" ? e[t] + n : e[t] - n, RS = (e, t) => Math.min(t || e, e);
function IS(e, t) {
  const n = [], r = e.length / t, i = e.length;
  let o = 0;
  for (; o < i; o += r)
    n.push(e[Math.floor(o)]);
  return n;
}
function KJ(e, t, n) {
  const r = e.ticks.length, i = Math.min(t, r - 1), o = e._startPixel, a = e._endPixel, s = 1e-6;
  let l = e.getPixelForTick(i), c;
  if (!(n && (r === 1 ? c = Math.max(l - o, a - l) : t === 0 ? c = (e.getPixelForTick(1) - l) / 2 : c = (l - e.getPixelForTick(i - 1)) / 2, l += i < t ? c : -c, l < o - s || l > a + s)))
    return l;
}
function qJ(e, t) {
  We(e, (n) => {
    const r = n.gc, i = r.length / 2;
    let o;
    if (i > t) {
      for (o = 0; o < i; ++o)
        delete n.data[r[o]];
      r.splice(0, i);
    }
  });
}
function bs(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function $S(e, t) {
  if (!e.display)
    return 0;
  const n = Tn(e.font, t), r = br(e.padding);
  return (Ut(e.text) ? e.text.length : 1) * n.lineHeight + r.height;
}
function YJ(e, t) {
  return Go(e, {
    scale: t,
    type: "scale"
  });
}
function GJ(e, t, n) {
  return Go(e, {
    tick: n,
    index: t,
    type: "tick"
  });
}
function XJ(e, t, n) {
  let r = Ok(e);
  return (n && t !== "right" || !n && t === "right") && (r = HJ(r)), r;
}
function ZJ(e, t, n, r) {
  const { top: i, left: o, bottom: a, right: s, chart: l } = e, { chartArea: c, scales: u } = l;
  let d = 0, f, p, g;
  const m = a - i, v = s - o;
  if (e.isHorizontal()) {
    if (p = $n(r, o, s), Pe(n)) {
      const y = Object.keys(n)[0], S = n[y];
      g = u[y].getPixelForValue(S) + m - t;
    } else n === "center" ? g = (c.bottom + c.top) / 2 + m - t : g = DS(e, n, t);
    f = s - o;
  } else {
    if (Pe(n)) {
      const y = Object.keys(n)[0], S = n[y];
      p = u[y].getPixelForValue(S) - v + t;
    } else n === "center" ? p = (c.left + c.right) / 2 - v + t : p = DS(e, n, t);
    g = $n(r, a, i), d = n === "left" ? -Dt : Dt;
  }
  return {
    titleX: p,
    titleY: g,
    maxWidth: f,
    rotation: d
  };
}
class Za extends eo {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, n) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this;
    return t = Pr(t, Number.POSITIVE_INFINITY), n = Pr(n, Number.NEGATIVE_INFINITY), r = Pr(r, Number.POSITIVE_INFINITY), i = Pr(i, Number.NEGATIVE_INFINITY), {
      min: Pr(t, r),
      max: Pr(n, i),
      minDefined: pr(t),
      maxDefined: pr(n)
    };
  }
  getMinMax(t) {
    let { min: n, max: r, minDefined: i, maxDefined: o } = this.getUserBounds(), a;
    if (i && o)
      return {
        min: n,
        max: r
      };
    const s = this.getMatchingVisibleMetas();
    for (let l = 0, c = s.length; l < c; ++l)
      a = s[l].controller.getMinMax(this, t), i || (n = Math.min(n, a.min)), o || (r = Math.max(r, a.max));
    return n = o && n > r ? r : n, r = i && n > r ? n : r, {
      min: Pr(n, Pr(r, n)),
      max: Pr(r, Pr(n, r))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    rt(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, n, r) {
    const { beginAtZero: i, grace: o, ticks: a } = this.options, s = a.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = n, this._margins = r = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = eZ(this, o, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = s < this.ticks.length;
    this._convertTicksToLabels(l ? IS(this.ticks, s) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a.display && (a.autoSkip || a.source === "auto") && (this.ticks = FJ(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, n, r;
    this.isHorizontal() ? (n = this.left, r = this.right) : (n = this.top, r = this.bottom, t = !t), this._startPixel = n, this._endPixel = r, this._reversePixels = t, this._length = r - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    rt(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    rt(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    rt(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), rt(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    rt(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const n = this.options.ticks;
    let r, i, o;
    for (r = 0, i = t.length; r < i; r++)
      o = t[r], o.label = rt(n.callback, [
        o.value,
        r,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    rt(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    rt(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, n = t.ticks, r = RS(this.ticks.length, t.ticks.maxTicksLimit), i = n.minRotation || 0, o = n.maxRotation;
    let a = i, s, l, c;
    if (!this._isVisible() || !n.display || i >= o || r <= 1 || !this.isHorizontal()) {
      this.labelRotation = i;
      return;
    }
    const u = this._getLabelSizes(), d = u.widest.width, f = u.highest.height, p = dn(this.chart.width - d, 0, this.maxWidth);
    s = t.offset ? this.maxWidth / r : p / (r - 1), d + 6 > s && (s = p / (r - (t.offset ? 0.5 : 1)), l = this.maxHeight - bs(t.grid) - n.padding - $S(t.title, this.chart.options.font), c = Math.sqrt(d * d + f * f), a = _X(Math.min(Math.asin(dn((u.highest.height + 6) / s, -1, 1)), Math.asin(dn(l / c, -1, 1)) - Math.asin(dn(f / c, -1, 1)))), a = Math.max(i, Math.min(o, a))), this.labelRotation = a;
  }
  afterCalculateLabelRotation() {
    rt(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    rt(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: r, title: i, grid: o } } = this, a = this._isVisible(), s = this.isHorizontal();
    if (a) {
      const l = $S(i, n.options.font);
      if (s ? (t.width = this.maxWidth, t.height = bs(o) + l) : (t.height = this.maxHeight, t.width = bs(o) + l), r.display && this.ticks.length) {
        const { first: c, last: u, widest: d, highest: f } = this._getLabelSizes(), p = r.padding * 2, g = li(this.labelRotation), m = Math.cos(g), v = Math.sin(g);
        if (s) {
          const y = r.mirror ? 0 : v * d.width + m * f.height;
          t.height = Math.min(this.maxHeight, t.height + y + p);
        } else {
          const y = r.mirror ? 0 : m * d.width + v * f.height;
          t.width = Math.min(this.maxWidth, t.width + y + p);
        }
        this._calculatePadding(c, u, v, m);
      }
    }
    this._handleMargins(), s ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, n, r, i) {
    const { ticks: { align: o, padding: a }, position: s } = this.options, l = this.labelRotation !== 0, c = s !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let f = 0, p = 0;
      l ? c ? (f = i * t.width, p = r * n.height) : (f = r * t.height, p = i * n.width) : o === "start" ? p = n.width : o === "end" ? f = t.width : o !== "inner" && (f = t.width / 2, p = n.width / 2), this.paddingLeft = Math.max((f - u + a) * this.width / (this.width - u), 0), this.paddingRight = Math.max((p - d + a) * this.width / (this.width - d), 0);
    } else {
      let u = n.height / 2, d = t.height / 2;
      o === "start" ? (u = 0, d = t.height) : o === "end" && (u = n.height, d = 0), this.paddingTop = u + a, this.paddingBottom = d + a;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    rt(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: n } = this.options;
    return n === "top" || n === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let n, r;
    for (n = 0, r = t.length; n < r; n++)
      Fe(t[n].label) && (t.splice(n, 1), r--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const n = this.options.ticks.sampleSize;
      let r = this.ticks;
      n < r.length && (r = IS(r, n)), this._labelSizes = t = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, n, r) {
    const { ctx: i, _longestTextCache: o } = this, a = [], s = [], l = Math.floor(n / RS(n, r));
    let c = 0, u = 0, d, f, p, g, m, v, y, S, x, b, w;
    for (d = 0; d < n; d += l) {
      if (g = t[d].label, m = this._resolveTickFontOptions(d), i.font = v = m.string, y = o[v] = o[v] || {
        data: {},
        gc: []
      }, S = m.lineHeight, x = b = 0, !Fe(g) && !Ut(g))
        x = uS(i, y.data, y.gc, x, g), b = S;
      else if (Ut(g))
        for (f = 0, p = g.length; f < p; ++f)
          w = g[f], !Fe(w) && !Ut(w) && (x = uS(i, y.data, y.gc, x, w), b += S);
      a.push(x), s.push(b), c = Math.max(x, c), u = Math.max(b, u);
    }
    qJ(o, n);
    const E = a.indexOf(c), C = s.indexOf(u), A = (k) => ({
      width: a[k] || 0,
      height: s[k] || 0
    });
    return {
      first: A(0),
      last: A(n - 1),
      widest: A(E),
      highest: A(C),
      widths: a,
      heights: s
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, n) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const n = this._startPixel + t * this._length;
    return CX(this._alignToPixels ? co(this.chart, n, 0) : n);
  }
  getDecimalForPixel(t) {
    const n = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: n } = this;
    return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0;
  }
  getContext(t) {
    const n = this.ticks || [];
    if (t >= 0 && t < n.length) {
      const r = n[t];
      return r.$context || (r.$context = GJ(this.getContext(), t, r));
    }
    return this.$context || (this.$context = YJ(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, n = li(this.labelRotation), r = Math.abs(Math.cos(n)), i = Math.abs(Math.sin(n)), o = this._getLabelSizes(), a = t.autoSkipPadding || 0, s = o ? o.widest.width + a : 0, l = o ? o.highest.height + a : 0;
    return this.isHorizontal() ? l * r > s * i ? s / r : l / i : l * i < s * r ? l / r : s / i;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const n = this.axis, r = this.chart, i = this.options, { grid: o, position: a, border: s } = i, l = o.offset, c = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), f = bs(o), p = [], g = s.setContext(this.getContext()), m = g.display ? g.width : 0, v = m / 2, y = function($) {
      return co(r, $, m);
    };
    let S, x, b, w, E, C, A, k, R, M, P, D;
    if (a === "top")
      S = y(this.bottom), C = this.bottom - f, k = S - v, M = y(t.top) + v, D = t.bottom;
    else if (a === "bottom")
      S = y(this.top), M = t.top, D = y(t.bottom) - v, C = S + v, k = this.top + f;
    else if (a === "left")
      S = y(this.right), E = this.right - f, A = S - v, R = y(t.left) + v, P = t.right;
    else if (a === "right")
      S = y(this.left), R = t.left, P = y(t.right) - v, E = S + v, A = this.left + f;
    else if (n === "x") {
      if (a === "center")
        S = y((t.top + t.bottom) / 2 + 0.5);
      else if (Pe(a)) {
        const $ = Object.keys(a)[0], F = a[$];
        S = y(this.chart.scales[$].getPixelForValue(F));
      }
      M = t.top, D = t.bottom, C = S + v, k = C + f;
    } else if (n === "y") {
      if (a === "center")
        S = y((t.left + t.right) / 2);
      else if (Pe(a)) {
        const $ = Object.keys(a)[0], F = a[$];
        S = y(this.chart.scales[$].getPixelForValue(F));
      }
      E = S - v, A = E - f, R = t.left, P = t.right;
    }
    const j = we(i.ticks.maxTicksLimit, d), N = Math.max(1, Math.ceil(d / j));
    for (x = 0; x < d; x += N) {
      const $ = this.getContext(x), F = o.setContext($), q = s.setContext($), B = F.lineWidth, L = F.color, Y = q.dash || [], K = q.dashOffset, te = F.tickWidth, J = F.tickColor, Q = F.tickBorderDash || [], ne = F.tickBorderDashOffset;
      b = KJ(this, x, l), b !== void 0 && (w = co(r, b, B), c ? E = A = R = P = w : C = k = M = D = w, p.push({
        tx1: E,
        ty1: C,
        tx2: A,
        ty2: k,
        x1: R,
        y1: M,
        x2: P,
        y2: D,
        width: B,
        color: L,
        borderDash: Y,
        borderDashOffset: K,
        tickWidth: te,
        tickColor: J,
        tickBorderDash: Q,
        tickBorderDashOffset: ne
      }));
    }
    return this._ticksLength = d, this._borderValue = S, p;
  }
  _computeLabelItems(t) {
    const n = this.axis, r = this.options, { position: i, ticks: o } = r, a = this.isHorizontal(), s = this.ticks, { align: l, crossAlign: c, padding: u, mirror: d } = o, f = bs(r.grid), p = f + u, g = d ? -u : p, m = -li(this.labelRotation), v = [];
    let y, S, x, b, w, E, C, A, k, R, M, P, D = "middle";
    if (i === "top")
      E = this.bottom - g, C = this._getXAxisLabelAlignment();
    else if (i === "bottom")
      E = this.top + g, C = this._getXAxisLabelAlignment();
    else if (i === "left") {
      const N = this._getYAxisLabelAlignment(f);
      C = N.textAlign, w = N.x;
    } else if (i === "right") {
      const N = this._getYAxisLabelAlignment(f);
      C = N.textAlign, w = N.x;
    } else if (n === "x") {
      if (i === "center")
        E = (t.top + t.bottom) / 2 + p;
      else if (Pe(i)) {
        const N = Object.keys(i)[0], $ = i[N];
        E = this.chart.scales[N].getPixelForValue($) + p;
      }
      C = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (i === "center")
        w = (t.left + t.right) / 2 - p;
      else if (Pe(i)) {
        const N = Object.keys(i)[0], $ = i[N];
        w = this.chart.scales[N].getPixelForValue($);
      }
      C = this._getYAxisLabelAlignment(f).textAlign;
    }
    n === "y" && (l === "start" ? D = "top" : l === "end" && (D = "bottom"));
    const j = this._getLabelSizes();
    for (y = 0, S = s.length; y < S; ++y) {
      x = s[y], b = x.label;
      const N = o.setContext(this.getContext(y));
      A = this.getPixelForTick(y) + o.labelOffset, k = this._resolveTickFontOptions(y), R = k.lineHeight, M = Ut(b) ? b.length : 1;
      const $ = M / 2, F = N.color, q = N.textStrokeColor, B = N.textStrokeWidth;
      let L = C;
      a ? (w = A, C === "inner" && (y === S - 1 ? L = this.options.reverse ? "left" : "right" : y === 0 ? L = this.options.reverse ? "right" : "left" : L = "center"), i === "top" ? c === "near" || m !== 0 ? P = -M * R + R / 2 : c === "center" ? P = -j.highest.height / 2 - $ * R + R : P = -j.highest.height + R / 2 : c === "near" || m !== 0 ? P = R / 2 : c === "center" ? P = j.highest.height / 2 - $ * R : P = j.highest.height - M * R, d && (P *= -1), m !== 0 && !N.showLabelBackdrop && (w += R / 2 * Math.sin(m))) : (E = A, P = (1 - M) * R / 2);
      let Y;
      if (N.showLabelBackdrop) {
        const K = br(N.backdropPadding), te = j.heights[y], J = j.widths[y];
        let Q = P - K.top, ne = 0 - K.left;
        switch (D) {
          case "middle":
            Q -= te / 2;
            break;
          case "bottom":
            Q -= te;
            break;
        }
        switch (C) {
          case "center":
            ne -= J / 2;
            break;
          case "right":
            ne -= J;
            break;
          case "inner":
            y === S - 1 ? ne -= J : y > 0 && (ne -= J / 2);
            break;
        }
        Y = {
          left: ne,
          top: Q,
          width: J + K.width,
          height: te + K.height,
          color: N.backdropColor
        };
      }
      v.push({
        label: b,
        font: k,
        textOffset: P,
        options: {
          rotation: m,
          color: F,
          strokeColor: q,
          strokeWidth: B,
          textAlign: L,
          textBaseline: D,
          translation: [
            w,
            E
          ],
          backdrop: Y
        }
      });
    }
    return v;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: n } = this.options;
    if (-li(this.labelRotation))
      return t === "top" ? "left" : "right";
    let i = "center";
    return n.align === "start" ? i = "left" : n.align === "end" ? i = "right" : n.align === "inner" && (i = "inner"), i;
  }
  _getYAxisLabelAlignment(t) {
    const { position: n, ticks: { crossAlign: r, mirror: i, padding: o } } = this.options, a = this._getLabelSizes(), s = t + o, l = a.widest.width;
    let c, u;
    return n === "left" ? i ? (u = this.right + o, r === "near" ? c = "left" : r === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - s, r === "near" ? c = "right" : r === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : n === "right" ? i ? (u = this.left + o, r === "near" ? c = "right" : r === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + s, r === "near" ? c = "left" : r === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
      textAlign: c,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: n }, left: r, top: i, width: o, height: a } = this;
    n && (t.save(), t.fillStyle = n, t.fillRect(r, i, o, a), t.restore());
  }
  getLineWidthForValue(t) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const i = this.ticks.findIndex((o) => o.value === t);
    return i >= 0 ? n.setContext(this.getContext(i)).lineWidth : 0;
  }
  drawGrid(t) {
    const n = this.options.grid, r = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let o, a;
    const s = (l, c, u) => {
      !u.width || !u.color || (r.save(), r.lineWidth = u.width, r.strokeStyle = u.color, r.setLineDash(u.borderDash || []), r.lineDashOffset = u.borderDashOffset, r.beginPath(), r.moveTo(l.x, l.y), r.lineTo(c.x, c.y), r.stroke(), r.restore());
    };
    if (n.display)
      for (o = 0, a = i.length; o < a; ++o) {
        const l = i[o];
        n.drawOnChartArea && s({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), n.drawTicks && s({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: n, options: { border: r, grid: i } } = this, o = r.setContext(this.getContext()), a = r.display ? o.width : 0;
    if (!a)
      return;
    const s = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, u, d, f;
    this.isHorizontal() ? (c = co(t, this.left, a) - a / 2, u = co(t, this.right, s) + s / 2, d = f = l) : (d = co(t, this.top, a) - a / 2, f = co(t, this.bottom, s) + s / 2, c = u = l), n.save(), n.lineWidth = o.width, n.strokeStyle = o.color, n.beginPath(), n.moveTo(c, d), n.lineTo(u, f), n.stroke(), n.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const r = this.ctx, i = this._computeLabelArea();
    i && Vy(r, i);
    const o = this.getLabelItems(t);
    for (const a of o) {
      const s = a.options, l = a.font, c = a.label, u = a.textOffset;
      sd(r, c, 0, u, l, s);
    }
    i && Uy(r);
  }
  drawTitle() {
    const { ctx: t, options: { position: n, title: r, reverse: i } } = this;
    if (!r.display)
      return;
    const o = Tn(r.font), a = br(r.padding), s = r.align;
    let l = o.lineHeight / 2;
    n === "bottom" || n === "center" || Pe(n) ? (l += a.bottom, Ut(r.text) && (l += o.lineHeight * (r.text.length - 1))) : l += a.top;
    const { titleX: c, titleY: u, maxWidth: d, rotation: f } = ZJ(this, l, n, s);
    sd(t, r.text, 0, 0, o, {
      color: r.color,
      maxWidth: d,
      rotation: f,
      textAlign: XJ(s, n, i),
      textBaseline: "middle",
      translation: [
        c,
        u
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, n = t.ticks && t.ticks.z || 0, r = we(t.grid && t.grid.z, -1), i = we(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== Za.prototype.draw ? [
      {
        z: n,
        draw: (o) => {
          this.draw(o);
        }
      }
    ] : [
      {
        z: r,
        draw: (o) => {
          this.drawBackground(), this.drawGrid(o), this.drawTitle();
        }
      },
      {
        z: i,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (o) => {
          this.drawLabels(o);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const n = this.chart.getSortedVisibleDatasetMetas(), r = this.axis + "AxisID", i = [];
    let o, a;
    for (o = 0, a = n.length; o < a; ++o) {
      const s = n[o];
      s[r] === this.id && (!t || s.type === t) && i.push(s);
    }
    return i;
  }
  _resolveTickFontOptions(t) {
    const n = this.options.ticks.setContext(this.getContext(t));
    return Tn(n.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class zc {
  constructor(t, n, r) {
    this.type = t, this.scope = n, this.override = r, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const n = Object.getPrototypeOf(t);
    let r;
    eQ(n) && (r = this.register(n));
    const i = this.items, o = t.id, a = this.scope + "." + o;
    if (!o)
      throw new Error("class does not have id: " + t);
    return o in i || (i[o] = t, JJ(t, a, r), this.override && St.override(t.id, t.overrides)), a;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const n = this.items, r = t.id, i = this.scope;
    r in n && delete n[r], i && r in St[i] && (delete St[i][r], this.override && delete Wo[r]);
  }
}
function JJ(e, t, n) {
  const r = dl(/* @__PURE__ */ Object.create(null), [
    n ? St.get(n) : {},
    St.get(t),
    e.defaults
  ]);
  St.set(t, r), e.defaultRoutes && QJ(t, e.defaultRoutes), e.descriptors && St.describe(t, e.descriptors);
}
function QJ(e, t) {
  Object.keys(t).forEach((n) => {
    const r = n.split("."), i = r.pop(), o = [
      e
    ].concat(r).join("."), a = t[n].split("."), s = a.pop(), l = a.join(".");
    St.route(o, i, l, s);
  });
}
function eQ(e) {
  return "id" in e && "defaults" in e;
}
class tQ {
  constructor() {
    this.controllers = new zc(Of, "datasets", !0), this.elements = new zc(eo, "elements"), this.plugins = new zc(Object, "plugins"), this.scales = new zc(Za, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, n, r) {
    [
      ...n
    ].forEach((i) => {
      const o = r || this._getRegistryForType(i);
      r || o.isForType(i) || o === this.plugins && i.id ? this._exec(t, o, i) : We(i, (a) => {
        const s = r || this._getRegistryForType(a);
        this._exec(t, s, a);
      });
    });
  }
  _exec(t, n, r) {
    const i = Fy(t);
    rt(r["before" + i], [], r), n[t](r), rt(r["after" + i], [], r);
  }
  _getRegistryForType(t) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const r = this._typedRegistries[n];
      if (r.isForType(t))
        return r;
    }
    return this.plugins;
  }
  _get(t, n, r) {
    const i = n.get(t);
    if (i === void 0)
      throw new Error('"' + t + '" is not a registered ' + r + ".");
    return i;
  }
}
var Ar = /* @__PURE__ */ new tQ();
class nQ {
  constructor() {
    this._init = [];
  }
  notify(t, n, r, i) {
    n === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const o = i ? this._descriptors(t).filter(i) : this._descriptors(t), a = this._notify(o, t, n, r);
    return n === "afterDestroy" && (this._notify(o, t, "stop"), this._notify(this._init, t, "uninstall")), a;
  }
  _notify(t, n, r, i) {
    i = i || {};
    for (const o of t) {
      const a = o.plugin, s = a[r], l = [
        n,
        i,
        o.options
      ];
      if (rt(s, l, a) === !1 && i.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    Fe(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), n;
  }
  _createDescriptors(t, n) {
    const r = t && t.config, i = we(r.options && r.options.plugins, {}), o = rQ(r);
    return i === !1 && !n ? [] : oQ(t, o, i, n);
  }
  _notifyStateChanges(t) {
    const n = this._oldCache || [], r = this._cache, i = (o, a) => o.filter((s) => !a.some((l) => s.plugin.id === l.plugin.id));
    this._notify(i(n, r), t, "stop"), this._notify(i(r, n), t, "start");
  }
}
function rQ(e) {
  const t = {}, n = [], r = Object.keys(Ar.plugins.items);
  for (let o = 0; o < r.length; o++)
    n.push(Ar.getPlugin(r[o]));
  const i = e.plugins || [];
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    n.indexOf(a) === -1 && (n.push(a), t[a.id] = !0);
  }
  return {
    plugins: n,
    localIds: t
  };
}
function iQ(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function oQ(e, { plugins: t, localIds: n }, r, i) {
  const o = [], a = e.getContext();
  for (const s of t) {
    const l = s.id, c = iQ(r[l], i);
    c !== null && o.push({
      plugin: s,
      options: aQ(e.config, {
        plugin: s,
        local: n[l]
      }, c, a)
    });
  }
  return o;
}
function aQ(e, { plugin: t, local: n }, r, i) {
  const o = e.pluginScopeKeys(t), a = e.getOptionScopes(r, o);
  return n && t.defaults && a.push(t.defaults), e.createResolver(a, i, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Qm(e, t) {
  const n = St.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x";
}
function sQ(e, t) {
  let n = e;
  return e === "_index_" ? n = t : e === "_value_" && (n = t === "x" ? "y" : "x"), n;
}
function lQ(e, t) {
  return e === t ? "_index_" : "_value_";
}
function LS(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function cQ(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function eg(e, ...t) {
  if (LS(e))
    return e;
  for (const n of t) {
    const r = n.axis || cQ(n.position) || e.length > 1 && LS(e[0].toLowerCase());
    if (r)
      return r;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function FS(e, t, n) {
  if (n[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function uQ(e, t) {
  if (t.data && t.data.datasets) {
    const n = t.data.datasets.filter((r) => r.xAxisID === e || r.yAxisID === e);
    if (n.length)
      return FS(e, "x", n[0]) || FS(e, "y", n[0]);
  }
  return {};
}
function dQ(e, t) {
  const n = Wo[e.type] || {
    scales: {}
  }, r = t.scales || {}, i = Qm(e.type, t), o = /* @__PURE__ */ Object.create(null);
  return Object.keys(r).forEach((a) => {
    const s = r[a];
    if (!Pe(s))
      return console.error(`Invalid scale configuration for scale: ${a}`);
    if (s._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${a}`);
    const l = eg(a, s, uQ(a, e), St.scales[s.type]), c = lQ(l, i), u = n.scales || {};
    o[a] = Ls(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      s,
      u[l],
      u[c]
    ]);
  }), e.data.datasets.forEach((a) => {
    const s = a.type || e.type, l = a.indexAxis || Qm(s, t), u = (Wo[s] || {}).scales || {};
    Object.keys(u).forEach((d) => {
      const f = sQ(d, l), p = a[f + "AxisID"] || f;
      o[p] = o[p] || /* @__PURE__ */ Object.create(null), Ls(o[p], [
        {
          axis: f
        },
        r[p],
        u[d]
      ]);
    });
  }), Object.keys(o).forEach((a) => {
    const s = o[a];
    Ls(s, [
      St.scales[s.type],
      St.scale
    ]);
  }), o;
}
function Wk(e) {
  const t = e.options || (e.options = {});
  t.plugins = we(t.plugins, {}), t.scales = dQ(e, t);
}
function Vk(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function fQ(e) {
  return e = e || {}, e.data = Vk(e.data), Wk(e), e;
}
const BS = /* @__PURE__ */ new Map(), Uk = /* @__PURE__ */ new Set();
function Wc(e, t) {
  let n = BS.get(e);
  return n || (n = t(), BS.set(e, n), Uk.add(n)), n;
}
const xs = (e, t, n) => {
  const r = zo(t, n);
  r !== void 0 && e.add(r);
};
class pQ {
  constructor(t) {
    this._config = fQ(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Vk(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Wk(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return Wc(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, n) {
    return Wc(`${t}.transition.${n}`, () => [
      [
        `datasets.${t}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, n) {
    return Wc(`${t}-${n}`, () => [
      [
        `datasets.${t}.elements.${n}`,
        `datasets.${t}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const n = t.id, r = this.type;
    return Wc(`${r}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, n) {
    const r = this._scopeCache;
    let i = r.get(t);
    return (!i || n) && (i = /* @__PURE__ */ new Map(), r.set(t, i)), i;
  }
  getOptionScopes(t, n, r) {
    const { options: i, type: o } = this, a = this._cachedScopes(t, r), s = a.get(n);
    if (s)
      return s;
    const l = /* @__PURE__ */ new Set();
    n.forEach((u) => {
      t && (l.add(t), u.forEach((d) => xs(l, t, d))), u.forEach((d) => xs(l, i, d)), u.forEach((d) => xs(l, Wo[o] || {}, d)), u.forEach((d) => xs(l, St, d)), u.forEach((d) => xs(l, Zm, d));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), Uk.has(n) && a.set(n, c), c;
  }
  chartOptionScopes() {
    const { options: t, type: n } = this;
    return [
      t,
      Wo[n] || {},
      St.datasets[n] || {},
      {
        type: n
      },
      St,
      Zm
    ];
  }
  resolveNamedOptions(t, n, r, i = [
    ""
  ]) {
    const o = {
      $shared: !0
    }, { resolver: a, subPrefixes: s } = zS(this._resolverCache, t, i);
    let l = a;
    if (mQ(a, n)) {
      o.$shared = !1, r = Ki(r) ? r() : r;
      const c = this.createResolver(t, r, s);
      l = Ra(a, r, c);
    }
    for (const c of n)
      o[c] = l[c];
    return o;
  }
  createResolver(t, n, r = [
    ""
  ], i) {
    const { resolver: o } = zS(this._resolverCache, t, r);
    return Pe(n) ? Ra(o, n, void 0, i) : o;
  }
}
function zS(e, t, n) {
  let r = e.get(t);
  r || (r = /* @__PURE__ */ new Map(), e.set(t, r));
  const i = n.join();
  let o = r.get(i);
  return o || (o = {
    resolver: Ky(t, n),
    subPrefixes: n.filter((s) => !s.toLowerCase().includes("hover"))
  }, r.set(i, o)), o;
}
const hQ = (e) => Pe(e) && Object.getOwnPropertyNames(e).some((t) => Ki(e[t]));
function mQ(e, t) {
  const { isScriptable: n, isIndexable: r } = Pk(e);
  for (const i of t) {
    const o = n(i), a = r(i), s = (a || o) && e[i];
    if (o && (Ki(s) || hQ(s)) || a && Ut(s))
      return !0;
  }
  return !1;
}
var gQ = "4.5.0";
const vQ = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function WS(e, t) {
  return e === "top" || e === "bottom" || vQ.indexOf(e) === -1 && t === "x";
}
function VS(e, t) {
  return function(n, r) {
    return n[e] === r[e] ? n[t] - r[t] : n[e] - r[e];
  };
}
function US(e) {
  const t = e.chart, n = t.options.animation;
  t.notifyPlugins("afterRender"), rt(n && n.onComplete, [
    e
  ], t);
}
function yQ(e) {
  const t = e.chart, n = t.options.animation;
  rt(n && n.onProgress, [
    e
  ], t);
}
function Hk(e) {
  return Gy() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const tu = {}, HS = (e) => {
  const t = Hk(e);
  return Object.values(tu).filter((n) => n.canvas === t).pop();
};
function bQ(e, t, n) {
  const r = Object.keys(e);
  for (const i of r) {
    const o = +i;
    if (o >= t) {
      const a = e[i];
      delete e[i], (n > 0 || o > t) && (e[o + n] = a);
    }
  }
}
function xQ(e, t, n, r) {
  return !n || e.type === "mouseout" ? null : r ? t : e;
}
let Dn = class {
  static defaults = St;
  static instances = tu;
  static overrides = Wo;
  static registry = Ar;
  static version = gQ;
  static getChart = HS;
  static register(...t) {
    Ar.add(...t), KS();
  }
  static unregister(...t) {
    Ar.remove(...t), KS();
  }
  constructor(t, n) {
    const r = this.config = new pQ(n), i = Hk(t), o = HS(i);
    if (o)
      throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused.");
    const a = r.createResolver(r.chartOptionScopes(), this.getContext());
    this.platform = new (r.platform || LJ(i))(), this.platform.updateConfig(r);
    const s = this.platform.acquireContext(i, a.aspectRatio), l = s && s.canvas, c = l && l.height, u = l && l.width;
    if (this.id = fX(), this.ctx = s, this.canvas = l, this.width = u, this.height = c, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new nQ(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = MX((d) => this.update(d), a.resizeDelay || 0), this._dataChanges = [], tu[this.id] = this, !s || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Qr.listen(this, "complete", US), Qr.listen(this, "progress", yQ), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: n }, width: r, height: i, _aspectRatio: o } = this;
    return Fe(t) ? n && o ? o : i ? r / i : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return Ar;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : hS(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return dS(this.canvas, this.ctx), this;
  }
  stop() {
    return Qr.stop(this), this;
  }
  resize(t, n) {
    Qr.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: n
    } : this._resize(t, n);
  }
  _resize(t, n) {
    const r = this.options, i = this.canvas, o = r.maintainAspectRatio && this.aspectRatio, a = this.platform.getMaximumSize(i, t, n, o), s = r.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = a.width, this.height = a.height, this._aspectRatio = this.aspectRatio, hS(this, s, !0) && (this.notifyPlugins("resize", {
      size: a
    }), rt(r.onResize, [
      this,
      a
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    We(n, (r, i) => {
      r.id = i;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, n = t.scales, r = this.scales, i = Object.keys(r).reduce((a, s) => (a[s] = !1, a), {});
    let o = [];
    n && (o = o.concat(Object.keys(n).map((a) => {
      const s = n[a], l = eg(a, s), c = l === "r", u = l === "x";
      return {
        options: s,
        dposition: c ? "chartArea" : u ? "bottom" : "left",
        dtype: c ? "radialLinear" : u ? "category" : "linear"
      };
    }))), We(o, (a) => {
      const s = a.options, l = s.id, c = eg(l, s), u = we(s.type, a.dtype);
      (s.position === void 0 || WS(s.position, c) !== WS(a.dposition)) && (s.position = a.dposition), i[l] = !0;
      let d = null;
      if (l in r && r[l].type === u)
        d = r[l];
      else {
        const f = Ar.getScale(u);
        d = new f({
          id: l,
          type: u,
          ctx: this.ctx,
          chart: this
        }), r[d.id] = d;
      }
      d.init(s, t);
    }), We(i, (a, s) => {
      a || delete r[s];
    }), We(r, (a) => {
      Di.configure(this, a, a.options), Di.addBox(this, a);
    });
  }
  _updateMetasets() {
    const t = this._metasets, n = this.data.datasets.length, r = t.length;
    if (t.sort((i, o) => i.index - o.index), r > n) {
      for (let i = n; i < r; ++i)
        this._destroyDatasetMeta(i);
      t.splice(n, r - n);
    }
    this._sortedMetasets = t.slice(0).sort(VS("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: n } } = this;
    t.length > n.length && delete this._stacks, t.forEach((r, i) => {
      n.filter((o) => o === r._dataset).length === 0 && this._destroyDatasetMeta(i);
    });
  }
  buildOrUpdateControllers() {
    const t = [], n = this.data.datasets;
    let r, i;
    for (this._removeUnreferencedMetasets(), r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      let a = this.getDatasetMeta(r);
      const s = o.type || this.config.type;
      if (a.type && a.type !== s && (this._destroyDatasetMeta(r), a = this.getDatasetMeta(r)), a.type = s, a.indexAxis = o.indexAxis || Qm(s, this.options), a.order = o.order || 0, a.index = r, a.label = "" + o.label, a.visible = this.isDatasetVisible(r), a.controller)
        a.controller.updateIndex(r), a.controller.linkScales();
      else {
        const l = Ar.getController(s), { datasetElementType: c, dataElementType: u } = St.datasets[s];
        Object.assign(l, {
          dataElementType: Ar.getElement(u),
          datasetElementType: c && Ar.getElement(c)
        }), a.controller = new l(this, r), t.push(a.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    We(this.data.datasets, (t, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const n = this.config;
    n.update();
    const r = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !r.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const o = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let a = 0;
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: d } = this.getDatasetMeta(c), f = !i && o.indexOf(d) === -1;
      d.buildOrUpdateElements(f), a = Math.max(+d.getMaxOverflow(), a);
    }
    a = this._minPadding = r.layout.autoPadding ? a : 0, this._updateLayout(a), i || We(o, (c) => {
      c.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(VS("z", "_idx"));
    const { _active: s, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : s.length && this._updateHoverStyles(s, s, !0), this.render();
  }
  _updateScales() {
    We(this.scales, (t) => {
      Di.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, n = new Set(Object.keys(this._listeners)), r = new Set(t.events);
    (!tS(n, r) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, n = this._getUniformDataChanges() || [];
    for (const { method: r, start: i, count: o } of n) {
      const a = r === "_removeElements" ? -o : o;
      bQ(t, i, a);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, r = (o) => new Set(t.filter((a) => a[0] === o).map((a, s) => s + "," + a.splice(1).join(","))), i = r(0);
    for (let o = 1; o < n; o++)
      if (!tS(i, r(o)))
        return;
    return Array.from(i).map((o) => o.split(",")).map((o) => ({
      method: o[1],
      start: +o[2],
      count: +o[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Di.update(this, this.width, this.height, t);
    const n = this.chartArea, r = n.width <= 0 || n.height <= 0;
    this._layers = [], We(this.boxes, (i) => {
      r && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers()));
    }, this), this._layers.forEach((i, o) => {
      i._idx = o;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this._updateDataset(n, Ki(t) ? t({
          datasetIndex: n
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, n) {
    const r = this.getDatasetMeta(t), i = {
      meta: r,
      index: t,
      mode: n,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", i) !== !1 && (r.controller._update(n), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Qr.has(this) ? this.attached && !Qr.running(this) && Qr.start(this) : (this.draw(), US({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: r, height: i } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(r, i);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const n = this._layers;
    for (t = 0; t < n.length && n[t].z <= 0; ++t)
      n[t].draw(this.chartArea);
    for (this._drawDatasets(); t < n.length; ++t)
      n[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const n = this._sortedMetasets, r = [];
    let i, o;
    for (i = 0, o = n.length; i < o; ++i) {
      const a = n[i];
      (!t || a.visible) && r.push(a);
    }
    return r;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let n = t.length - 1; n >= 0; --n)
      this._drawDataset(t[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const n = this.ctx, r = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, i = $Z(this, t);
    this.notifyPlugins("beforeDatasetDraw", r) !== !1 && (i && Vy(n, i), t.controller.draw(), i && Uy(n), r.cancelable = !1, this.notifyPlugins("afterDatasetDraw", r));
  }
  isPointInArea(t) {
    return ml(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, n, r, i) {
    const o = vJ.modes[n];
    return typeof o == "function" ? o(this, t, r, i) : [];
  }
  getDatasetMeta(t) {
    const n = this.data.datasets[t], r = this._metasets;
    let i = r.filter((o) => o && o._dataset === n).pop();
    return i || (i = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: t,
      _dataset: n,
      _parsed: [],
      _sorted: !1
    }, r.push(i)), i;
  }
  getContext() {
    return this.$context || (this.$context = Go(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const n = this.data.datasets[t];
    if (!n)
      return !1;
    const r = this.getDatasetMeta(t);
    return typeof r.hidden == "boolean" ? !r.hidden : !n.hidden;
  }
  setDatasetVisibility(t, n) {
    const r = this.getDatasetMeta(t);
    r.hidden = !n;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, n, r) {
    const i = r ? "show" : "hide", o = this.getDatasetMeta(t), a = o.controller._resolveAnimations(void 0, i);
    fl(n) ? (o.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(t, r), a.update(o, {
      visible: r
    }), this.update((s) => s.datasetIndex === t ? i : void 0));
  }
  hide(t, n) {
    this._updateVisibility(t, n, !1);
  }
  show(t, n) {
    this._updateVisibility(t, n, !0);
  }
  _destroyDatasetMeta(t) {
    const n = this._metasets[t];
    n && n.controller && n.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, n;
    for (this.stop(), Qr.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: n } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), dS(t, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete tu[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, n = this.platform, r = (o, a) => {
      n.addEventListener(this, o, a), t[o] = a;
    }, i = (o, a, s) => {
      o.offsetX = a, o.offsetY = s, this._eventHandler(o);
    };
    We(this.options.events, (o) => r(o, i));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, n = this.platform, r = (l, c) => {
      n.addEventListener(this, l, c), t[l] = c;
    }, i = (l, c) => {
      t[l] && (n.removeEventListener(this, l, c), delete t[l]);
    }, o = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let a;
    const s = () => {
      i("attach", s), this.attached = !0, this.resize(), r("resize", o), r("detach", a);
    };
    a = () => {
      this.attached = !1, i("resize", o), this._stop(), this._resize(0, 0), r("attach", s);
    }, n.isAttached(this.canvas) ? s() : a();
  }
  unbindEvents() {
    We(this._listeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._listeners = {}, We(this._responsiveListeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, n, r) {
    const i = r ? "set" : "remove";
    let o, a, s, l;
    for (n === "dataset" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller["_" + i + "DatasetHoverStyle"]()), s = 0, l = t.length; s < l; ++s) {
      a = t[s];
      const c = a && this.getDatasetMeta(a.datasetIndex).controller;
      c && c[i + "HoverStyle"](a.element, a.datasetIndex, a.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const n = this._active || [], r = t.map(({ datasetIndex: o, index: a }) => {
      const s = this.getDatasetMeta(o);
      if (!s)
        throw new Error("No dataset found at index " + o);
      return {
        datasetIndex: o,
        element: s.data[a],
        index: a
      };
    });
    !id(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n));
  }
  notifyPlugins(t, n, r) {
    return this._plugins.notify(this, t, n, r);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((n) => n.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, n, r) {
    const i = this.options.hover, o = (l, c) => l.filter((u) => !c.some((d) => u.datasetIndex === d.datasetIndex && u.index === d.index)), a = o(n, t), s = r ? t : o(t, n);
    a.length && this.updateHoverStyle(a, i.mode, !1), s.length && i.mode && this.updateHoverStyle(s, i.mode, !0);
  }
  _eventHandler(t, n) {
    const r = {
      event: t,
      replay: n,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, i = (a) => (a.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", r, i) === !1)
      return;
    const o = this._handleEvent(t, n, r.inChartArea);
    return r.cancelable = !1, this.notifyPlugins("afterEvent", r, i), (o || r.changed) && this.render(), this;
  }
  _handleEvent(t, n, r) {
    const { _active: i = [], options: o } = this, a = n, s = this._getActiveElements(t, i, r, a), l = yX(t), c = xQ(t, this._lastEvent, r, l);
    r && (this._lastEvent = null, rt(o.onHover, [
      t,
      s,
      this
    ], this), l && rt(o.onClick, [
      t,
      s,
      this
    ], this));
    const u = !id(s, i);
    return (u || n) && (this._active = s, this._updateHoverStyles(s, i, n)), this._lastEvent = c, u;
  }
  _getActiveElements(t, n, r, i) {
    if (t.type === "mouseout")
      return [];
    if (!r)
      return n;
    const o = this.options.hover;
    return this.getElementsAtEventForMode(t, o.mode, o, i);
  }
};
function KS() {
  return We(Dn.instances, (e) => e._plugins.invalidate());
}
function wQ(e, t, n) {
  const { startAngle: r, x: i, y: o, outerRadius: a, innerRadius: s, options: l } = t, { borderWidth: c, borderJoinStyle: u } = l, d = Math.min(c / a, vr(r - n));
  if (e.beginPath(), e.arc(i, o, a - c / 2, r + d / 2, n - d / 2), s > 0) {
    const f = Math.min(c / s, vr(r - n));
    e.arc(i, o, s + c / 2, n - f / 2, r + f / 2, !0);
  } else {
    const f = Math.min(c / 2, a * vr(r - n));
    if (u === "round")
      e.arc(i, o, f, n - Je / 2, r + Je / 2, !0);
    else if (u === "bevel") {
      const p = 2 * f * f, g = -p * Math.cos(n + Je / 2) + i, m = -p * Math.sin(n + Je / 2) + o, v = p * Math.cos(r + Je / 2) + i, y = p * Math.sin(r + Je / 2) + o;
      e.lineTo(g, m), e.lineTo(v, y);
    }
  }
  e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd");
}
function OQ(e, t, n) {
  const { startAngle: r, pixelMargin: i, x: o, y: a, outerRadius: s, innerRadius: l } = t;
  let c = i / s;
  e.beginPath(), e.arc(o, a, s, r - c, n + c), l > i ? (c = i / l, e.arc(o, a, l, n + c, r - c, !0)) : e.arc(o, a, i, n + Dt, r - Dt), e.closePath(), e.clip();
}
function SQ(e) {
  return Hy(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function EQ(e, t, n, r) {
  const i = SQ(e.options.borderRadius), o = (n - t) / 2, a = Math.min(o, r * t / 2), s = (l) => {
    const c = (n - Math.min(o, l)) * r / 2;
    return dn(l, 0, Math.min(o, c));
  };
  return {
    outerStart: s(i.outerStart),
    outerEnd: s(i.outerEnd),
    innerStart: dn(i.innerStart, 0, a),
    innerEnd: dn(i.innerEnd, 0, a)
  };
}
function la(e, t, n, r) {
  return {
    x: n + e * Math.cos(t),
    y: r + e * Math.sin(t)
  };
}
function dd(e, t, n, r, i, o) {
  const { x: a, y: s, startAngle: l, pixelMargin: c, innerRadius: u } = t, d = Math.max(t.outerRadius + r + n - c, 0), f = u > 0 ? u + r + n + c : 0;
  let p = 0;
  const g = i - l;
  if (r) {
    const N = u > 0 ? u - r : 0, $ = d > 0 ? d - r : 0, F = (N + $) / 2, q = F !== 0 ? g * F / (F + r) : g;
    p = (g - q) / 2;
  }
  const m = Math.max(1e-3, g * d - n / Je) / d, v = (g - m) / 2, y = l + v + p, S = i - v - p, { outerStart: x, outerEnd: b, innerStart: w, innerEnd: E } = EQ(t, f, d, S - y), C = d - x, A = d - b, k = y + x / C, R = S - b / A, M = f + w, P = f + E, D = y + w / M, j = S - E / P;
  if (e.beginPath(), o) {
    const N = (k + R) / 2;
    if (e.arc(a, s, d, k, N), e.arc(a, s, d, N, R), b > 0) {
      const B = la(A, R, a, s);
      e.arc(B.x, B.y, b, R, S + Dt);
    }
    const $ = la(P, S, a, s);
    if (e.lineTo($.x, $.y), E > 0) {
      const B = la(P, j, a, s);
      e.arc(B.x, B.y, E, S + Dt, j + Math.PI);
    }
    const F = (S - E / f + (y + w / f)) / 2;
    if (e.arc(a, s, f, S - E / f, F, !0), e.arc(a, s, f, F, y + w / f, !0), w > 0) {
      const B = la(M, D, a, s);
      e.arc(B.x, B.y, w, D + Math.PI, y - Dt);
    }
    const q = la(C, y, a, s);
    if (e.lineTo(q.x, q.y), x > 0) {
      const B = la(C, k, a, s);
      e.arc(B.x, B.y, x, y - Dt, k);
    }
  } else {
    e.moveTo(a, s);
    const N = Math.cos(k) * d + a, $ = Math.sin(k) * d + s;
    e.lineTo(N, $);
    const F = Math.cos(R) * d + a, q = Math.sin(R) * d + s;
    e.lineTo(F, q);
  }
  e.closePath();
}
function _Q(e, t, n, r, i) {
  const { fullCircles: o, startAngle: a, circumference: s } = t;
  let l = t.endAngle;
  if (o) {
    dd(e, t, n, r, l, i);
    for (let c = 0; c < o; ++c)
      e.fill();
    isNaN(s) || (l = a + (s % bt || bt));
  }
  return dd(e, t, n, r, l, i), e.fill(), l;
}
function PQ(e, t, n, r, i) {
  const { fullCircles: o, startAngle: a, circumference: s, options: l } = t, { borderWidth: c, borderJoinStyle: u, borderDash: d, borderDashOffset: f, borderRadius: p } = l, g = l.borderAlign === "inner";
  if (!c)
    return;
  e.setLineDash(d || []), e.lineDashOffset = f, g ? (e.lineWidth = c * 2, e.lineJoin = u || "round") : (e.lineWidth = c, e.lineJoin = u || "bevel");
  let m = t.endAngle;
  if (o) {
    dd(e, t, n, r, m, i);
    for (let v = 0; v < o; ++v)
      e.stroke();
    isNaN(s) || (m = a + (s % bt || bt));
  }
  g && OQ(e, t, m), l.selfJoin && m - a >= Je && p === 0 && u !== "miter" && wQ(e, t, m), o || (dd(e, t, n, r, m, i), e.stroke());
}
class Jy extends eo {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, n, r) {
    const i = this.getProps([
      "x",
      "y"
    ], r), { angle: o, distance: a } = vk(i, {
      x: t,
      y: n
    }), { startAngle: s, endAngle: l, innerRadius: c, outerRadius: u, circumference: d } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], r), f = (this.options.spacing + this.options.borderWidth) / 2, p = we(d, l - s), g = hl(o, s, l) && s !== l, m = p >= bt || g, v = Ni(a, c + f, u + f);
    return m && v;
  }
  getCenterPoint(t) {
    const { x: n, y: r, startAngle: i, endAngle: o, innerRadius: a, outerRadius: s } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: l, spacing: c } = this.options, u = (i + o) / 2, d = (a + s + c + l) / 2;
    return {
      x: n + Math.cos(u) * d,
      y: r + Math.sin(u) * d
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: n, circumference: r } = this, i = (n.offset || 0) / 4, o = (n.spacing || 0) / 2, a = n.circular;
    if (this.pixelMargin = n.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = r > bt ? Math.floor(r / bt) : 0, r === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const s = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(s) * i, Math.sin(s) * i);
    const l = 1 - Math.sin(Math.min(Je, r || 0)), c = i * l;
    t.fillStyle = n.backgroundColor, t.strokeStyle = n.borderColor, _Q(t, this, c, o, a), PQ(t, this, c, o, a), t.restore();
  }
}
function Kk(e, t, n = t) {
  e.lineCap = we(n.borderCapStyle, t.borderCapStyle), e.setLineDash(we(n.borderDash, t.borderDash)), e.lineDashOffset = we(n.borderDashOffset, t.borderDashOffset), e.lineJoin = we(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = we(n.borderWidth, t.borderWidth), e.strokeStyle = we(n.borderColor, t.borderColor);
}
function CQ(e, t, n) {
  e.lineTo(n.x, n.y);
}
function AQ(e) {
  return e.stepped ? HX : e.tension || e.cubicInterpolationMode === "monotone" ? KX : CQ;
}
function qk(e, t, n = {}) {
  const r = e.length, { start: i = 0, end: o = r - 1 } = n, { start: a, end: s } = t, l = Math.max(i, a), c = Math.min(o, s), u = i < a && o < a || i > s && o > s;
  return {
    count: r,
    start: l,
    loop: t.loop,
    ilen: c < l && !u ? r + c - l : c - l
  };
}
function TQ(e, t, n, r) {
  const { points: i, options: o } = t, { count: a, start: s, loop: l, ilen: c } = qk(i, n, r), u = AQ(o);
  let { move: d = !0, reverse: f } = r || {}, p, g, m;
  for (p = 0; p <= c; ++p)
    g = i[(s + (f ? c - p : p)) % a], !g.skip && (d ? (e.moveTo(g.x, g.y), d = !1) : u(e, m, g, f, o.stepped), m = g);
  return l && (g = i[(s + (f ? c : 0)) % a], u(e, m, g, f, o.stepped)), !!l;
}
function kQ(e, t, n, r) {
  const i = t.points, { count: o, start: a, ilen: s } = qk(i, n, r), { move: l = !0, reverse: c } = r || {};
  let u = 0, d = 0, f, p, g, m, v, y;
  const S = (b) => (a + (c ? s - b : b)) % o, x = () => {
    m !== v && (e.lineTo(u, v), e.lineTo(u, m), e.lineTo(u, y));
  };
  for (l && (p = i[S(0)], e.moveTo(p.x, p.y)), f = 0; f <= s; ++f) {
    if (p = i[S(f)], p.skip)
      continue;
    const b = p.x, w = p.y, E = b | 0;
    E === g ? (w < m ? m = w : w > v && (v = w), u = (d * u + b) / ++d) : (x(), e.lineTo(b, w), g = E, d = 0, m = v = w), y = w;
  }
  x();
}
function tg(e) {
  const t = e.options, n = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? kQ : TQ;
}
function MQ(e) {
  return e.stepped ? EZ : e.tension || e.cubicInterpolationMode === "monotone" ? _Z : bo;
}
function jQ(e, t, n, r) {
  let i = t._path;
  i || (i = t._path = new Path2D(), t.path(i, n, r) && i.closePath()), Kk(e, t.options), e.stroke(i);
}
function NQ(e, t, n, r) {
  const { segments: i, options: o } = t, a = tg(t);
  for (const s of i)
    Kk(e, o, s.style), e.beginPath(), a(e, t, s, {
      start: n,
      end: n + r - 1
    }) && e.closePath(), e.stroke();
}
const DQ = typeof Path2D == "function";
function RQ(e, t, n, r) {
  DQ && !t.options.segment ? jQ(e, t, n, r) : NQ(e, t, n, r);
}
class Qy extends eo {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash" && t !== "fill"
  };
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, n) {
    const r = this.options;
    if ((r.tension || r.cubicInterpolationMode === "monotone") && !r.stepped && !this._pointsUpdated) {
      const i = r.spanGaps ? this._loop : this._fullLoop;
      gZ(this._points, r, t, i, n), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = NZ(this, this.options.segment));
  }
  first() {
    const t = this.segments, n = this.points;
    return t.length && n[t[0].start];
  }
  last() {
    const t = this.segments, n = this.points, r = t.length;
    return r && n[t[r - 1].end];
  }
  interpolate(t, n) {
    const r = this.options, i = t[n], o = this.points, a = kZ(this, {
      property: n,
      start: i,
      end: i
    });
    if (!a.length)
      return;
    const s = [], l = MQ(r);
    let c, u;
    for (c = 0, u = a.length; c < u; ++c) {
      const { start: d, end: f } = a[c], p = o[d], g = o[f];
      if (p === g) {
        s.push(p);
        continue;
      }
      const m = Math.abs((i - p[n]) / (g[n] - p[n])), v = l(p, g, m, r.stepped);
      v[n] = t[n], s.push(v);
    }
    return s.length === 1 ? s[0] : s;
  }
  pathSegment(t, n, r) {
    return tg(this)(t, this, n, r);
  }
  path(t, n, r) {
    const i = this.segments, o = tg(this);
    let a = this._loop;
    n = n || 0, r = r || this.points.length - n;
    for (const s of i)
      a &= o(t, this, s, {
        start: n,
        end: n + r - 1
      });
    return !!a;
  }
  draw(t, n, r, i) {
    const o = this.options || {};
    (this.points || []).length && o.borderWidth && (t.save(), RQ(t, this, r, i), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function qS(e, t, n, r) {
  const i = e.options, { [n]: o } = e.getProps([
    n
  ], r);
  return Math.abs(t - o) < i.radius + i.hitRadius;
}
class eb extends eo {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, n, r) {
    const i = this.options, { x: o, y: a } = this.getProps([
      "x",
      "y"
    ], r);
    return Math.pow(t - o, 2) + Math.pow(n - a, 2) < Math.pow(i.hitRadius + i.radius, 2);
  }
  inXRange(t, n) {
    return qS(this, t, "x", n);
  }
  inYRange(t, n) {
    return qS(this, t, "y", n);
  }
  getCenterPoint(t) {
    const { x: n, y: r } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: r
    };
  }
  size(t) {
    t = t || this.options || {};
    let n = t.radius || 0;
    n = Math.max(n, n && t.hoverRadius || 0);
    const r = n && t.borderWidth || 0;
    return (n + r) * 2;
  }
  draw(t, n) {
    const r = this.options;
    this.skip || r.radius < 0.1 || !ml(this, n, this.size(r) / 2) || (t.strokeStyle = r.borderColor, t.lineWidth = r.borderWidth, t.fillStyle = r.backgroundColor, Jm(t, r, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
function Yk(e, t) {
  const { x: n, y: r, base: i, width: o, height: a } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let s, l, c, u, d;
  return e.horizontal ? (d = a / 2, s = Math.min(n, i), l = Math.max(n, i), c = r - d, u = r + d) : (d = o / 2, s = n - d, l = n + d, c = Math.min(r, i), u = Math.max(r, i)), {
    left: s,
    top: c,
    right: l,
    bottom: u
  };
}
function Ri(e, t, n, r) {
  return e ? 0 : dn(t, n, r);
}
function IQ(e, t, n) {
  const r = e.options.borderWidth, i = e.borderSkipped, o = _k(r);
  return {
    t: Ri(i.top, o.top, 0, n),
    r: Ri(i.right, o.right, 0, t),
    b: Ri(i.bottom, o.bottom, 0, n),
    l: Ri(i.left, o.left, 0, t)
  };
}
function $Q(e, t, n) {
  const { enableBorderRadius: r } = e.getProps([
    "enableBorderRadius"
  ]), i = e.options.borderRadius, o = ya(i), a = Math.min(t, n), s = e.borderSkipped, l = r || Pe(i);
  return {
    topLeft: Ri(!l || s.top || s.left, o.topLeft, 0, a),
    topRight: Ri(!l || s.top || s.right, o.topRight, 0, a),
    bottomLeft: Ri(!l || s.bottom || s.left, o.bottomLeft, 0, a),
    bottomRight: Ri(!l || s.bottom || s.right, o.bottomRight, 0, a)
  };
}
function LQ(e) {
  const t = Yk(e), n = t.right - t.left, r = t.bottom - t.top, i = IQ(e, n / 2, r / 2), o = $Q(e, n / 2, r / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: n,
      h: r,
      radius: o
    },
    inner: {
      x: t.left + i.l,
      y: t.top + i.t,
      w: n - i.l - i.r,
      h: r - i.t - i.b,
      radius: {
        topLeft: Math.max(0, o.topLeft - Math.max(i.t, i.l)),
        topRight: Math.max(0, o.topRight - Math.max(i.t, i.r)),
        bottomLeft: Math.max(0, o.bottomLeft - Math.max(i.b, i.l)),
        bottomRight: Math.max(0, o.bottomRight - Math.max(i.b, i.r))
      }
    }
  };
}
function Nh(e, t, n, r) {
  const i = t === null, o = n === null, s = e && !(i && o) && Yk(e, r);
  return s && (i || Ni(t, s.left, s.right)) && (o || Ni(n, s.top, s.bottom));
}
function FQ(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function BQ(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function Dh(e, t, n = {}) {
  const r = e.x !== n.x ? -t : 0, i = e.y !== n.y ? -t : 0, o = (e.x + e.w !== n.x + n.w ? t : 0) - r, a = (e.y + e.h !== n.y + n.h ? t : 0) - i;
  return {
    x: e.x + r,
    y: e.y + i,
    w: e.w + o,
    h: e.h + a,
    radius: e.radius
  };
}
class Gl extends eo {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: n, options: { borderColor: r, backgroundColor: i } } = this, { inner: o, outer: a } = LQ(this), s = FQ(a.radius) ? ld : BQ;
    t.save(), (a.w !== o.w || a.h !== o.h) && (t.beginPath(), s(t, Dh(a, n, o)), t.clip(), s(t, Dh(o, -n, a)), t.fillStyle = r, t.fill("evenodd")), t.beginPath(), s(t, Dh(o, n)), t.fillStyle = i, t.fill(), t.restore();
  }
  inRange(t, n, r) {
    return Nh(this, t, n, r);
  }
  inXRange(t, n) {
    return Nh(this, t, null, n);
  }
  inYRange(t, n) {
    return Nh(this, null, t, n);
  }
  getCenterPoint(t) {
    const { x: n, y: r, base: i, horizontal: o } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: o ? (n + i) / 2 : n,
      y: o ? r : (r + i) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
const YS = (e, t) => {
  let { boxHeight: n = t, boxWidth: r = t } = e;
  return e.usePointStyle && (n = Math.min(n, t), r = e.pointStyleWidth || Math.min(r, t)), {
    boxWidth: r,
    boxHeight: n,
    itemHeight: Math.max(t, n)
  };
}, zQ = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class GS extends eo {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, n, r) {
    this.maxWidth = t, this.maxHeight = n, this._margins = r, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let n = rt(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (n = n.filter((r) => t.filter(r, this.chart.data))), t.sort && (n = n.sort((r, i) => t.sort(r, i, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n;
  }
  fit() {
    const { options: t, ctx: n } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const r = t.labels, i = Tn(r.font), o = i.size, a = this._computeTitleHeight(), { boxWidth: s, itemHeight: l } = YS(r, o);
    let c, u;
    n.font = i.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(a, o, s, l) + 10) : (u = this.maxHeight, c = this._fitCols(a, i, s, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(u, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, n, r, i) {
    const { ctx: o, maxWidth: a, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
      0
    ], u = i + s;
    let d = t;
    o.textAlign = "left", o.textBaseline = "middle";
    let f = -1, p = -u;
    return this.legendItems.forEach((g, m) => {
      const v = r + n / 2 + o.measureText(g.text).width;
      (m === 0 || c[c.length - 1] + v + 2 * s > a) && (d += u, c[c.length - (m > 0 ? 0 : 1)] = 0, p += u, f++), l[m] = {
        left: 0,
        top: p,
        row: f,
        width: v,
        height: i
      }, c[c.length - 1] += v + s;
    }), d;
  }
  _fitCols(t, n, r, i) {
    const { ctx: o, maxHeight: a, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = a - t;
    let d = s, f = 0, p = 0, g = 0, m = 0;
    return this.legendItems.forEach((v, y) => {
      const { itemWidth: S, itemHeight: x } = WQ(r, n, o, v, i);
      y > 0 && p + x + 2 * s > u && (d += f + s, c.push({
        width: f,
        height: p
      }), g += f + s, m++, f = p = 0), l[y] = {
        left: g,
        top: p,
        col: m,
        width: S,
        height: x
      }, f = Math.max(f, S), p += x + s;
    }), d += f, c.push({
      width: f,
      height: p
    }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: r, labels: { padding: i }, rtl: o } } = this, a = ba(o, this.left, this.width);
    if (this.isHorizontal()) {
      let s = 0, l = $n(r, this.left + i, this.right - this.lineWidths[s]);
      for (const c of n)
        s !== c.row && (s = c.row, l = $n(r, this.left + i, this.right - this.lineWidths[s])), c.top += this.top + t + i, c.left = a.leftForLtr(a.x(l), c.width), l += c.width + i;
    } else {
      let s = 0, l = $n(r, this.top + t + i, this.bottom - this.columnSizes[s].height);
      for (const c of n)
        c.col !== s && (s = c.col, l = $n(r, this.top + t + i, this.bottom - this.columnSizes[s].height)), c.top = l, c.left += this.left + i, c.left = a.leftForLtr(a.x(c.left), c.width), l += c.height + i;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      Vy(t, this), this._draw(), Uy(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: n, lineWidths: r, ctx: i } = this, { align: o, labels: a } = t, s = St.color, l = ba(t.rtl, this.left, this.width), c = Tn(a.font), { padding: u } = a, d = c.size, f = d / 2;
    let p;
    this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = 0.5, i.font = c.string;
    const { boxWidth: g, boxHeight: m, itemHeight: v } = YS(a, d), y = function(E, C, A) {
      if (isNaN(g) || g <= 0 || isNaN(m) || m < 0)
        return;
      i.save();
      const k = we(A.lineWidth, 1);
      if (i.fillStyle = we(A.fillStyle, s), i.lineCap = we(A.lineCap, "butt"), i.lineDashOffset = we(A.lineDashOffset, 0), i.lineJoin = we(A.lineJoin, "miter"), i.lineWidth = k, i.strokeStyle = we(A.strokeStyle, s), i.setLineDash(we(A.lineDash, [])), a.usePointStyle) {
        const R = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: A.pointStyle,
          rotation: A.rotation,
          borderWidth: k
        }, M = l.xPlus(E, g / 2), P = C + f;
        Ek(i, R, M, P, a.pointStyleWidth && g);
      } else {
        const R = C + Math.max((d - m) / 2, 0), M = l.leftForLtr(E, g), P = ya(A.borderRadius);
        i.beginPath(), Object.values(P).some((D) => D !== 0) ? ld(i, {
          x: M,
          y: R,
          w: g,
          h: m,
          radius: P
        }) : i.rect(M, R, g, m), i.fill(), k !== 0 && i.stroke();
      }
      i.restore();
    }, S = function(E, C, A) {
      sd(i, A.text, E, C + v / 2, c, {
        strikethrough: A.hidden,
        textAlign: l.textAlign(A.textAlign)
      });
    }, x = this.isHorizontal(), b = this._computeTitleHeight();
    x ? p = {
      x: $n(o, this.left + u, this.right - r[0]),
      y: this.top + u + b,
      line: 0
    } : p = {
      x: this.left + u,
      y: $n(o, this.top + b + u, this.bottom - n[0].height),
      line: 0
    }, Mk(this.ctx, t.textDirection);
    const w = v + u;
    this.legendItems.forEach((E, C) => {
      i.strokeStyle = E.fontColor, i.fillStyle = E.fontColor;
      const A = i.measureText(E.text).width, k = l.textAlign(E.textAlign || (E.textAlign = a.textAlign)), R = g + f + A;
      let M = p.x, P = p.y;
      l.setWidth(this.width), x ? C > 0 && M + R + u > this.right && (P = p.y += w, p.line++, M = p.x = $n(o, this.left + u, this.right - r[p.line])) : C > 0 && P + w > this.bottom && (M = p.x = M + n[p.line].width + u, p.line++, P = p.y = $n(o, this.top + b + u, this.bottom - n[p.line].height));
      const D = l.x(M);
      if (y(D, P, E), M = jX(k, M + g + f, x ? M + R : this.right, t.rtl), S(l.x(M), P, E), x)
        p.x += R + u;
      else if (typeof E.text != "string") {
        const j = c.lineHeight;
        p.y += Gk(E, j) + u;
      } else
        p.y += w;
    }), jk(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, n = t.title, r = Tn(n.font), i = br(n.padding);
    if (!n.display)
      return;
    const o = ba(t.rtl, this.left, this.width), a = this.ctx, s = n.position, l = r.size / 2, c = i.top + l;
    let u, d = this.left, f = this.width;
    if (this.isHorizontal())
      f = Math.max(...this.lineWidths), u = this.top + c, d = $n(t.align, d, this.right - f);
    else {
      const g = this.columnSizes.reduce((m, v) => Math.max(m, v.height), 0);
      u = c + $n(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());
    }
    const p = $n(s, d, d + f);
    a.textAlign = o.textAlign(Ok(s)), a.textBaseline = "middle", a.strokeStyle = n.color, a.fillStyle = n.color, a.font = r.string, sd(a, n.text, p, u, r);
  }
  _computeTitleHeight() {
    const t = this.options.title, n = Tn(t.font), r = br(t.padding);
    return t.display ? n.lineHeight + r.height : 0;
  }
  _getLegendItemAt(t, n) {
    let r, i, o;
    if (Ni(t, this.left, this.right) && Ni(n, this.top, this.bottom)) {
      for (o = this.legendHitBoxes, r = 0; r < o.length; ++r)
        if (i = o[r], Ni(t, i.left, i.left + i.width) && Ni(n, i.top, i.top + i.height))
          return this.legendItems[r];
    }
    return null;
  }
  handleEvent(t) {
    const n = this.options;
    if (!HQ(t.type, n))
      return;
    const r = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const i = this._hoveredItem, o = zQ(i, r);
      i && !o && rt(n.onLeave, [
        t,
        i,
        this
      ], this), this._hoveredItem = r, r && !o && rt(n.onHover, [
        t,
        r,
        this
      ], this);
    } else r && rt(n.onClick, [
      t,
      r,
      this
    ], this);
  }
}
function WQ(e, t, n, r, i) {
  const o = VQ(r, e, t, n), a = UQ(i, r, t.lineHeight);
  return {
    itemWidth: o,
    itemHeight: a
  };
}
function VQ(e, t, n, r) {
  let i = e.text;
  return i && typeof i != "string" && (i = i.reduce((o, a) => o.length > a.length ? o : a)), t + n.size / 2 + r.measureText(i).width;
}
function UQ(e, t, n) {
  let r = e;
  return typeof t.text != "string" && (r = Gk(t, n)), r;
}
function Gk(e, t) {
  const n = e.text ? e.text.length : 0;
  return t * n;
}
function HQ(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var wr = {
  id: "legend",
  _element: GS,
  start(e, t, n) {
    const r = e.legend = new GS({
      ctx: e.ctx,
      options: n,
      chart: e
    });
    Di.configure(e, r, n), Di.addBox(e, r);
  },
  stop(e) {
    Di.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, n) {
    const r = e.legend;
    Di.configure(e, r, n), r.options = n;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, n) {
      const r = t.datasetIndex, i = n.chart;
      i.isDatasetVisible(r) ? (i.hide(r), t.hidden = !0) : (i.show(r), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: n, pointStyle: r, textAlign: i, color: o, useBorderRadius: a, borderRadius: s } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(n ? 0 : void 0), u = br(c.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: o,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: r || c.pointStyle,
            rotation: c.rotation,
            textAlign: i || c.textAlign,
            borderRadius: a && (s || c.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
const ks = {
  average(e) {
    if (!e.length)
      return !1;
    let t, n, r = /* @__PURE__ */ new Set(), i = 0, o = 0;
    for (t = 0, n = e.length; t < n; ++t) {
      const s = e[t].element;
      if (s && s.hasValue()) {
        const l = s.tooltipPosition();
        r.add(l.x), i += l.y, ++o;
      }
    }
    return o === 0 || r.size === 0 ? !1 : {
      x: [
        ...r
      ].reduce((s, l) => s + l) / r.size,
      y: i / o
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let n = t.x, r = t.y, i = Number.POSITIVE_INFINITY, o, a, s;
    for (o = 0, a = e.length; o < a; ++o) {
      const l = e[o].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), u = Xm(t, c);
        u < i && (i = u, s = l);
      }
    }
    if (s) {
      const l = s.tooltipPosition();
      n = l.x, r = l.y;
    }
    return {
      x: n,
      y: r
    };
  }
};
function Cr(e, t) {
  return t && (Ut(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function ei(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function KQ(e, t) {
  const { element: n, datasetIndex: r, index: i } = t, o = e.getDatasetMeta(r).controller, { label: a, value: s } = o.getLabelAndValue(i);
  return {
    chart: e,
    label: a,
    parsed: o.getParsed(i),
    raw: e.data.datasets[r].data[i],
    formattedValue: s,
    dataset: o.getDataset(),
    dataIndex: i,
    datasetIndex: r,
    element: n
  };
}
function XS(e, t) {
  const n = e.chart.ctx, { body: r, footer: i, title: o } = e, { boxWidth: a, boxHeight: s } = t, l = Tn(t.bodyFont), c = Tn(t.titleFont), u = Tn(t.footerFont), d = o.length, f = i.length, p = r.length, g = br(t.padding);
  let m = g.height, v = 0, y = r.reduce((b, w) => b + w.before.length + w.lines.length + w.after.length, 0);
  if (y += e.beforeBody.length + e.afterBody.length, d && (m += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), y) {
    const b = t.displayColors ? Math.max(s, l.lineHeight) : l.lineHeight;
    m += p * b + (y - p) * l.lineHeight + (y - 1) * t.bodySpacing;
  }
  f && (m += t.footerMarginTop + f * u.lineHeight + (f - 1) * t.footerSpacing);
  let S = 0;
  const x = function(b) {
    v = Math.max(v, n.measureText(b).width + S);
  };
  return n.save(), n.font = c.string, We(e.title, x), n.font = l.string, We(e.beforeBody.concat(e.afterBody), x), S = t.displayColors ? a + 2 + t.boxPadding : 0, We(r, (b) => {
    We(b.before, x), We(b.lines, x), We(b.after, x);
  }), S = 0, n.font = u.string, We(e.footer, x), n.restore(), v += g.width, {
    width: v,
    height: m
  };
}
function qQ(e, t) {
  const { y: n, height: r } = t;
  return n < r / 2 ? "top" : n > e.height - r / 2 ? "bottom" : "center";
}
function YQ(e, t, n, r) {
  const { x: i, width: o } = r, a = n.caretSize + n.caretPadding;
  if (e === "left" && i + o + a > t.width || e === "right" && i - o - a < 0)
    return !0;
}
function GQ(e, t, n, r) {
  const { x: i, width: o } = n, { width: a, chartArea: { left: s, right: l } } = e;
  let c = "center";
  return r === "center" ? c = i <= (s + l) / 2 ? "left" : "right" : i <= o / 2 ? c = "left" : i >= a - o / 2 && (c = "right"), YQ(c, e, t, n) && (c = "center"), c;
}
function ZS(e, t, n) {
  const r = n.yAlign || t.yAlign || qQ(e, n);
  return {
    xAlign: n.xAlign || t.xAlign || GQ(e, t, n, r),
    yAlign: r
  };
}
function XQ(e, t) {
  let { x: n, width: r } = e;
  return t === "right" ? n -= r : t === "center" && (n -= r / 2), n;
}
function ZQ(e, t, n) {
  let { y: r, height: i } = e;
  return t === "top" ? r += n : t === "bottom" ? r -= i + n : r -= i / 2, r;
}
function JS(e, t, n, r) {
  const { caretSize: i, caretPadding: o, cornerRadius: a } = e, { xAlign: s, yAlign: l } = n, c = i + o, { topLeft: u, topRight: d, bottomLeft: f, bottomRight: p } = ya(a);
  let g = XQ(t, s);
  const m = ZQ(t, l, c);
  return l === "center" ? s === "left" ? g += c : s === "right" && (g -= c) : s === "left" ? g -= Math.max(u, f) + i : s === "right" && (g += Math.max(d, p) + i), {
    x: dn(g, 0, r.width - t.width),
    y: dn(m, 0, r.height - t.height)
  };
}
function Vc(e, t, n) {
  const r = br(n.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - r.right : e.x + r.left;
}
function QS(e) {
  return Cr([], ei(e));
}
function JQ(e, t, n) {
  return Go(e, {
    tooltip: t,
    tooltipItems: n,
    type: "tooltip"
  });
}
function eE(e, t) {
  const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return n ? e.override(n) : e;
}
const Xk = {
  beforeTitle: Jr,
  title(e) {
    if (e.length > 0) {
      const t = e[0], n = t.chart.data.labels, r = n ? n.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (r > 0 && t.dataIndex < r)
        return n[t.dataIndex];
    }
    return "";
  },
  afterTitle: Jr,
  beforeBody: Jr,
  beforeLabel: Jr,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const n = e.formattedValue;
    return Fe(n) || (t += n), t;
  },
  labelColor(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: n.pointStyle,
      rotation: n.rotation
    };
  },
  afterLabel: Jr,
  afterBody: Jr,
  beforeFooter: Jr,
  footer: Jr,
  afterFooter: Jr
};
function Sn(e, t, n, r) {
  const i = e[t].call(n, r);
  return typeof i > "u" ? Xk[t].call(n, r) : i;
}
class tE extends eo {
  static positioners = ks;
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const n = this.chart, r = this.options.setContext(this.getContext()), i = r.enabled && n.options.animation && r.animations, o = new Dk(this.chart, i);
    return i._cacheable && (this._cachedAnimations = Object.freeze(o)), o;
  }
  getContext() {
    return this.$context || (this.$context = JQ(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, n) {
    const { callbacks: r } = n, i = Sn(r, "beforeTitle", this, t), o = Sn(r, "title", this, t), a = Sn(r, "afterTitle", this, t);
    let s = [];
    return s = Cr(s, ei(i)), s = Cr(s, ei(o)), s = Cr(s, ei(a)), s;
  }
  getBeforeBody(t, n) {
    return QS(Sn(n.callbacks, "beforeBody", this, t));
  }
  getBody(t, n) {
    const { callbacks: r } = n, i = [];
    return We(t, (o) => {
      const a = {
        before: [],
        lines: [],
        after: []
      }, s = eE(r, o);
      Cr(a.before, ei(Sn(s, "beforeLabel", this, o))), Cr(a.lines, Sn(s, "label", this, o)), Cr(a.after, ei(Sn(s, "afterLabel", this, o))), i.push(a);
    }), i;
  }
  getAfterBody(t, n) {
    return QS(Sn(n.callbacks, "afterBody", this, t));
  }
  getFooter(t, n) {
    const { callbacks: r } = n, i = Sn(r, "beforeFooter", this, t), o = Sn(r, "footer", this, t), a = Sn(r, "afterFooter", this, t);
    let s = [];
    return s = Cr(s, ei(i)), s = Cr(s, ei(o)), s = Cr(s, ei(a)), s;
  }
  _createItems(t) {
    const n = this._active, r = this.chart.data, i = [], o = [], a = [];
    let s = [], l, c;
    for (l = 0, c = n.length; l < c; ++l)
      s.push(KQ(this.chart, n[l]));
    return t.filter && (s = s.filter((u, d, f) => t.filter(u, d, f, r))), t.itemSort && (s = s.sort((u, d) => t.itemSort(u, d, r))), We(s, (u) => {
      const d = eE(t.callbacks, u);
      i.push(Sn(d, "labelColor", this, u)), o.push(Sn(d, "labelPointStyle", this, u)), a.push(Sn(d, "labelTextColor", this, u));
    }), this.labelColors = i, this.labelPointStyles = o, this.labelTextColors = a, this.dataPoints = s, s;
  }
  update(t, n) {
    const r = this.options.setContext(this.getContext()), i = this._active;
    let o, a = [];
    if (!i.length)
      this.opacity !== 0 && (o = {
        opacity: 0
      });
    else {
      const s = ks[r.position].call(this, i, this._eventPosition);
      a = this._createItems(r), this.title = this.getTitle(a, r), this.beforeBody = this.getBeforeBody(a, r), this.body = this.getBody(a, r), this.afterBody = this.getAfterBody(a, r), this.footer = this.getFooter(a, r);
      const l = this._size = XS(this, r), c = Object.assign({}, s, l), u = ZS(this.chart, r, c), d = JS(r, c, u, this.chart);
      this.xAlign = u.xAlign, this.yAlign = u.yAlign, o = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: s.x,
        caretY: s.y
      };
    }
    this._tooltipItems = a, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && r.external && r.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: n
    });
  }
  drawCaret(t, n, r, i) {
    const o = this.getCaretPosition(t, r, i);
    n.lineTo(o.x1, o.y1), n.lineTo(o.x2, o.y2), n.lineTo(o.x3, o.y3);
  }
  getCaretPosition(t, n, r) {
    const { xAlign: i, yAlign: o } = this, { caretSize: a, cornerRadius: s } = r, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: d } = ya(s), { x: f, y: p } = t, { width: g, height: m } = n;
    let v, y, S, x, b, w;
    return o === "center" ? (b = p + m / 2, i === "left" ? (v = f, y = v - a, x = b + a, w = b - a) : (v = f + g, y = v + a, x = b - a, w = b + a), S = v) : (i === "left" ? y = f + Math.max(l, u) + a : i === "right" ? y = f + g - Math.max(c, d) - a : y = this.caretX, o === "top" ? (x = p, b = x - a, v = y - a, S = y + a) : (x = p + m, b = x + a, v = y + a, S = y - a), w = x), {
      x1: v,
      x2: y,
      x3: S,
      y1: x,
      y2: b,
      y3: w
    };
  }
  drawTitle(t, n, r) {
    const i = this.title, o = i.length;
    let a, s, l;
    if (o) {
      const c = ba(r.rtl, this.x, this.width);
      for (t.x = Vc(this, r.titleAlign, r), n.textAlign = c.textAlign(r.titleAlign), n.textBaseline = "middle", a = Tn(r.titleFont), s = r.titleSpacing, n.fillStyle = r.titleColor, n.font = a.string, l = 0; l < o; ++l)
        n.fillText(i[l], c.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + s, l + 1 === o && (t.y += r.titleMarginBottom - s);
    }
  }
  _drawColorBox(t, n, r, i, o) {
    const a = this.labelColors[r], s = this.labelPointStyles[r], { boxHeight: l, boxWidth: c } = o, u = Tn(o.bodyFont), d = Vc(this, "left", o), f = i.x(d), p = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, g = n.y + p;
    if (o.usePointStyle) {
      const m = {
        radius: Math.min(c, l) / 2,
        pointStyle: s.pointStyle,
        rotation: s.rotation,
        borderWidth: 1
      }, v = i.leftForLtr(f, c) + c / 2, y = g + l / 2;
      t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Jm(t, m, v, y), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Jm(t, m, v, y);
    } else {
      t.lineWidth = Pe(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;
      const m = i.leftForLtr(f, c), v = i.leftForLtr(i.xPlus(f, 1), c - 2), y = ya(a.borderRadius);
      Object.values(y).some((S) => S !== 0) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, ld(t, {
        x: m,
        y: g,
        w: c,
        h: l,
        radius: y
      }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), ld(t, {
        x: v,
        y: g + 1,
        w: c - 2,
        h: l - 2,
        radius: y
      }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(m, g, c, l), t.strokeRect(m, g, c, l), t.fillStyle = a.backgroundColor, t.fillRect(v, g + 1, c - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[r];
  }
  drawBody(t, n, r) {
    const { body: i } = this, { bodySpacing: o, bodyAlign: a, displayColors: s, boxHeight: l, boxWidth: c, boxPadding: u } = r, d = Tn(r.bodyFont);
    let f = d.lineHeight, p = 0;
    const g = ba(r.rtl, this.x, this.width), m = function(A) {
      n.fillText(A, g.x(t.x + p), t.y + f / 2), t.y += f + o;
    }, v = g.textAlign(a);
    let y, S, x, b, w, E, C;
    for (n.textAlign = a, n.textBaseline = "middle", n.font = d.string, t.x = Vc(this, v, r), n.fillStyle = r.bodyColor, We(this.beforeBody, m), p = s && v !== "right" ? a === "center" ? c / 2 + u : c + 2 + u : 0, b = 0, E = i.length; b < E; ++b) {
      for (y = i[b], S = this.labelTextColors[b], n.fillStyle = S, We(y.before, m), x = y.lines, s && x.length && (this._drawColorBox(n, t, b, g, r), f = Math.max(d.lineHeight, l)), w = 0, C = x.length; w < C; ++w)
        m(x[w]), f = d.lineHeight;
      We(y.after, m);
    }
    p = 0, f = d.lineHeight, We(this.afterBody, m), t.y -= o;
  }
  drawFooter(t, n, r) {
    const i = this.footer, o = i.length;
    let a, s;
    if (o) {
      const l = ba(r.rtl, this.x, this.width);
      for (t.x = Vc(this, r.footerAlign, r), t.y += r.footerMarginTop, n.textAlign = l.textAlign(r.footerAlign), n.textBaseline = "middle", a = Tn(r.footerFont), n.fillStyle = r.footerColor, n.font = a.string, s = 0; s < o; ++s)
        n.fillText(i[s], l.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + r.footerSpacing;
    }
  }
  drawBackground(t, n, r, i) {
    const { xAlign: o, yAlign: a } = this, { x: s, y: l } = t, { width: c, height: u } = r, { topLeft: d, topRight: f, bottomLeft: p, bottomRight: g } = ya(i.cornerRadius);
    n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.beginPath(), n.moveTo(s + d, l), a === "top" && this.drawCaret(t, n, r, i), n.lineTo(s + c - f, l), n.quadraticCurveTo(s + c, l, s + c, l + f), a === "center" && o === "right" && this.drawCaret(t, n, r, i), n.lineTo(s + c, l + u - g), n.quadraticCurveTo(s + c, l + u, s + c - g, l + u), a === "bottom" && this.drawCaret(t, n, r, i), n.lineTo(s + p, l + u), n.quadraticCurveTo(s, l + u, s, l + u - p), a === "center" && o === "left" && this.drawCaret(t, n, r, i), n.lineTo(s, l + d), n.quadraticCurveTo(s, l, s + d, l), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke();
  }
  _updateAnimationTarget(t) {
    const n = this.chart, r = this.$animations, i = r && r.x, o = r && r.y;
    if (i || o) {
      const a = ks[t.position].call(this, this._active, this._eventPosition);
      if (!a)
        return;
      const s = this._size = XS(this, t), l = Object.assign({}, a, this._size), c = ZS(n, t, l), u = JS(t, l, c, n);
      (i._to !== u.x || o._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = s.width, this.height = s.height, this.caretX = a.x, this.caretY = a.y, this._resolveAnimations().update(this, u));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const n = this.options.setContext(this.getContext());
    let r = this.opacity;
    if (!r)
      return;
    this._updateAnimationTarget(n);
    const i = {
      width: this.width,
      height: this.height
    }, o = {
      x: this.x,
      y: this.y
    };
    r = Math.abs(r) < 1e-3 ? 0 : r;
    const a = br(n.padding), s = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && s && (t.save(), t.globalAlpha = r, this.drawBackground(o, t, i, n), Mk(t, n.textDirection), o.y += a.top, this.drawTitle(o, t, n), this.drawBody(o, t, n), this.drawFooter(o, t, n), jk(t, n.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, n) {
    const r = this._active, i = t.map(({ datasetIndex: s, index: l }) => {
      const c = this.chart.getDatasetMeta(s);
      if (!c)
        throw new Error("Cannot find a dataset at index " + s);
      return {
        datasetIndex: s,
        element: c.data[l],
        index: l
      };
    }), o = !id(r, i), a = this._positionChanged(i, n);
    (o || a) && (this._active = i, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, n, r = !0) {
    if (n && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const i = this.options, o = this._active || [], a = this._getActiveElements(t, o, n, r), s = this._positionChanged(a, t), l = n || !id(a, o) || s;
    return l && (this._active = a, (i.enabled || i.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, n))), l;
  }
  _getActiveElements(t, n, r, i) {
    const o = this.options;
    if (t.type === "mouseout")
      return [];
    if (!i)
      return n.filter((s) => this.chart.data.datasets[s.datasetIndex] && this.chart.getDatasetMeta(s.datasetIndex).controller.getParsed(s.index) !== void 0);
    const a = this.chart.getElementsAtEventForMode(t, o.mode, o, r);
    return o.reverse && a.reverse(), a;
  }
  _positionChanged(t, n) {
    const { caretX: r, caretY: i, options: o } = this, a = ks[o.position].call(this, t, n);
    return a !== !1 && (r !== a.x || i !== a.y);
  }
}
var Or = {
  id: "tooltip",
  _element: tE,
  positioners: ks,
  afterInit(e, t, n) {
    n && (e.tooltip = new tE({
      chart: e,
      options: n
    }));
  },
  beforeUpdate(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  reset(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const n = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...n,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", n);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const n = t.replay;
      e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: Xk
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const QQ = (e, t, n, r) => (typeof t == "string" ? (n = e.push(t) - 1, r.unshift({
  index: n,
  label: t
})) : isNaN(t) && (n = null), n);
function eee(e, t, n, r) {
  const i = e.indexOf(t);
  if (i === -1)
    return QQ(e, t, n, r);
  const o = e.lastIndexOf(t);
  return i !== o ? n : i;
}
const tee = (e, t) => e === null ? null : dn(Math.round(e), 0, t);
function nE(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class to extends Za {
  static id = "category";
  static defaults = {
    ticks: {
      callback: nE
    }
  };
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const n = this._addedLabels;
    if (n.length) {
      const r = this.getLabels();
      for (const { index: i, label: o } of n)
        r[i] === o && r.splice(i, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, n) {
    if (Fe(t))
      return null;
    const r = this.getLabels();
    return n = isFinite(n) && r[n] === t ? n : eee(r, t, we(n, t), this._addedLabels), tee(n, r.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds();
    let { min: r, max: i } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (r = 0), n || (i = this.getLabels().length - 1)), this.min = r, this.max = i;
  }
  buildTicks() {
    const t = this.min, n = this.max, r = this.options.offset, i = [];
    let o = this.getLabels();
    o = t === 0 && n === o.length - 1 ? o : o.slice(t, n + 1), this._valueRange = Math.max(o.length - (r ? 0 : 1), 1), this._startValue = this.min - (r ? 0.5 : 0);
    for (let a = t; a <= n; a++)
      i.push({
        value: a
      });
    return i;
  }
  getLabelForValue(t) {
    return nE.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function nee(e, t) {
  const n = [], { bounds: i, step: o, min: a, max: s, precision: l, count: c, maxTicks: u, maxDigits: d, includeBounds: f } = e, p = o || 1, g = u - 1, { min: m, max: v } = t, y = !Fe(a), S = !Fe(s), x = !Fe(c), b = (v - m) / (d + 1);
  let w = rS((v - m) / g / p) * p, E, C, A, k;
  if (w < 1e-14 && !y && !S)
    return [
      {
        value: m
      },
      {
        value: v
      }
    ];
  k = Math.ceil(v / w) - Math.floor(m / w), k > g && (w = rS(k * w / g / p) * p), Fe(l) || (E = Math.pow(10, l), w = Math.ceil(w * E) / E), i === "ticks" ? (C = Math.floor(m / w) * w, A = Math.ceil(v / w) * w) : (C = m, A = v), y && S && o && SX((s - a) / o, w / 1e3) ? (k = Math.round(Math.min((s - a) / w, u)), w = (s - a) / k, C = a, A = s) : x ? (C = y ? a : C, A = S ? s : A, k = c - 1, w = (A - C) / k) : (k = (A - C) / w, Fs(k, Math.round(k), w / 1e3) ? k = Math.round(k) : k = Math.ceil(k));
  const R = Math.max(iS(w), iS(C));
  E = Math.pow(10, Fe(l) ? R : l), C = Math.round(C * E) / E, A = Math.round(A * E) / E;
  let M = 0;
  for (y && (f && C !== a ? (n.push({
    value: a
  }), C < a && M++, Fs(Math.round((C + M * w) * E) / E, a, rE(a, b, e)) && M++) : C < a && M++); M < k; ++M) {
    const P = Math.round((C + M * w) * E) / E;
    if (S && P > s)
      break;
    n.push({
      value: P
    });
  }
  return S && f && A !== s ? n.length && Fs(n[n.length - 1].value, s, rE(s, b, e)) ? n[n.length - 1].value = s : n.push({
    value: s
  }) : (!S || A === s) && n.push({
    value: A
  }), n;
}
function rE(e, t, { horizontal: n, minRotation: r }) {
  const i = li(r), o = (n ? Math.sin(i) : Math.cos(i)) || 1e-3, a = 0.75 * t * ("" + e).length;
  return Math.min(t / o, a);
}
class ree extends Za {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, n) {
    return Fe(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: n, maxDefined: r } = this.getUserBounds();
    let { min: i, max: o } = this;
    const a = (l) => i = n ? i : l, s = (l) => o = r ? o : l;
    if (t) {
      const l = Ir(i), c = Ir(o);
      l < 0 && c < 0 ? s(0) : l > 0 && c > 0 && a(0);
    }
    if (i === o) {
      let l = o === 0 ? 1 : Math.abs(o * 0.05);
      s(o + l), t || a(i - l);
    }
    this.min = i, this.max = o;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: n, stepSize: r } = t, i;
    return r ? (i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, n = t.ticks;
    let r = this.getTickLimit();
    r = Math.max(2, r);
    const i = {
      maxTicks: r,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== !1
    }, o = this._range || this, a = nee(i, o);
    return t.bounds === "ticks" && EX(a, this, "value"), t.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a;
  }
  configure() {
    const t = this.ticks;
    let n = this.min, r = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const i = (r - n) / Math.max(t.length - 1, 1) / 2;
      n -= i, r += i;
    }
    this._startValue = n, this._endValue = r, this._valueRange = r - n;
  }
  getLabelForValue(t) {
    return Wy(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class no extends ree {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: Sk.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0);
    this.min = pr(t) ? t : 0, this.max = pr(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), n = t ? this.width : this.height, r = li(this.options.ticks.minRotation), i = (t ? Math.sin(r) : Math.cos(r)) || 1e-3, o = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, o.lineHeight / i));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
const Ef = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Pn = /* @__PURE__ */ Object.keys(Ef);
function iE(e, t) {
  return e - t;
}
function oE(e, t) {
  if (Fe(t))
    return null;
  const n = e._adapter, { parser: r, round: i, isoWeekday: o } = e._parseOpts;
  let a = t;
  return typeof r == "function" && (a = r(a)), pr(a) || (a = typeof r == "string" ? n.parse(a, r) : n.parse(a)), a === null ? null : (i && (a = i === "week" && (pl(o) || o === !0) ? n.startOf(a, "isoWeek", o) : n.startOf(a, i)), +a);
}
function aE(e, t, n, r) {
  const i = Pn.length;
  for (let o = Pn.indexOf(e); o < i - 1; ++o) {
    const a = Ef[Pn[o]], s = a.steps ? a.steps : Number.MAX_SAFE_INTEGER;
    if (a.common && Math.ceil((n - t) / (s * a.size)) <= r)
      return Pn[o];
  }
  return Pn[i - 1];
}
function iee(e, t, n, r, i) {
  for (let o = Pn.length - 1; o >= Pn.indexOf(n); o--) {
    const a = Pn[o];
    if (Ef[a].common && e._adapter.diff(i, r, a) >= t - 1)
      return a;
  }
  return Pn[n ? Pn.indexOf(n) : 0];
}
function oee(e) {
  for (let t = Pn.indexOf(e) + 1, n = Pn.length; t < n; ++t)
    if (Ef[Pn[t]].common)
      return Pn[t];
}
function sE(e, t, n) {
  if (!n)
    e[t] = !0;
  else if (n.length) {
    const { lo: r, hi: i } = By(n, t), o = n[r] >= t ? n[r] : n[i];
    e[o] = !0;
  }
}
function aee(e, t, n, r) {
  const i = e._adapter, o = +i.startOf(t[0].value, r), a = t[t.length - 1].value;
  let s, l;
  for (s = o; s <= a; s = +i.add(s, 1, r))
    l = n[s], l >= 0 && (t[l].major = !0);
  return t;
}
function lE(e, t, n) {
  const r = [], i = {}, o = t.length;
  let a, s;
  for (a = 0; a < o; ++a)
    s = t[a], i[s] = a, r.push({
      value: s,
      major: !1
    });
  return o === 0 || !n ? r : aee(e, r, i, n);
}
class cE extends Za {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, n = {}) {
    const r = t.time || (t.time = {}), i = this._adapter = new fJ._date(t.adapters.date);
    i.init(n), Ls(r.displayFormats, i.formats()), this._parseOpts = {
      parser: r.parser,
      round: r.round,
      isoWeekday: r.isoWeekday
    }, super.init(t), this._normalized = n.normalized;
  }
  parse(t, n) {
    return t === void 0 ? null : oE(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, n = this._adapter, r = t.time.unit || "day";
    let { min: i, max: o, minDefined: a, maxDefined: s } = this.getUserBounds();
    function l(c) {
      !a && !isNaN(c.min) && (i = Math.min(i, c.min)), !s && !isNaN(c.max) && (o = Math.max(o, c.max));
    }
    (!a || !s) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), i = pr(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r), o = pr(o) && !isNaN(o) ? o : +n.endOf(Date.now(), r) + 1, this.min = Math.min(i, o - 1), this.max = Math.max(i + 1, o);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY;
    return t.length && (n = t[0], r = t[t.length - 1]), {
      min: n,
      max: r
    };
  }
  buildTicks() {
    const t = this.options, n = t.time, r = t.ticks, i = r.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]);
    const o = this.min, a = this.max, s = TX(i, o, a);
    return this._unit = n.unit || (r.autoSkip ? aE(n.minUnit, this.min, this.max, this._getLabelCapacity(o)) : iee(this, s.length, n.minUnit, this.min, this.max)), this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : oee(this._unit), this.initOffsets(i), t.reverse && s.reverse(), lE(this, s, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let n = 0, r = 0, i, o;
    this.options.offset && t.length && (i = this.getDecimalForValue(t[0]), t.length === 1 ? n = 1 - i : n = (this.getDecimalForValue(t[1]) - i) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? r = o : r = (o - this.getDecimalForValue(t[t.length - 2])) / 2);
    const a = t.length < 3 ? 0.5 : 0.25;
    n = dn(n, 0, a), r = dn(r, 0, a), this._offsets = {
      start: n,
      end: r,
      factor: 1 / (n + 1 + r)
    };
  }
  _generate() {
    const t = this._adapter, n = this.min, r = this.max, i = this.options, o = i.time, a = o.unit || aE(o.minUnit, n, r, this._getLabelCapacity(n)), s = we(i.ticks.stepSize, 1), l = a === "week" ? o.isoWeekday : !1, c = pl(l) || l === !0, u = {};
    let d = n, f, p;
    if (c && (d = +t.startOf(d, "isoWeek", l)), d = +t.startOf(d, c ? "day" : a), t.diff(r, n, a) > 1e5 * s)
      throw new Error(n + " and " + r + " are too far apart with stepSize of " + s + " " + a);
    const g = i.ticks.source === "data" && this.getDataTimestamps();
    for (f = d, p = 0; f < r; f = +t.add(f, s, a), p++)
      sE(u, f, g);
    return (f === r || i.bounds === "ticks" || p === 1) && sE(u, f, g), Object.keys(u).sort(iE).map((m) => +m);
  }
  getLabelForValue(t) {
    const n = this._adapter, r = this.options.time;
    return r.tooltipFormat ? n.format(t, r.tooltipFormat) : n.format(t, r.displayFormats.datetime);
  }
  format(t, n) {
    const i = this.options.time.displayFormats, o = this._unit, a = n || i[o];
    return this._adapter.format(t, a);
  }
  _tickFormatFunction(t, n, r, i) {
    const o = this.options, a = o.ticks.callback;
    if (a)
      return rt(a, [
        t,
        n,
        r
      ], this);
    const s = o.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && s[l], d = c && s[c], f = r[n], p = c && d && f && f.major;
    return this._adapter.format(t, i || (p ? d : u));
  }
  generateTickLabels(t) {
    let n, r, i;
    for (n = 0, r = t.length; n < r; ++n)
      i = t[n], i.label = this._tickFormatFunction(i.value, n, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const n = this._offsets, r = this.getDecimalForValue(t);
    return this.getPixelForDecimal((n.start + r) * n.factor);
  }
  getValueForPixel(t) {
    const n = this._offsets, r = this.getDecimalForPixel(t) / n.factor - n.end;
    return this.min + r * (this.max - this.min);
  }
  _getLabelSize(t) {
    const n = this.options.ticks, r = this.ctx.measureText(t).width, i = li(this.isHorizontal() ? n.maxRotation : n.minRotation), o = Math.cos(i), a = Math.sin(i), s = this._resolveTickFontOptions(0).size;
    return {
      w: r * o + s * a,
      h: r * a + s * o
    };
  }
  _getLabelCapacity(t) {
    const n = this.options.time, r = n.displayFormats, i = r[n.unit] || r.millisecond, o = this._tickFormatFunction(t, 0, lE(this, [
      t
    ], this._majorUnit), i), a = this._getLabelSize(o), s = Math.floor(this.isHorizontal() ? this.width / a.w : this.height / a.h) - 1;
    return s > 0 ? s : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], n, r;
    if (t.length)
      return t;
    const i = this.getMatchingVisibleMetas();
    if (this._normalized && i.length)
      return this._cache.data = i[0].controller.getAllParsedValues(this);
    for (n = 0, r = i.length; n < r; ++n)
      t = t.concat(i[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let n, r;
    if (t.length)
      return t;
    const i = this.getLabels();
    for (n = 0, r = i.length; n < r; ++n)
      t.push(oE(this, i[n]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return bk(t.sort(iE));
  }
}
function Uc(e, t, n) {
  let r = 0, i = e.length - 1, o, a, s, l;
  n ? (t >= e[r].pos && t <= e[i].pos && ({ lo: r, hi: i } = Po(e, "pos", t)), { pos: o, time: s } = e[r], { pos: a, time: l } = e[i]) : (t >= e[r].time && t <= e[i].time && ({ lo: r, hi: i } = Po(e, "time", t)), { time: o, pos: s } = e[r], { time: a, pos: l } = e[i]);
  const c = a - o;
  return c ? s + (l - s) * (t - o) / c : s;
}
class ote extends cE {
  static id = "timeseries";
  static defaults = cE.defaults;
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(t);
    this._minPos = Uc(n, this.min), this._tableRange = Uc(n, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: n, max: r } = this, i = [], o = [];
    let a, s, l, c, u;
    for (a = 0, s = t.length; a < s; ++a)
      c = t[a], c >= n && c <= r && i.push(c);
    if (i.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: r,
          pos: 1
        }
      ];
    for (a = 0, s = i.length; a < s; ++a)
      u = i[a + 1], l = i[a - 1], c = i[a], Math.round((u + l) / 2) !== c && o.push({
        time: c,
        pos: a / (s - 1)
      });
    return o;
  }
  _generate() {
    const t = this.min, n = this.max;
    let r = super.getDataTimestamps();
    return (!r.includes(t) || !r.length) && r.splice(0, 0, t), (!r.includes(n) || r.length === 1) && r.push(n), r.sort((i, o) => i - o);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const n = this.getDataTimestamps(), r = this.getLabelTimestamps();
    return n.length && r.length ? t = this.normalize(n.concat(r)) : t = n.length ? n : r, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (Uc(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const n = this._offsets, r = this.getDecimalForPixel(t) / n.factor - n.end;
    return Uc(this._table, r * this._tableRange + this._minPos, !0);
  }
}
const Zk = "label";
function uE(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
function see(e, t) {
  const n = e.options;
  n && t && Object.assign(n, t);
}
function Jk(e, t) {
  e.labels = t;
}
function Qk(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Zk;
  const r = [];
  e.datasets = t.map((i) => {
    const o = e.datasets.find((a) => a[n] === i[n]);
    return !o || !i.data || r.includes(o) ? {
      ...i
    } : (r.push(o), Object.assign(o, i), o);
  });
}
function lee(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zk;
  const n = {
    labels: [],
    datasets: []
  };
  return Jk(n, e.labels), Qk(n, e.datasets, t), n;
}
function cee(e, t) {
  const { height: n = 150, width: r = 300, redraw: i = !1, datasetIdKey: o, type: a, data: s, options: l, plugins: c = [], fallbackContent: u, updateMode: d, ...f } = e, p = Ue(null), g = Ue(null), m = () => {
    p.current && (g.current = new Dn(p.current, {
      type: a,
      data: lee(s, o),
      options: l && {
        ...l
      },
      plugins: c
    }), uE(t, g.current));
  }, v = () => {
    uE(t, null), g.current && (g.current.destroy(), g.current = null);
  };
  return Le(() => {
    !i && g.current && l && see(g.current, l);
  }, [
    i,
    l
  ]), Le(() => {
    !i && g.current && Jk(g.current.config.data, s.labels);
  }, [
    i,
    s.labels
  ]), Le(() => {
    !i && g.current && s.datasets && Qk(g.current.config.data, s.datasets, o);
  }, [
    i,
    s.datasets
  ]), Le(() => {
    g.current && (i ? (v(), setTimeout(m)) : g.current.update(d));
  }, [
    i,
    l,
    s.labels,
    s.datasets,
    d
  ]), Le(() => {
    g.current && (v(), setTimeout(m));
  }, [
    a
  ]), Le(() => (m(), () => v()), []), /* @__PURE__ */ He.createElement("canvas", {
    ref: p,
    role: "img",
    height: n,
    width: r,
    ...f
  }, u);
}
const uee = /* @__PURE__ */ nn(cee);
function tb(e, t) {
  return Dn.register(t), /* @__PURE__ */ nn((n, r) => /* @__PURE__ */ He.createElement(uee, {
    ...n,
    ref: r,
    type: e
  }));
}
const nb = /* @__PURE__ */ tb("line", dJ), Xl = /* @__PURE__ */ tb("bar", lJ), rb = /* @__PURE__ */ tb("doughnut", uJ);
Dn.register(Jy, Or, wr);
const dee = {
  id: "centerText",
  afterDraw(e, t, n) {
    const { ctx: r } = e, i = e.getDatasetMeta(0);
    if (!i?.data?.[0]) return;
    const { x: o, y: a } = i.data[0], {
      top: s = "",
      bottom: l = "",
      topSize: c = 20,
      bottomSize: u = 10,
      topColor: d = "#0F172A",
      bottomColor: f = "#64748B"
    } = n || {};
    r.save(), r.textAlign = "center", r.textBaseline = "middle", r.fillStyle = d, r.font = `600 ${c}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(s, o, a - 5), r.fillStyle = f, r.font = `500 ${u}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(l, o, a + 12), r.restore();
  }
}, ate = ({ sold: e = 847, unsold: t = 73, growthPct: n = "+9.1%" }) => {
  const r = e + t, i = {
    labels: ["Sold", "Unsold"],
    datasets: [
      {
        data: [e, t],
        backgroundColor: ["#12B981", "#EF4444"],
        borderWidth: 2,
        hoverOffset: 4
      }
    ]
  }, o = {
    responsive: !0,
    maintainAspectRatio: !1,
    cutout: "68%",
    plugins: {
      legend: { display: !1 },
      tooltip: {
        callbacks: { label: (a) => `${a.label}: ${a.parsed}` },
        displayColors: !1
      },
      centerText: {
        top: `${r}`,
        bottom: "Total Units",
        topSize: 20,
        bottomSize: 10
      }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Unit Status",
      period: "This Month",
      icon: /* @__PURE__ */ O.jsx(bg, { className: "h-6 w-6 text-green-600" }),
      className: "h-[238px]",
      children: /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-12 gap-[16px] items-center", children: [
        /* @__PURE__ */ O.jsxs("div", { className: "col-span-5 space-y-3", children: [
          /* @__PURE__ */ O.jsxs("div", { children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] lending-[16px] text-[#64748B]", children: "Sold" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px] text-[#1FA05B]", children: e })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] lending-[16px] text-[#64748B]", children: "Unsold" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px] text-[#EF4444]", children: t })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "text-[10px] text-[#1FA05B] flex gap-[8px] items-center ", children: [
            n,
            " ",
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] text-[10px]", children: "Compared to last month" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "col-span-7", children: /* @__PURE__ */ O.jsx("div", { className: "h-[158px] w-[158px] ml-auto mr-2", children: /* @__PURE__ */ O.jsx(
          rb,
          {
            data: i,
            options: o,
            plugins: [dee]
          }
        ) }) })
      ] })
    }
  );
}, dE = ({ value: e = 0, total: t = 1, colorClass: n = "", label: r = "" }) => {
  const i = Math.max(0, Math.min(100, e / (t || 1) * 100)), o = n === "bg-[#8B5CF6]" ? "text-[#8B5CF6]" : n === "bg-[#12B981]" ? "text-[#12B981]" : "text-slate-600";
  return /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col items-start", children: [
    /* @__PURE__ */ O.jsx("div", { className: "w-2/3 min-w-[80px] h-3 rounded-full overflow-hidden", children: /* @__PURE__ */ O.jsx(
      "div",
      {
        className: `h-3 rounded-full ${n}`,
        style: { width: `${i}%` }
      }
    ) }),
    /* @__PURE__ */ O.jsx("div", { className: `${o} !text-[12px] font-bold mt-1`, children: e }),
    /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] text-[#64748B] mt-1", children: r })
  ] });
}, fE = ({ title: e, value: t, suffix: n, valueClass: r = "" }) => /* @__PURE__ */ O.jsxs("div", { className: "bg-white border border-[#EBEBEB] rounded-xl shadow-[0_0_12px_0_#EAF2FF] h-[98px] p-4 flex flex-col justify-center", children: [
  /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#121212] mb-1", children: e }),
  /* @__PURE__ */ O.jsxs(
    "div",
    {
      className: `text-[28px] leading-[32px] flex item gap-[4px] font-medium ${r}`,
      children: [
        t,
        " ",
        n && /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px] font-medium", children: n })
      ]
    }
  )
] }), ste = ({
  totalUnits: e = 847,
  occupiedUnits: t = 756,
  ownerCount: n = 700,
  tenantCount: r = 56,
  avgResidents: i = 4.4,
  avgLeaseMonths: o = 18
}) => {
  const a = n + r;
  return /* @__PURE__ */ O.jsxs("div", { children: [
    /* @__PURE__ */ O.jsxs("div", { className: "bg-white border border-[#EBEBEB] rounded-xl shadow-[0_0_12px_0_#EAF2FF] p-4 h-[128px]", children: [
      /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[12px] mb-4", children: [
        /* @__PURE__ */ O.jsx(d_, { className: "h-6 w-6 text-[#329DFF]" }),
        /* @__PURE__ */ O.jsx("div", { className: "font-medium text-[#121212]", children: "Occupancy Overview" })
      ] }),
      /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between gap-", children: [
        /* @__PURE__ */ O.jsxs("div", { children: [
          /* @__PURE__ */ O.jsx("div", { className: "text-xs leading-[16px] text-[#64748B]", children: "Occupied Units" }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px] font-medium text-[#121212]", children: t }),
            /* @__PURE__ */ O.jsxs("div", { className: "text-[#64748B] text-[20px] leading-[32px]", children: [
              "/",
              e
            ] })
          ] })
        ] }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-end", children: [
          /* @__PURE__ */ O.jsx(
            dE,
            {
              value: n,
              total: a,
              colorClass: "bg-[#8B5CF6]",
              label: "Owner"
            }
          ),
          /* @__PURE__ */ O.jsx(
            dE,
            {
              value: r,
              total: a,
              colorClass: "bg-[#12B981]",
              label: "Tenant"
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ O.jsxs("div", { className: "mt-2.5 grid grid-cols-2 gap-[12px]", children: [
      /* @__PURE__ */ O.jsx(
        fE,
        {
          title: "Avg Residents Per Unit",
          value: i,
          valueClass: "text-[#8B5CF6]"
        }
      ),
      /* @__PURE__ */ O.jsx(
        fE,
        {
          title: "Avg Lease Period",
          value: o,
          suffix: "months",
          valueClass: "text-[#E7A015]"
        }
      )
    ] })
  ] });
};
Dn.register(Jy, Or, wr);
const fee = {
  id: "centerText",
  afterDraw(e, t, n) {
    const { ctx: r } = e, i = e.getDatasetMeta(0);
    if (!i?.data?.[0]) return;
    const { x: o, y: a } = i.data[0], {
      top: s = "",
      bottom: l = "",
      topSize: c = 20,
      bottomSize: u = 10,
      topColor: d = "#0F172A",
      bottomColor: f = "#64748B"
    } = n || {};
    r.save(), r.textAlign = "center", r.textBaseline = "middle", r.fillStyle = d, r.font = `600 ${c}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(s, o, a - 5), r.fillStyle = f, r.font = `500 ${u}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`, r.fillText(l, o, a + 12), r.restore();
  }
}, lte = ({
  ownerCount: e = 1e3,
  tenantCount: t = 200,
  nonResidingOwners: n = 26,
  growthPct: r = "+9.1%"
}) => {
  const i = Math.max(e - n, 0), o = e + t, a = {
    labels: ["Owners", "Tenants", "Non-residing Owner"],
    datasets: [
      {
        data: [i, t, n],
        backgroundColor: ["#3C81F6", "#08B6D4", "#8B5CF6"],
        borderWidth: 2,
        hoverOffset: 4
      }
    ]
  }, s = {
    responsive: !0,
    maintainAspectRatio: !1,
    cutout: "68%",
    plugins: {
      legend: { display: !1 },
      tooltip: {
        callbacks: { label: (l) => `${l.label}: ${l.parsed}` },
        displayColors: !1
      },
      centerText: {
        top: `${o}`,
        bottom: "Total Members",
        topSize: 20,
        bottomSize: 10
      }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Resident Overview",
      icon: /* @__PURE__ */ O.jsx(u_, { className: "h-6 w-6 text-[#8B5CF6]" }),
      className: "h-[238px]",
      children: /* @__PURE__ */ O.jsxs("div", { className: " flex-1 min-h-0 grid grid-cols-12 gap-[16px] items-center", children: [
        /* @__PURE__ */ O.jsxs("div", { className: "col-span-5", children: [
          /* @__PURE__ */ O.jsxs("div", { children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] text-[#64748B] leading-[16px]", children: "Total Owners" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px ]  text-[#3C81F6]", children: e })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] text-[#64748B]  leading-[16px]", children: "Total Tenants" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px ] text-[#08B6D4]", children: t })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "text-[10px] text-[#1FA05B] flex gap-2 items-center", children: [
            r,
            " ",
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] ", children: "Compared to last month" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "col-span-7", children: /* @__PURE__ */ O.jsx("div", { className: "h-[162px] w-[162px] ml-auto mr-2", children: /* @__PURE__ */ O.jsx(
          rb,
          {
            data: a,
            options: s,
            plugins: [fee]
          }
        ) }) })
      ] })
    }
  );
};
Dn.register(to, no, Gl, Or, wr);
const cte = ({
  blocks: e = [
    { name: "Block A", owner: 110, rented: 24, vacant: 8 },
    { name: "Block B", owner: 95, rented: 18, vacant: 6 },
    { name: "Block C", owner: 65, rented: 12, vacant: 18 },
    { name: "Block D", owner: 78, rented: 16, vacant: 30 }
  ]
}) => {
  const t = e.map((s) => s.name), n = e.map((s) => s.owner), r = e.map((s) => s.rented), i = e.map((s) => s.vacant), o = {
    labels: t,
    datasets: [
      {
        label: "Owner",
        data: n,
        backgroundColor: "#3C81F6",
        barThickness: 40
      },
      {
        label: "",
        data: n.map(() => 2),
        backgroundColor: "transparent",
        barThickness: 40
      },
      {
        label: "Rented",
        data: r,
        backgroundColor: "#8B5CF6",
        barThickness: 40
      },
      {
        label: "",
        data: r.map(() => 2),
        backgroundColor: "transparent",
        barThickness: 40
      },
      {
        label: "Vacant",
        data: i,
        backgroundColor: "#08B6D4",
        barThickness: 40
      }
    ]
  }, a = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          pointStyle: "rectRot",
          padding: 20
        }
      },
      tooltip: {
        callbacks: {
          label: (s) => `${s.dataset.label}: ${s.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        stacked: !0,
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        stacked: !0,
        beginAtZero: !0,
        suggestedMax: 180,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 20 }
      }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Block-wise Occupancy",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "text-xl text-[#884EA7]" }),
      className: "w-full h-[360px]",
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ O.jsx(Xl, { data: o, options: a })
    }
  );
};
Dn.register(
  to,
  no,
  eb,
  Qy,
  Or,
  wr
);
const pee = (e) => {
  const [t, n] = String(e).split(" ");
  return `${{
    Jan: "January",
    Feb: "February",
    Mar: "March",
    Apr: "April",
    May: "May",
    Jun: "June",
    Jul: "July",
    Aug: "August",
    Sep: "September",
    Oct: "October",
    Nov: "November",
    Dec: "December"
  }[t] || t} 20${n}`;
}, ute = ({
  labels: e = ["Jan 25", "Feb 25", "Mar 25", "Apr 25", "May 25"],
  moveIn: t = [24, 27, 20, 26, 23],
  moveOut: n = [12, 17, 8, 5, 16]
}) => {
  const r = {
    labels: e,
    datasets: [
      {
        label: "Move-in",
        data: t,
        borderColor: "#12B981",
        backgroundColor: "rgba(16,185,129,0.15)",
        pointBackgroundColor: "#12B981",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Move-out",
        data: n,
        borderColor: "#8B5CF6",
        backgroundColor: "rgba(124,58,237,0.15)",
        pointBackgroundColor: "#8B5CF6",
        pointStyle: "rectRot",
        fill: !1
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    interaction: { mode: "index", intersect: !1 },
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 0,
        callbacks: {
          title: (o) => pee(o[0].label),
          label: (o) => `${o.dataset.label}: ${o.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        suggestedMax: 28,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 4, precision: 0 }
      }
    },
    elements: {
      line: { borderWidth: 2, tension: 0 },
      point: { radius: 0, hoverRadius: 3, hitRadius: 10 }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Move-in/Out Trends",
      className: "w-full h-[360px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "text-[20px] text-[#884EA7]" }),
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ O.jsx(nb, { data: r, options: i })
    }
  );
};
Dn.register(to, no, eb, Qy, Or, wr);
const hee = (e) => {
  const [t, n] = String(e).split(" ");
  return `${{
    Jan: "January",
    Feb: "February",
    Mar: "March",
    Apr: "April",
    May: "May",
    Jun: "June",
    Jul: "July",
    Aug: "August",
    Sep: "September",
    Oct: "October",
    Nov: "November",
    Dec: "December"
  }[t] || t} 20${n}`;
}, mee = ({
  labels: e = ["Jan 25", "Feb 25", "Mar 25", "Apr 25", "May 25"],
  moveIn: t = [24, 27, 20, 26, 23],
  moveOut: n = [4, 17, 8, 5, 16, 4, 7]
}) => {
  const r = {
    labels: e,
    datasets: [
      {
        label: "Income",
        data: t,
        borderColor: "#10B981",
        backgroundColor: "rgba(16,185,129,0.15)",
        pointBackgroundColor: "#10B981",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Expenditure",
        data: n,
        borderColor: "#AB0000",
        backgroundColor: "rgba(124,58,237,0.15)",
        pointBackgroundColor: "#AB0000",
        pointStyle: "rectRot",
        fill: !1
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    interaction: { mode: "index", intersect: !1 },
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 0,
        callbacks: {
          title: (o) => hee(o[0].label),
          label: (o) => `${o.dataset.label}: ${o.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        suggestedMax: 28,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 4, precision: 0 }
      }
    },
    elements: {
      line: { borderWidth: 2, tension: 0 },
      point: { radius: 0, hoverRadius: 3, hitRadius: 10 }
    }
  };
  return /* @__PURE__ */ O.jsx(nb, { data: r, options: i });
};
function pE({
  label: e,
  value: t,
  positive: n,
  bgColor: r,
  delta: i,
  deltaLabel: o,
  textColor: a
}) {
  return /* @__PURE__ */ O.jsxs(
    "div",
    {
      className: `rounded-lg p-4 ${r} border border-[#EBEBEB] h-[126px]`,
      children: [
        /* @__PURE__ */ O.jsx("div", { className: `text-[16px] leading-[20px] ${a}`, children: e }),
        /* @__PURE__ */ O.jsx("div", { className: "mt-[16px] leading-[28px]  !text-[24px] font-medium text-[#121212]", children: t }),
        /* @__PURE__ */ O.jsxs("div", { className: "mt-[8px] flex items-center gap-[8px] leading-[14px] text-[10px]", children: [
          /* @__PURE__ */ O.jsx(
            "div",
            {
              className: n ? "text-[#1FA05B] font-medium" : "text-[#EF4444] font-medium",
              children: i
            }
          ),
          /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] ", children: o })
        ] })
      ]
    }
  );
}
function dte() {
  return /* @__PURE__ */ O.jsxs(
    ot,
    {
      title: "Accounting",
      className: "w-full h-[523px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: [
        /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-2 gap-[16px]", children: [
          /* @__PURE__ */ O.jsx(
            pE,
            {
              label: "Total Income",
              value: "AED 5.68M",
              delta: "+4.4%",
              positive: !0,
              bgColor: "bg-slate-50",
              deltaLabel: "Compared to last month",
              textColor: "text-[#1FA05B]"
            }
          ),
          /* @__PURE__ */ O.jsx(
            pE,
            {
              label: "Total Expenditure",
              value: "AED 1.83M",
              delta: "-1.1%",
              positive: !1,
              bgColor: "bg-slate-50",
              deltaLabel: "Compared to last month",
              textColor: "text-[#AB0000]"
            }
          )
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "h-[254px] mt-[35.5px]", children: /* @__PURE__ */ O.jsx(mee, {}) })
      ]
    }
  );
}
Dn.register(to, no, Gl, Or, wr);
const fte = () => {
  const e = [
    "Maintenance",
    "Security",
    "Utilities",
    "Housekeeping",
    "Administration",
    "Others"
  ], r = {
    labels: e,
    datasets: [
      {
        label: "Budget",
        data: [55e3, 56e3, 64e3, 38e3, 54e3, 65e3],
        backgroundColor: "#93C5FD",
        barThickness: 60
      },
      {
        label: "Actual",
        data: [63e3, 48e3, 51300, 28e3, 42e3, 35e3],
        backgroundColor: "#3B82F6",
        barThickness: 60
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          pointStyle: "rectRot",
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 6,
        callbacks: {
          title: (o) => e[o[0].dataIndex],
          label: (o) => {
            const a = o.parsed.y;
            return `${o.dataset.label}: AED ${(a / 1e3).toFixed(1)}K`;
          }
        }
      }
    },
    scales: {
      x: {
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        grid: { color: "#F1F5F9" },
        ticks: {
          color: "#64748B",
          callback: (o) => `${o / 1e3}K`
        }
      }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Budget vs Actuals",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ O.jsx(Xl, { data: r, options: i })
    }
  );
}, pte = () => {
  const e = [
    { title: "Primary Account", amount: 285e4, subtitle: "Savings" },
    { title: "Emergency Fund", amount: 12e5, subtitle: "Fixed deposit" },
    { title: "Maintenance Fund", amount: 68e4, subtitle: "Current" }
  ], t = e.reduce((r, i) => r + i.amount, 0), n = (r) => r >= 1e6 ? `AED ${(r / 1e6).toFixed(2)}M` : r >= 1e3 ? `AED ${(r / 1e3).toFixed(1)}K` : `AED ${r}`;
  return /* @__PURE__ */ O.jsxs(
    ot,
    {
      title: "Cash & Bank Balance",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      children: [
        /* @__PURE__ */ O.jsx("div", { className: "flex flex-col gap-[12px]", children: e.map((r, i) => /* @__PURE__ */ O.jsxs(
          "div",
          {
            className: "flex items-center justify-between bg-[#F9FAFB] rounded-lg p-3",
            children: [
              /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col", children: [
                /* @__PURE__ */ O.jsx("div", { className: "text-[14px] font-medium text-[#121212]", children: r.title }),
                /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] text-[#64748B]", children: r?.subtitle })
              ] }),
              /* @__PURE__ */ O.jsx("div", { className: "flex flex-col items-end", children: /* @__PURE__ */ O.jsx("div", { className: "text-[14px] text-[#1FA05B] font-semibold", children: n(r.amount) }) })
            ]
          },
          i
        )) }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between border-t border-[#EBEBEB] h-[68px] px-3", children: [
          /* @__PURE__ */ O.jsx("div", { className: "text-[14px] font-medium text-[#121212]", children: "Total" }),
          /* @__PURE__ */ O.jsx("div", { className: "text-[16px] text-[#1FA05B] font-bold", children: n(t) })
        ] })
      ]
    }
  );
};
Dn.register(to, no, Gl, Or, wr);
const hte = () => {
  const e = ["Current Month", "1-3 Months", "3-6 Months", "6+ Months"], t = [13e3, 9400, 8800, 7200], n = [18, 12, 18, 6], r = {
    labels: e,
    datasets: [
      {
        label: "Due",
        data: t,
        backgroundColor: "#EF4444",
        barThickness: 60
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: { display: !1 },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 6,
        callbacks: {
          title: (o) => e[o[0].dataIndex],
          label: (o) => `Due: AED ${(o.parsed.y / 1e3).toFixed(1)}K`,
          afterLabel: (o) => `Units Count: ${n[o.dataIndex]}`
        }
      }
    },
    scales: {
      x: {
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        grid: { color: "#F1F5F9" },
        ticks: {
          color: "#64748B",
          callback: (o) => `${o / 1e3}K`
        }
      }
    }
  };
  return /* @__PURE__ */ O.jsxs(
    ot,
    {
      title: "Dues Ageing",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: [
        /* @__PURE__ */ O.jsx("div", { className: "grid grid-cols-4 md:grid-cols-4 gap-[12px] h-[48px]", children: e.map((o, a) => /* @__PURE__ */ O.jsx("div", { className: "p-2 rounded-lg bg-slate-50", children: /* @__PURE__ */ O.jsxs("div", { className: "flex justify-between items-start", children: [
          /* @__PURE__ */ O.jsx("div", { className: "font-medium leading-[16px] !text-[12px] rounded", children: o }),
          /* @__PURE__ */ O.jsxs("div", { className: "text-right", children: [
            /* @__PURE__ */ O.jsxs("div", { className: "text-red-600 font-medium leading-[16px] !text-[12px]", children: [
              "AED ",
              (t[a] / 1e3).toFixed(1),
              "K"
            ] }),
            /* @__PURE__ */ O.jsxs("div", { className: " text-gray-500 leading-[14px] text-[10px]", children: [
              n[a],
              " Units"
            ] })
          ] })
        ] }) }, o)) }),
        /* @__PURE__ */ O.jsx("div", { className: "h-[192px]", children: /* @__PURE__ */ O.jsx(Xl, { data: r, options: i }) })
      ]
    }
  );
};
Dn.register(Jy, Or, wr);
const mte = () => {
  const e = [
    "Maintenance",
    "Utilities",
    "Security",
    "Administration",
    "Others"
  ], t = [45e4, 32e4, 28e4, 18e4, 12e4], n = {
    labels: e,
    datasets: [
      {
        label: "Expenses",
        data: t,
        backgroundColor: [
          "#08B6D4",
          "#8B5CF6",
          "#EF4444",
          "#F69E0A",
          "#12B981"
        ],
        borderColor: "#FFFFFF",
        borderWidth: 2,
        cutout: "70%"
      }
    ]
  }, r = t.reduce((o, a) => o + a, 0), i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: { display: !1 },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 10,
        callbacks: {
          label: (o) => `${o.label}: AED ${o.formattedValue}`
        }
      }
    }
  };
  return /* @__PURE__ */ O.jsxs(
    ot,
    {
      title: "Expense Categories",
      className: "w-full h-[523px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: [
        /* @__PURE__ */ O.jsxs("div", { className: "relative h-[259px] flex justify-center items-center", children: [
          /* @__PURE__ */ O.jsx(rb, { data: n, options: i }),
          /* @__PURE__ */ O.jsxs("div", { className: "absolute text-center", children: [
            /* @__PURE__ */ O.jsxs("div", { className: "!text-[24px] font-medium leading-[28px] text-[#121212]", children: [
              "AED ",
              (r / 1e6).toFixed(2),
              "M"
            ] }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[#121212] leading-[18px] text-[14px]", children: "Total Expenses" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "space-y-2", children: e.map((o, a) => /* @__PURE__ */ O.jsxs(
          "div",
          {
            className: "flex justify-between items-center text-[14px] pb-2",
            children: [
              /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px] !text-[12px] leading-[16px] text-[#64748B]", children: [
                /* @__PURE__ */ O.jsx(
                  "div",
                  {
                    className: "w-[7px] h-[7px] rotate-45",
                    style: { backgroundColor: n.datasets[0].backgroundColor[a] }
                  }
                ),
                o
              ] }),
              /* @__PURE__ */ O.jsxs("div", { className: "leading-[16px] !text-[12px] text-[#64748B]", children: [
                "AED ",
                (t[a] / 1e3).toFixed(0),
                "K"
              ] })
            ]
          },
          o
        )) })
      ]
    }
  );
}, ws = [
  { name: "Gym Equipment", value: 1e6, color: "#08B6D4" },
  { name: "Security", value: 8e5, color: "#EF4444" },
  { name: "Others", value: 6e5, color: "#F59E0B" },
  { name: "Pool Maintenance", value: 7e5, color: "#8B5CF6" },
  { name: "Administration", value: 52e4, color: "#10B981" }
];
function gte() {
  const e = ws.reduce((t, n) => t + n.value, 0);
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Asset Value Breakdown",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
        /* @__PURE__ */ O.jsxs("div", { className: "w-[214px] h-[181px] relative", children: [
          /* @__PURE__ */ O.jsx(Yo, { width: "100%", height: "100%", children: /* @__PURE__ */ O.jsxs(df, { children: [
            /* @__PURE__ */ O.jsx(
              Vl,
              {
                data: ws,
                innerRadius: 60,
                outerRadius: 90,
                paddingAngle: 2,
                dataKey: "value",
                nameKey: "name",
                children: ws.map((t, n) => /* @__PURE__ */ O.jsx(zr, { fill: t.color }, `cell-${n}`))
              }
            ),
            /* @__PURE__ */ O.jsx(qo, { formatter: (t) => `AED ${t.toLocaleString()}` })
          ] }) }),
          /* @__PURE__ */ O.jsxs("div", { className: "absolute inset-0 flex flex-col items-center justify-center pointer-events-none", children: [
            /* @__PURE__ */ O.jsxs("div", { className: "font-medium text-lg leading-[12px] ", children: [
              "AED ",
              (e / 1e6).toFixed(2),
              "M"
            ] }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[10px] leading-[12.59px] text-[#121212] mt-[6px]", children: "Total Assets" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex justify-between w-full px-4 sm:px-8 mt-4 text-[14px]", children: [
          /* @__PURE__ */ O.jsx("div", { className: "flex flex-col gap-[8px]", children: ws.slice(0, 3).map((t) => /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px]", children: [
            /* @__PURE__ */ O.jsx(
              "div",
              {
                className: "inline-block h-[7px] w-[7px] rotate-45",
                style: { backgroundColor: t.color }
              }
            ),
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] leading-[16px] !text-[12px]", children: t.name })
          ] }, t.name)) }),
          /* @__PURE__ */ O.jsx("div", { className: "flex flex-col gap-[8px] items-start", children: ws.slice(3).map((t) => /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px]", children: [
            /* @__PURE__ */ O.jsx(
              "div",
              {
                className: "inline-block h-[7px] w-[7px] rotate-45",
                style: { backgroundColor: t.color }
              }
            ),
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] leading-[16px] !text-[12px]", children: t.name })
          ] }, t.name)) })
        ] })
      ] })
    }
  );
}
Dn.register(to, no, Gl, Or, wr);
const vte = () => {
  const e = [
    "Gym",
    "Parking",
    "Swimming Pool",
    "Community Hall",
    "Tennis Court"
  ], t = [13e3, 9400, 8800, 7200, 6e3], n = [18, 12, 18, 6], r = {
    labels: e,
    datasets: [
      {
        label: "Due",
        data: t,
        backgroundColor: "#8B5CF6",
        barThickness: 60
      }
    ]
  }, i = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: { display: !1 },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 6,
        callbacks: {
          title: (o) => e[o[0].dataIndex],
          label: (o) => `Due: AED ${(o.parsed.y / 1e3).toFixed(1)}K`,
          afterLabel: (o) => `Units Count: ${n[o.dataIndex]}`
        }
      }
    },
    scales: {
      x: {
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        grid: { color: "#F1F5F9" },
        ticks: {
          color: "#64748B",
          callback: (o) => `${o / 1e3}K`
        }
      }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Revenue by Category",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      titleWeight: "semi-bold",
      children: /* @__PURE__ */ O.jsx(Xl, { data: r, options: i })
    }
  );
};
function gee(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M15 5l0 2" }, child: [] }, { tag: "path", attr: { d: "M15 11l0 2" }, child: [] }, { tag: "path", attr: { d: "M15 17l0 2" }, child: [] }, { tag: "path", attr: { d: "M5 5h14a2 2 0 0 1 2 2v3a2 2 0 0 0 0 4v3a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-3a2 2 0 0 0 0 -4v-3a2 2 0 0 1 2 -2" }, child: [] }] })(e);
}
function vee(e) {
  return Ge({ attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M855.7 210.8l-42.4-42.4a8.03 8.03 0 0 0-11.3 0L168.3 801.9a8.03 8.03 0 0 0 0 11.3l42.4 42.4c3.1 3.1 8.2 3.1 11.3 0L855.6 222c3.2-3 3.2-8.1.1-11.2zM304 448c79.4 0 144-64.6 144-144s-64.6-144-144-144-144 64.6-144 144 64.6 144 144 144zm0-216c39.7 0 72 32.3 72 72s-32.3 72-72 72-72-32.3-72-72 32.3-72 72-72zm416 344c-79.4 0-144 64.6-144 144s64.6 144 144 144 144-64.6 144-144-64.6-144-144-144zm0 216c-39.7 0-72-32.3-72-72s32.3-72 72-72 72 32.3 72 72-32.3 72-72 72z" }, child: [] }] })(e);
}
function yee({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Ol,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ O.jsxs(
    ot,
    {
      title: e,
      icon: /* @__PURE__ */ O.jsx("div", { className: "h-6 w-6 grid place-items-center", children: /* @__PURE__ */ O.jsx(o, { className: `h-6 w-6 ${a}` }) }),
      children: [
        /* @__PURE__ */ O.jsx("div", { className: "text-4xl font-semibold tracking-tight text-[#121212]", children: t }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px] text-[14px]", children: [
          /* @__PURE__ */ O.jsx(
            "div",
            {
              className: i ? "text-emerald-600 font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ O.jsx("div", { className: "text-slate-500", children: r })
        ] })
      ]
    }
  );
}
function yte() {
  const e = [
    {
      title: "Total Bookings",
      value: 160,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: c_,
      iconColor: "text-emerald-600"
    },
    {
      title: "Utilisation Rate",
      value: 73,
      delta: "+2.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: vee,
      iconColor: "text-[#329DFF]"
    },
    {
      title: "Revenue",
      value: 3,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: gee,
      iconColor: "text-[#FA7E28]"
    },
    {
      title: "Pending Dues",
      value: 5,
      delta: "-8.0%",
      deltaLabel: "Compared to last month",
      positive: !1,
      Icon: f_,
      iconColor: "text-[#DBB467]"
    }
  ];
  return /* @__PURE__ */ O.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-[24px]", children: e.map((t, n) => /* @__PURE__ */ O.jsx(yee, { ...t }, n)) });
}
const Hc = [
  { name: "Completed", value: 46, color: "#12B981" },
  { name: "Delayed", value: 2, color: "#EF4444" },
  { name: "Missed", value: 2, color: "#F69E0A" }
];
function bte() {
  const t = Hc.find((n) => n.name === "Completed")?.value || 0;
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Guard Patrols",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
        /* @__PURE__ */ O.jsxs("div", { className: "w-[215px] h-[182px] relative", children: [
          /* @__PURE__ */ O.jsx(Yo, { width: "100%", height: "100%", children: /* @__PURE__ */ O.jsxs(df, { children: [
            /* @__PURE__ */ O.jsx(
              Vl,
              {
                data: Hc,
                innerRadius: 60,
                outerRadius: 90,
                paddingAngle: 2,
                dataKey: "value",
                nameKey: "name",
                children: Hc.map((n, r) => /* @__PURE__ */ O.jsx(zr, { fill: n.color }, `cell-${r}`))
              }
            ),
            /* @__PURE__ */ O.jsx(qo, { formatter: (n) => n.toLocaleString() })
          ] }) }),
          /* @__PURE__ */ O.jsxs("div", { className: "absolute inset-0 flex flex-col items-center justify-center pointer-events-none", children: [
            /* @__PURE__ */ O.jsxs("div", { className: "font-medium text-[19.35px] leading-[23.65px] ", children: [
              t,
              "/",
              50
            ] }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[10.75px] leading-[15.05px] text-[#64748B]", children: "Completed" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsx("div", { className: "flex flex-col gap-[8px] mt-3 w-full px-6 text-[14px]", children: Hc.map((n) => /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px]", children: [
            /* @__PURE__ */ O.jsx(
              "div",
              {
                className: "inline-block w-[7px] h-[7px] rotate-45",
                style: { backgroundColor: n.color }
              }
            ),
            /* @__PURE__ */ O.jsx("div", { className: "leading-[16.09px] text-[12.07px] text-[#64748B]", children: n.name })
          ] }),
          /* @__PURE__ */ O.jsx("div", { className: "leading-[16.09px] text-[12.07px] text-[#64748B]", children: n.value })
        ] }, n.name)) })
      ] })
    }
  );
}
Dn.register(
  to,
  no,
  eb,
  Qy,
  Or,
  wr
);
const xte = () => {
  const t = {
    labels: ["10 AM", "12 PM", "2 PM", "4 PM", "6 PM", "8 PM", "10 PM"],
    datasets: [
      {
        label: "Guest",
        data: [9, 5, 12, 7, 3, 6, 4],
        borderColor: "#EF4444",
        backgroundColor: "rgba(239,68,68,0.15)",
        pointBackgroundColor: "#EF4444",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Cab",
        data: [15, 12, 10, 14, 7, 12, 8],
        borderColor: "#7C3AED",
        backgroundColor: "rgba(124,58,237,0.15)",
        pointBackgroundColor: "#7C3AED",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Delivery",
        data: [22, 18, 16, 20, 22, 14, 17],
        borderColor: "#10B981",
        backgroundColor: "rgba(16,185,129,0.15)",
        pointBackgroundColor: "#10B981",
        pointStyle: "rectRot",
        fill: !1
      },
      {
        label: "Service",
        data: [13, 12, 8, 9, 5, 10, 7],
        borderColor: "#F59E0B",
        backgroundColor: "rgba(245,158,11,0.15)",
        pointBackgroundColor: "#F59E0B",
        pointStyle: "rectRot",
        fill: !1
      }
    ]
  }, n = {
    responsive: !0,
    maintainAspectRatio: !1,
    interaction: { mode: "index", intersect: !1 },
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          padding: 20
        }
      },
      tooltip: {
        backgroundColor: "#0F172A",
        titleColor: "#FFFFFF",
        bodyColor: "#FFFFFF",
        displayColors: !1,
        padding: 12,
        caretSize: 0,
        callbacks: {
          title: (r) => r[0].label,
          label: (r) => `${r.dataset.label}  ${r.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B" }
      },
      y: {
        beginAtZero: !0,
        suggestedMax: 28,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 4, precision: 0 }
      }
    },
    elements: {
      line: { borderWidth: 2, tension: 0 },
      point: { radius: 0, hoverRadius: 3, hitRadius: 10 }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Hourly Traffic Flow",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "text-[20px] text-[#884EA7]" }),
      children: /* @__PURE__ */ O.jsx(nb, { data: t, options: n })
    }
  );
};
function wte() {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Incident Reports",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ O.jsxs("div", { children: [
        /* @__PURE__ */ O.jsxs("div", { className: "flex w-full text-center gap-[24px]", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex-1 py-3 bg-[#FBF4F4] h-[76px] rounded", children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[24px] leading-[28px] font-medium text-[#AB0000]", children: "3" }),
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#AB0000]", children: "Open" })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex-1 py-3 bg-[#FFFBF2] h-[76px] rounded", children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[24px] leading-[28px] font-medium text-[#E7A015]", children: "5" }),
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#E7A015]", children: "In-progress" })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex-1 py-3 bg-[#F7FEFA] h-[76px] rounded", children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[24px] leading-[28px] font-medium text-[#1FA05B]", children: "12" }),
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#1FA05B]", children: "Closed" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsxs("div", { className: "mt-4 ", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between p-3 bg-[#FAFBFD] rounded-md border border-[#FAFBFD]", children: [
            /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px]", children: [
              /* @__PURE__ */ O.jsx("div", { className: "w-4 h-4 rounded-full flex items-center justify-center bg-[#AB0000]", children: /* @__PURE__ */ O.jsx("div", { className: "text-white !text-[12px] font-bold", children: "!" }) }),
              /* @__PURE__ */ O.jsx("div", { className: "text-gray-700 font-medium", children: "INC 001" })
            ] }),
            /* @__PURE__ */ O.jsxs("div", { className: "px-3 py-1 rounded-full !text-[12px] font-semibold flex items-center gap-[4px] text-[#AB0000] bg-red-50", children: [
              /* @__PURE__ */ O.jsx("div", { children: "4 - Danger" }),
              /* @__PURE__ */ O.jsx("div", { className: "w-2 h-2 rounded-full bg-[#AB0000]" })
            ] })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between p-3 bg-[#FAFBFD] rounded-md border border-[#FAFBFD]", children: [
            /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px]", children: [
              /* @__PURE__ */ O.jsx("div", { className: "w-4 h-4 rounded-full flex items-center justify-center bg-[#E7A015]", children: /* @__PURE__ */ O.jsx(o0, { className: "text-white text-[10px]" }) }),
              /* @__PURE__ */ O.jsx("div", { className: "text-gray-700 font-medium", children: "INC 002" })
            ] }),
            /* @__PURE__ */ O.jsxs("div", { className: "px-3 py-1 rounded-full !text-[12px] font-semibold flex items-center gap-[4px] text-[#E7A015] bg-yellow-50", children: [
              /* @__PURE__ */ O.jsx("div", { children: "3 - High" }),
              /* @__PURE__ */ O.jsx("div", { className: "w-2 h-2 rounded-full bg-[#E7A015]" })
            ] })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between p-3 bg-[#FAFBFD] rounded-md border border-[#FAFBFD]", children: [
            /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px]", children: [
              /* @__PURE__ */ O.jsx("div", { className: "w-4 h-4 rounded-full flex items-center justify-center bg-[#1FA05B]", children: /* @__PURE__ */ O.jsx(o0, { className: "text-white text-[10px]" }) }),
              /* @__PURE__ */ O.jsx("div", { className: "text-gray-700 font-medium", children: "INC 003" })
            ] }),
            /* @__PURE__ */ O.jsxs("div", { className: "px-3 py-1 rounded-full !text-[12px] font-semibold flex items-center gap-[4px] text-[#1FA05B] bg-green-50", children: [
              /* @__PURE__ */ O.jsx("div", { children: "1 - Low" }),
              /* @__PURE__ */ O.jsx("div", { className: "w-2 h-2 rounded-full bg-[#1FA05B]" })
            ] })
          ] })
        ] })
      ] })
    }
  );
}
function Ote() {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Staff Attendance",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ O.jsxs("div", { children: [
        /* @__PURE__ */ O.jsxs("div", { className: "flex w-full text-center h-[76px] gap-[16px] mb-2", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex-1 py-4 bg-green-50 rounded-md", children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[24px] leading-[18px] font-medium text-[#1FA05B] pb-[8px]", children: "25" }),
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#1FA05B]", children: "Present" })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex-1 py-4 bg-red-50 rounded-md", children: [
            /* @__PURE__ */ O.jsx("div", { className: "!text-[24px] leading-[18px] font-medium text-[#AB0000] pb-[8px]", children: "1" }),
            /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#AB0000]", children: "Absent" })
          ] })
        ] }),
        /* @__PURE__ */ O.jsxs("div", { className: "mt-[24px] ", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ O.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Security guards" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "12/12 Present" })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ O.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Housekeeping" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "7/8 Present" })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ O.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Maintenance" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "4/4 Present" })
          ] }),
          /* @__PURE__ */ O.jsxs("div", { className: "flex justify-between items-center p-3 bg-[#FAFBFD] rounded-md", children: [
            /* @__PURE__ */ O.jsx("div", { className: " font-medium !text-[12px] leading-[18px]", children: "Gardening" }),
            /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B] leading[20px] text-[14px]", children: "2/2 Present" })
          ] })
        ] })
      ] })
    }
  );
}
function bee(e) {
  return Ge({ attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M116,132V96a12,12,0,0,1,24,0v36a12,12,0,0,1-24,0Zm12,56a16,16,0,1,0-16-16A16,16,0,0,0,128,188ZM228,56v56c0,54.29-26.32,87.22-48.4,105.29-23.71,19.39-47.44,26-48.44,26.29a12.1,12.1,0,0,1-6.32,0c-1-.28-24.73-6.9-48.44-26.29C54.32,199.22,28,166.29,28,112V56A20,20,0,0,1,48,36H208A20,20,0,0,1,228,56Zm-24,4H52v52c0,35.71,13.09,64.69,38.91,86.15A126.14,126.14,0,0,0,128,219.38a126.28,126.28,0,0,0,37.09-21.23C190.91,176.69,204,147.71,204,112Z" }, child: [] }] })(e);
}
function xee({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Ol,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ O.jsxs(
    ot,
    {
      title: e,
      icon: /* @__PURE__ */ O.jsx("div", { className: "h-6 w-6 grid place-items-center", children: /* @__PURE__ */ O.jsx(o, { className: `h-6 w-6 ${a}` }) }),
      children: [
        /* @__PURE__ */ O.jsx("div", { className: "text-4xl font-semibold tracking-tight text-[#121212]", children: t }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px] text-[14px]", children: [
          /* @__PURE__ */ O.jsx(
            "div",
            {
              className: i ? "text-emerald-600 font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ O.jsx("div", { className: "text-slate-500", children: r })
        ] })
      ]
    }
  );
}
function Ste() {
  const e = [
    {
      title: "Total Visitors",
      value: 160,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: d_,
      iconColor: "text-[#329DFF]"
    },
    {
      title: "Active Incidents",
      value: 73,
      delta: "+2.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: rG,
      iconColor: "text-[#F69E0A]"
    },
    {
      title: "Missed Patrols",
      value: 3,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: bee,
      iconColor: "text-[#AB0000]"
    },
    {
      title: "Parking Usage",
      value: 5,
      delta: "-8.0%",
      deltaLabel: "Compared to last month",
      positive: !1,
      Icon: eR,
      iconColor: "text-[#36AB6C]"
    }
  ];
  return /* @__PURE__ */ O.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-[24px]", children: e.map((t, n) => /* @__PURE__ */ O.jsx(xee, { ...t }, n)) });
}
const wee = [
  { title: "Maintenance", total: 25, pending: 8 },
  { title: "Security", total: 15, pending: 3 },
  { title: "Housekeeping", total: 12, pending: 4 },
  { title: "Utilities", total: 10, pending: 2 }
];
function Ete() {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Complaints",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "text-[20px] text-[#884EA7]" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ O.jsx("div", { className: "flex flex-col gap-[12px]", children: wee.map((e, t) => /* @__PURE__ */ O.jsxs(
        "div",
        {
          className: "flex items-center justify-between bg-[#F9FAFB] rounded-lg p-3 h-[62px]",
          children: [
            /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col", children: [
              /* @__PURE__ */ O.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-[#121212]", children: e.title }),
              /* @__PURE__ */ O.jsxs("div", { className: "!text-[12px] leading-[16px] text-[#64748B]", children: [
                "Total: ",
                e.total
              ] })
            ] }),
            /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col items-end", children: [
              /* @__PURE__ */ O.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-red-700", children: String(e.pending).padStart(2, "0") }),
              /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#64748B]", children: "Pending" })
            ] })
          ]
        },
        t
      )) })
    }
  );
}
Dn.register(to, no, Gl, Or, wr);
const _te = ({
  blocks: e = [
    { name: "Level 1", owner: 110, rented: 24, vacant: 8 },
    { name: "Level 2", owner: 95, rented: 18, vacant: 6 },
    { name: "Level 3", owner: 65, rented: 12, vacant: 18 },
    { name: "Level 4", owner: 78, rented: 16, vacant: 30 }
  ]
}) => {
  const t = e.map((s) => s.name), n = e.map((s) => s.owner), r = e.map((s) => s.rented), i = e.map((s) => s.vacant), o = {
    labels: t,
    datasets: [
      {
        label: "Closed",
        data: n,
        backgroundColor: "#12B981",
        barThickness: 44
      },
      {
        label: "",
        data: n.map(() => 2),
        backgroundColor: "transparent",
        barThickness: 44
      },
      {
        label: "In Progress",
        data: r,
        backgroundColor: "#F59D0D",
        barThickness: 44
      },
      {
        label: "",
        data: n.map(() => 2),
        backgroundColor: "transparent",
        barThickness: 44
      },
      {
        label: "Open",
        data: i,
        backgroundColor: "#EF4444",
        barThickness: 44
      }
    ]
  }, a = {
    responsive: !0,
    maintainAspectRatio: !1,
    plugins: {
      legend: {
        position: "bottom",
        labels: {
          usePointStyle: !0,
          boxWidth: 10,
          boxHeight: 10,
          pointStyle: "rectRot",
          padding: 20
        }
      },
      tooltip: {
        callbacks: {
          label: (s) => `${s.dataset.label}: ${s.parsed.y}`
        }
      }
    },
    scales: {
      x: {
        stacked: !0,
        grid: { display: !1 },
        ticks: { color: "#64748B" }
      },
      y: {
        stacked: !0,
        beginAtZero: !0,
        suggestedMax: 180,
        grid: { color: "#F1F5F9" },
        ticks: { color: "#64748B", stepSize: 20 }
      }
    }
  };
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Complaints by Level",
      className: "w-full h-[362px]",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "text-[20px] text-[#884EA7]" }),
      children: /* @__PURE__ */ O.jsx(Xl, { data: o, options: a })
    }
  );
}, Oee = [
  { title: "Access Card", total: 45, pending: 11 },
  { title: "NOC Request", total: 12, pending: 7 },
  { title: "Parking Allocation", total: 8, pending: 6 },
  { title: "Document Request", total: 25, pending: 2 }
];
function Pte() {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Request Box",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "text-[20px] text-[#884EA7]" }),
      className: "h-[362px]",
      children: /* @__PURE__ */ O.jsx("div", { className: "flex flex-col gap-[12px]", children: Oee.map((e, t) => /* @__PURE__ */ O.jsxs(
        "div",
        {
          className: "flex items-center justify-between bg-[#F9FAFB] rounded-lg p-3 h-[62px]",
          children: [
            /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col", children: [
              /* @__PURE__ */ O.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-[#121212]", children: e.title }),
              /* @__PURE__ */ O.jsxs("div", { className: "!text-[12px] leading-[16px] text-[#64748B]", children: [
                "Total: ",
                e.total
              ] })
            ] }),
            /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col items-end", children: [
              /* @__PURE__ */ O.jsx("div", { className: "text-[14px] leading-[18px] font-medium text-red-700", children: String(e.pending).padStart(2, "0") }),
              /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#64748B]", children: "Pending" })
            ] })
          ]
        },
        t
      )) })
    }
  );
}
function See(e) {
  return Ge({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinejoin: "round", strokeWidth: "32", d: "M416 221.25V416a48 48 0 0 1-48 48H144a48 48 0 0 1-48-48V96a48 48 0 0 1 48-48h98.75a32 32 0 0 1 22.62 9.37l141.26 141.26a32 32 0 0 1 9.37 22.62z" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M256 56v120a32 32 0 0 0 32 32h120m-232 80h160m-160 80h160" }, child: [] }] })(e);
}
function Eee({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Ol,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ O.jsxs(
    ot,
    {
      title: e,
      icon: /* @__PURE__ */ O.jsx("div", { className: "h-6 w-6 grid place-items-center", children: /* @__PURE__ */ O.jsx(o, { className: `h-6 w-6 ${a}` }) }),
      children: [
        /* @__PURE__ */ O.jsx("div", { className: "text-4xl font-semibold tracking-tight text-[#121212]", children: t }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px] text-[14px]", children: [
          /* @__PURE__ */ O.jsx(
            "div",
            {
              className: i ? "text-emerald-600 font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ O.jsx("div", { className: "text-slate-500", children: r })
        ] })
      ]
    }
  );
}
function Cte() {
  const e = [
    {
      title: "Open Complaints",
      value: 145,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: c_,
      iconColor: "text-[#AB0000]"
    },
    {
      title: "Pending Requests",
      value: 83,
      delta: "+2.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: See,
      iconColor: "text-[#E7A015]"
    },
    {
      title: "Avg Response Time",
      value: "3h",
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: JD,
      iconColor: "text-[#1FA05B]"
    },
    {
      title: "Resolution Rate",
      value: "93%",
      delta: "-8.0%",
      deltaLabel: "Compared to last month",
      positive: !1,
      Icon: YD,
      iconColor: "text-[#329DFF]"
    }
  ];
  return /* @__PURE__ */ O.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-[24px]", children: e.map((t, n) => /* @__PURE__ */ O.jsx(Eee, { ...t }, n)) });
}
function hE({ title: e, date: t, rsvp: n, utilisation: r, status: i }) {
  return /* @__PURE__ */ O.jsxs("div", { className: " bg-[#F8FAFC] h-[106px] px-3 mt-3", children: [
    /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ O.jsx("div", { className: "text-[16px] leading-[20px] font-semibold text-[#121212]", children: e }),
      /* @__PURE__ */ O.jsx(
        "div",
        {
          className: `!text-[12px] font-medium leading-[16px] px-2 py-1  ${i === "Completed" ? "text-[#36AB6C] bg-[#E6F7EE]" : i === "Upcoming" ? "text-[#329DFF] bg-[#E6F2FF]" : "text-slate-500 bg-slate-100"}`,
          children: i
        }
      )
    ] }),
    /* @__PURE__ */ O.jsx("div", { className: "text-[14px] leading-[18px] text-[#64748B]", children: t }),
    /* @__PURE__ */ O.jsxs("div", { className: "flex justify-between items-center mt-2", children: [
      /* @__PURE__ */ O.jsxs("div", { className: "text-[14px] leading-[18px] text-[#64748B]", children: [
        n,
        " RSVP"
      ] }),
      /* @__PURE__ */ O.jsxs("div", { className: "text-[#3C82F6] text-[14px] leading-[18px] font-medium", children: [
        r,
        "% utilisation"
      ] })
    ] }),
    /* @__PURE__ */ O.jsx("div", { className: "w-full bg-[#F8FAFC] h-[6px] rounded mt-2 mb-3", children: /* @__PURE__ */ O.jsx(
      "div",
      {
        className: "h-[6px] rounded bg-[#3C82F6]",
        style: { width: `${r}%` }
      }
    ) })
  ] });
}
function Ate() {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Events Utilisation",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "w-full h-[360px]",
      children: /* @__PURE__ */ O.jsxs("div", { children: [
        /* @__PURE__ */ O.jsx(
          hE,
          {
            title: "Holi Celebration",
            date: "25 Jun 2025",
            rsvp: "78/100",
            utilisation: 71,
            status: "Upcoming"
          }
        ),
        /* @__PURE__ */ O.jsx(
          hE,
          {
            title: "Maintenance Meeting",
            date: "25 Jun 2025",
            rsvp: "45/60",
            utilisation: 75,
            status: "Completed"
          }
        )
      ] })
    }
  );
}
function Kc({ label: e, value: t, subLabel: n, bgColor: r, textColor: i }) {
  return /* @__PURE__ */ O.jsxs("div", { className: `rounded-lg p-4 ${r} h-[124px]`, children: [
    /* @__PURE__ */ O.jsx("div", { className: `text-[16px] font-medium ${i} leading-[20px]`, children: e }),
    /* @__PURE__ */ O.jsx("div", { className: "mt-4 text-[28px] leading-[32px] font-semibold text-[#121212]", children: t }),
    /* @__PURE__ */ O.jsx("div", { className: "!text-[12px] leading-[16px] text-[#64748B] mt-2", children: n })
  ] });
}
function Tte() {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: "Notice Board Status",
      period: /* @__PURE__ */ O.jsx(Yt, { className: "h-5 w-5 text-[#884EA7] cursor-pointer" }),
      className: "w-full h-[360px]",
      children: /* @__PURE__ */ O.jsxs("div", { className: "grid grid-cols-2 gap-[16px]", children: [
        /* @__PURE__ */ O.jsx(
          Kc,
          {
            label: "Active",
            value: 138,
            subLabel: "3 expiring soon",
            bgColor: "bg-[#F0FFF7]",
            textColor: "text-[#1FA05B]"
          }
        ),
        /* @__PURE__ */ O.jsx(
          Kc,
          {
            label: "Scheduled",
            value: 13,
            subLabel: "4 this week",
            bgColor: "bg-[#FFFBF2]",
            textColor: "text-[#E7A015]"
          }
        ),
        /* @__PURE__ */ O.jsx(
          Kc,
          {
            label: "Recurring",
            value: 3,
            subLabel: "All active",
            bgColor: "bg-[#EDF6FF]",
            textColor: "text-[#329DFF]"
          }
        ),
        /* @__PURE__ */ O.jsx(
          Kc,
          {
            label: "Expired",
            value: 7,
            subLabel: "4 recent",
            bgColor: "bg-[#F6F6F6]",
            textColor: "text-[#64748B]"
          }
        )
      ] })
    }
  );
}
function eM(e) {
  return Ge({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M20 22H4C3.44772 22 3 21.5523 3 21V3C3 2.44772 3.44772 2 4 2H20C20.5523 2 21 2.44772 21 3V21C21 21.5523 20.5523 22 20 22ZM19 20V4H5V20H19ZM8 9H16V11H8V9ZM8 13H16V15H8V13Z" }, child: [] }] })(e);
}
function _ee({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Ol,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: e,
      icon: /* @__PURE__ */ O.jsx("div", { className: `h-6 w-6 grid place-items-center rounded-md ${s}`, children: /* @__PURE__ */ O.jsx(o, { className: `h-4 w-4 ${a}` }) }),
      className: "h-[132px]",
      children: /* @__PURE__ */ O.jsxs("div", { children: [
        /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px] font-medium text-[#121212]", children: t }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px] pt-[8px] !text-[12px] leading-[16px]", children: [
          /* @__PURE__ */ O.jsx(
            "div",
            {
              className: i ? "text-[#1FA05B] font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B]", children: r })
        ] })
      ] })
    }
  );
}
function kte({ data: e }) {
  const t = [
    {
      title: e?.title || "Total Bookings",
      value: 145,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: eM,
      iconColor: "text-emerald-600",
      iconBg: "bg-emerald-50"
    }
  ];
  return /* @__PURE__ */ O.jsx("div", { className: "h-full", children: t.map((n, r) => /* @__PURE__ */ O.jsx(_ee, { ...n }, r)) });
}
function Pee(e) {
  return Ge({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" }, child: [] }] })(e);
}
function Cee({
  title: e,
  value: t,
  delta: n,
  deltaLabel: r,
  positive: i = !0,
  Icon: o = Ol,
  iconColor: a = "text-emerald-600",
  iconBg: s = "bg-emerald-50"
}) {
  return /* @__PURE__ */ O.jsx(
    ot,
    {
      title: e,
      icon: /* @__PURE__ */ O.jsx("div", { className: `h-6 w-6 grid place-items-center rounded-md ${s}`, children: /* @__PURE__ */ O.jsx(o, { className: `h-4 w-4 ${a}` }) }),
      className: "h-[132px]",
      children: /* @__PURE__ */ O.jsxs("div", { children: [
        /* @__PURE__ */ O.jsx("div", { className: "text-[28px] leading-[32px] font-medium text-[#121212]", children: t }),
        /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-[8px] pt-[8px] !text-[12px] leading-[16px]", children: [
          /* @__PURE__ */ O.jsx(
            "div",
            {
              className: i ? "text-[#1FA05B] font-medium" : "text-rose-600 font-medium",
              children: n
            }
          ),
          /* @__PURE__ */ O.jsx("div", { className: "text-[#64748B]", children: r })
        ] })
      ] })
    }
  );
}
function Mte() {
  const e = [
    {
      title: "Notice",
      value: 160,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: eM,
      iconColor: "text-emerald-600",
      iconBg: "bg-emerald-50"
    },
    {
      title: "Post",
      value: 83,
      delta: "+2.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: tR,
      iconColor: "text-[#329DFF]",
      iconBg: "bg-emerald-50"
    },
    {
      title: "Poll",
      value: 3,
      delta: "+11.0%",
      deltaLabel: "Compared to last month",
      positive: !0,
      Icon: tG,
      iconColor: "text-[#FA7E28]",
      iconBg: "bg-orange-100"
    },
    {
      title: "Poll",
      value: 5,
      delta: "-8.0%",
      deltaLabel: "Compared to last month",
      positive: !1,
      Icon: Pee,
      iconColor: "text-[#DBB467]",
      iconBg: "bg-yellow-100"
    }
  ];
  return /* @__PURE__ */ O.jsx("div", { className: "px-5 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-[24px]", children: e.map((t, n) => /* @__PURE__ */ O.jsx(Cee, { ...t }, n)) });
}
export {
  dte as Accounting,
  gte as AssetValueBreakdown,
  cte as BlockWiseOccupancy,
  fte as Budgets,
  ot as Card,
  pte as CashBankBalance,
  Zee as Community,
  Ete as Complaints,
  _te as ComplaintsByLevel,
  hte as DuesAgeing,
  Jee as Engagement,
  Mte as EngagementStatsGrid,
  Ate as EventsUtilisation,
  mte as ExpenseCategories,
  Qee as Facilities,
  ete as FinanceSummary,
  Ste as GateAndSecurityStatsGrid,
  tte as GateUpdates,
  bte as GuardPatrols,
  kee as Header,
  nte as Helpdesk,
  Cte as HelpdeskStatsGrid,
  xte as HourlyTrafficFlow,
  wte as IncidentReports,
  mee as IncomeExpenditure,
  Mee as MainHeader,
  ute as MoveInOutTrends,
  Tte as NoticeBoardStatus,
  ste as OccupancyOverview,
  Pte as RequestBox,
  lte as ResidentOverview,
  vte as RevenuebyCategory,
  kte as SingleStats,
  Ote as StaffAttendance,
  yte as StatsGrid,
  ate as UnitStatus
};
